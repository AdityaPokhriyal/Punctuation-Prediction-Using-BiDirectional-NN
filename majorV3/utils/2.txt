we will have my blank job
backslash n will come here sorry backslash 0 will come here, but s t r l e n means string
length I will count how many elements are there in the string; can you tell me how many
elements are there in the string? 1 2 3 blank is a valid character 1, 2, 3 4, 5, 6. So, the
string length will be returned that will returned is 6, similarly we have another function
very popular function string comparison s t r c m p; that means, I have got two strings
my job and here my job, and I compared them if sorry if they are the same then I will
have a one ok.
So, that is another function the fourth function is s t r c a t what is meant by
concatenation? Concatenation s t r c a t is actually s t r c a t means string concatenation.

That means, if I have a string here say a b c ended with this, and there is another string
say p q r ended with this, when I concatenate it that these two strings what I get is a
joining of these two strings one after another. When I say that string b is concatenated
with a then my pattern will be a b c note that this backslash 0 will not come p q r and
backslash 0. This is known as concatenation all right of two strings. So, that is being
given by a function s t r c a t.
Now. So, these are the very common functions for string operations. For our job if we
need some other functions we can always write functions which will learn in a couple of
lectures from now, but these are already available in the c library all right s t d i o dot h
and also when we use that square root function .

And therefore, in order to do that we have to include st string dot h, if you recall we had
said that if you recall we can include always you do that hash include.

Earlier we had included math dot h; that means, all the mathematic library of all the
mathematical functions math dot h when we use for example, s q r square root.
So, this is this is a function that is already inbuilt, inbuilt in this math library similarly for
strings if I use this s t r c p y, s t r c a t, s t r c m, c m p compare, then I have to include
strings dot h in my function alright. So, here are some examples.

Very much like a string assignment operator string copy just like an assignment, for
example, we have we are saying string copy string 1 string 2.
So, both string 2 will be copied in string 1. So, assigns the content of string 2 to string 1
assigns the. So, this is the source this is the destination. So, it is copied from here to here
say string copy city Calcutta what will happen here; that means, I am trying to copy city
is a string that is already defined alright I have defined city and I am copying this string
now this is a string constant, this part is a string constant this is a string constant.
So, what I am doing is I am I have got a variable city, variable of type string.

Now this how did you define it to be a type of type string it was char city say something
like this char city 20. So, 20 characters can come there.
Now, when I write city s t r c copy city to Calcutta or right now we say Kolkata say we
do Kolkata. Then in this variable Kolkata will be loaded all right a followed by a
backslash 0 right. On the other hand suppose city is here and suppose another city
another string variable is there, which is maybe Mumbai and I copy string copy city my
city; that means, what will happen this string, this string my city will come into this
variable city.
So, this Kolkata will be overwritten and will be replaced by Mumbai. Now Kolkata is of
length 1 2 3 4 5 6 7 and Mumbai is 1 2 3 4 5 6 in that case what will happen? As I copy
this whole string over here then here Mumbai m will come u will come m b a i and this
backslash 0 will come here and so, the entire string will be kept here the last sorry up to
this and with a backslash 0 here, and the remaining part of unused part of Kolkata will be
lost.
Now, warning there is an warning here that is assignment operator does not work for
string. So, I could not have done string 1 assign string 2 or as we are doing here city
assigned, my city that would not do that assignment operator will not work in the case of
strings. So, city assigned Calcutta is invalid.

String length s t r l e n this is you I will ask you when we teach you function, to write a
function for finding the string length although it is available in the standard c library.
Counts and returns the number of characters in a string. So, len suppose len is a variable
of type integer, len is of type integer len is of type integer and we say s t r l e n string.
So, string is some string all right some variable name s t r1e n city. So, city is a variable
and whatever is the n suppose city is Mumbai, it will find out the length of the characters
in this string and that will come in to len. So, len here we will get the value 6 when I do
this function on this on the string.

The null character at the end as I said is not counted because that tells you that you need
not count any further; counting ends with the first null character.

So, if I do Calcutta if I copy Calcutta the string, constant calculative city and I find out
the length of city it will be 1 2 3 4 5 6 7 8 and backslash 0 will be left out. So, n is
assigned 8 writing the string length.

So, one problem that can be given to you that I am not talking about this function part
right now.
Suppose I am trying to find out the string length of a character string I am trying to find
how do you find out string length I mean its writing a program that is finding the string
length you need not bother about the structure of this as yet, but let us look at the
algorithm purely what is being done? Len some variable has been put to 0 and then while
I am not encountering now s t r is an array of course, array of characters. As you can see
its an idea characters as long as that is not equal to backslash 0; that means, not the end
of the string I am going to going in going on incrementing this len, len was 0 len
becomes one like that and then we return len after I completed then I return len .
Now, this is provided in the of course, I have to include the string dot h, but this thing
this is what I am writing if, but actually this is a already available. So, I need not write it,
I need to simply include hash include I call it hash include strings dot h that library.
There similar program is already written and when I write strlen that is the program that
is activated.
String compare is comparing two strings.

So, we are comparing two strings and returns 0 if they are identical what I just now said
was just the opposite. If they are matching then it returns 0 and if they do not match a
little non intuitive. So, keep it in mind that if the two strings match, then we will return a
0 otherwise will return a non-zero.
So, example is here if I compare city with the string Delhi is 0 then I do something. What
does it mean city is a string already, suppose that is again Chennai suppose that is
Chennai and I am comparing. So, city is a variable which has got this value, and I am
comparing with Delhi of course, now they are not matching. So, it will not it will return
non zero. But if the city was Delhi then these two have matched and I would have got a
one here right.
Now; obviously, you can also just think and decide how this algorithm can be written
that is 0073o, simple now you have learnt all the tidbits of writing such a program.

So, if this is not equal to 0 then then we do this. So, similarly I can do city 1 city 2 now.

So, before that you can simply think of how the algorithm will look like in case of this
suppose I have got two strings.

One is say Chennai and the other string is of course, backslash 0 here instead of n there is
a name here.
So, how will you do that? So, you will compare these two character by character. So, this
is suppose city 1 and this is city 2. So, you can very easily compare while city 1 i of
course, i has been assigned to 0 here is same as city 2 i what shall we do? We will go on
incrementing I plus plus, but and if it is not equal we will come out.
So, this here I compare here I compare I come here and here I find that city 3 here, city 1
3 and city 2 3 are not the same. So, I will come out, but what happens if they are same.
So, I need to put in if they are same I how long shall I go on no mismatch is there
suppose this is also n while city is city 1 is not equal to city 2, while city 1 is equal to city
2 do I need another condition here yes and city i is not equal to backslash 0.
So, are you understanding this, while this condition which I have already written there.
That should be true in order to proceed in order to proceed further for further checking, I
should they are matching. So, I should proceed and, but and also the fact should be that
none of these two cities names. So, two strings have reached the end is not equal to this and city 2 i if any one of them has matched has reached the end
then my while condition will be violated. So, I will not continue any further.

So, I can keep a flag here that what should I say match is one. So, if I go on doing this
match will be remaining 1, whenever I come out of this loop I will make match 0 that
means, it has there has been a match because the convention is that if they are matching
then it should be 0. So, you please also try to write this function right this program right
we will ask you to make it a function a couple of lectures later. I hope this is clear this
part please try to understand this condition try to understand this condition all right.
Next we have got the last one that is a s t r c a t. that is rather simple you will also be able
to write the program for that it is two strings are just being kind of concatenated, but one
thing that you must remember appending concatenating means joining, while appending
means at adding one at the end of the other. So, when I write this a b c, p q r then p q r
has been appended to a b c .
So, string 2 is appended to string one; that means, it is joined at the end of string 1. So,
the null character at the end of string 1 is removed and string 2 is joined from that point.
(Refer Slide Time: 32:48)

as we said that there can be a b c backslash 0 and then when I append p q r to that, then p
q r will p will replace this and backslash 0 will come here. So, ultimately we will have a
b c, p q r backslash 0 all right.

So, string copy suppose I have name one a string assigned by string copy Amit; A m i t.
So, it looks like this a m i t backslash here there is a backslash 0 and there is a blank here
you see the string is not a m i t a m i t blank and another string is name two which is R o
y, then when I append them concatenate them there it will be a m i t blank this blank and
then R o y and this this blank has been replaced by r. So, r has gone here and we will get
this.
So, this is string concatenation this will often come handy when you type in some
character strings or type and lines or compute using some text strings text English
sentence has been given and you are trying to find out where the verb is and all those
then you need a lot of string operations like this.

So, here is an example here we are reading a line of text and counting the number of
uppercase letters how many uppercase letters are there. So, what are the things we are
including here? s t d i o dot h and old friend is here, string dot h is also there then look at
this function I have defined a line to be of length 81 big one 81.
Now, I have got the variables I and current count is equal to 0, I am asking the user to
input the line I am reading the line using this format which we just discussed; that means,
anything can come here I mean anything can come here like a b c slash, dash alright
percentage p whatever is coming except backslash n its coming here and then I am
finding the length of the line.
Suppose the line that was actually typed in in this way through this scan f is say apple
blank is red.

All right and then there is backslash here now this string length s t r l e n will find out the
length of the string 1 2 3 4 5 6 7 8 9 10 11 12. So, 12 is n is becoming 12.
So, for i equal to 1 to n, now here is another new function that we are finding is upper if
the character is upper case letter, is upper if the character that is being red that that is
being passed here I put in some character and if the character is an upper case letter then
I will count that. So, suppose here I make a little change I say this is I say that this is
capital and I say that this is capital.
So, what is happening is it is reading character by character from here I 0 onwards, and
checking whether this character is an upper character if that is so, count is becoming 1.
So, count becomes one as a is upper case letter, then we go on in this loop i is being
incremented until it comes to 12 less than 12. So, here is another one. So, I will get the
count to be 2, it goes on and here I will get another one. So, its free print f the number of
uppercase letters is percentage d is now look at this. The number of uppercase letters in
string percentages s is percentage d. So, line will be printed as a line apple is red the
number of uppercase letters in apple is red is 3.
So, here this program demonstrates a couple of things.

One is first of all this is a new thing that you have learned is upper, I am just writing it
separately. So, that it is clear, but in actual c library the function is written in the form
without this gap or without any special character in between, this is the first thing that we
have learned. And how we have already seen it is an application of what we learnt how
we can read a line using this wildcard format. And then we found out what is the length
of the line by our newly learned function s t r l e n; and using that we have this is this
looping we already know we have practiced it so often.
So, we now using this value using this for loop for so, many iterations. So, many
repetitions that is determined by the value of n will check the entire string. So, this is an
example of applying the string function in string operations, will go further with some
more examples later.

We have looked at arrays and their utility, we have in particular looked at one
dimensional array and today we will introduce another variety of array, which is 2-
dimensional array. In fact, we can have multi-dimensional arrays in general arrays can
be; we can have in n dimensional array.

For a particular value of n equal to 1, we are having this one-dimensional array, right?
Where, I have got some say 1 dimensional array of integers. So, for n equal to 2 we can
have 2 dimensional arrays; that means, where there will length and there will be a
breadth of the array. So, that array can be considered of consisting of a number of 1
dimensional arrays for example, as I am showing in this diagram I have got 2 dimensions
on this dimension, I have got 4 rows on and on this dimension, I am sorry, this let me
draw it a fresh.
So, on this side I have got 4 rows and, on this side, I have got 1 2 3 4 5 6 positions. So,
these are called columns and these are called rows, right? So, here I have got 2
dimensions one is the length, that is 6 or 6 columns and the breadth which is 4 rows
since, these 2 dimensions. So, it is a 2-dimensional array.
So, a 2-dimensional array like this can be considered to be consisting of see in this case 4
1 dimensional arrays arrange one after another. So, this is one array, which we learnt till
now this is another array this part is another array this part is another array. So, we have
got 4 different arrays 1 2 3 4, 4 different arrays arranged one after another.

So, I can have for n equal to 2, I have got rows and columns. So, we get 2 dimensional
arrays. Similarly, for n equal to 3 we can have 3 dimensional arrays, like so I have got
one 2 dimensional arrays like this, and we can think of another 2 dimensional array line
here, another 2 dimensional array line here, in that way I can have an arrangement of say
may be 3 or 4, 2 dimensional arrays one after another, that is also an arrangement each of
these may be 4 rows and 6 columns, sorry may be like this 4 rows and 6 columns.
So, this row this 3-dimensional array will be 4 rows 6 columns and 4 such, 2 dimensional
arrays this is one 2-dimensional array this another 2-dimensional array, I am and this one
2-dimensional array and we have got 4 such 2-dimensional arrays arranged one after
another, right? If I had a one more here, if I had one more here, same array then this
would be changed to 5, in that way I can extend my concept of arranging data as we had

done for 1 dimensional array, we are extending it to 2 dimensions 3 dimensions in that
way, it be difficult to concept I mean show it on the this screen we can go up to n.
So, n dimensional arrays, which will have different dimensions all together, but today we
will be just discussing about 2 dimensional arrays and the thing is quite general and can
be extended to other dimensional arrays also
So, we are now, talking about 2 dimensional arrays you can see the most common
example of 2-dimensional array is a table means an arrangement of data just like this.
This is list arrangement of information is known as a table, often we see table in other
forms also for example, I can have a table of something like this.

So, the first here I put name of the boy, name of a student then I store age of a student,
school to which the student goes and address of the student may be, and I have got such
scope of keeping it for say 4 students one student number 1, student number 2, student
number 3, student number of 4 and I go on. So, this is this is known as a table because, I
am organising them in a organised in a tabular form.
So, this is a table. So, what we were looking at now, is another table where here I am
showing that, there are 4 students student 1, student 2, student 3, student 4 for each of the
students I have got some marks in the different subjects, subject 1, subject 2, subject 3,
subject 4 and subject 5. So, I can consider that all the marks of student 1 in the different

subjects are stored in a row, this row for the first student similarly, this row for the 2nd
student, right? Similarly, this row for the 3rd student and this row for the 4th student.
So, each row wise I get the information of all students and column wise if I look in this
direction, what do I get in subject 1 what are the different marks? And who have got
what marks? And most interesting part is the intersection say for example, this element
of the array what will this element tell me, this element has is identified by it is row and
column, which row it is in and which column it is in, this element is 75 when what is the
meaning of this 75 is the student 2s sub marks of subject 2, it is in whatever we tell you
can tell, that is the subject to marks of student 2, this is the subject 3 marks of student 3.
So, in that way, I can represent any of these as identified by some row, name row
number and column number recall that, in the case of 1 dimensional array.

When we are talking of one dimensional array there we had indices index, right? So, that
index was telling us say for example, there are suppose these are marks again out of 10
alright, and I wanted to know what is the marks in subject 1. So, the i value i equal to 0
was pointing me to this, suppose this is marks i value was showing this, if I take the i
value 1, then I get the marks of this subject like that now, in that case in the case of 1 if I
wanted to have this element, that was identified by i value equal to 0 1 2 3 4, but in the
case of a 2 dimensional array just as we are seeing here, we will be getting to a particular

element again in the same way with index, but here say for example, this element this
element here.
How do I identify this element? This element will be identified by this row and this
column. So, my index while this was for one dimensional array the index was i, in this
case the index will be i and j. So, any pair i j pair will identify which row and which
column. So, this particular element is determined by the i value again just because, it is
see I am saying that, it is starting from 0 1 2 and here 0 1 2 3 4. So, say this element can
be identified by i is equal to 1 1, right? For example, this element this element is
identified by sorry, index value i j I am sorry here, the index is 1 1.
So, the i j pair a pair is 1 1 for this i should be 1 and j should be 3. So, this pair is
identified by 1, 3 whenever I get. So, suppose here this array was marks, similarly I will
have an a name for this 2-dimensional array and I can access any element by this indices,
but in this case since it is a 2-dimensional array, I have got 2 pointers 2 parts of this row
part and the column part. So, here you can see that, the subjects are organised in this way
subject marks are organised in this way and we can access any of this elements using the
proper indexes student number and the subject number.

In the table that was shown here, a showing how many elements 1 2 3 4 5 into 420
elements, right? So, the table contains 20 values 5 in each line and it can be arranged
organises as a matrix 2-dimensional matrix consisting of 4 rows and 5 columns.

Now, C allows us to define such tables by using 2-dimensional array what does it mean,
the general form is like this type, array name, row size, column size. Always you
compare with what we learned for 1 dimensional array is just an extension of that, for
example, marks 4 5. So, in this case which we saw just now, it is an array with and let us
call this say, the name of this array is it also marks.

And marks has got. So, let me write here, because it is marks and it has got 4 rows and it
has got 5 columns. So, that is how I can describe this array, and then we can go on filling

up the values of this array. So, array name, row size and column size. So, for example,
int marks, similarly I can have cells of 25 items over 12 marks may be say, I can have
something like, so let us try to see what this possibly can mean is that suppose I have got
a table where, there are 12 rows alright, I will have 12 rows here and there will be 25
columns here alright, there will be 300 items so I am not showing that.
But say each of these rows may mean say this is January row, this is a February row, this
is a march row etc, and suppose here there are different items or shop has got different
items and in that way it has got 25 different items and here. We write how many units of
a particular this row is shirts alright, this one says that, in the month of February how
many shirts have been sold and may be this says in the month of say this is pen in the
month of January or in the month of January how many pens have been sold?
So, in that way this entire matrix or this array can be named as the arrays cells, which
will have 12 rows and 25 columns, similarly and another very important thing to note is
this type, this type that we declared also in the case of 1 dimensional array is also
applicable here, because each of these elements in this array will be of the same type. So,
here cells I am saying and I have said cells is float.
So, the way I wrote it is not correct I should write it as say, how many elements are
there? What it can be that in the month of January? What is the worth of not how many
shirts were sold? But, shirts worth how many rupees were sold. So, it can be here 100.5
say because, each of these elements have floating point numbers, alright? Similarly,
matrix can be a 100 by 100 matrix where, each of the elements will there double
precision number. So, we have got 2 places, 2 dimensions that we are specifying here.

Unlike what we did in the case of a 1-dimensional array where, we did something like int
marks say 5. So, int marks 5 is a 1-dimensional array with 5 elements, I can say that
these are with 5 columns of this 1-dimensional array, which is 1 row had there been more
rows like this, then immediately I have to identify which row and which column and if
there be 2 such rows, then this array should be described as int marks say here, 2 5
because, they are rows.

Similar to that of 1 dimensional array, but we use 2 indices, indices is the plural of index
indices, right? So, the first one indicates the row and the second one indicates the column
both the indices should be expressions which, evaluate to integer values and that was the
case for 1 dimensional arrays also. So, if I have something like marks 2 5 these integer,
these values must be integers, I can write expressions we will show there later, but those
expressions must evaluate to integer values, alright?

Examples are x m n 0. So, whatever m value is m has to be an integer, suppose m here is
2 and n is 1, then in this array whose name is x we have got a number of rows and a
number of columns, which element am I referring to here, I am referring to row to 0 1 2
3. So, I am referring to this row and which column I am referring to 1. So, this was 0 1 2
3 4. So, I am referring to this column therefore, I am actually pointing at this particular
element, alright? This particular element.

Similarly, I can do operations like this what does this mean let us try to understands this
means, I have I am referring to 3 different 2-dimensional arrays one is a, which has got
some rows and columns and these another array this is a this is b and I have got another
array c..
Now, I am taking what is being done here, this means c i k. So, this c is being designated
by an index i, another index k this one is being done by referred by i and some j this 1 by
j and k what is being done here, that for different values of i j and k, I am selecting this
has got a special application, but I am not going to that I am looking at taking at the
taking a particular value from here, that is c i and c k k is pointing here.
So, this one I am taking and adding that, with the product of a i and j, j might be pointing
somewhere here, I am taking this element and I am taking may be b j for b array j row I
am sorry, j row j should be here, j row and k column. So, I am taking another element
from here. So, I am taking this element multiplied by this element here, and adding that
with this element that is taken from c, that is what I am doing. So, this simple example,
but this has got for mode implication you will realise that soon.

Here you see, what we have done here why is this example shown here, you see we are
specifying the index in the form of an expression, suppose j was 2 and here, which one I
am referring to a j into 2 so; that means, a 6 followed by whatever value of k was might
be 6 2; that means, I am referring to the element of the array a, a is an array whose 7th
row and 3rd column element is being taken.
So, if this be like this I am taking this 7th row element and 2nd or 3rd column element, I
am taking that value and finding this square root of that, and that is again being put to the
corresponding value of that, is coming to some other variable name actually this should
be since, this an array this should have been kept as some other variable in b, alright?

So, how is 2 dimensional arrays stored in memory we know that, a 1-dimensional array
is stored in a memory row I mean in the contiguous memory locations.

So, just for the sake of recalling if we had, if I have a 1 dimensional array say 3 5 4 7,
they were being mapped to the memory actual memory, here is the memory location the
different memory locations and I am storing them here, 3 5 4 7 in contiguous locations,
but what happens to the case of 2 dimensional array for example, if I have the array that I
am drawing here, with 3 rows and 2 columns, alright?

So, what is the dimension of this array a, a is 3 2 3 rows and 2 columns now, suppose it
is 1 7 5 3 2 0 say those are the values in that, case if I stored it in the memory I can stored
it now, I am drawing how it can be stored in the memory I need 1 2 3 4 5 6 locations in
the memory. So, I will have 6 locations. So, I can store them 1 5 2 7 3 0 or I can store
them as 1 7 5 3 2 0. Now, what is a difference between these 2 storages this one is I am
storing them column wise and, in this case, I am storing them row wise row after row,
right?
In c the compiler stores the arrays row wise, which is often known as in the row major
form and this is the column major form, but in c we are doing it in row major form there
is a specific significance of this. Because, whenever I want to access an element say a
array, I want to find the particular element say 2 3, which element shall I find out here
for example, here let us take this case and let me try to find out the element say A this is
A capital A I want to find out the element 2 1; that means, I am actually trying to find out
the row number 2 and element number 1. So, I am trying to find this one out. Now,
where will it be if I do not know. So, say this is accidentally I came coming to the same
let us say, let us make this 1 1 1; that means, which one row 1 column 1. So, I am
actually trying to find this element 3.
Now, what is the address of this element, where is it stored you can see that 3 has been
stored here if I store in the column major form, but if I store in the row major form it is

here. So, whenever I am trying to find this element out of this memory representation I
will actually have to fetch it from the memory, right? So, therefore, I have to find out the
address of this and for that, I need to know where it is stored row wise or column wise
since, I know it is row wise.
So, how should I go about it since, there are 2 columns, so for the first row I will say
that, if this been my starting address 1000 in the first row we will take 1000 and 1000
this is starting from 1002, alright? This is the first row, this is the second row, and this
means the second-row part and second rows this is one what is this element 5, this is
second row and 0th element and this one is second row and then the next element.
So, it is 1 1. So, using knowing that, whether it is stored in the row major form or column
major form is very essential in order that, I can find out the address of the element in a 2-
dimensional array, we will continue this further more explanations are required about
this.

So, we were discussing that how a 2 dimensional array is stored in the memory.

Now, we have already said that that is and 2 dimensional array is stored in a row wise
form. So, we have to find out the address of a particular element in the memory, right.

If we have a 2 dimensional array and the row and the column is specified all right. So,
say here there are 1 2 3 4 5 rows and 3 columns say a particular element here has got the
address say the name of this array is A this particular element has got the address A 0 1
2, A 2 3, A 2 0 1 2, A 2 2 right this element. So, it is stored how it is stored this stored in
this consecutive way first this one is stored then this one is stored, then this one is stored
row wise right.
So, if in my each of them have got a memory location, so if the location of this is 1000
and if it be an integer array then this location will be 1002, this location will be 1004,
this location will be 1006, 1008, 1010, right, in that way it will go on. So, a little thought
will tell you that if the starting address. So, what will be the starting address? What will
be the address of this? It will be 1000 plus how many columns have to come for each
column shift for each column. What will be the address of this? 1010, 1012, 1014, 1016,
right, actually this should be in the location 1016 of the memory.
So, we start with 1000 and then since each of the elements each of the elements are
taking 2 bytes. So, I will have to go for each shift 2 bytes and how many such shifts.
What is the distance from here to here element wise? We have got 8 such positions right
and so with that I can find out the address of this x. So, if this was x and this was element
was k then what would be my address; k into the offset is so many columns 2 3, 2
columns sorry 2 means 3 columns per row and 3 such rows. So, it will be 6 rows. So, in

general we can say that if x be the starting address of the array in the memory and c be
the number of columns and k be the number of bytes allocated then the address will be x
plus i into c plus j c is the column number plus j. How many columns are there? So, if I
go back to this if I go back to this I can say the how many columns c is each it has got 3
columns. So, k into 3 plus sorry 3 into k plus j right 3 into k means 2 plus j, j was 2.
So, that will be my result 1000 plus 6 plus two 8. So, that will be the location that I will
be finding out. So, here that is the formulation; x plus I into c plus j times k, k is number
of bytes allocated per element plus please look at this. So, the rows are the matrix is
actually stored as a 0 0, a 0 1, a 0 2. So, this entire thing is a 0 3, so 1 2 3 4 so there 4
columns in one row. Then, the second row a 1, a 1 column 0, a 1 column 1, a 1 column 2,
a 1 column 3, then, I proceed in this way. So, this is the arrangement of 3 rows and each
row having 4 columns and using this formula which is intuitive we can find out the exact
location of a particular element.
So, this part is row 1 this part is sorry this part is row 0, this part is row 1, this part is row
2, you can see that this is row 1 column 0, row 1 column 1, row 1 column 2 so and so
forth.

Now, given so that is how it is stored and how we can find out what the address is, but
how do we read a particular array elements into a 2 dimensional array. We have seen that
I can read one dimensional array the elements of a 1 dimensional array into the array by

repeatedly getting the character from the user and storing it in the proper indexes and
proper positions by varying the index right. Here also we will be reading one element at
a time and we will store them. So, my array is say the array that I am storing is a i j
having some rows and columns and i is the row index and j is the column index. So,
initially in this for loop look here, there are there is a nested for loop here. So, first I am
keeping the i fixed for i equal to 0. Now, I come here inside this, inside this there is a
nesting of for loop say I have got 4 columns. So, for j is equal to 0 to j less than 4? What
do I do? I scanf and a i j now each element here each element here is identified by the
row number and column number and so this one is and a 11, this one is and a 13 in that
way we do.
So, now for j is equal to 0 I read the particular value and store it here suppose it is 5 next
what is done, I am still inside this loop i increment j. So, j comes here note that i is fixed
still how long will a i remain fixed as long as I am inside this inner loop and how long
shall I be inside this inner loop till j reaches the end of the number of columns. So, next I
read the other value. So, it is 2, next I read the other value it is 7, next I read another
value may be it 0, then it comes to 4 comes to the end of the row because all the columns
have been filled up then I come out of this loop and again go inside this. So, i is now
incremented, i is now incremented to this one and I again do the same thing inside this
loop. So, this inside this loop is filling up a row and this one is filling up all the rows.

Please take a little time to understand this. This loop, I am once again explaining this
loop is filling up one row keeping i fixed, i is fixed and in a loop I am filling up the
values here, here, here, here and then I increment this one. So, this part for filling up all
the rows one by one, I come here again and again fill this up then I increment i and again
fill this up again I increment this i, come here and fill this up all right that is how we read
the elements of an array. So, that is being what is being shown here.

The ampersand is necessary here just as in the case of an array it was necessary it is
necessary here as well. The elements can be entered all in one line or in different lines it
really does not matter whether you pet type 5, blank 6, blank 7, blank 8 or you type 5
enter 6 enter like that that really does not matter because we already know that every
element will be stored in a row wise fashion.

How to print the elements of an array? Again, suppose I have got an array, suppose I
have got an array suppose I have got a 2 dimensional array and I will have to print the
elements I cannot just print the array in one shot I cannot do that. So, again here I will be
fixed and then I will print say this is a 0 1 2 3 0 1 2 3. So, first a 00 will be printed
whatever was the value here I am printing it here, then j will be incremented. So, the next
one that will be printed will be a 01, next j will be incremented. So, it will be a 02, a 03
so and so forth and then I will be incremented again in this way. So, it will be next
printing will be a 1 and j will be reinitialised to 0 1, a 10, a 11 and like that it will be
printed.

Now, the elements are since it is a back slash n you can see the elements have printed
one per line because every time I am printing I am giving a back slash n. So, although
the; my array could be 1 2 3 5 4 6 7 9, it will be printed as 1 2 3 5 4 6 7 9 because at
every point I have given a back slash n.

Now, here what are we doing here? In this case the elements will all be printed in the
same line because I have not put the back slash n. So, it will be printed all the elements
say sorry all the elements say 1 2 3 4 5 6 7 8, it will be printed in this way if that was the

matrix then this part will be printed in one line and then I go up there is no back slash n
this one will be followed and the entire thing will be printed in one line, 1 2 3 4 5 6 7 8.

But if I had done this that first I had this again 1 2 3 4 5 6 7 8 and I want it to be printed
in this way because here I have not given any back slash n it will be printed one two 3 4
and as it comes out of this loop it goes here and comes to the next row first thing that it
does is printf back slash n. So, the control will come here and then 5 6 7 8 will be printed
therefore, this is a better way of printing a 2 dimensional array. So, that it looks like a 2
dimensional array.

So, that this will make the elements now the question is you just think how can we print
two matrices side by side. So, suppose there is one matrix 1 2 3 4 another is character
matrix a b c d how can you print them side by side what should we do? Can you think of
that? I mean if I say I have got two matrices one is 1 2 3 4 5 6 7 8. Another matrix is say
a b c d. So, I they have different dimensions.
So, first of all, first of all how can you represent such a metrics? Say this matrix how will
you declare that simple this will be a character matrix character let us call the this matrix
let it be M, M is 2 by 2; that means, each elements of this matrix will be a character. And
this is int, let it be N, 2 by 4, right. These are the two matrices now you can think of how
you can print two matrices side by side. If I do look at this by this row by this I will first
print 1 2 3 4 and then what should I do? I should go to here I should again for j is equal
to j to M call might be j plus plus, I will be doing I will be printing M i j. So, this will
come immediately side by side if necessary I could have given another blank in between
and I could have printed this as a complete row next I go up and print this and this. So, I
suggest that you try to write this program and run it and see whether you get a nice
output or not.

Now, we come to a very well known problem that we often encounter matrix addition. I
am going to add two matrices. This is a very simple problem. So, all of you know how
this can be done.

So, I have got a matrix of the same size two matrices. So, it is 1 2 3 4 7 6 9 2 and there is
another matrix 10 12 15 13 7 14 3 0. Now, I want to add them and have another matrix.
First of all this is a matrix of 2 rows and 4 columns 2 rows and 4 columns. So, we can
say that this A is a 2 by 4 matrix and this one B is also a 2 by 4 matrix. Now, the sum I

will store in another matrix whose dimension will also be two by 4 has to be. And how is
matrix addition done? I will first take this element.
What is this element? I am saying this element what is this element. This element means
a particular i j value 0 0 element i 0 j 0 from these array. So, I take this element 1 and
then take b i j of the same i j value 0 0 1 add them together 1 plus 10 I get 11, I put that
11 in the i j value remaining same 0 0 of the c matrix. So, here it is 11.
Next, I am increasing the index i here j remains sorry I am incrementing whatever I do I
keep the I fixed and increment the j. So, i is 1, j is 1 is 0, j is 1. So, with that I take this
value 2 and take this value with a same i and j value, i is 0 and j is 1 add them. So, that is
4teen and I store this value here in that way I go on for this entire matrix that is how I do
the matrix addition. So, let us see how the code looks like for this and let us try to
understand the code this much is include s t d i o dot h then my main program is
continuing. What is being done?
Here I am trying to add 2, I am writing the program for adding 2 matrices of size 100 by
100 let us look at this 100 by 100, a matrix of size 100 rows and 100 columns, b of 100
rows and 100 columns and c of 100 rows and 100 columns. And I have got other integer
values p q m n. I am reading the matrices, I am reading sorry I am reading m and n
alright two values. Now, what is m and n? m and n although I have here recall the
difference between I mention about the size and the dimension is the maximum size the
maximum size that it can have 100 and 100 are the maximum sizes of the a matrix and b
matrix, but actually I can have I may not need so many locations. So, what I can do?

I have got a has got so much size, but actually I am filling up only these say this much.
So, this is my m, I am sorry this is my m and this is my n ok.
So, my actual matrix is small dimension is a largest size that I can accommodate all
right. So, I need that actual value m and n and then for p is an index p equals to 0 less
than m p plus plus q. So, I am reading the matrix a, and here you see I am not using the
conventional i j indices I am saying p is keeping account of my row and q is keeping
account of my column. So, for p 0 to m and q 0 to n I am filling up the a matrix, then I
come here fill up this matrix out of this outer loop.
This inner loop, with this inner loop what am I doing I am filling out particular row and
the outer loop I am going to the next column, repeatedly I am saying that. So, in this way
I read matrix a here, here I read matrix b then I am doing the addition here. Again my the
dimensions of the two matrices will be the same when I add and the result matrix will
also be the same according to matrix algebra, that is I am adding two matrices they will
result in the same dimension matrix. So, again for p equal to 0 to m and q equal to 0 to m
I take c p q. So, I have taken two matrices.

And now I am generating c matrix where this value this particular element is being
computed by the corresponding element from a and the corresponding element from b
being added I am filling it up and this is going on in a loop all right and so I fill this
entire thing up. What is a last for loop? This last for loop is nothing, but printing the
same array, printing the array in the proper way.
Now, here you please note that it is back slash n. So, it will come nicely after one row
there will be a we will go to the new line and we will print it this way. So, this is a matrix
addition which is a very useful very common and simple application of our knowledge of
two dimensional array to start with.
We will other applications of this to in a future. Now, the other thing that will be
discussing in the consequence lectures are next. So, we now have got an idea of 1
dimensional array and we have got an idea of 2 dimensional array. We have also seen
strings and character arrays. Next, we will move to functions in the next lecture. We
have already mentioned about the term functions while moving and in the course of other
discussion, and we have already seen one particular function that is main function that is
always there is a main body of any C program and we have also seen some library
functions. But next lecture onwards we will look at user defined functions.
We have seen some stored functions in the earlier lecture like string copy, string length,
finding string length, similarly a user can himself or herself write a particular function of

his or her own need. We will have to see why we need to write functions and how a
function can be written from the next lecture onwards.
Thank you.

In the earlier lectures, we had discussed about one dimensional array as well as 2
dimensional array, we have seen how one dimensional array can be stored, read and
printed and as well as we saw how a linear search can be applied over one dimensional
array.
Similarly we have seen for 2 dimensional arrays how it can be read, it can be stored, it is
stored in row major form and how it can be printed. Now today we will start discussing
on a very important and vital component of programming and also (Refer Time: 01:06)
of the C language that is functions. The concept of functions is very general and we will
have to first look at it from the general angle why it is required, what is a function?
And then we can look at some of the details of this the implementation of this concept in
the C language. So, first let us start with functions.

So, we will we will start to visualise a task.

Suppose I have got a big task alright which I have to implement by programming. Now
any task this is one task this task may be too complicated. And for any human
programmer or any human being to solve this task from the beginning till end in one shot
may be difficult. Often what we do we break up this task into a set of smaller sub tasks,
different sub tasks? And each of this sub tasks are smaller enough, small enough. So, that
we can manage it better each of these are possibly better managed, alright.
We can say if you think of a program segment a part of a program. If the task is broken
big task is broken down into a small task a number of small tasks, then it is easier to
write the program for each of these smaller tasks. And each of these tasks can be
independently tested for it is correctness, whether it is working properly or not each of
these can be separately tested.
And then if all these are connected together if all these are connected together one after
another and then I can ultimately get this enter task done. So, instead of addressing the
whole task into execute the whole task, or implement the whole task, as a single task it is
often advisable to break it down into a number of subtasks.
Now let us talk about programming, now if we want to know what is a when we say the
term function, if we take the English meaning of that function is means doing something.
So, it is a also a task therefore, this entire function can be broken down into smaller
functions and each of this functions can be implemented independently.

So, the advantage that we get by this means is that we can divide the problem into
smaller parts and thereby we can conquer the small, we can conquer the smaller sub
segments and in the process, we in the process we achieve the complete task that is the
first thing. So, by this it is easier to implement and also easier to test or verify.
We can check whether each of these components are working correctly or not. Now
when we find that all the components are working correctly and if they are connected
together correctly, then we will have the entire problem solved correctly that is the first
advantage of writing a complex program broken down into smaller functions.
Now the other advantage is suppose I had 2 implement one task.

And in order to implement this big task, I had to write a number of functions smaller
functions. Say 3 smaller functions together implement this big function alright. So, let us
call them f 1 function 1, f 2 for function 2 and f 3 for function 3.
Now suppose I have now this problem has been solved by solving each of these 3
functions, each of these 3 functions have been written and tested and consequently they
have been connected together and we have got the complete function. Now suppose
another friend of yours wants to write another task solve another task say this was this
was also a task.
So, this is also a function I am writing that as capital F 1 and there is another friend of
yours who is trying to complete, another task which we are naming as F 2. Now in order
to develop F 2, he finds that I have to solve some problems some sub problems, which
are solved by f 1 and another sub problem which is solved by f 3, might be that this sub
problem requires f 1, f 3 and say another function which was not written by anybody till
now f 4.
Now; obviously, since f 1 has been written and tested he the writer of f 2 did not write f 1
again, because that f 1 this f 1 can be used for this purpose similarly this f 3 can be used
for this purpose, and only effort that he has to spend is to write f 4. Thus the functions
which are written already right can be reused.

So, this reusability is another very important advantage of writing functions. Now we
have said that in order to solve F 1 or F 2 we have to write we will have to independently
write and test smallest functions and connect them together. What do I mean by
connecting them together let us try to understand that.

So, say we have a function that is to be done developed and we find that this part has to
be this part; this task has to be solved by some function. So, I write a function here for
this part; let me do it again.

This is my whole problem that I have to solve. So, I am solving some things here some
steps I am solving. And then I find here there is something that has to be done which is
not very easy. So, for that I came at this point and for this I need to write a function or
might be there is a function already existing in my library, which has been writ
ten by somebody else, which I can reuse.
Now in that case and also say here after doing that here I can do a couple of simpler tasks
and then here I come to another point, which requires it to be independently solved and
written. So, I need a function for that and then after that I will do some more simple
things and my task will be over say this is a situation.
So, when I come here I will have to I means this program, which is a main tasks main
task that I have to solve. So, since we have seen the name main in our description for C
earlier, let me also name this to be main and I am just for nothing I am just putting some
parenthesis here.
So, main is a main task that I have to do and at this point I am doing somethings and
here I need the help of this, now remember. That this function whose name is say f f 1
that can be used by my main function or somebody else main function also. Therefore,
when I need this to be executed with my data, then I must whatever data I have prepared
here that some of that I will have to pass on to this here.
And this will solve this subtask and then I will have to; that means, a this must give back
whatever it computed to the main task and the main task will continued doing simple
things here. So, you see that there are 2 links; one is going in the function, another is
coming out or some data that is being returned by this function. This is being returned by
this function. Then I carry out some tasks simpler tasks here and at this point I find now I
need help.
So, some part of the data from here will be used by the function f 2 and that has to come
to f 2 here and f 2 will carry out the task and will return to the point here. Now about this
return you should observe one thing, that the function was called from this point, we call
this thing to be a function call function call with some data being passed on to this. And
function calls or function invocation and after invocation this function works and it
returns where does it return?

It returns to the point in the main task just after the point from where it was called. It was
called from here. So, it comes here and then returns to the next point just after the after
this call. So, this is a calling point and this a return point.
Similarly for here you see that it is executing and at this point it is being called. And after
execution the control is returned into the immediately after the point from where it was
called.

So, this is one important thing to understand the other important thing is that let me draw
it again here. I have got my main task and this is my main and here is another main task,
some other main task not written by me, but somebody else this is of mister A and this is
of mister B for mister B there is he has written another main.
Now mister A or mister B both will require this function f. Now the task the purpose of
what this task does is same for example, this task is computes the average of some
numbers, 10 numbers, 5 numbers whatever it is or may be floating point numbers,
integer numbers, whatever it is it computes the average.
So, let me let me quickly rename it not keeping it wage any longer let me call it, average
or for a specific purpose, I want to write it inside the reason will be clear immediately
this computes the average.

Now mister a wants to use this average function for some data for 3 data he wants to
compute the average of 3 integers, suppose this one this one computes the average of 3
integers, but the integers can vary right. So, this also wants to find the average of 3
integers to make it simple.
But the in numbers for which A wants to compute the averages different from the
numbers that B will compute the average for, but this a v g is common to both therefore,
suppose the numbers that some integers say are a b and c and here this person wants to
find the average of 3 integers which are p q and r 3 variable names.
Now this average cannot remember p q r or a b c it will simply just like think of a box
with 3 pipes coming in and data will come in through there. So, he just names this
average for he names these pipes as x this is y and this is z. So, when this function main
wants to compute the average of a b c he must send a through the pipe x b through the
pipe y and c through the pipe z and you will get the average computed, and the average
will be returned from the point where it was called from this point immediately after that
it will go back clear.
Now when let me change the colour, now when the function main B; B wants to compute
the average he wants to compute the average of p q r. So, p will be sent to the pipe x, q
will be sent to the pipe y, and r will be sent to the pipe z. And the average will be
computed suppose it was called from this point, from this point, this average was called.

So, then it will return the to this point with the value of the average with the value of the
average whatever is computed here.
Therefore, so if this is clear then let us come to 2 more terms.

They are that this function main A, A is main was sending a, b, c to the function as
parameters we call it as parameters. And this function which is our average function is
not biased to a, it has got it knows that it needs 3 inputs and there are 3 input pipes, 3
input positions.
So, these x y z are arguments this we call as arguments alright; that means, this average
when it is written it has got 3 input pipes. So, we can write simply like this function
name average with 3 parameter arguments x y and z. Now who ever calls it we will have
to establish the mapping, between the parameters that it wants to pass the parameters it
wants to pass to the through the arguments.
So, the connection that we had shown in the earlier diagram which was where both the
programs, were both the programs are accessing it. So, each of these parameters should
the parameters should be matching with this arguments. Let us come to this once again
say.

So, here is main of A and here is main of B, I repeat what I was saying till now and this
has got p q r now, you must be must have realised now, what are these p q r? When I use
this function average, which has got 3 arguments x y z which are nothing, but 3 pipes
which are arguments and when I call from some point, when I call this function average
then I have to pass these parameters p q r to these arguments x y z.
So, p will go to x q will go to y and z r will go to z, on the other hand when a is calling
when a is calling, what is happening, when a is calling then a had the a b c to be passed
on to this. So, a goes to x, b goes to y and c goes to z. Now since now if you just think
these are 3 pipes, now the pipes are every pipe has got a width.
So, if I want to fit smaller pipe into a bigger pipe that would not fit. So, the width of
diameter of both the pipes must fit together, what do I mean by that, what I mean by that
is that whatever arguments are whatever are the types of the arguments that must match
the types of the parameters or in other words the types of the parameters also must match
the types of the arguments. So, that the pipes fit there should not be any mismatch over
there. So, let us take little more deeper look here.

So, suppose I have got a main function here I am not so much bothered about the same
types now and the main function is running and here I want to say result is average of a b
c and etcetera, etcetera, etcetera, etcetera and we end here. And let us assume that here I
have declared int a, b, c both of them are integers. Now we have got the function which
is average.
Now, this average of 3 integers can be a float. So, I just write I will explain it a little later
float average x, y, z and I can say int x, y, z and whatever I am computing average here
and. So, thus this is simple you can have int sum and sum equals x plus y plus z, and
average is equal to x plus y plus z by 3. Then I write returned, why do I write returned I
will come to that.
Now look at the 2 things a I will talk about this part a little later. Here I am I have
declared a b c to be integers. So, in the memory for a b and c 2 bytes or 4 bytes as the
system may demand that type of that much memory has been given. Now when I write
here a v g; that means, I am invoking or calling this function a v g. And I am passing on
a v g requires 3 parameters x, y, z and x, y, z are all integers. And I could have written
there is another way of writing it that I could have written here int x int y int z that is also
possible, but later we will see.

So, a, b, c there is a correspondence between a, b and c with x, y and z. And they are
matching in the type then this computation. So, we come here then follow my blue line
this is being computed and ultimately the value of average is computed.
Look that the value is being computed in a v g which is also the name of the function.
So, in a way you can say that the name of the function is just like a variable that is
holding the value, that is holding the value. So, that average any variable that is holding a
value must have a type that is why since average of 3 integers can be a float therefore,
we have to assign a type to the name of the function.
Designating what type of value it is returning. So, here we can see that it will compute
average and then there is a statement new statement that you are encountering here is
returned, where is it returning it is returning to the point from where it is called at is this
point.
So, the average, suppose if the values are 1 2 and 3 then the average is 2. So, then 2 goes
to this a v g and that a v g is being transferred to result. Now if I do print result here 2
will be printed. So, this is to give you an idea of what is meant by in calling a function
invoking a function, what is meant by returning from a function, and what are parameters
and arguments.
We will see more of this in the subsequent lectures, but you should also understand why
we do this reasons at 2 fold as I said one is to divide or break down a complex problem
into manageable sub problems, and the second and test them independently, and the
other issue is other advantage big advantage is that once we make a thing a function,
which is tested we can keep it for being reused that is a very very important thing.
And this concept is general over different languages like; we have got class etcetera
which we can reuse a number of times. And this is this idea the implementations are
varying from language to language, but the concept is common and is used in different
languages.
Thank you and we will continue with functions in the subsequent lectures.

We have seen what a function is, and why a function is required, what are the advantages
of using a function? We have also seen, what is a parameter and what is an argument,
and the types of the parameters in the argument must match. Otherwise, the system will
of course, give you error and the reason is because there will be type mismatch and the
data will not be passed properly ok. Because this is essentially a parameter is being
assigned to an argument ok. Now, in this lecture we will look at some more detail
nuisance, detailed points of function. So, to start with let us revise what we have seen.

A function; what is a function? A function is a self-contained program segment. This
very important; this not the whole program, but it is self-contained, and it is a program
segment; part of a program. That is a main task and a part of that being executed is being
implemented by this function, and this self-contained because this can be independently
tested giving data and finding out, whether the task for which it has been designed is
actually being fulfilled or not ok. It carries out some specific and well-defined task. Now
that is the general concept of a function, now in C, any C program can consist of one or

more functions. At least one should be there why, because we need always the main right
we have seen that we need main.

Any C function must have a main. And main is nothing but a function. And why did we
put here this empty bracket; because the structure of a function is always a function name
and a place for the arguments right.
Now, you can say that well, when we are starting a main function we are writing a main
function that we will do the task, it is not taking data from anywhere outside. Therefore,
why there is no argument. Yes, you are right. There is no argument that is why we put 2
braces and there is an empty space here, this is empty, right? But still it looks like a
function. Moreover, in the earlier lecture, we have seen that the result of the function is
returned in it is name. And since this is a with like a variable, it will have a type. So,
some type like for average we found float.

So, this main can also have a type. So, we will see later that this main can have a type.
We will have a set of empty arguments and the body of the function, and there can be
some there can be type. Say, sometimes a type can be int. If this main function; that
means, this main function will return and integer and when we say that it does not return
anything, we can say also that this function is of type void; that means, it does not return
any value ok, void. So, we will see this later, but this is the reason why we say that every
C program must consist of one or more than one function. One of these functions must
be called the main; and the execution of the program always begins by carrying out the
instructions in main. That is the entry points any program. I mean, I cannot say that main
will be somewhere in the middle no.

When I start, when I start, it must the gateway is the main. And then from within main, I
can go out and use some function f 1, and from f 1 I can go out to another function f 2,
another function sorry, another function f 2 like that.
But the gateway the entry should be main; and ultimately the exit say f 2 will return here,
then f 1 will return here. Ultimately the exit will also be through main, alright? A
function will carry out it is intended task, whenever it is called or invoked. So, we have
encountered with this term called or invoked right.

So, in general, a function will process information, that is passed to it, from the calling
portion of the program. From, where it has from where it has been called or invoked.
And then, the function will take the data; that is, if some data is to be passed, then it will
be passed to it from the calling part. And it will return a single value. So, what are these
points? Information is passed via special identifiers, called arguments and parameters.
And the value that is returned is returned by the return statement. Some functions do not
return anything. For example, let us say this. Say, I am writing a function, say my
function.

It is maybe, it is not taking any parameters. Because in the body it is simply nothing
doing nothing just printing printf, hello, let us also valid function. So, in this case the
main function, where it was it was just here and it just called my function here with
nothing this also possible. So, my function it goes there and does not. So, I do not need
to give any return, but if I give a return that is also fine it does not return anything. So,
this of type void it is not returning anything. So, but the control in any case it does not
return any value, but the control will come back here and from here it will be executed.
So, there may be some functions, which do not return any value like it just printing some
data ok. That is possible for example; I can make it even more realistic.

Say here main is here, and there is int A 5, int B 6, alright? And here, I call average a
comma b, right. And here I write average int x, int y. And here I just compute average is
equal to x plus y by 2. Printf a v g equals back slash, a v g equals, I am sorry, percentage
f back slash n comma a v g. That you understand. And I can write return or I may not
write return. So, what will happen? This will come here 5 and 6, 5 will be passed on here
x will be 5 y will be 6. The value will be 5.5 that will be printed here. But I have to give
a type to this average, because here the average type is not defined. So, I have to say this
will be float average. Because there is some value, some type to this value some type to
this variable. Which will hold the value? So, this also possible here you can see that, I do
not need to write a return, but there is no harm, if I write just simply return, that is the
good practice; that means, my return my control will come back here. And that is the last
statement that will be the end ok. So, let us move forward. So, some function may not
return anything the return type is specified as void.

So, here is an example of factorial. We start with so, here first I have written the function
here, and then I have written the main.
But however, in whatever way we write, the main the program while execution we will
enter the main first, alright? So, so the execution will be something like this that will
enter from here main. It takes the variable n, which is an integer; then n1 to less than 10
n plus, printf percentage d ok, and n and then factorial alright. So, factorial a now when
this factorial n is encountered, then we the; this function is called. This function what is
doing? It has got int m. So, m is the argument, and is being called with a parameter n;
which has been which is being taken; first 1 then 2 then 3. Like that till it is 10.
So, I am taking it n, and then here let us see, what we are doing int i. Now, this i this
variable i and this variable temp. These 2 variables are purely internal variables; that
means, this variables are internal to the body of the function. Now each of the functions
has got a life, each has a life right. So, factorial as long as factorial is running factorial is
live, and when factorial is live, whatever variables are defined within factorial, they are
live. As soon as we exit from factorial, that function is dead. And the variables
associated solely I repeat. The variables associated solely with the function also dies with
the death of the function. So, let us see here i and temp. Then for i equal to one to m
temp equals temp times i. So, 1 times, 2 times, 3 times 4.

So, it is what is being computed, 1 times 2 times 3 times 4. So, like that whatever is the
value of m that is being up to that we are computing a factorial, alright? So, if I call it,
now here I have called it with n the value of n, alright? With a value of n, I am calling it,
and I am getting the factorial. And the temp is being returned, where it is being returned,
this temp is being returned to factorial temp is being returned to factorial, and that is
being printed through this percentage d, alright?
So, this is being printed. So, return temp, because why it is different? Here I did not write
return, because I have named it as factorial, and I have written temp then temp is going
to this value factorial. If I had not done return then ultimately; because here I am keeping
the result in temp; not in factorial has not been used as any variable inside the function.
Now when I go there, and suppose if I had use some other temp here, this temp and this
temp would have been different. We will come to this later, but this just an example of a
function being invoked.

We just recapitulating, why we need functions? This term may be new to you. It is
modularising a program, is breaking down a program into small parts. Each part
independent part is called a module. That is why breaking down a big program into
smaller parts is known as modularisation. So, it is modularising a program. All variables
declared inside function are local variables. Very, very important. Which are declared
inside functions are local variables; that means, they are known only as long as the

function is remaining running. As soon as the function completes it is execution. They
also seize to exist. Therefore, a value variable I for example, can be used as an internal
variable of a function, and can also be used in a some other function or in the main
function. They will actually physically be mapped to different memory locations.
So, we have also seen what parameters are. The parameters are communicate
information between functions, parameter and argument ok. They also become local
variables. So, parameter arguments are local variables the parameters means, the
arguments are also local variables. The benefits are divide and conquer we know we, we
has we have devoted one completely lecture on that; manageable program development.
Software reusability; all existing functions can use can be used as building blocks for
new programs, and this is another thing that you may realise later, that inside a function,
how I am implementing or how somebody has implemented, it may be very complicated,
and I need not bother about that.
I know what it asks for, what variables have to be put in through this and what output I
will get out of it? Therefore, whatever is there inside is abstracted out from it is hidden
from it. The internal details are not needed; that is, another big advantage of using
functions. And of course, avoid code repetition; something which somebody has written.
Or say for example, in a main program. Let us take another example to understand.

This better say, I have got a program, in which I am doing some computations. Say,
computing the standard deviation here, I am computing the standard deviation here, and
may be. So, at both these places I write this, write this, but that is not needed.

If I have a function for computing standard deviation then, here is my main program and
there is one function for standard deviation here. And from this point, I can simply call
this get the value again continue, from wherever I need I can again call this, and I can get
the value, and in that way, I save in the number of lines of code that I write. So, that is
known as avoiding code repetition.

Now, defining a function; how do you? Now we are till now I was trying to explain you
somethings, now we are looking at the syntactic details of a C function. Now that can
vary from language to language, but more or less the ideas are same. So, a function
definition has got 2 parts. The first line, first line and the sorry, the first line and the what
is happening here? First line and the body of the function ok. Now, what is the first line
typically? What can we have in the first line? First line we have got the function name. I
do not know why it is not coming. In the first line we have got the function name, and
the parameter list. I call it argument list, but whatever you.
So, a function has got the first line. And we can see; what the first line is? The first line
will contain the function name, and a return value type, what type of value is being
returned. Followed by this is the body of the function. The second part is the body of the
function. Where there are declarations and statements. Some internal values can be
declared internal variables can be declared here. And the other statements are also here.
Now, so, that is; so, this one I actually I am calling them argument. Some people also
call both of them to be parameters ok.

Now so, the first line contains the return value type. The function name and optionally a
set of comma separated arguments enclosed in parentheses. Like, say here I am defining
a function called gcd, greatest common deviser. It has got a type int, and has got 2
arguments. One is A and one is B, I have written the types of them in this parentheses
itself int A, comma int B they are comma separated.
The argument is possible that I can declare the arguments also on the next line. For
example, I can say instead of writing it in this way, I can write in this way int gcd A
comma B and in the next line before the body, before the before the bracket, probably in
earlier example I did a mistake, I had put the bracket inside the bracket. It should not be
inside the bracket. Immediately after that it you can write int A comma B; that means,
you are declaring that these are A and B. Either inside or immediately after that, both of
them are fine. Now these are called the formal arguments or some people also call it
formal parameters.

Now what is the body of a function? The body of a function is actually a compound
statement. I will just take just as I had statements like for loop ok, or. So, let us take or
say while loop or if conditions, where I write if some condition then some statement, else
some statement like that. So now, this whole thing is a compound statement. Similarly,
here the entire body of the function can be assumed to be a complete compound say
statement; where we are passing on to arguments and is giving us some value. Let us
look at what is being done here. In gcd int A, int B. So, from the calling function must be
I am supplying some values p and q, may be 2 integers of type integers, which are
mapping to this p and q A and B.

Now here you know we have seen this algorithm earlier. We take a variable temp. Now
that is now the body of the function is defined by these braces. Temp, while B is not
divided by A, as long as that does not happen. We take we divide B by A and take the
remainder, and then go on that classical way of finding the gcd, you find the reminder
and make the remainder the deviser, right? So, that is exactly what we are doing in a
loop.
Ultimately the final deviser which divides and gives us A 0, that will be the when it that
will be the gcd. So, that gcd now; that gcd is coming in this A. Therefore, I cannot here
just write simply return. I have to say that return A. And may be from the main function I
had something like say hcf is equal to gcd p comma q. Now, this a is being returned to
this gcd. And because this g c because it was a gcd function, this was called and that is
why it is going to a is coming to the here, and then by this assignment statement that is
going to hcf. That is how the function is being connected ok. We also see what is the
body of the function?

So, when a function is called from some other function. The corresponding arguments in
the function are called actual arguments or actual parameters; that means what I am
calling parameter, some people call them actual parameters. So, just in the earlier
example p q were actual parameters. And what was there a b or x y, whatever was there
is a b are the are the formal parameters or formal arguments. Now as we had said, the
formal and the actual arguments must match in their data types. The identifiers used as
formal arguments are local. Not recognised outside the function. The names of formal
and actual arguments may differ as we have seen here, they are differing my actual
arguments were p q.

And here it is A and B of course, they are differing. Now this A and B, whatever it is
here, this A and B will not be reflected anywhere outside this function. Suppose, here
there is a main, the main will not get the value of A and B, this completely local here and
as soon as it is ends the A and B vanishes, A and B will no longer B available to you.
Same is true for temp because temp has been defined internally within this function
alright. So, this is a very key thing that you must understand.
So, so, when a function is called from some other function, the arguments are passed
points to note that the names and of the formal and actual arguments may differ right.

So, here I will conclude with this lecture I will conclude with this example. So, here we
are computing the gcd of 4 numbers. In the main function, we have got n1, n 2, n 3, n 4,
4 values have been read here, you can see that they are being read as and n1 and n 2 and
n 3 and n 4. They are been read. Now the result is; now gcd of n1, n 2 gcd of n 3, n 4. So,
there is one function gcd; which takes int A int B, right that is what we saw. Now first,
when within this parentheses, we will first compute this gcd n1 and n 2. So, a will have
n1 the value of n1, b will have the value of n 2, and the function will return something,
return A as we saw in the last example, return A. And so, the body of the function
ultimately ends with return a. And that a will come here suppose that value was 3 say.
So, 3 comes here. So, what do I have now? I have got gcd of 3 comma gcd of n 3, n 4. So
now, this same function will be called with a having the value of n 3 and b having the
value of n 4. And suppose I compute them, and I find ultimately that the gcd is 5. So, the
5 will come here.
Then what happens to this? Then we will compute again called gcd with 3 and 5. So,
again here now a will have 3, and b will have 5 and the return of course, a 3 and 5 will be
a the result the hcf of 3 and 5 is 1. So, return a that will come here, and the result will be
one. That is how the gcd is computed in cascading of the function calls. The same
function you see is being called time and again repeatedly from this single statement in
the main function. We will continue looking at functions more.

So, in the earlier lecture, we have seen how a function can be invoked, and it returns the
values. As we had mentioned that it is not the case that always a function will return a
value here is an example.

You look at this function div 7 which says; that means, the purpose of this function is to
find out whether a particular number that is passed on to it as a parameter, and parameter
whether that is divisible by 7 or not. So, the program the code is very simple what should
we do? If n is divisible by 7; that means, if n modulus 7 is equal to 0, then we say printf
n is divisible by 7 otherwise we print n is not divisible by 7.
Now, in this case we are just printing from here straight the print out is coming printing
is coming out from here. The main function is only passing on the value reading
scanning reading some value of n and passing on that value of n here or may be here it is
n is the argument. So, might be the main program is reading a value num, and passing
that value num here. Now this num is also of type integer and the rest of the things are
being done by the function. It is testing whether it is divisible by 7, if it is divisible by 7,

it is printing like that otherwise its printing the other message. Now in this case putting
this return is optional, because even if I did not put the put the return when I would have
met these parentheses that is n bracket it would automatically return to the calling point.
However there is no harm if I put the return.

So, returning control; we have seen that how the thing is invoked by parameter passing.
Now returning control if nothing is returned then you can simply write return semicolon
or we can skip that and until it comes to the right brace, that is last right brace that is
automatically taken as the return. But if something is to be returned if something is to be
returned then we must put the return statement with say may be return A times B some
expression or it could be return C or it could be something like return 0 or return 1
whatever we have to do something, some expression and expression automatically in I
mean you know we will also capture the constants so.

Now, let us look at this example here you see the layout is also important here we are
first writing the function this is the function the function declaration is coming first
square of x square of an integer x and square of an integer x will also be an integer
therefore, the type of the function is int as you can see here. So, that is this whole thing is
the function declaration, then starts the body of the function. So, here the function
declaration consists of the name of the function, and the parameter that is x of type
integer and this int, here is a return data type what the type of the data type that will be
returned. So, these 3 together make the function declaration.
Next we are coming to the body of the function int y what is that that is a temporary
variable temporary variable why I am calling it temporary? Because it lives as long as
this function is active, as soon as the function is function ends the role the definition of
this y is also lost. So, here you see we will come to that later that here you see that this is
an internal variable, here I am computing the square y assigned x times x, and I am
returning y. I am returning y and after returned that y vanishes y where is y returning to?
Wherever they square has been called now here you see here is a sum of square the what
is main doing now let us come to main. Main has got some variables a b and sum of
square is another variable. So, printf give a and b I am reading a and b. Now I am calling
this function twice first with the parameter a next with the parameter b and a and b how I
mean in sequence goes to this argument x and the square of a is computed. So, return y
will return first here a square. So, we get a square here then this is called and y is

returned here. So, we get b square and then these 2 are added and we get sum of square
alright and then we are printing the sum of square. So, you need to you can also try to see
what is a flow of data in such cases alright let us move ahead.
So, these are the parameters passed and here are the, here is the argument you can see
that.

Now, invoking a function call here the same thing what is happening when a the thing
that I just now explained.

When I am saying now let us see what happens to the variables assume that the value of
a that has been read here is 10 alright then square of a means square of 10. So, 10goes to
x, right.

So, a is 10 here that goes to x. So, x becomes 10, now we compute y which is 10 times
10 I am getting y. Y is becoming hundred right now this hundred is coming here actually
this arrow is a little wrong here. So, it will be actually coming to this point clear next
suppose.

So, in that case, similarly it will be for b, if b was some value that is the how then x
suppose b was 7 then x will get 7 and then y will be 49, and 49 will come to that square
of b. So, 100 plus 49 will now be added and will be kept as the sum of square. So, in the
earlier example you could see that in the earlier example the first the function was return
and then the main now let us look at go ahead function definition.
So, we have seen that a function name preceded by return value type and declaration
statement and then the function body I am repeating certain things variables can be
declare declared inside the blocks the blocks can be nested; that means, there can
multiple blocks function cannot be defined inside another function this must be clearly
understood a function cannot be defined within another function and returning of control
the control will have to be returned as we have seen, if nothing returned then return we
have already seen that if something is returned then return that expression.

Here again another example of function, the more examples you do the better you will
understand. Here the function as the name implies you see its always better to use
meaningful names of functions some of digits of n. So, if there be number like 125 then I
am trying to extract this digits 1 plus 2 plus 5. So, that will be 8 that is what my program
wants to do. So, initially sum is equal to 0 while n is not equal to 0, sum plus remainder.

So, 125 if I divide by 10, then I will have 12 here and remainder is 5. So, sum plus 5. So,
sum becomes 5 clear.
Now, then we find out the device dividend that is 12 and again divide that by 10, we get
2 to be the remainder. So, we take sum to be 5 plus 2 and so and so forth. Ultimately I
am getting the sum. So, return sum this another example of a function; here you can see
that this n is coming as a parameter all these sum; sum is a an internal variable and will
not have life beyond the body of the program.

So, here you see sum of digits is a function name int is a return data type, parameter list
is that local variables is sum. Sum is a local variable and return statement is return sum
clear all these we have already discussed, this is merely a division; and here you can see
that the return can have an expression here only a variable is an expression.

Now, we come to a very important concept, which I was mentioning in the passing that
the life of an intern variable internal to a function exists as long as the function is live as
long as the function is active.
Now, that formally is known is called the scope of the variable or the variable scope. So,
let us look here there is an interesting program. Now here you see my entry point is the
main, but even before that, I have declared a variable int A; that means, this A is a global
variable that means, it is there always. Suppose it is A value 100 then it remains this this
is retained. So, let us keep this and let us see what happens. Now I am entering main and
I have assigned A to 1 now; that means, now inside this function inside this main I have
got mains A which is another A let me write it m is it visible let me do it in a better way.

So, there is one A, I am calling that A g that is this A, is A g that is the global A and
suppose that is 100. Now this is another a which is defined in the main. So, the function
this will be live inside main. So, let me call it A m alright. So, now, A becomes 1 here as
I come here a 1, then I am calling my proc a function my proc from here it comes to my
proc and suppose my proc has got another A here. So, let me call that to be A x just for
understanding that it is of my proc or let me call it let me call it of the function right; so,
AF. Now that is initialised to 2 now you see how many different as I have? Multiple as
now inside this block I initialise another A to be 3. So, that is another A that means, this
one is not being disturbed A is 2 and while A is 2 I am making another a because here I
am declaring you see this is a pure declaration int A. If I had just written A, if I had just
written A assigned 3, then this A would be assigned 3, but here I have declared another
A int A.
Therefore there is another A coming within this y while block that I am calling AB, and
that is becoming 3. Now I am printing A, which here will be printed the inner most the
current A that means, 3 will be printed then I break; break means what? I come out of the
while loop we have learned break. So, we come out of the while loop and then I print a
which is so, as soon as I break out of this this is gone no longer live.
So, I am coming here now which a is in my scope which a is in my scope, my scope is
this I am within this function. So, this A. So, that will be printed here. So, 2 or there was

some back slash n I am ignoring them that will come one after another and then I come
out of this its over. So, I go to this main function go back sorry not here I am sorry it
should go back to this point; that means, I will now execute print which a is in my scope
now I have come out of this come out of this function. So, the its scope is also gone. So,
the scope of this function main is now live. So, what is the value one? So, that will be
printed; that is how the things will be printed. So, we will repeat it if necessary, but let us
try to see the execution.

Now so, if I first do it then this one will be printed a assigned 3 next that is gone. So,
here A will be this will be assigned A assigned 2, then I will go up there and the A that is
in the scope of this function that will be assigned and then. So, that will be assigned ok.
You see although I declared a global A internally when I declare some other A, this
global A I have I look here a point has to be seen. I declared A, a global A here A g that
was declared. Here I have assigned to A, I have not declared another A, I have not
written int A I have simply written a assigned 1 that means, the a that was there is
already existing globally that has been assigned one.
But when I come here and I am declaring int A internally inside this process, another A
is created which is the A of the function and that is assigned by with 2 not this one, they
are 2 distinct entities. Now again here I have declared another A. So, since I have
declared another A, this is the A of this while loop might be and that is becoming 3 and

accordingly the corresponding whenever I say print which one will be printed, which one
will be printed will be the one that is within its scope this a is in the scope of this. So,
that was printed this and gone this A was is in the scope of this. So, printed and gone and
this A is in the scope of this and this is printed. So, this is known as the scope of
variables ok.

So, if we summarise functions, you can see this I do not know how much is visible. So,
main function I am calling of a function factorial, and we have already seen that and then
the function is having different its a self contained programme, which has got its definite
name function definition whether type of the argument is also specified. Now main is a
function and here I am calling a function, I am actually calling a function by name
calling by name and is a returned data type repeating that the function name is there the
parameter is there and the return statement.
And the other variables like temp and all those are local variables you are repeating.

Now some points is a function cannot be defined within another function, which we have
told, but I am repeating it again all function definitions must be disjoint; that means, I
cannot define one function within another nested function calls are allowed what is
meant by nested function call nested function call means that suppose here is a main
program going on.

I call a function this is function say F 1, and this was my main from some point in the
function in order to solve this problem F 1, I may call another function F 2 this is nesting

calling, but not defined they are defined separately F 1 defined separately, F 2 defined
separately, m defined separately. Now from F 2, I may call another function F 3 and F 3
completes F 2 has called F 3 because of some reason. So, that problem reason is
answered I mean for some value of a some computation that computation has been done
from here it returns to the point from where it was called. So, this a return point. So, is it
clear or should I use some other caller for the return point is it necessary. So, I am not
getting the colour. So, let me use the existing colour whatever was there. So, let it go. So,
from here now the colour has come. So, I can show the return here I am returning, but
then again I am continuing with this function.
And when F 2 is over, then I again return to F 1. So, it was called F 1 called F 2 for some
purpose that purpose is solved. So, I return here and then F 1 continues again in its
whatever it has doing and F 1 was called by main for some particular reason when that
purpose is served, then we return to this point and then main continues right and
ultimately main ends with this bracket. Now here this is known as nesting; that means, I
nesting of calls.
So, I have made a call, and from that call I can make another call from there I can make
another call. But the point to point to note is that all this functions must be independently
and separately defined they cannot be defined one among the other. So, nested function
calls are allowed A calls B, B calls C as I have shown m calls F 1, F 1 calls F 2, F 2 calls
F 3 like that it can happen. The function called last will be the first to return; obviously,
we have seen that in our earlier slide that we go back to the F 4 from F4 I return to F 2
and like that and. So, a function can call also call itself either directly or in a cycle, we
will see this separately what is meant by that. A calls B this is this can be in 2 ways one
is that say A calls B, B calls C, C calls back A that is possible like say here if we see that.

Main was running it called F 1, F 1 called F 2 and then F 2 can again call F 1 and then
this call ultimately for this call the return has to come here and ultimately it will have to
return here etcetera. So, this part will have to see separately that is its a function one
function is calling another and that can be in a cycle F 1 calling F 2, F 2 calling F 1 it can
happen or recursion means say a particular function F 1 calling itself a number of times
that requires a special attention and a special discussion that we have to carry out we will
do that in subsequently.
But right now just it is remember that these calls can be in a cycle or it can be called to
itself which is a recursion.

Now, we have got some math library functions, which perform common mathematical
calculations and I do not remember whether in an earlier class I mistakenly said that, I
had mistakenly I do not remember exactly whether I did that or not that you need to
include just as we include math dot s t d i o dot h, similarly we have to include math dot
h. So, just as we include s t d i o dot h if we use some mathematical functions which are
already available in the c library, we have to include math dot h. I do not remember
whether while first introducing the square root function, I have might be mistakenly I
wrote math dot leap that is a library function. So, dot leap if I had said that that you
should ignore it is math dot h include math dot h and.

So, here there is an important thing, when I compile you known any function that we any
program that we write we have to compile it in order to get and executable code. Now in
your exercises you must have done by now the typically you compile a c program like
this.

C c myprog dot c right, but if you use some mathematical library in your function then
you should write c c minus l m myprog dot c or; that means, link to the mathematical
library you compile first you compile now you see.

What is happening is the mathematical libraries are here say some square root function
somebody has written for you and that is in the c library alright may be some other
function like to upper, which converts from lower case to upper case all these things are
there. Now to upper is the separate library where square root is the math library. So, if in
your function you if in your program you write you refer to the square root some
mathematical library, then you must do this why because purely myprog dot c will
generate some object code alright object code.
Now the code for this has to be linked to this has to linked. So, that your ultimately the
fool executable code also takes into this account this code link to this code will be
forming your executable code because the square root you will need anyway at that time
of running it right. So, here it has shown minus l m at the later also c c program name
and then link with the mathematical library format for calling the functions, forget about
this let us make it for the time being ignore this just say percentage f function name. So,
this is point number 1, there are many mathematical library functions in order to include
in order to use them we have to include immediately after s t d i o dot h hash include
math dot h and we must use this give this linking command.
Now, when we call the function, the function name argument if multiple arguments then
we can use a comma separated list say for example, printf some format the square root
nine or there is only one. Argument not much arguments may be constant variables or
expressions all math now this is important. All math functions return the data type
double this is important you should keep in mind this are for c, all the math functions are
returning the data type double. So, in order to make it compatible with the variable where
you except the value returned by the math function that should also be double arguments
may be constants or variables.

So, here are some examples of math library function like finding the cos of some angle x
finding the sin thus all this functions are known as a sin a cos a tan inverse tan (Refer
Time:33:41) tan ceiling function floor function. Floor function means it finds the greatest
largest integral value that is less than x, suppose some say 200.56. So, the largest integral
value is 2 hundred that is the floor function. So, cos a cos is finding the cos of an angle in
degree whereas, a cos sorry cos is for finding the cosine of angle in radian now there is
no point in memorising them as and when you need them look at the manual look at the
book and very soon you will get a custom to the different library which are available for
c and.

We will come back to this in the next function, next lecture about some more very well-
known functions which you have already encountered with and then we will proceed further with recursion.
Thank you.

In the earlier lectures, we have looked at functions and we will still be looking at
functions. We have also looked at the library functions and just to recapitulate that,
whenever we are using some library functions in our program, then we have to some
mathematical library functions, then we have to hash include math dot h. And while we
link it, we have while we compile it, we will also have to link it with the maths library
with the option minus l m as we have seen.
Now, today, since now, we have got an idea of what functions are. Let us have a relook
at our old friends scanf and printf, which we were using a number of times. Now, scanf
and printf are nothing but functions. These are also some library functions and those are
included whenever we use include s t d I o dot h. Now, you see scanf and printf being
functions when we enter data, let us look at this structure.

We write scanf followed by some parameters. We have also seen that, a function is a
function is nothing but, something like f; say, function name followed by some

parameters. Here, this scanf is that function name and the parameters are the control
string; that means, say for scanf you have got something like percentage d and then x
alright. So, this is the control string and these are the arguments alright. So, both of these
are arguments to the functions scanf.
So, scanf is nothing but a function. So, whenever in my program, suppose I am writing a
program and here I use scanf with some parameters. Like this, then it is nothing but a call
to a system function. A system function which actually does the task of reading the data
from the input input device.

So, a control string refers to typically the data types of the arguments. We have seen
percentage d percentage f etcetera. And the arguments are pointers to data items in
memory. These arguments in scanf are what are; the typical arguments in scanf? They
are say, whenever I use scanf, say percentage d then and a or something like that right?
Now, this and is nothing but an address of the variable a. So, in my memory, wherever
the variable a is, the variable a the compiler is allocated this memory location, for the
variable a and I am passing the address of that so; that means, it is a pointer pointing to
some address or a pointer that is pointing to this particular location in the case of scanf,
ok. So, that is why, it said the arguments these arguments arg 1 arg 2 arg n are
representing nothing but pointers to data items in the memory .

So, the example, a typical example is, say, percentage d percentage f percentage c to
which is nothing but the control string, it is designating that and a; a is a is an integer and
and a is a pointer to a. And average is a floating-point number. And and average is a
pointer to average. And type is a character type variable. And and type is, why is type a
character type variable? Because, I have put in here and c since I have put in here and c
that tells me that this type is a character type variable and and type and type is a pointer
to the variable type.
The control string consists of individual groups of characters with one-character group
for each input data item. So, this is one-character group for this a type. So, percentage we
have seen that percentage sign means, is a conversion character.

The commonly used conversion characters we have already seen some of them, these are
known to us, percentage d is for decimal or integers, percentage f for floating point
numbers, percentage c for single character, percentage s is a string. Whenever, I am
reading something variable as a string, we have discussed that in that case, we are
reading the string using percentage s and that is a string is always terminated by null
character.
Similarly, percentage x denotes that, the number that I am reading is a hexadecimal
character. Hexadecimal means decimal is with a base ten; that means, 0 to 9 are my
elements. So, all the numbers I have, I am describing using 0 to 9. That is my alphabet
set. Whereas, in the case of hexadecimal, the base is 16 and so, base being 16, I have got
0 1 2 3 4 5 6 7 8 9. These 10 numbers followed by A for 10, B for 11, C 12, D 13, E 14
and F 15.

So, up to that, 0 to 15, I can have. So, in a 16, when I work with a base 16 and that is
known as hexadecimal. Now so, so you can just establishing a similarity, analogy with
our binary numbers system that we have seen, we can have, say, a number A B.
Now, A B is a string. So, the position string position weights are, first position is 16 to
the power 0, second position is 16 to the power 1, third position is 16 to the power 2, like
that. In the case of binary, we had the first position way, it was 2 to the power 0, 2 to the
power 1, 2 to the power 2, like that right. Now and each of these positions can be filled
up in the case of binary by 0 and 1, but here, in the case of hexadecimal, it can be filled
up with any of these 0 to a 0 to F.
So, A B, when I say; that means, B is what in decimal B is 11 12. So, 12 times what is
the weight of this position 16 to the power 0 plus A is 11 sorry, sorry, sorry, sorry, I am,
I am, I am sorry. this is 10. 10 to sorry let me correct that, A is 10 and B is 11. So, it is 11
into 16 to the power 0 and 10 times 16 to the power 1. So, how much is that coming to?
160 plus 11. So, that is the number 171. Now, if I had to represent 171 in binary, I would
have required much more number of bits right.
And since it is hexadecimal, another so, here we using hexadecimal, I am being able to
do that using 2 hexadecimal bits, which we can call hex x, but, let us see A B.

A being 10 and B being 11, in binary what would that be B is 11; that means, 8 2 1, this
is 11 and 10 is 8 2 that is all. So, I would have required 4 bits for representing 171, which
I am representing using hex x alright. So, that is a hexadecimal integer. So, if I if I print
something in hex in this in this format, then it would be printed like 171 will be printed
as A B. Otherwise, it will be printed as in the binary number or in the decimal number. If
I do it with percentage d will be printed like this.
So, it was a brief introduction to hexadecimal numbers, but that you can read up
yourself. So, let us proceed.

We can also specify the maximum field width of a data item. Now, this is something I
had purposefully evaded till now, just to not to make the things complicated. I want that
you first get a custom to the normal features of c. But now, we are in a now, I think you
have you are in a position where you can write programs. Here, I am introducing the
notion of field width. A data will be printed within a width, right? So many positions will
be given to that number. data item the number indicating the field width before the
conversion character.
For example, let us make it clear. For example, percentage 3 d, percentage 5 d for A and
B; that means, A will be expected to be of sorry; A will be expected to be of 3 positions;
say, percentage it is 3 d decimal 171 whereas, B will be 5 d. So, there will be 5 positions
for this 1 2 3 4 5. So, may be 52732. Now, if I want to print 171 or read 171 using the
format 5 d, then what should I print? I should print a sorry I should provide the data for
the 5 fields. I should put it blank, blank or 0 0 then 171 assuming, it is right justify
alright.
So, this is the width. This is the width that we are talking about. We can specify how
many what is the when I am reading what is the format of the data? How many widths,
how many positions it is taking for as the data, right?

So, say for example, if I have.171 5 3 2 then 7, then, if I read it, the first data if field is
feed is this, I type to the keyboard and if it is in percentage 3 d it will be fine ok. So, I
will read that.

Again, now coming to writing now, this printf is also a system function. Just like scanf
printf is also a system function and here also, since you know already, how do you write
printf? I write printf using a control string within the double code and then followed by

this number of arguments. So, the same thing will hold here. Control string refers to the
string containing formatting information and data types of the arguments to be output .
So, now, here while printing the arg 1 arg 2, these are the representing the individual data
items. In the case of scanf, they were pointers to the data items. Here, they are individual
data items that I have told you earlier. That is why, we use ampersand a ampersand b in
the case of scanf. But in the case of printf, we just write a b, ok. Because, this a b are
directly referring to the variables the data items. The conversion characters are the same
as scanf.

So, let us look at some examples. Printf the average of a and b is avg and that avg is
percentage f, you can see that right. So, avg is a float.
Now, I could have also done this that, so, this is nothing but, there is a control string ,
here you see, I have said that 3 d 3 d 5 d. So, a will be printed. So, when do you printed a
will be printed, there is no new line here you can see.
So, a b and a times b plus 2 will be printed side by side. So, a will be printed on 3 fields
like, say 171, b b will be printed on 3 next 3 there is no space given. So, this will be b 6 3
2 and the expression. Here a times b plus 2 will have have 5 spaces 5 positions given
now; obviously, if my data for result for a was 1712, then only this much will be printed.
Then the rest will be left out, ok.

So, here you see for the percentage f.
Now, for this, I think it is not very difficult to understand. You can read them in the any
textbook. It is clearly discussed in most of the textbooks. So, I recommend you to go
through these formats and as you practice, you will keep that in mind, but just to tell you
this. So, floating point number will have 2 parts, right? One is the integer part and the
other is a decimal part. So, suppose here, when I say 7.2 f x is a floating-point number,
which is being printed in the formats 7.2 f. So, this entire width is 7 positions and the 2
positions here are kept for the decimal. So, these 2 are kept for the decimal and we
imagine, we will have a decimal point here and the rest 5 will be 5 will be for the integer
part.
For y what will happen? For y the total field is 5, out of which, so total field is 5 out of
which only 1 position is kept after the fraction. So, here, I assume the this point.
And so, there are 4 positions to represent an integer and one position to deserve represent
a fraction. So, if my result was 101.52 in this format, if I print that, then I will get 0101
or this 0 can be may not be printed.

Many more options are available. You can read from the book and we will do this later.

Now, coming to a very important concept ah, that is, function prototypes. This is
possibly new name that you are getting. What are these prototypes? Now, we are going
to write functions and those functions, one of the functions which must be there is the
main function, right? Typically, people write first the main function and then the first the
functions and then the main function, but you are free not to do that also. So, usually a
function is defined before it is called. So, typically, what we do is, when our main our

programs starts, so, we start the program starts from here, we define of we write a
function with some parameters here and the body of the function is here, then, we write,
say, main. And inside main, I call f 1 this assigned to some variable x like that. So, this is
the typically some what we do alright. After I did, this include s t d I o dot h. I started
with the function first; that is, one option now, but always, that is not done.

So, main in that case, if I define the functions first the functions, that I am going to use, I
have thought about that I have designed them. So, first I write those functions and after
that, I write the main function. In that case, the main is the last function in the program.
So, in that case, the compiler, so, I have got my program here, entire program here. And I
have defined the function f 1 here. I have defined function f 2 here. And when I write
main here and in main, I refer to f 1 f 2 whichever whenever is this required.
Now, let us look at the compiler think of yourself to be the compiler. Now, if you had
started compiling the main first and you would have come to f and f 2, then you would
wonder what is that f 1 and f 2. No variables are defined right? You would have taken
just like, if you had written x in the main, some function f 1 some function like f 1 a b
right. Then, this f 1 is not recognised; I mean you do not know about that here, but if you
write it before, the compiler will actually start looking from the beginning of the page,
beginning of the program. You will understand, a function has been defined here, I
understand that function. So, I know that and the I know what this function does it

compiles that and f 2 also. So, when it comes to in this reduction, when it comes to the
main and finds f 1 and f 2, it already knows that. So, there is no problem. So, easy for the
compiler to identify the functions, when it scans through the file this a file right, the
whole thing is a file

However, always that is not done many programmers prefer a top down approach, where
I will first define main and then I will put the functions, but then what will happen to the
compiler? The compiler if it starts with main, it is starting from the beginning and if it
encounters f 1 or f 2 in the body of the main function, then it will get confused what is it
just like, if I had got a variable x being used and it is not defined there been error
because, I do not know what this x is, what type it is right? So, I have to declare that
before there. Similarly, for functions there must be some way to tell the compiler that is
the function and for that function prototypes are used function prototypes are used.

Let us look at this needed we the function comes later. So, function prototypes let us
look at . Are usually written at the beginning of the program ahead of any other functions
including main, say for example, this is a prototype. This is a prototype, int g c d int a int
b ok. So, a and b are the parameters and g c d is a function of return type int. So, I know
just by this prototype by this, I know the basic whatever is a body whatever is a body of
g c d, I know it is interface, I know it is input output. What is it is input output? There
will be some a coming some parameter.
There are 2 parameters internally, they are named as a and b. I also know that, this is an
integer and this is also is integer and I know that it is name is g c d and I also know that,
it is output is an integer. Whatever is in between, I am not bothered about right now this
much I know. So, I will expect whenever g c d will come, I will allocate 2 integers space
for that and one return facility should be there.
Similarly, let us look at the second one div 7 int number.

So, the prototype tells that, it is a function. It is name is div 7. You can guess div 7
means, is testing the divisibility by 7 and there is one integer that is being fed and that
integers name is number and void is a type; that means, it is not returning anything. May
be, it is printing something from here, it just checks takes a number; it sees whether it is
divisible by 7 and prints it here divisible by 7, not divisible by 7, whatever you know.
How to find divisibility by 7? So, you take the number and find the mod of that with 7
and if this is equal to 0, then divisible by 7, otherwise not. So, that is in the body of the
function and here, we just do the printing. So, I am not returning anything to the calling
function. That is why, this is known as void. Void is a valid type.

Note the semicolon now here this very important. Whenever for hash include the s t d I o
dot h, I did not give a semicolon. But whenever I am declaring a function of function
prototype, I have to give a semicolon just as I had given a semicolon when I declare
something like int x semicolon.
Similarly, here, this semicolon is very important. It just like a declaration. So, the
argument names can be different, but it is I mean it is a good practice to use the same
names in the function. Now ah, so, what is being said here is that, although I am using
here, showing that A and A, but when I am actually writing the function later say, sorry.

When I am writing the function later, when I wrote later on int g c d, I can make, let us
space, sorry I can write int g c d int x comma int y that is also possible ok. Because, my
prototype just said that, 2 integer places. Now actually, I can change the name, change
the name of the place, but that is not that important. I mean that is not I mean, usually it
is better if we can keep both of them.

So, here is a function prototype example. I will continue with this in the next lecture. I
will discuss this and we will move to some other important feature of function like
parameter passing in the next lecture onwards.

So, in the last lecture, we have discussed about function prototype. Before moving to
some other topic let us look at an example of function prototype and so that we can
understand it better.

Here you see here is a program were I have got a function n c r, n choose r and another
function fact. Now, the functions are actually little later here you see n choose r is like
this standard n choose r that you do. Here that is a factorial n by factorial r, so factorial n
divided by factorial r into factorial n minus r that we know from our school right. So, that
is one function that is one function.
The other function is the factorial. So, here is another function, this is one function this
another function. Now, look at the beauty of this function this function is in a simple one
return statement I have written everything. So, here you see the body of the function is
merely a computation of an expression fact 10 divided by fact r divided by n, fact n
minus r and this will be computed and that will be returned as an integer. Now, what will
be the input the input will be n and the r both of them are integers.

Another point to note here is this function itself this function itself when is running first
say I get into this function and I tried to compute the return value, first I find fact n and
from here I am calling another function that is the factorial function and the factorial
function is taking only one input one integer n and based on that it is computing the
factorial. Computing the factorial you must be remembering by now, or knowing by
now, that is I am starting with 1 and 1 times 2 times 3 etcetera I am going on doing and
that is what is being done here temp is 1 and temp is equal to temp times i, this is wrong
this should be small i, temp is temp times i, whatever the i value is, 1 times 1, 1 times 2,
1 times 3 it goes on till i reaches n and then i return temp.
So, the point to that you know, this will this thing you know. So, what is being done here
is when I am computing this function then I come to this I call this function return temp,
I return here and then I move here and again I find again I call to this fact again, this time
with the different parameter r and so again fact r is computed after this is computed
second time when I return back here. And then I again call this fact using n minus r, so
just to make the things clear. So, the first time I am calling this from here and returning
back here, second time I am calling this from here the same thing and returning back
here and third time I am calling from here and returning back here.

Now, for the third call I am, so, here is one n and that this n and here what I am passing I
am passing n minus r, I am first computing this and that is being passed here and that is

being computed. So, here you see it is an example of nested call this was called from the
main and this in turns call I mean call another function and in this way it goes on. That is
about the beauty of these two functions. But now, here is my main, main function here is
my main function. So, the compilers comes from in this way and recognises at this point
that ok, n c r is a function how does it know it looks like int. But how does it recognise
that it is a function? It recognises n c r to a function because of this parameter argument
list.

Here it is said int r there are two integers coming in as parameters next it understands
that fact is also a function. So, its expecting to encounter n c r and facts somewhere down
the line and proceeds here it takes m and n, reads m and n, then it is in a loop where it is
calling n c r. So, it is series you can understand n c r is computing some with some value
i initially 1. So, it is basically n c 1 plus n c 2 plus n c 3 plus etcetera it will go up to m
all right. So, that is what is being computed here and so from here a call is made to this.
And as we have seen earlier while this is being executed this one is calling here this is
returning back here then again this one. Now, we are making a journey in this line. So,
this one is calling this and we are returning back here as we have seen just now. Now
ultimately when this entire thing is computed then we will come to this, last bracket here
sorry I should not this bracket here; that means, it is a end of n c r. So, I had called n c r

from here. So, I will return back here and will whatever n c r value is that will be added
to sum and that will go to this sum and then will proceed in this way I hope this clear.

Now, here I have not written n c r. So, I could have I could have written this earlier in
that case this prototype would not be needed, but since I decided that I will be writing it
later. So, I decided to just introduce them as prototypes here. Now, you should be very
careful about the syntax of the, of writing the prototypes it should have the function type
just like a function name and the parameters.
Now, you will see later that it is also possible that I could have written something like int
n c r, int comma int that will also mean that this n c r takes two integers as I mean arguments, that will also that is also allowed, but it is nice to write this in
this way.

Now, next will move to a very important concept; let us quickly have a look at this the
prototype declaration and the function definitions are actually here.

Now, we are moving to a very important concept of passing the parameters, how do we
pass the parameters from the calling function to the called function. There are two
distinct ways in which it can be done one is calling by value another is calling by
reference. So, right now, let us think of calling by value all right. Now, let us try to
understand it in a simple way.

Say, here is my main function or the calling function let me not call it main function as
we have seen they can be nested functions. So, this is the calling function. Now, inside
the calling function I have got some variable x and which may have the value says
somewhere 5 it is an integer. Now, somewhere here I am calling a function let us call a
simple function decrement or no decrement add 2 or say add 2; that means, whatever is a
value we will add 2 to that simple thing. So, here I say y is add 2 x and then semicolon
and I go on. And here is my function add 2 int a all right and add 2 is also type integer.
Now, so a we know is a local variable to the function. So, here I will take. So, what will
happen? Suppose it was 5, this will result in a will get 5 and here may be here I declare
another variable say b although it was not necessary, but I am just saying b is a plus 2
because its task is to add 2 and then I say return b. So, this b which is an integer is being
returned. So, b which will be in this case it was 5 it will be going back here. I hope this is
clear.
Now, when you know the scope of variables that b is a variable or a or b whatever the
life of those or the validity of those are restricted only during the life of this function. So,
but; however, in the case of a looking from the point of view of compiler I have got a
variable a and I have got another variable b and here I have another variable x. Now, this
variable x was having the value 5. So, here in x I had 5 by this statement, this statement
made it 5. Now, since x is 5 and this one is expecting the value a, now, this 5 will be

copied in a; what is being copied? Not x, but the value of x. So, this one will be will be
getting 5 right. So, the copy value is being copied, the value is copied in this variable 5.
Now, it takes b was something, but here. So, b becomes 5 plus 2 b becomes 7, 7 comes
out.
Now, suppose I change this program a little bit. I erase this b and make it sorry I make it
a. So, this b is no longer there this is not required all right this variable has not been
defined I say that this line is also not there, int a and I just do a plus, a assigned a plus 2.
So, now, when it was called add x then from here from here this x was copied here and a
will be incremented to 7. So, this will be incremented to 7 and obviously, this will be
return a not return b because b is not there anymore, so 7, that 7 will be returned here.
But you see if here now, 7 has been returned and 7 will be y. Now, suppose if I say I am
not following the syntax I am just saying because there is no space here printf something
x. What would be printed? For x what would be printed? 5 will be printed because x is
still 5 x has not changed. I have simply copied the value to the argument variable and
have played with that changed it whatever I wanted to do I have done.
So, take a little time to understand this. This means that the variable that I have in the
calling function the value of that will be copied to the argument of the called function.
So, there are several advantage is to this one is, so it passes the value of the argument
execution of the function does not change the actual parameter like the actual parameter
was x which was 5, it remains as 5 although the function added two to that and it came
back all changes to a parameter done inside the function are done on a copy of the actual
parameter not the original parameter. The copy is removed when the function returns to
the caller that entire variable location that was given for the variable a in our example is
returned back to the pool of memory locations. The value of the actual parameters in the
caller is not affected. Consequently it also saves us from some accidental changes
programming that can come copying due to programming errors.

On the other hand the other thing that is another type of parameter passing is known as
call by reference, call by reference. Here we are not copying we are not copying the
variable, we are passing the address of the original argument.

So, let us take the earlier example again if I had my main function here and I had
similarly int x and here y was add 2 x here printf something x, and here I had that
function add two int a and here in the body I did a assign a plus 2 and return a, return a.
Now, here is a variable x and that has got an address say that address is whatever 5000.

So, now, its value here somewhere x was 5. So, its value is 5. So, here what I am in the
case of reference I am not copying the value of 5 to a instead in the parameter passing I
will write it in a different way not in this way which I will discuss later.
If I assume that this one a, a is not taking the value, but the address of the parameter,
address of the parameter. Means what? Means that this time this a here I am passing not
the value 5, but I am just simply saying that whatever data you want to work with that is
the data is in this location 5000. And it excepts that reference that the data that I am
working on my a is actually staying 5000. So, what it does? It takes the when it computes
a assigned a plus 2 this is not looking nice. So, let me write it a, a assigned a plus 2 it.
Now, knows that it is not the value a is here I have to get the value from this location. So,
it gets the value from this location, but no other variable location has been allocated
because I know where there is only one common place, only one common place you
have done given something here and you haves told me where you have kept the data
and I am also working in that vessel itself.
So, what is happening here is this 5 will be changed to 7, here only and return I need not
return a it was just return would be sufficient. So, changes have been done here. So, in
this case when I come to this printf x what will happen what will be printed 7 will be
printed because the actual data has changed here. Let me show it you another example.

Here is my calling function and I think this vessel analogy will be fine. Now, it says that
here is the data where I have poured it only tells you where it has poured, the name of the
vessel, suppose the name of the vessel is a there are many other vessels A B C and only
this vessel name has been passed and when this one is doing something it knows the
vessel name A. So, it comes here and takes the data from here does something and
returns the data from here and here this program when it is computing when it returns
and then ultimately it returns there and while it returns it takes this value this value the
change value and continues. So, in the case of calling by reference we are not copying
the value. On the other hand what would have happen in the case of call by value using
the same vessel analogy?

Say, this program was running the value was in a vessel the value was there in a vessel,
but sorry, but my function do not bother about the inter change of colours; my function
was also having its own vessel and when the function has been called the main function
calls this a calls or say x calls y right, then also x copies y, copies the value of the
variable suppose that was a that is copied in the vessel that is belonging to the function it
may be b. So, this one does whatever it does here and returns this value over here. So,
this one is not disturbed whatever changes are being done are, done here.
So, that is a very fundamental concept in parameter passing. There are two types of
parameter passing one is call by value another is call by reference. Now so, here you see

execution of the function may affect the original because I am sharing the same vessel.
Now, this in C, in C we actually we are in C we actually carry out only call by value,
only call by value except for the case of arrays except for the case of arrays there is a
reason for that you will understand and for arrays we are not passing the values we are
passing by reference otherwise its always call by value.
So, let us have a look at some of the examples here, first example.

We have got the main let us see what is happening, a has been initialised to 10 and b is
not initialised, printf initially a, a. So, what will be printed? Look at this, this will print
first line initially a equals the value of a which is 10. So, here, here there is a variable a
which has got the value 10. Then b is being assigned change a what is change a change a
is a function.
So, one mistake is here I should have declared this change prototype here; however, I
should have the function prototype should have been defined earlier. Now, I come here
printf before in the; what does the function do prints before x x. So, before, so this point
before x equal to x whatever x was, it has got the copy of that x, it has got the copy of
that x. So, this it was a, a and that has been copied here for its own x, x is also 10 copied
because when it called you actually copied this. When this call was made, when this call
was made first then before that, before that it was also copied here and then only this was
done. So, it was printed then x divided by 2. So, x becomes 5 by this statement done.

So, what is being printed? After here this line is being printed here after x equals x. So,
what will be printed? I am still inside the function please remember I am still inside the
function. So, 5 will be printed and then I return return x. So, what is being returned? 5 is
being returned where it is being returned here, x has been a has been changed and that is
going to b printf a assigned. So, this printf is this printf a sorry a equals here it I am
printing a, a is a, so a is not changed. So, it is being printed as 10 and b is being printed
as 5.
So, you see a has not been changed the reflection of the change has been reflected in this
function and is being assigned to b, clear. Now, let us take another example and you will
yourself try to look at this example and a little change has been done let us all together
try to follow this example. So, a starting again a mistake is I should have declared the
function prototype here. So, those things I have not shown here so, but you should do it.

Now, let us see here. Again int x equals 10. So, x is a variable to the main function x is
having 10 printf M here main function, printing initially x is 10, there is calling the
function. So, here the function is being called. And whenever this function is being
called there is a local to the function there is an argument x where this 10 is being
copied.
Now, printf here, this printf in the function it prints before x was x before changing. So,
x was x. So, what will be printed? 10 will be printed. Then I change x here. So, at this

point x is becoming 5, all right. Then I am saying print after the change this is this
printout after that change x is what it has been changed 5 and then I return to the main
function with the change value of x, so b gets 5. Now, I am printing in the main function
x is 10 and b is 5. So, it has been changed that is being reflected in this printf and b is
also 5 b was here, b is in the main function. So, that b has been assigned after this change
and that is also 5. Now, the distinction I think will be clear. So, so these are the two cases
that we have shown.

So, now, here let us see this is another example.

Here the slight change that has been done is that the change value I am keeping in x.
Now, this was x, and x was 10. Now, note x was 10. So, initially x is 10 fine, from this
line. Now, I have called change x, so it is coming here. But its parameter is also x, but
that really does not matter. These x from here I will create another x. This who is the
owner of this x, the owner of this x is only this function as long as this function is
running these x has got a meaning it is existing other after that it is not there. But since I
called it the value 10 was copied in this, but you see these two are two different memory
locations. Consequently what is happening? When I print it here before x was 10. Now,
see which x is being printed? This x is being printed because this x is not known to this
function this function only knows its own x then x is changed to 5 that is also done to be
done locally here and is being said here after that the x is 5 because this x is known then
I return x. So, 5 is returned and 5 is assigned to x.
Now, whenever I have gone out of this function this x is no longer existing vanishes; that
means, the compiler returns it to the memory pool now. So, which x? Is this x? This x.
So, this value that is 5 that is being changed will come here. Now, here I am doing printf
x x; that means, both b is, so x will be printed as 5 and b equals x. So, x is also 5. Here
you see that the same value is the variable is x. So, both will be 5.
So, I hope you could understand this difference. Let us take the another example or we
will come back to this in the next class and we will start with a new example and

continue with parameter passing. So, what we learnt in todays lecture is a very
important concept of call by value and call by reference and we could see that in C in
general call by value is adopted except for arrays and what is call by value call by value
means the calling function copies the value of the parameter to the variable
corresponding to the argument. Whatever change is done is done locally inside that
argument and when is returned it goes back to the main function, the value goes back to
the main function. Whereas, in case of call by reference the there is only one vessel one
variable and I am not creating another variable, I am simply passing the address of that
variable to the called function and the called function changes in that particular variable
and whatever changes are happening they are reflected in the main function, calling
function as well.
We will continue with this.

So, we had looked at parameter passing and we have looked, we have seen that the
difference between call by value and call by difference and we have see quite a few
examples to be specific 3 examples on call by value how. And also another thing that
was supposed to be noted I hope you have noted that, that is the scope of variables. That
whenever there is an x in the main function and the x in the called function then these
two xs are different. The x that is defined in the called function is a separate location
than the x in the main function and that the life of that variable ends with the end of the
function, right.

Now, let us look at these example, you yourself will be able to trace this. So, I give you
some time to trace this through and then we will continue. Look at this function carefully
and do not look at this green part, do not look at the green part yourself and try to
without looking at that try to find out what the values will be for the different printf
statements.

Let us start. So, we have got x assigned to 10 and y assigned to 5, x and y, x is 10 and y
is 5. Now, so when the I printf do this printf x is printed to be 10 y is printed to be 5 fine,
no issue. Then I call a function interchange x y. Look at this the type of this function
interchange the type of this function interchange is void because that immediately tells us
that it is not going to return anything it is going to do something as the name implies it is
going to interchange x and y. And what are the parameters? Parameters are x and y this
is the argument. So, here I have got another set of x and y.
Again note that this x and y are different. Now I initialize temp, so temp is another
variable here temp. Now, what I am doing here? The first printf what is being done here
printf x equal to x and y equal to y which x and which y the x this x and this y. Now,
when I entered this function these values have been copied here. So, the printf will
simply print 10 and 5 no issue now temp is getting x, x was 10. So, I put 10 here and
then x assigned y sorry y assigned x; that means, the value of y I am still within the
function I am within the function. So, this value is being assigned. So, by this statement
what happens this becomes 5 and this remains 5 right and then what is being done here y
assign temp; that means, this temp is becoming 5 right temp is becoming sorry, sorry I
am sorry absolutely sorry this was 10.
Now, for this statement temp is going to y; that means, y will be changed to 10. So, here
I find 5 and 10. So, it is a when it entered here I could see 10 and 5 and so when I come
and print from here x will be 5 and y will be 10, I come out of the program and printf x
and y. What will be printed? My god, what I find is x is being printed as 10 and y is
being printed as 5 as it was here. So, no change has actually taken place. Why did it
happen like this? You can immediately see the reason that whatever change took place
took place here inside the function and this actually tells you the importance of the scope
of variables. These variables scope ended with this function and their change was not
reflected in the main here that is why although I did it here it would not change.
However, suppose let us do some intellectual exercise here.

Suppose x was 10 and y was 5 and there was a temp, now temp is inside the function. So,
I will use different colours for that I will, now although I remind you that C does not
allow call by reference, but just to see whether you have understood call by reference
properly. Suppose we are allowed to use call by reference then my main program has got
this x and y. So, it comes here prints say prints x and y. So, 10 and 5 are printed x equal
to 10 y is equal to 5 and it calls interchange all right, it calls interchange.
And suppose just suppose that this call has been done by call by reference. So, what has
been passed here? The address of this and the address of this not the values, so no other
copies have been made. So, now, I have got the local variable temp and here I do temp is
assigned x. So, temp gets 10 then x assigned y. Now, what is my x and what is my y?
The content of this address which have been passed will go to the content of x. So, this
will be 5 and then y will be assigned temp. What will happen?.
This temp this value will go to the suppose I can make call by reference then this will go
to this address, but if I just simply write in this way that does not mean it really does not
tell me whether I am saying that I am copying the from the address of actually copying
the value, but I am just taking telling a hypothetical case. So, this 10 will go there and
this 5 would be changed. In that case when I come back from here and I print here then I
would have got the change scenario reflected, but the mechanism writing simply like this

in C means it is called by value not called by reference. So, what is being passed is
actually the value.
So, if I could, if I could do that then it was possible to have that interchange and there is
a mechanism for passing the addresses and not the actual values by using a concept
called I mean structure called pointers which are nothing, but addresses we will have to
we will see that later if time permits. But in general remember that this interchange has
not been possible by call by value in the way we wrote the program. So, with this we
complete our discussion on parameter passing normally, but a distinction between
parameter passing by call by value and call by reference.

And we now start another very important point that is passing arrays to functions.

Now let us try to think. Here when we were having a variable x another variable y in the
called function, in the caller function and I was having in my called function two other
variables a and b, then the value of this would be copied here and the value of this was
copied here. But suppose x is not an integer x is an array of 20 elements then all those 20
elements have to copy here and suppose this is an array of another 20 elements, so
another 20 elements I have to copy here right. C allows only for arrays the parameter
passing by difference. Now in order to understand that let us try to look at the structure
of an array.

Suppose I have got an array a 10 now I am not making a distinction between the size of
the array actual size of the array and the dimension of the array I am assuming that the
array a has got 10 elements. So, I have got 1 2 3 4 5 6 7 8 9 10 all right and these are a 0
a 1 a 2 up to a 9, right these are the locations we know that. We also know that an array
is allocated contiguous memory locations by the compiler.
So, all these are contiguous therefore, it is sufficient to know the address of the starting
location, suppose this is 1000. If this is 1000 and if it be an integer and I assume that an
integer, integer takes 2 bytes say 16 bits and then this will be 1002 this will be 1004
etcetera I can compute any particular address, any particular address of this. So, if I say a
5 the address of this a 5 address of a 5 can be easily computed as the starting address
thousand whatever is a starting address plus the index is 5; that means, and the size of
integer which I know in a particular machine say 2 bytes times how much will be 106,
108. So, what will be 2 into whatever is a index minus 1; sorry a 5, a 5 will be the 6th
element right. So, 5 times whatever this is suppose this i, i times i right size of the integer
times i.
So, it will be 1000 plus 2 times 5, 1010. So, this is a 0 a 2 a 0 will be 1006, a 4 will be
1008 and a 5 will be 1010. Since it is contiguous it is sufficient for me to know the
starting address of the array, therefore, it is good enough to establish the correspondence
between the name of the array and the starting point of the array. What I mean by that is
again I draw this.

Now, I named the array differently A and suppose it has got 5 elements all right. Now A
and A 0 are treated to be synonymous. When I say a; that means, I am actually referring
to this element, this address, not this element this address. And since I know that
therefore, A i depending on the value of i, I can compute where the actual location will
be this is the fundamental concept we need to understand, all right. Therefore, we can
pass the an array to a function as ordinary arguments.
For example, is factor whether x i is a factor of x 0, suppose I want to do that. So, you
see is factor earlier I did x or y here I am writing x i, x 0. So, x i is what? Suppose x is an
integer array. So, x i is an integer x 0 is another integer. So, I can simply pass this, sin of
a particular angle. Where is that angle? In an array x an array x is there and in that the
fifth, sixth element I am taking. So, this element is coming as the parameter. So, let us
proceed a little further.

Now, that is for the individual elements x i or x 5 x 0 I am just passing an element and if
it is an integer array then an integer is being passed if it is a floating array, floating point
array then a float will be passed, but what if I want to pass the entire array to a function.
That is what I just now explained. That is an array name like A can be used as an
argument to a function because A essentially means A 0 and if I can pass A 0 the address
of A 0 is known then all the elements are known because they are contiguous.

Now, the way it is passed differs from that of the ordinary variables. Why? Here when I
have got an array and array A with A 0 when I am passing the array suppose somewhere
in my function f I am passing the array A and just to say that it is an area I just do
something like this. This is not the correct syntax, I will show you the syntax a little
later.
Now, you see I write it in this way all right. Now that means, I am passing A 0, but if I
pass the value of A 0 which might be a 50 I have got no clue about the other values I am
not passing all the values. So, what do I have to pass? if I pass the address of A 0 address
of A 0. So, this is what is being passed is address of A 0 then I can get access to all these
elements A i, A 1, A 2 anything because I can compute the address very easily as I have
shown just now, all right, I can do that.
So, this is an example this is a case where we call by reference we actually will pass the
address and not the value of A 0. We are passing the address of A 0 and the address of A
0 is the same as the name A this is a very fundamental concept and let us try to
understand this. How is it passed? The array name must appear by itself. So, now, we are
talking about the some syntaxes, the array name must appear by itself as argument
without brackets or subscripts the corresponding formal argument is written in the same
manner. Let us look at an example.

Say here, I am going to pass the whole array as a parameter. So, I have declared constant
int a size 5. So, something some variable a size is assigned 5. Now, float average is a
function which will which is taking as parameter, sorry which is taking as parameter an
array B all right, just the name of the B only array name or address of B is passed. Now,
this symbol is mentioned to indicate that this is an array right. Now, let us see what is
happening int i total 0, for i equals 0 i less than a size; that means, less than 5 i plus plus
total equals total plus b i. So, what is happening? So, here is an array B, here is an array
A, a size the array size is 5 and all these elements are being added.
Now, all these elements are being added in this loop. So, B i only B 1, B 2, B 0, B 1, B 2,
B 0, B 4 they are being added to total and then I am returning what am I returning I am
returning total divided by a size now there is a new thing here also its better to look into
that. Now, the array now average will be a floating point number and B is an integer
array. So, sometimes, when i, so what has been done here is float a size when we do this
float some variable x; that means, this variable is being type casted is being made to be
represented as a float. So, if it was 5, 5 suppose then float A size. So, since is 5 float A
size will make it 5.0.
And suppose the array was 1 2 0 4 5. So, 9 to 11, 12 total was 12. So, float total will
make it 12.0. So, I am casting twelve forcing it to be represented as a float. So, then 12.0
is being divided by 5 with 5.0 and I am getting the average and that average is being

returned here. So, that is that was not our main contention here that is the purpose of this
float. But the main contention here is that I have passed this array B, but who passed it
the main function. Let us study the main function.
The main function x is an array of size A size that is 5 and x average is of some variable
and x has been assigned as 10 20 30 40 50; x average I will compute, but I am calling
this function average from here and I am passing x. What is x? x is an array and that is
appearing just as a variable here and that is being accepted as B. So, what is a
correspondence between x and B, x is somewhere suppose starting with location 5000
and there are 5 elements as I been said here 10, 20, 30, 40, 50.

Now, when this x is passed to B this function now knows that B is an array because it
had this thing and this 5000 is passed to B. So, now, B knows where is B, B is the same
array. Now, whatever change I do here, suppose in this function instead of computing the
total if I had written this function in a different way for example let us do that and
suppose I have got this function x, I have got this function x this array, sorry I am sorry x
where 10 20 30 40 50 are there and in my function change, I can also say void change int
B this and in the body of the function what I do is for please try to understand i assign 0
to this, i less than equal to A size or 5 whatever it is, i plus plus, B i plus plus say this.
What will happen?

Inside this function change I will take the first one change it to 11, this one will be 21,
this one will be 31, this only 41, this only 51 and when I return I made a change in B, but
B and x are the same because this address 5000 was passed to the function change and
this b got 5000 and so whatever change has been done here will be reflected in the main
function when I return, clear.
So, that is the importance. So, here I have called it with the actual array name here of
course, I computed a total and return some other value, but if I had just change it inside
this function I could have made it void function and the change would have been
automatically reflected in the name.

So, here you see we do not need to write the array size it works with arrays of any size.
For example, here void this etcetera where list is an array of 100 elements and average I
am calling here float average int a is an integer, and float x is map to list all right, x is an
array because here how is the correspondence done. This list, list is being mapped to this
same address is being passed and n is being passed to a how many elements are there, all
right. So, I need not specify the size because the size is already specified here. I have got
100 element array, this is my list, this is list right. So, I have got 100 element here I
know. What I have passed to x is just the address. So, whatever it is 100 or 150 that be
true for x also right. So, we do not need to write the size of the array.

Now, similarly array is used as output parameters. So, suppose I am going to do vector
sum; that means, I have got two arrays a and b. So, what I am doing here? I have got two
arrays a, an integer array another integer array b and I am adding them. So, I will add this
element say 5 with this 7 and I have got another array v sum, v sum where the sum will
be stored so this will be 12, if it was 6 and this was 5 here we will store I will add these
two and I will store 11 ok.
So, let us see how the vector sum. Now, vector sum will be void you know because it is
doing the addition and the addition is remaining in this vector sum. So, I have got let us
start with the main function x is an array. So, this is actually x a or let me say let me put
the main function first. So, it will be x in the main function and a in the this function y
slash b. I am writing slash b because these two was the same because the address is
shared all right and vector sum will be z. So, z or vector sum. So, x is 1 2 3, y is 4 5 6
and z, z has not been initialized because, so let me let me; so that you are not confused,
let me do it like this.

I have got an array that is x having values 1 2 3, another array y having values 4 5 6 and
another array, another array z which will have the final value and z all right it is 0
elements, but we do not know the value. Now, I am calling vector sum and what am I
passing x is being passed to this x goes to this. So, this is known as a for the function y
goes to this. So, this is known as b. So, x and a locations are shared z and v sum the
locations are shared, all right.
Now, I am calling vector sum. So, all these are being added in a loop 5 7 9, then I come
out I come out. Now, you see when I come out of this function these are already reflected
because it was passed by reference. Now, let us look at the print, print vector what is
happening here. Void print vector that is another function that I am calling here z 3; that
means, 3 elements will be printed from that z array z array was here which had that
elements like 5, 7 and 9.

Now, with that print vector it is just in a loop i equal to 0, i less than length. What is
length? Length is 3 and what is the array z is a. Now, this a and this a are different again,
this a and this a are different. This a, this is this a was this functions a and this a is this
function a. So, they are different. So, here they are printing 5, 7, 9. So, that is as an
output parameter.
So, you see actually whenever I am reflecting on an array I need not pass it because
essentially automatically passed right. So, that is what is very important. So, I hope you
have understood this.

The actual mechanism is when an array is passed it is the array elements are not passed,
but what is passed is an address and the argument becomes a pointer to the first element
or a pointer to the first element; that means, the address of the first element. And when
an array element is accessed inside the function the address is calculated I have already
explained the formula that is used for finding the array. So, this is known as call by
reference.

So, I think you have understood this. We will continue our discussions in the future
lectures on some other important issues.

We have discussed about passing arrays as parameters. And for passing arrays as
parameters in C to, C functions we take the course to call by reference. Otherwise for all
other parameter passing we take the course to call by value. And just to summarize the
call by value and call by reference. Call by value we copy the value of the actual
parameter to the formal parameter; formal argument and in call by reference we do not
copy the value, but we just pass on the address of the pointer and reference to the actual
parameter ok.
So, as a result; what happens? That if any change to that variable is resulted in the
function itself, in the case of call by value that will not be automatically reflected to the
main program, but in the case of call by reference since there is no other separate copy
that will automatically be reflected. Just to conclude that part we will see a number of
applications of functions just to come to conclude that.

Let us have a quick look at 1 function, but there is no idea, but just vision of the
prototypes that you can see here, finding the maximum of 3 integers.

So, we have the header file, here include studio dot h. Then here we declared a function
prototype. The actual function maximum has been written later. So, here you see that
what does this line tell us? This line tells us that maximum is a function and it consists of
3 integer arguments, or 3 integer parameters will come. So, as if this is a function which
has got 3 input doors and each door is wide enough to accommodate an integer ok. So,
that much is told. And whatever is inside this I am not aware of that, and at this stage I
am not aware of that. And the output will also be another integer that is told by this.
Then so, here the salient point to see is that here I have just it was sufficient to just
specify the types, no names have been put in. Now comes the main program that is very
simple a, b, c are 3 integers.

So, they are local to this function, enter the integers abc are interred here. So, you know;
what a is? what b is, and what c is, and then you are calling inside c. Here inside the print
f I can call maximum with the parameters a, b, c and we come here. And here I have
defined here I did not name here I did not name the variables; here I have defined the
names of the variables int x, int y, int z. So, this x, y, z again property of this maximum
alright.
So, xyz are here. And the algorithm of the logic is simple. Initially I make max to be x; if
y is greater than max and y is the max, otherwise z is the max and then I am returning
max. I am returning max means I am coming here, and then that max is being printed.

And returns 0 now my main function, where is my main? Main is here, main has got a
type int. So, I am returning 0. So, int will if at the end of, the main function a 0 is
returned, I will assume that the program has successfully completed ok. The reason I
brought up this example is just to illustrate this case that you need not at the prototype
level you can escape specifying the parameters.

So, here is a prototype declaration, function calling, and function definition you know
that.

So, this are already repeated I am not going into that.

So, instead I will be talking about a new thing here, that is hash include.

We have talked about hash include, we have used hash include. And we menti1d that
hash include is nothing but a preprocessor statement. A preprocessor statement how? Say
hash includes filename. We have seen hash include studio dot h, but it can be for that
matter any file name, hash include file name.
Say for example I can specify the full path, say slash usr in a Linux environment slash
home rajan my file dot h. I want to include this file; I want to include this file in mind for
serving. This file in my program, all right; the content of the corresponding file will be
included in the present file, before compilation is d1 before compilation is d1. And the
compiler will compile there after considering the content as it is. So, it is a preprocessor
statement. That is, I put that inside that hash include that file is included and then the
compilation is d1 ok.

Now, let us look at this hash include example. Look at this program segment which is
my source program, which is known as proc dot c. So, this is my source program. This
source program has got hash include no stdio dot h, but it has just said that in hash
include my file dot h, and then a main program follows ok. Now, this my file dot h is
nothing but another file, which is which has got hash include stdio dot h and index.
So, when I include my file dot h, then this particular file will be included this particular
file that is this segment will be included here.

So, consequently what will happen is when I say in general hash include file name dot h
it includes a file name file, file name dot h from a specific directory which is known as
the include directory. When I say hash include it takes from the include directory, and in
the include directory I have kept my file dot h, and consequently when that is included
the ultimately the thing that looks like is, it will be it will look like this.
Because that hash include I am sorry, there should not be an inverted comma here, it
should be just hash include stdio dot h followed by intex. So, this whole thing whole
thing has been has replaced my file dot h. And where was my file dot h? My file dot h
was under user usr include file name dot h. So, that is how the include I can have other
files included in my program. Now another point of critical discussion a is macro
definition. We have seen the macros like hash define.

So, let us so, that is again a preprocessor directive. We have seen that hash include is a
preprocessor command; that means, even before the compilation is d1; that is, that is
copied there on the other hand, you see the preprocessor directive of hash defined string
1 string 2; that means, string 1 should be replaced by string 2. So, how does it happen? It
replaces string 1 by string to whenever it occurs, where ever it occurs, where ever it
occurs before compilation.
So, for example, hash defined pi to be 3.14. So, wherever it will find this pi, wherever it
will find this pi, it will replace that with 3.14.

So, here for example, you see, we have got hash include stdio dot h, then we define pi to
be 3.14 as the hash define preprocessor command. Now in my main program I have got
float r 4-time 4; r is 4, and area is another variable both are float. Now area is pi times r
times r, r is already initialized. So, what will happen is this will be translated to this pi
will be replaced. So, the body will be float r assigned 4 and area.
And area is so, r is 4, and area will be 3.14 times r times r. So, before come even before
compilation, this pi is being replaced by 3 of the value 3.14 as has been stated in the hash
defined command.

We can also give hash define with an argument. Till now we have seen hash define pi as
a constant hash define some constant k to be 5 or whatever. Here we can also define
some functions. Like you see hash define square x is x times x. So, wherever square x
will appear, that will be replaced by x times x ok.

Say for example, here let us look at this program again. I think you are not being able to
read this. So, let me go back say let me have if I have, declared say, hash define square x
is x times x.

Then in my program, wherever I will get say, p is assigned square y. So, this will be
translated as p assigned y times y ok. So, this; what should be d1 that has already been
told here that square x is this. So, this will simply replace it ok. So, that is the purpose of
hash define here, we can see that and so, let us look at this example again.

Main y is 5, print f value is y times y; that means, this is being repeat this is what has
been generated after the square x has been square here it was square x plus 3. So, that has
become y times y plus 3. Now, which 1 is faster to execute? You can think of I can if I

write square x written as a macro definition, then I am pasting as if I am pasting the body
of the code inside this in the main program replacing that. So, I do not need to call any
function. I can write it as a macro definition and I as a result even before compilation.
Even before compilation, I can get this look. And so, this can be straightaway applied
without requiring to call a function. Now if square x is written as an ordinary function,
not like a macro definition, in that case I have to call a function, and calling a function
has got some overheads which I am not discussing here. So, if it be a very simple thing
like this it is better to make it a macro. So, that it automatically gets pasted and it
becomes faster.

However, there is a word of caution for example, if I had defined square x, now it is now
when I am defining as a macro it is I have to ensure that it is correct. Therefore, if I
define square x as x times x. Now, how the macro definition substitution will be carried
out? Let us look at this. If there be something like r assigned square of a plus square of
30.
So, it will be a times a plus 30 times 30. That is how it will happen ok, now what about r
square of a plus b? It will be simply pasted as a plus b times a plus b. Consequently, the
result will be wrong, because in the during execution b times a will be d1 first, and then
that will be added with a and with b. So, this is not what I intended. Therefore, if I had
d1 this, define this as like this, and like this, this problem would not have occurred.

So, unless I do that this a plus b should will not be I need to take if I define it like this
then it becomes this which is the correct 1. But unless I do that it will lead to a wrong
result.

So, you must be very careful about it, this is wrong. And the macro definition should
have been written as I have shown square x is x times x, in that case we would have got
the correct result. Now before moving to anything else, we will now look at some
applications of what we have learned. We are now at a position where we have learnt all
the fundamental tools, without the sophistications, that are required to write a program
ok.
So, suppose I want to solve a problem like this. That, I have got 5 students in the class;
and the 5 students have got 5 names of course, and each of them have got some marks,
total marks, right. Now how do I represent that? And I want to find out which student I
want to print the name of the student who has got the highest marks, all right? Is the
problem clear let me repeat the problem, I have got 5 students in a class? And I want to
find out which student has got the highest marks. And I want to know the name of that
student ok.
How can I solve this problem? This is a simple problem. Here what I will need is, first I
will need an array of the names of the students. So, first I need an array of the names of
the students.

So, here 5 names will be stored very, very disproportionate array. And let me call this
array to be name or names. And on this side, I have got another array, which holds the
marks order of the different students. Corresponding to the roll number maybe 1, 2, 3, 4,
5 the marks are stored here. Somebody got 50, somebody got 55, somebody got 62,
somebody 70, somebody 32. Say, and their names are a, b, c, l m p q x and y; suppose,
these are names, these are the different names. Now why do I need to add is, these are
this; the array called marks. Why do I need 2? 2 arrays, first of all the arrays should be
holding same type of data.
So, what is the type of data that the array names are holding? It is a array of character or
character string. Now how can I represent these names? I can represent them as an array
of an array of strings, or each of these names is what each of these names is a character
array. Therefore, if I just look at names, names will look like a 2-dimensional array. Now
what would be my algorithm first of all come to the representation.
Later, what would my; be my algorithm? First of all, I will have to go to this mark array
which is simpler it is an array of integers, assuming all integer marks are given. Then I
will have to carry out find out the maximum of this. And you can write a function to find
the maximum of an array, right. So, let us try to write the function first so, I have got an
array marks; which has got 5 elements, all right.

So, I can call a function max, what let us first of all think of this maximum value what
will it return me? Say, it we will find out say if I come to this, it will find out which 1 is
the maximum, and will return me an index, right or this is not the maximum sorry this 1
is the maximum.
So, it will return me an index 0 1 2 3 so, it will return me an integer. Therefore, I can
start with like this that int maximum of I can call an array, integer array int suppose that
is m, this and the main function will call it with marks. And inside this what will happen?
You know, initially let me call a value int this is a local max assigned m 0. So, I initialize
a variable max with m 0. Now for I assign some index i.
So, I have to declare I also here. I assigned 1 i less than equal to 5 less than equal to 4,
sorry, less than equal to 4, i plus
. Here if mi is greater than max, then if I then max is mi. And that will go on. Now
ultimately what shall I turned from this? Should I return the max, no, I am returning the
value of i. Because, where I found the maximum now? So, for that now this I is
changing. So, here I will also have to make say. So, let me just make this I to be 0, let me
make this i to be initially i is 0. So, I could have d1 away with this. And wherever I get
this max I am changing this i, whenever I am getting this max I can say that there is
another max index. And I am making max index equals i. So, I am remembering where I
found the max and I will be returning the max index, all right.

So, my maximum function in this way, what it will do is it will sorry it will find out the
maximum so, it will return 3. So, the first thing is find max. Now I have got an array
names, how does that represent it? The representation can be as strings or it can be as an
array of characters. If I consider this to be an array of characters, then remember that it is
a 2-dimensional array ok. And I will in that case I will take. So, this 3 and I will come to
this 3 this, and I will print out this particular element from that array ok. So now, what
about these names let us see. Names is an address a p, q, r or something.

So, I can have this as an array of characters. So, p q r l m whatever it is, and this part is
blank. So, what is my declaration of names? Names will be there are 5 names, 5 rows
and each row is a character.
So, it is a character array char names, let me write it here. Char names 5 rows, and each
row may have 3 columns, right. At best like this lm p lm k pq r like that say. Now I have
suppose come with that maximum index was this rows so, that is 3. Now how do I print
this pq r name here, if it is kept is a string I could have straight with percentage s format.
But here how would I do with this here I can, I will have I will print which row I will
print. I am not writing the entire code ok. Print f which row would I print I had print the
names 3, but there are 3 characters. So, names 3 in a loop I have to print right. So, print f
so, how would the printing be d1? How do I print? 1 rows of an array a 2 dimensional so,

here I come. So, I will print in a loop names 3 0 3 1 3 2 ok. Actually, this is 3 should be
somewhere here, it is confusing 3 should be somewhere here say a, b, c.
So, 3 is actually this row. So, names I will be printing 3 0 3 1 3 2 and that I can print in a
for loop. So, I leave it to you to try to print this in the character format. You can also try
it in the string format. So, what we have d1 here is, we have seen the how the macros are
replace replaced, and we will see further examples of functions all through in the future
lectures, where we will be applying functions and arrays consequently.

We have seen functions in the earlier lecture. And we have also seen we tried to solve a
problem with where there were names of the students in one array, and the marks in
another array. And we tried to find out try to print out the name of the student who got
the highest marks so, for that we had 2 different arrays. Now the same thing I can do
today say I have 10 students.

And each of them have appeared for, I am so sorry, each of them has appeared for 4
subjects, all right. Or let us say there are 5 students, and each of them has appeared for 4
subjects. So, how do I, what would be a convenient way of representing them? One
convenient way of representing them would be to have a 2-dimensional matrix, 2-
dimensional array, where on this side I will have the roll number of the students, which
is an integer and I have got 5 students. So, 1, 2, 3, 4 and 5, 5 students, and the marks as
the columns right, for any problem solving we will have to think of how can we
represent the data so that our computation is made easy. So, at our computation is
facilitated.

So, suppose there are 5 students say roll number one, roll number 2, roll number 3, roll
number 4, roll number 5, and for each of them we have got 4 columns for the 4 subjects,
right. Suppose the subjects are say language science, mathematics and say history, 4
subjects right. And so, how would I read the marks? How would I first of all store the
marks of the students, you can very easily understand now, now I am not writing the
program I am leaving the writing of the program to you.
But let us try to understand how it can possibly be solved. So, I will have a function, I
can write a function of acquiring data. What will that do? For on this side, I can have an
index i, that will talk about the row that I am talking about; that means, which student I
am talking about and another index maybe j or instead of i j you can say roll and marks,
that is also fine ok. So, keeping I fixed, and then you can fill up the row of the marks of
the student. So, how would that program segment look like? That program segment will
look like for i assigned 0, i less than equal to 4, because there are 5 students, i plus plus.

That is for one row for j equals 0 , j less than equal to 3, because there are 4 columns j
plus plus , scanf now you know what to write within the scanf ok.
So, in that way I can read the marks. What I was saying is that instead of this I can see
for, I can be very clear about it, for roll equal to 0 roll less than equal to 4 roll plus plus,
sorry , roll plus plus. And for j similarly I can make marks. So, marks 0, marks less than
3, marks plus plus it is a train that way I can fill up the table ok. So now, in that way, I

can fill up the table and say, I get the marks as 50, 25, 70, 35 like that some numbers.
Now I can have another function that will find out the total marks of each student. So,
right now I do not have a space for that.
So, I can keep that in mind when I am preparing my table, then I can have the fifth
column for the total marks, right. Now I will pass on I have read this. So, first of all, I in
from my main program, I went to a particular function I called a particular function,
which acquired the data and filled up all these. Say, 70, 20, 90, 15, 35, 75, 90, 80, 20, 25,
60, 30, 10, 20, 30, 40. Like that that it has been prepared. So, quickly let us see what we
did.

We had we entered into a main function. And from the main function, I called invoked a
function, which is acquired data, and what should the type of that function be acquired
data, is it returning anything? No.
So, it should be something like void acquire data d. And where is it acquiring the data?
In the integer array, int say let us call that array A and there should be it is a 2-
dimensional array. So, I should have something like this. This time writing clearly int a if
that array was a, that was the parameter. Now so, here that was array A, and here it has
been called like acquire data, say, my array. And also the size has been specified. The
size is suppose globally specified.

So, I get that array size. Suppose it is defined that row roll size is 5 and subject size is 4.
So, I know, but this says subject size plus 1. So, I needed one more. So, I can I can go
here and from there, I returned here. And then I can call another fine total of my array.
Then what will you do? Essentially, I come to this, and what does that function do that
piece of function; that is, finding out the total of each student.
So, that will again be a for loop like the one that we had done earlier, and I will add keep
I to be fixed, and add these and write the total here. Now I could have kept it here, or I
can have another array total let us do that, suppose I am not having I am just having the
marks here. And the total array is not here, but a separate array all together, all right.
So, I have another array which is total. So, I can have the sum of each of them being
passed to this. So, in that case when I am calling, when I am calling fine total then I am
passing on this array as well as the total array 2 arrays because I want to put the sum on
the total array ok. With that I can find the sum of this sum of this, sum of this, sum of
this, sum of this. And then I can make another function, where it finds the max or
whatever I want to do.
So, accordingly the point is that for each of the activities, I can make small small
functions. One is for acquiring data; one is for finding the total. One is for finding the
maximum number, or maybe some other things also sorting and all those. I can do, I can
find out the failure list another function. So, I can have a complete set of small small
functions.

Each independently done, say did acquiring data, finding total, finding max, all these and
they are communicating through a main program, and the main program my data is one
array. So, let me let me draw the data using red.
So, here I have got my array, which was called my array, array which had the size 5, 5
and 4. And I had another array total, total which is a one-dimensional array how many? 5
students so these 2 so, the main function is invoking from different points for different
tasks these functions. And this function is working on this array, shared array. This
function is working on this array and generating the total, maybe this function is doing
something else.
So, that these arrays are being shared by the main function and the small functions. That
is how using functions I can divide a task into smaller sub tasks and can do it very nicely.
Now with this, now let us move to another problem one a version of which we had
encountered earlier; that is, searching an array. When we have got an array for example,
here when he found say suppose, I found the total here. I found the total, and from there I
find out which one is a maximum or is it that if there is any student whose total is less
than 100, I want to test that.
So, I have to search this array. Similarly, I can search if there is any student, who has got
in science more than 90. I can search that along this array, all right? I find if there is any
40 is the pass mark, if there is any student. Who has not passed in maths? I find here

there is a failure case. So, for that I need to do a search. So, search is very fundamental,
search is absolutely fundamental to computation. And so, first we have already seen
linear search, but I once again have a journey through that ok.

So, we know that in a search we are given a key which we are searching for a particular
key that we want to find out, if the key is present in the array, then we have to say that
the key is present and also the position where the key is present, all right. Now we will
consider 2 cases. One is that the array is unsorted.
What do I mean by unsorted? By unsorted I mean that the elements are not in any
particular order.

For example, think of this array where the elements are 5, 3, 2, 9, 8, 17, 6. Now this array
is not in any increasing order, not in some decreasing order. It is decreasing here
decreasing here. Again, increased here, decreased here, again increased here, decreased
here. On the other hand, if the array was something like this; say, 2, 3, 5, 6, sorry, 2, 3, 5,
5, 6, 8, 9, 17. Then this array is sorted in an increasing order. That as I go from top to
down it is in an increasing order, it is sorted in increasing order. It could be sorted, in the
decreasing order also. Like, say for example, I start with 17, then 9, then 8, then 6, then
5, then 3, then 2.
So, this is as we go down the numbers are decreasing. So, these are ordered or sorted.
And this is unsorted. These also sorted, but in a different order. So, I may have to search
from an array that is either unsorted or sorted. So, first let us think of dealing with
unsorted arrays, all right. And we will look into the linear search algorithm for doing
that. And if the elements are sorted we have got a more efficient such algorithm called
the binary search.

So, linear search we have already seen in an earlier lecture. So, the basic idea is we start
at the beginning of the array. So, if we come here, if we come here, sorry, we start say I
want to search this. I start at the beginning of the array. I start here. And I have got a key.
A key is there, say key is 8. So, I start from the top.
Look for the availability of a look for the element matching the key, 5 is not matching 8,
then I go on increasing this index, and go on comparing till I find either if 8 is not there, I
will come to the end of the array all the elements have been checked I have not found the
match, or when I get the match I will say that at this position, I have got the key
matching, all right. So, we will start at the beginning of the adding, and inspect every
element to see if it matches the key. Now if I want to do it in this way, we often talk
about time complexity, it is a measure I am not going into the formal way of the
measure, the measure of how long an algorithm takes to run.
So, as you can understand, if there are n elements in the array, then the best case would
be let us you will find out what it will be say, I start with this. It may be supposed, the
key was 5, suppose the key was 5. In that case, that is the best case with one match one
comparison I find it how many comparisons how many inspections I needed only one.
So, that is the best case, the worst case could be if my key was 6. If my key was 6, then I
would have to inspect every element. And since there are 7 elements here, I had to carry
out 7 comparisons, 7 inspections till I found the match right.

So, the best case would be first element one inspection one search operation. And the
worst case would be no match found. Either the last element or not at all found even after
that. In that case I need n search operations. So, the best case is one, the worst case is if
the size of the array is n, then n. So, the average would be n plus 1 by 2 search
operations, n plus 1 by 2 that is a cost how much time that gives a measure of the time
the algorithm will take to run.

So now we are trying to write it we had explained this algorithm also earlier. But now
that we have done functions, let us write a function for linear search. Why am I writing
the function? Say again if I go to this case. Now I may like to say my task is to find out
whether I any student who has got more than 80, all right. So, I will need to write a
function, I have to search this in a linear way in a sequential way one after another and
for that I have to write a function.
So, how is that function, how will that function look like? Let us see what are the things I
need I have got an array. So, I need to know which array I will be working with, and that
is this array A. And what is the size of the array n whatever that is 7 maybe in our case
the example that I was showing was 7. So, that is so, after I compare 7 elements, if I do
not find the key, then I am unsuccessful in finding the search is not yielding any result.
The other thing is key the element for example, 8 which I am finding out in this array of
numbers, right. Say something like this I am trying to find out 8.

So now let us look at the algorithm. Int pos equal to 0 pos means position. So, initially I
am in this position. That is this array is a so, a 0, while pos is less than size it is, right
now 0 it is less than size; that means, the pos is not has not exceeded the last element;
that means, I have not yet checked the last element. That is why this is said, and the this
pos the element a pos a pos, pos is the index is 5, and suppose my key is 8, if a pos is not
equal to key.
Then I will increment pos, I will check for the next element. Now look at this. This is an
end here. If either of these conditions fail; that means, if I have not found it fine, but I
have exceeded the key exceeded the array size, I mean limit then I will stop. Or if I have
found the key 8 here, although I have not reached the end I will stop ok. So, that is the
condition, then I go on increasing pos; if pos is less than n; that means, when I come out
of this while loop, when any of these conditions are not satisfied.
So, if pos is less than n; that means, actually it should have been pos is less than sighs ok.
If I have come, if still pos is let us it should be pos is less than size. If pos is less than
size; that means, I have not come to the end of the array then; obviously, why did I come
out? Because this condition was false this condition was false means what? I have
already found the key, right then I will return the position.
So, pos increments from 0 to 1 to 2, to 3, then to 4, when I do that the size was 5, I have
not exceeded 5 is still less than 5. And so, pos could be in 2, but I have come out I have
come out because I found this. So, at pos pos position 4, I am getting the key. So, pos is
returned, otherwise if this is not true, then I will return minus 1, minus 1. If it is returned;
that means, that I have not found the key ok. So, this is the look of the linear search
function, very simple. Now so, the key appears in if the key appears within this limit,
then I will return the pointer pos otherwise I shall return the key.

So, here is an example say, this is the array x, 12 minus 3, 78, 67, 6, 50 etcetera. I want
to trace the following calls. I call search so, if you go up the linear search, let me call this
is linear search. It should be written down as linear search. I am calling with the array x
all right the size of the array 8, and the key is 6 ok. Here what will happen? Size of the
array is 8.
So, I will start from here 12, no minus 3, no my key is 6 right, I increment pos from here
to here, no, it is not matching pos is not the key, a pos is not the key here a pos the key.
So, I come out with 0, 1, 2, 3, 4, pos value is 4 here. What will happen for this? I the
same array x size 8, but my key is 5 you can see that I will go up to this and after that I
will increment pos plus plus. So, it will be more than 8. And so, the size is 8. So, I will
not be able to I will say that I have not got the key, all right.
So, that is so, this one will return 4, and this one will return minus 1. That is how the
linear search algorithm works. Now let us stop here for today. Next, we will look at
another more efficient search, but it require that demands something more from us that
the array must be sorted in that case we can apply the binary search algorithm to make it
more efficient ok. So, today what we saw is how we can write as small small functions to
solve a big problem after a break down that big problem into smaller parts. And also, we
found how we can the concept of linear search which we learnt earlier, how we can write
a function for that ok.

In the earlier lecture, we have seen, how we can search in a list of items, may be list of
integers or may be list of names or list of real numbers in a linear way; that means, we
start from one end of the list and we have got a key and we check for every element
whether the element in the list matches the key or not. In that way, we go on from top to
bottom. And ultimately, if we get the match of the key to an element of the list, we
declare it is found. And we also say where it is found.
Otherwise, if it, if we exhaust the list and still do not find the element, then we say that
the list is not found. And the way in which we have find searching from the top to
bottom, that process is known as linear search. We have also seen that, the time that time
that is required to search for an element in the best case, it would be of order 1; that
means, at the very beginning, we can find the element. Otherwise, we have to show
many comparisons, we have to do? The minimum is 1 if we get the match at the
beginning of the top of the list. Otherwise, we have to we may have to exhaust all the
elements and whether it is found or not found. We can say only after we have compared
all the elements.
So, if there is a list of n elements, the maximum number of comparisons that I may have
to do will be n. Therefore, on an average, it will be n plus 1 by 2 that we say in
complexity of algorithms parlance. In that parlance, in that terminology, we call it order
of n ok. That is not the main issue with us, but with we can say therefore, that in a list of
elements, if I have got n elements and the list is not sorted, so, may be 5 2 7 9 11 1, say,
this is the list and I want to search for a key.

So, this in this case, it is 6. But, in general, I can say that there are n elements right. In
general, I can say number of elements is n. So, the best case I can get a match here, the
number of comparisons I require is 1 and the worst case I have to come up to this and
compare all these n elements.
So, the number of comparison on an average will be n plus 1 by 2, all right. That is a
average number of comparisons that we denote in computer parlance as of the order of n.
This o is has got name called big o. I am sorry let me write it in this way. This called big
o notation big o notation. So, where it just denotes the how much time a computer can a
program will take to run, in terms of the input size, what is this n? This is the size of the
input data, we call it input size.
So, obviously, you can see that, as these list increases, if it becomes 100, then the time
average time that will be taken average. This is average complexity all right, will be
more than this. If it is with 1000 even more and as increases, the time will increase in a
linear fashion. As n increases, the time will increase in a linear fashion. However, the
way we are searching is known as linear search. One thing to note is that, in this case, we
are not making any assumption. This is time. We are not making any assumption about
the way in which the data items are organized.

Now, in an endeavor, to see, if we can make it better, we today discuss another very
important type of search algorithm, which is known as binary search. Why the name
binary is coming very clear in a moment, but the important thing to note is that, in this
case, the list or the array must be sorted; that means, it is organized in some particular
way; either in an ascending order or in the descending order ok.
So, that is why, it is called binary. Let us let me just try to explain it with an example.
Say, I have got the array, but in a sorted way.

So, I have got 1 2 the elements where there in the earlier case one 2 five seven nine
eleven right 1 2 5 7 9 11. So, 1 2 5 7 9 11. Now suppose my key is well, let the key be 2.
Now, we will start at middle of this array first we will look at the middle. Now, since is
this is an even number, even sized array, 6 elements middle can be somewhere here. Say,
let me take this, this is the midpoint.
Now, I compare the key with the middle element 2 and 7 are being compared. 2 things
can happen; either 2 the key I I will rather say, either the key is less than the mid element
or the key is equal to the mid element or the key is greater than the mid element. 3 things
can happen. Now, if the key is equal to the mid element, then my search immediately
stops. Yes, I found it and where did I find it? The index is mid.
If the key is less than the mid element, as is the case here, then what can I say? I can
immediately say that, the I still do not know whether the key is there in this array or not,
whether the key is here or not I do not know as here. But the thing that I say is, that the
key, since it is less than the mid, it cannot be on this side, it cannot be on this side. Not
possible. It must be if at all on this side, because, the key is less than the mid.
Therefore, I can restrict my search within this period. Suppose, within this zone, now
what I will do? I will again take the middle point of this array, right? So, between here it
is becoming very simple. So, the middle point of this part is suppose 5. I could have had
it from 1 1 to 5, but I am just taking from 1 to 7.
I come at this point and again now I compare this element and still it is less therefore, am
sure that it is not in this area it must be in this zone. Now I again, only for this part , I
apply again, I find mid element and this is here and I find that the key and the element
are matching. So, it is found. So, how many comparisons I needed here? In this case, I
need it 1 2 3 comparisons. In the case of linear search of course, you could have got it
luckily here in 2 comparisons all right.
But, what would have happened if my key was 9? In the case of linear search, suppose,
the key was 9 in that case, in the case of linear case what would what would have
happened I would have started from here 1 comparison, 2 comparison, 3 comparison, 4
comparison and the 5th comparison I would have got it right, on the 5th comparison I
would have got it. But, let us see what would have happened in the case of the new
search technique that we are looking at.

So, again I have 1 2 5 7 9 11 and my key is 9. I know that in case of linear search, I
needed 5 comparisons. What will happen here? I will come to the middle point here. I
find that the key is greater than mid. This is mid. The key is greater than mid. Therefore,
I know that the key if at all cannot remain in this zone. This part is ruled out this part is
ruled out. It must be in this zone. So, again within this I find the new mid. So, the new
mid comes here. And I find this new mid mid new this and I check this, now I find that
the key is equal to mid.
Therefore, I find my search completes here with this index as output. Now how many
comparisons I needed here? 1 2 only 2 comparisons.
So, 2 comparisons verses 1 2 3 4 5 comparisons in the case of linear search. Now why
was it reduced? The same thing would have happened with if my key was 11. Let us
have a look if the a key was 11. In that case, suppose, the key was 11, in the case of
linear search, I would have required 6 comparisons here to reach at 11.
However, in this case, I would I would be sure if key is greater than is, then my next
iteration will be between these 2 and I would have found mid new mid and I would have
got it with 3 comparisons. Now why is it becoming so? Why is the number of
comparison being reduced? The reason is we have got this array and at every stage, what
I am doing is, am looking at the key and depending on whether the key is greater than the
mid.

I am concentrating on only one half of the array either this array or this array. And then,
depending on the key value, I take suppose it is greater, then I will concentrate on these
zone. If it is less, I will concentrate on this zone. And iteratively, I will be reducing my
search to a smaller array. Let us have another example.
Let us have another example. Let us have it a little bigger all right. Let us have 17 19 20
21 25 32 38 40.

So, now I have got again even number let me have 42. Say odd number arrays 1 2 3 4.
Now I have got 9 elements right. Now I will start with the mid element. What is the mid
element? Here, between this, the mid element is this. And suppose my key is 19 , then I
know that, my key cannot lie, since it is less than 19, it cannot lie in this part of the array.
If at all, it will lie on this part of the array. Why? Why do I say that? I can say that
because, this array is sorted.
Otherwise, I could not have said. Since it is an increasing order, I can say that, since the
key is less than the mid element, therefore, it must be in this zone. And so, I come to this
zone and find out the mid element again may be in this zone or up to this. Say I come
here and find out the mid element this again. So, am looking, I am immediately reduced
my list to half, right? This half, it could have been if my key was 38, then I would have
restricted to this half not this half. But for 19, am restricted to this half. Now again, 19 is
less than 20, immediately I will restrict myself to this half and I will not consider this
part, gradually am going to the lower half or the higher half at every stage.

So, what is happening is something like this. Am starting with the whole array, then am
concentrating either in the left half or on the right half. Then again, depending on that,
either on the left half or on the right half if it is in the right half, then among them, this
am coming to left half and right half. So, at every stage, am dividing the array to half.
That is why this is called binary search. Either it is here or it is not here not in this zone.

So, in that way, I carry on. So, con consequently, the number of elements that I restrict
my search to gets reduced at every iteration. Let us look at this in a little more detail. So,
in every state, we reduce the number of elements by half. I think this is clear now, that
this statement. Now, if you do not find it, you can ignore the half of the array and repeat
the process.

So, now, let us look at this basics strategy. What do you want? The array is from 0 to n
minus 1, n elements. Here, I was showing mid zone only. So, this is the mid m and this is
the left end. This is the right end. So, there are 2 indexes, indices all right? Now, am
taking the key and I am checking this part m. The element m this element; that is, xm.
And depending on whether if it is greater than the key, if xm, if the key is greater than
xm, key is greater than xm is less, then I will be concentrating here. If xm is greater than
the key, then I will be concentrating on this half on this half or on this half. That is what I
was explaining till now ok.
So, here, if it is no, then I will. If it xm is less than the key , then the I will come to this
half. Otherwise, if it is less I will come to this half greater than that all right. So, will first
given this L and r, what is my mid element? How will I compute my mid element or m?
This L plus R divided by 2. And then, depending on whether it is less or greater, we will
we will move the left or L or R till the middle depending on the test. So, again let me
show it with a example that we are showing.

So, something like this 1 2 5 7 9 11 what is being said is, 9 11 ah. So, L is L equals 0 and
R is equal to 1 2 3 4 5 6 0 1 2 3 4 5. So, R is equal to 5. So, mid is L plus R divided by 2.
So, that is 5 divided by 2. So, we can take 2 or we can take 3 depending on. So, if I come
to if I take 2, if I take 3, then am coming to mid. So, what I will do is, if 3 is my
midpoint, if I take 5 by 2 is 3, then, that means, it will be in case of odd I will add 1 to
that. So, I can move. Now if the key is suppose, key is 9 suppose the key is 9. So, my
mid was the 3rd.
It is 0 1 2 3 or let me 0 1 2 3. There is my mid. Now, since the key is key is greater than
the element x m x mid, since it is x mid is less. I will be restrict my search in this area.
Therefore, what I will do? I will move this L to mid. So, this will be my new L. And I
will find the mid with. Now, next mid will be this new L plus R by 2. So, it will be this
element if my search was on the other side; that means, if the key was not 9, but the key
was 2 or 1, let us make it 1.
Then, at this point, I find that the key is less than x mid, then I will be restricting my
search in this area. In that case, I will move my R, I will shift this R over here, and this
the mid will be R, R will be the mid. So, next, I will be restricting my search in this half
and forget about this half. So, that is how we at every iteration, we break down the entire
array into halves. So, if you have understood this, let us proceed. Repeat the search

operation in the reduced interval. So, what we are doing is, we are looking at this binary
search algorithm and we are trying to design a function.

And finery binary search is a function, whose name am just keeping as bin search all
right. This is the name of the algorithm. And what are the parameters? Let us see. The
parameters are one is the array that is being passed the list that have to search. I also need
the size of the array and I need the key.
So, these are 3 things. So, binary search is a function. What are it is inputs? The list or
the array which is x, the size or what we are calling about right now n and the key and
what will the output be, bin search we will tell us whether it has been found or not ok.
But, so, it will be a 0 or 1. Found or not. 0 or 1 or it can written as an index also ok. So,
now, if we proceed with this idea, then let us develop the algorithm step by step inside
this function. I have got the search. I have got the list the list is given to me.

This array is known to me. I declare internally L R and I have to use a another index
called mid. Now, this has got no meaning outside. This function next step what should I
do?

Next step would be while some condition mid, I will have to find out L plus R by 2. As
you know, if this is the array x, if the mid element is greater than the keys So, the key,
say this mid element is 7 and my key is 9. So, this element is greater than I know that
this element is greater. So, this is 17. This is greater than the key. Then I will have to

keep my search within this zone. So, this R will be updated and the R will come here.
Otherwise, L will be moved here. This much is clear. You think over this and build upon
this algorithm we will take it up in next step again, we have to decide on how to build
this things up.

We were discussing about the binary search function or binary search procedure.

So, here we can see that binary search is of type integer is a function of type integer that
will be returning an integer. And it has got the parameters the list or the array which is
being designated as x here, the size of the array and the key. Now if the key appears say,
the array is here, the array is this, or the list is this, this is called x. And it starts with 0,
and the last one is therefore, whatever is in size minus 1.
So, if the key there is a key, and if the key appears anywhere here, it will return the
position of the point where the key is, if this be the position that be returned. And if not
found it will return minus 1, so either it will find the position send the position. So, that
is also integer, or minus 1 hence the height is integer, alright. Now we have got 2
pointers, one is L the left pointer left index and the right index of this. And from there we
are finding out the middle. So, we are finding out midpoint by this, like, now if the key is
smaller than the middle element.

If the key is smaller than this middle element, then obviously, our search will be on this
side. Therefore, this R will be moved to this point. L will remain here and my search will
be restricted in this zone. Otherwise L will be moved here, R will not be disturbed and
the search will be restricted to this zone. This much has been achieved by this piece of
code, what else do we need? What else do we need to do? Now how long will this go on?

So, in this way, what will happen is, I will move either L or R, either this or this, and
when will this be completed, how long will this loop go on? If you think a little bit we
will find that it will go on as long as L and R are not crossing over. So, if I shift and
search this part R is here.

Suppose I so, I initially start with L equal to be minus 1 and R to be the size. So, I am
shifting from so, here is my array and L value of L is minus 1. So, it is here and R is
equal to size; that means, pointing here size plus 1; that means, sorry this point is size
minus 1. So, that is actually here, and while as I share, I shift L and I shift between this
part etcetera.
Then my shift L, R is here; as soon as L and R crosses over, if R will R moves this side
then also a L and R can cross over. If they cross over then that is the; that is my point
where I should stop.

So, I initialize this; so, and I go on shifting this, depending on either L or R. That is
exactly what we are doing when we took the say 1, 2, 5, 7, 9, 13 like that 15. So, I start it
with the middle number, and when the key was suppose my key is 16, all right? Or say.
Let me erase this, my key is say 8; 12. Suppose, my key is 12, what will happen? My L
is here, there is L, this is R, I start with mid is 7 so, key is greater than this. So, I will
have to restrict my search in this zone I take the middle of this. So, R becomes this, this
becomes R, and I am sorry, am sorry R remains the same. I have to search between this
zone; so, what I do? I shift L I have to search between this zone. So, I shift L to this. So,
this is my 12, and this is R I have to search in between this. I will find this to be the mid,
fine? And I find that the key is less than the mid; so, I will restrict my search within this
zone, this zone, within this zone right.
Since it is less so, then what should I do? If since am moving on this zone, I will shift R
keeping L fixed I will shift R here. So, this will be R now; now between this n L l and R
I find mid, this is my mid ok. I find 9 to be less than 12; that means, it should be on this
side. So, I move L, as I move L; L is crossing R; that means, now I have come to a
position where I have ex exhausted everything, and I could not find the key, all right?
So, if L is greater than 0, and x L is equal to key, L is greater than equal to 0. And x L is
the is a key then I return to the point, otherwise return minus 1. So, that is the binary
search algorithm ok. This is how am carrying out the algorithm through a C code.

So, here is an example am writing down an array. Suppose, sorry am writing down a
sorted array, suppose it is minus 17, minus 5, 3, 6, 12, 21, 45, 63 and 50. 63 it cannot be
50, say this one is say this up to 63. That is my array.
Now if I carry out so, the size is 1, 2, 3, 4, 5, 6, 7, 8. I must have one another one. So, let
me have 75, and if 3 be my key this is the key. So, what will happen? I will start L here,
R here, and I will find the midpoint here. So, the midpoint will be here, 12 and 12 is
greater than the key. So, my search will be within this zone, this R will be shifted here.
So, this is my now R, and this is L, I will find out midpoint 3 here now. As soon as I
come to this mid, and I find that this mid is matching the key my search is found, all
right? I get I get my key in a particular position.

So, you can write it in different ways. So, so, in this way, if I do that, then I will get
different results. So, minus 17 I will just missed out minus 5, 3, 6, 12, 21, 45, 63 and 75.
So, if for this, my L was at minus 1 R was at 9, and I my mid was this x 4 12 ok. So, then
x 1 is minus 5. I carry on doing this. L is still 1, R is 4, R has been shifted to here. And x
2 is 3, I found it.
So, that is my result, in that way I will carry out and you can find out that L and R and
then I returned. L I go on shifting. So, that is what it has happened. I have got the mid
value, and I have got the value, but then still am going on shifting. You can you can also,
what I have suggesting is, it is also possible to check the equality with the x mid as soon
as I find that the element has matched with the mid then it is found.

I think you have understood it you can try writing out the algorithm yourself these are
binary search we will see later that it can be also done through recursion.
Now why are you doing so much? Earlier, linear search was very much simple, right?
Here suppose we had thousand elements, if we had thousand elements, then the ordinary
search if a key may key is the member of x, it would on an average require on an average
it would have required 500 comparisons on an average. But what will happen in the case
of binary system search? After the first compare 1000 elements.
So, we are left with only 500 elements, because I start it from I start it with an array, and
then based on that I have either gone on this half of the array or this half of the array
depending on whether the key is less than or greater than the midpoint this is the mid. So,
on an average first compare I am left with 500 elements. Next compare this part is again
divided if it is on this side am left with 250 elements, right. After at most 10 steps, we
are done in that way I go on dividing it and after at most 10 steps I am done.
So, I have thousand elements ok. So, I can so, in that way I get 250 elements, and 125,
125; then half of that 60, 65 or something like that.

In that way, number of steps that I will be following will be around 10. In general, if
there are n elements in the array, number of searches required is 2 to the power k should
be n, where k is number of steps ok. For n if there be 64. Initially, the list is 60 the size is
64, after first comparison list is 32. After second it is 16, then 8, then 4, then 2 and then 1
so, 6 steps. So, basically at every step am breaking it down into half. Therefore, if I need
the k steps.

Then, if I need k steps, then 2 to the power k should be equal to n; that means, how many
steps are there? How many, what is k if I take log and k log log k k log 2 is equal to n.
Therefore, k will be log 2 n to the power base of log 2. So, log 2, log 64 to the base 2 is
6. We will be completing in 6 steps. Whereas, in the worst case I would have needed 64
comparisons in the case if linear search. Now given this idea of binary search.
So, what have you seen? We have seen binary search is a search algorithm, that enables
us to search for an element much faster, than linear search the approach being that we
divide the array to be searched in half every time. So, we divide it into half and restrict
our search in half, and in the next step I further divide it into 2 half and restrict it to even
a smaller steps.
So, every time am halving whatever array am checking. So, 2 days to the power k time
by half date where k times have half date 2 days to the power k should cover the entire n.
And so, from there we get the complexity to be of log of log 2 log n to the base 2 log n to
the base 2 in general it will be log if 64 is replaced with n (Refer Time: 15:43) then it
should be log n to the base 2, that is my time complexity compared to. So, I can say this
order of log n to the base 2, compared to order of n, that was the case in the case of a in
the case of linear search.
Now, we will move to another very fundamental problem in programming. We often
need that say for example, here we have done one thing that is, I had a array like say 2, 3,
7, 6, 1, 9.

Now this was an array, on which I cannot run binary search. Why I cannot run binary
search? Because binary search can be done only on sorted array. So, if I sort it, either in
increasing or decreasing order. Say, for example, it becomes 1, 2, 3, 6, 7, 9. This is a
sorted array, or the other thing could be 9, 7, 6, 3, 2, 1. These also a sorted array. In the
other direction, it is descending order this is the ascending order ok.
So now another problem is, to arrange the things arrange the objects, suppose they are
number of numbers like this. We have to arrange them, sorted or arranged in a particular
way. The question is, how to do sorting, how to sort? So, suppose I have given this array
to my program, this is the input. Then if I want to apply binary search, then I cannot
directly apply it apply binary search on this. So, what I can do? I can first take the array
say I read the array let me write.

Then sort the array, and then read key apply binary search. Now binary search takes for n
number of elements it will be faster. But how do we sort the array? So, it is faster than
linear search, but is it advisable to approach in this way if the array is not sort, is it
advisable to sort the array and then apply binary search? In order to understand this, we
have to first see how an array can be sorted, how an array can be arranged in either
increasing or decreasing order.
That is also a very important problem that is called the sorting problem. And this has got
very important I mean application, in many of many of objects whenever I so, for
example, for example, you have got the marks of the students, all right? The you have
got a marks array hm.

Say, you have got 2-dimensional matrix may be where, all right, let us take one
dimensional one dimensional array; where, the roll numbers are here, every row is
corresponding to a roll number. And here I think, I will I will just do it again. I have got
the marks here; 56, 50, 65, 70 etcetera, etcetera.
Now, I want to find what is the highest marks. One thing is that I can find that, out or I
want to attribute ranks, first second third like that. In that case I can sort this array, and
from here I want to have an array like this; where the first element will be 7, the second
element will be 65, then 56, then 50. This also sorting the marks. In a decreasing order,
and along with that I can also sort the roll numbers, and can publish which roll number
got marks right. So, what we want to see next is sorting.

Let us define the basic problem first. Sorting means given an array like 0 to some size
minus 1 reorder the entries so that they are in this way; that x 1 is greater than equal to x
0 x 2 greater than equal to x 1. So, if it be this sorry, why is this greater than equal to
coming up? If for example, 2, 5, 5, 6, 6, 7, 9; this also sorted array. So, both these
elements could have taken any order, but since they are same they can be assumed to be
sorted. That is why this greater than equal to thing that is coming up.

The list here is in non-decreasing order, non-decreasing. I cannot say increasing order
because it is not increasing 2, 2, 5, 5, 6, 6, 7. So, here of course, there was an increase,
but here there is no increase. So, this is rather instead of calling it increasing order, we
can call it non-decreasing order. A list of elements in non-increasing order it is not
decreasing order. So, I can also sort it in the other way as it shown earlier.

So, here is an example, this is sorted in non-decreasing order, you can see this array. 10,
30 now this original list. Now if I sort them in non-decreasing order it will 10 minus 10,
10, 20, 30, 40, 60, 70, 72, 70s, 80. And if I do it in a non-increasing order, then minus
80, 70, 70 in this way. This is not increasing in this way, here it is not increasing, all
right? Here it is not decreasing if I go in this direction. So, these are the 2 possibilities.

So, the sorting problem is, if we have an array from 0 to size minus 1, I want to sort it
and get a sorted list, all right?

That is what I want to have. So, the first algorithm that will be talking about is selection
sort. Selection sort is something like this. That suppose we have got a list here and this
part of the array is already sorted, this part of the array is sorted in a non-decreasing
order. This already the smallest element is here, the smallest element minus 10, then 10,
then 20. This part is somehow as sorted. Now am less left with sorting this part only this

remainder. What should I do? I am going to select the candidate for this position, right.
Am going to select the candidate for this position. For that what shall I do? I will start
since part is sort, all the elements of this side or either equal to this or less than this.
So, I will have to look at this part, and find out minimum element that is here. This
element that is minimum, since this part is sorted, this element this element must be
greater than this elements. So, among these, only for these people this one is the smallest.
So, I select that I select that, and put it in this position I swap how do I do that? Suppose
here it was, it was minus 10, 10, 20, 30. And here it was 50, this point, this part is sorted.
50, 32, 72, 31. Now I remember this position, and search from here and find out the
minimum. So, this 31 comes I swap it here.
So, what happens to my array? This part, let us see what it will happen. It will now
become from here it was 30 it will be 31, 32, 72, 50. So, up to this part it is sorted now.
Now form here I will try to find out the minimum element. I find this is the minimum
element. And I sort out the minimum element. I swap this minimum element with itself.
So, up to this is sorted. Out of these now I have to find out the candidate for this position.
So, I find out the minimum I come here and swap this. So, it becomes 50, 72. So, here in
this selection sort the approach is that we have to we have to we are going position by
position. And I am selecting the element that belongs to that particular position. So,
whenever am starting with the search then at the beginning I am having am starting with
the if this be my array.

Then am first searching for this position. And this position will have will be the
minimum of all these. I search all through here, and find the minimum suppose the
minimum must 10 was here.
So, I take and bring this minus 10 here. So, it becomes minus 10 I know this is the
minimum. Now am sorting am now looking for this position. I select the element,
minimum element in this zone. I find here something 10. So, this part is done. So now,
10 is swapped here. So, 10, 10 and then this part is unsorted. This part I will sort. In this
we way we go on. This is one of the sorting approaches. We will deal with it further in
the next lecture.

So, we were discussing about sorting. And in particular we were discussing about, one
sorting technique which is a selection sort. So, in selection sort what do we do we have
got an array.

And of size, so, that means, the index is 0 to size minus 1. So, what we do? We some
parts we assume that some parts are sorted. So, first thing that we do is find the smallest
element. So, if from 0 to k is sorted already in the order. Then my job is to sort from k to
size minus 1. So, what we do the step is, that we find the smallest element minimum
value in the list x from k to size minus 1, all right. I find the minimum value, and then
swap the that minimum value with the k th position; that means, this position, with this
position I carry out here in this position I bring the minimum value. And these goes on
and then increase k, k will be increased to the next position. And in this way, I will be go
going on.

So, the sub problem is the sub problem is to find the minimum element. So, if I go here
as we have seen in the, I mean in this array, my task is to find the minimum position ok.
So, where is say this part, this part is already sorted, I am sitting here, and this is my k th
position, right. This my k th position, and I want to find the minimum where is the
minimum value ok. Where is the m value, minimum value where? So, for that, this is the
function to find the minimum location in the array x, and starting from this location k, up
to the loc up to the location size minus 1.
So, I need to needs know size, I need to need need to know k. That is how we are giving
the parameters, as we had explained in functions. So, at every point, you look at how the
functions are written that will help you revising this ok. Now the body of the function, x
pos will be the smallest element found so far. So, initially I am making pos to be k.
So, x pos is this point, now from k plus 1 to up to size I go on checking, whether this x j
this position is less than this position. So, I find out in this way, here I find the minimum
right, just see if you can understand the code. And find the minimum in between k plus 1
to size minus 1. In between this am trying to find the minimum. So, whenever I get the
minimum am I will be returning that particular position. So, this is the position that I will
be returning this position ok. So, what would be my full algorithm therefore? So, I have
got a function, I have got this function, min loc, which will return with the minimum
location.

Now so, it will yield with the location of the smallest element.

So now you see a selection sort, main sorting function will be this. It takes the array and
the size ok.
So, this is my array x, and this is the size. So, I will have to work between 0 to size
minus 1. I have got 2 intermediate variables k and m. For k equal to 0 to k size minus 1,
what am I doing? First am starting with this, this element; that is k equal to 0. And what
am I doing? I am finding out from k in the array x up to size I am finding the minimum

location. So, suppose here is the minimum. Then I am what am I doing here? Temp is
going to ak. So, this k is going to temp. And this ak is being returned by am this is the
minimum is coming here, and then this temp is going here. So, here what am I doing is, I
am swapping x my array was internally I called the here there is a small mistake I can
find. It should be xk, all this should be x, all right because I am dealing with x.
So, xk will get x minimum m because and vice versa and this y. So, what is happening
here let us see.

Suppose my array was something like this 50, 20, 70, 10, 100. So, I am first this is my k
equal to 1. I want to bring the minimum at this position. So, what I do? I from here I start
searching for the minimum. I find tenth with the minimum, then I swap here is this piece
of code, I swap I bring 10 here, and 20, 70 remains and 50 I take here. And then what do
I do? K is incremented so now k is here. Now I find min loc if what is the minimum here
compared less than this or not there is none so, fine next.
So, this remains next I increment this. So, this is also in position, this is in position,
because it need not be exchanged next my k is increased here at this step, k plus plus it
has been increased here. I find the minimum in this area; I find this to be the minimum.
So, what is happening? 10 was in place, 20 was in place, I swap 50 and 70 here. So, 50
comes here I find the minimum, 70 remains here, 100 remains here. Now I change my k

and see if there is any minimum left here at the min location is not returning me
anything. So, therefore, I get this to be my sorted array ok.
So, this is what so, you can see that so in this way we can, sorry, here is an example you
see here.

The example you see here, I start with this. So, 3 is the minimum, I can see here 12
minus 5 6 etcetera I can see, minus 17 is the minimum. So, I find out minus 17 here I
swap that. So, minus 17 comes here, and 3 goes to the place of minus 17. So, these 2
now 12, 12 and I find the minimum from 12 onwards, I find minus 5 to be the minimum.
So, that one will come here. So, minus 5 comes here, and 12 is swapped there. Now
within this part I find the minimum, minimum is 3. So, 3 will be swapped with 12, and
12 goes there in the place of 3 you see. Now so, I start with 6, I start finding the
minimum. 6 is the minimum fine. So, it remains I increase k. So now, 142, in this way, I
go on from here, who is the minimum for starting from 142? 12 is the minimum.
So, 12 and 142 will swapped 12, and 142 has been swapped. Next 21, 21 within this 21,
142, 45, 21 is the minimum. Therefore, I keep it in place. Next is I take 142 and 45, I
find that 45 is minimum I swap that, and 142 goes there. Next is 142 is the, that is the
sorted array that we get. This is what is known as selection sort. So, the philosophy of
selection sort is, that am selecting the minimum element among the unsorted elements

and placing it in the position proper position where that minimum element should be;
that is why we are selecting and putting it so, that is why it is known as selection sort.

So, how many steps are needed to sort n things here? If I do this, how many steps am I
taking. You see, how many steps am I taking? All through here if you look at this, how
many steps am I taking? If the list size of the list was n then the total number of steps
that are required is proportional to n square, because for every element why it is why it is
so? Let us try to understand this.
The reason is that for every position, how many positions are there? 1 2 3 like that, there
are n positions. Now for every position, for this position, how many comparisons I need
to find out the minimum? N minus 1 comparisons n comparisons for all these, next I
increment it here. So, how many do I need? I need for each of these for n, for n such
elements for each of them I need n comparisons then n plus for this I need n minus 1
comparisons, then I need n minus 2 comparisons, then I need n minus 3 comparisons in
this way for example, for this n 1 2 3. So, n minus 4 comparisons I need in this part, I
have to compare between these things. So, in that way I go on. So, for every so, for each
of them I need to compare this, right for n such things, I have to do this, n n plus m n
plus 1 n minus times n. So, that will be the order of n square if I find the product, right.

And number of comparison total number of steps and number of comparisons is again, n
into n minus 1 by 2 like as I said n minus 1 comparisons plus n minus 2 comparisons,
last one is one comparison. So, if you add this one to n minus 1 is n into n minus 1 by 2,
you know that, and that is of the order of n square, if I break it up it will be n square
minus n by 2.
So, that is again of the order of n square of the order of we write it as of the order of n
square all right.

Now next we come to another sorting algorithm, which is known as insertion sort. What
is the general situation? Again, just like the selection sort, we have got the smallest
element sort; it from 0 to this point is sorted. The remaining is unsorted, all right. Now
what we do is we compare and shift till xi is larger ok, I go on shifting.
So, what I do is I start with this element, and I put this in the proper position, I insert this
in the proper position I. So, I move this in this side or in this side, and I will come to the
proper position of this element, this element is being put since it is smaller the smallest
elements is sorted. So, I am taking this, and I am putting it in the place where it should
belong because I have not seen up to this.

So, so, insert sort is something like this let us see if I can show you a example first.
So, what am doing is, I am comparing and shifting, till xi is larger. I am continuously
shifting the elements, in this way I go on shifting this. Ultimately xi will be larger than
all these elements. So, therefore, my sorted position will be up to this, this is larger right.
So, I am sorry, I just went the other side other way. So, let us study this algorithm. This
algorithm is void, why it is void? Because it is not returning anything it is taking the
array and is sorting this is taking this array and this sorting this. So, it is type is void it is
taking a list and it is size. Now for I equal to 1 to size, I am taking item to the list I. So, I
have got elements like say 12, 7, 5, 17, 9. So, first I am taking I is one so, am taking this
element. This is the item. For js now I am looking at you see j equals I minus 1, and j is

greater than 0 and list. So, it is not am I am not going into this side. I will have to go in
these direction, what is this mean? I start with ji minus 1, and go till j is greater than
equal to 0, and the list is greater than I/.
So, all right so, my I is here; that means, I am not I am going till the end of this array on
the other side, I am going on the other side. And I shift what was my j here, j plus 1 and
the list are being swapped. So now, it will become 7, 12, 5, 17, 9. Now and then in that
way I go on shifting, all right. So now, if I come here, I increment I after one item so, I
will come 5 and 5. I will go on checking, what is the proper place of 5? So, it will be 5
will be swapped with this 12, 7, 17, 9. In that way I will try to find out every each of
these is for proper position. So, I think we can go for a more popular sort.

Let us go to the more popular sort, I think that will be better selection sort you have
learnt insertion sort is another form. But let us learn the more popular one that is the
bubble sort. Bubble sort as the name implies. It starts from the bottom, and the minimum
element is pushed up to the, how is that done? Just as a bubble floats up from the bottom
and goes to the top the minimum element should be pushed up the minimum element
should be pushed up to the top.
So, let us see how it happens. So, I first compare between these 2 elements, then these 2
elements, and in this way, I go on comparing between each of them and push it up ok. in
every iteration, the heaviest element drops at the bottom. So, what is happening is so, if I

go here from the top, I try to find out if this element, if this particular element, I am sorry
this particular element is heavier than this particular element. Then this particular
element should go at the top and this should come down here, all right? Next, I compare
sorry, next I compare what is happening? Next, I compare between this so, this was
shows the heavy element. And I find that this is not an heavy element. It is this heavier
than this. So, this may be more heavier if much heavier than this. So, this is not pushed
out ok, remains. Now next I compare between this, and every time I am making the same
mistake may be this is the heavier, lighter element. So, this lighter element will go up,
and this heavier element will come down.
So, it will be something like this, all right. So, in this way in one direction ultimately
what I will do? I will have the heaviest element at the bottom, and all the elements here
are lighter than this, this element lighter than this element, but these elements are not
sorted. So, what I will do? I will restrict my next iteration within this zone, and again
start between this elements, and see whichever is heavier that will be pushed down. Am I
clear?
You see, every time I am comparing between these and am pushing that down. I think it
will be clearer in a moment. Every iteration the heaviest element drops at the bottom and
the bottom this part is done and the bottom moves upward. So, next time onwards my
search will be restricted between this zone, this zone to the top and the heaviest will
come to the next time my search will be restricted to this zone like that. So, the heaviest
here, next heaviest here, next heaviest here, heaviest here, next heaviest here, next
heaviest here, like that it will go on. So, I want to see if I can give an example first.

Yeah, so, what is happening here is, say this was an unsorted array. The heaviest one has
been first pushed down this 89 was the heaviest one.
So, by piece by piece comparison I have pushed it down. Next time I was restricted to
this part of the array 89 has been pushed down. So and let me try to show you.

That say, suppose I have got an array like this 50, 16, 20, 30, 40. So, first I compare
between these 2, 16 50 is heavier. So, I come here next, I compare between these 2 50
and 20, 50 is heavier. So, 20 comes here 50 comes here. Now 50 and 30, 50 is heavier.

So, 30, 50 and then 50 and 40 so, I compare this. So, it becomes 450. So, in one turn
what do I get now I get 16, 20, 30, 40, 50 now it was search the many things are sorted
only one was in out of order so, that is been done. But suppose this was let me let me just
change it, it becomes became too easy. So, suppose it is 25, then after this swap, this
became 25 and 50. So, I have this array. Now I again check between this 2. Heavier is in
place, I check between this 2, no issue heavier in place, I check between this 2.
So now what will happen? 25 will come here, and 30 being heavier will come here. And
30 and I need not compare any further. I can because this is this I know is the heaviest.
So, what do I have now? 16, 20, 30 not 30, 30 has been swapped 25, 30. I again compare
between this 2. So, there is no change, as soon as I find that, there is no interchange; that
means, all this things are in order. This is the idea of the selection sorry the bubble sort.
Every time the minimum is shifting going to the bottom. Or I could have done it in the
other way I could have justified the name of the bubble sort, if I had taken the lowest
element, and pushed it up ok. So, quickly if we look at the algorithm a little bit.

So, we have got this is a bubble sort algorithm. Let us see, now in order to explain this, I
will need sometime, because here we are using some new ideas, star x and star y. I think
I will take it up in separate lecture, and discuss this separately, all right. But just as I had
explained now, the way the bubble sort works, I will just give you one more example to

show how a bubble sort works. And then in the next lecture, I will show you the
algorithm because that will require some more explanation.

Let us say, I have got this 30, 20, 5, 16, 2. So, what will be hap happening in the first
iteration? 30 will be compared with 20, 30 is heavier. So, it would 20, 30, 5, 16, 2. Now
30 will be compared with 5, what will happen and this will be swapped. 30, 16, 2. 30 will
be compared with 16. So, what will happen? 25, 16, 30 2 and 30 is again greater than 2.
So, 25, 16, 2, 30. So, 25, 16, 2, 30 by that I get this 30 at the bottom, I now I start with
again; 25, 16, 2 right.

So now, I have got 30 is at the bottom 25, 16, 2. And 30 is already in proper place, here I
will swap. So, what will happen? 5, 20, 16, 2 then 20 will and 16 so, it will be 5, 16, 20,
2, then 5, 16, 2, 20, 20 is in the proper place. So, 30 and 20 are in proper place. And 5,
16, 2 I will have to handle.

So, what will be there? 5, 16, 2. So, 5, 16, 2, and here I have got 20, and 30 already in the
proper place sort it. So, here 5 and 16 no change, 16 and 2 there will be some change. So,

5, 2, 16 so, 16 is in the proper place. So now, between 5 and 2 so, my thing will be 16,
20, 30 are in place.

16, 20, 30 are in place, and 5 and 2 I have to deal with, these are fine. So, my pointers are
changing, right, between these 2 now 5 is heavier. So, it will be 2, 5, 5 is in the proper
place. So, 2 5 in the proper place, 16 proper place, 20 proper place, 30 proper place. So,
only 2 there is no question of swapping. So, I get the complete sorted file ok. So, this is
the principle of bubble sort, I will be explaining the algorithm the code in the next class.
In the meanwhile, you can think of you can read book and you can try to see look at this
code and the algorithm yourself. I will discuss it in the next week lecture.
Thank you.

So, we were discussing about the Bubble Sort Algorithm and the approach as was discussed in
the last class was that every element, every iteration pushes the heavier element at the bottom
and the lighter elements therefore, goes go up.

So, we had shown an example a couple of examples by which we can show that the heavier
elements go down and the other lighter elements go up , we had given a number of examples to
that effect.

So, if there be 50 here I do not know this visible, let me write it here 50 here and 6 here and say
12 here and 7 here then what will happen is 50 will be swapped with 6 because 50 is heavier than
6. So, larger than 6. So, first it will be 6 and 50 and then 50 will be compared with 12 again there
will be a swap. So, there will be 12,50. 50 will be compared with 7. So, it will be 7, 50 in that
way ultimately the 50 if it is heaviest will come at the bottom.

So, we swap only if the element at the top is heavier there by heaviest element is coming to the
top and the others which are less than this heaviest element will be going at the top, the bottom
moves upward. Now, we are going to write the algorithm for this or the program, for this before
writing the program we need to understand a very interesting and fundamental concept of C
programming that is pointers.

We will not formally introduce pointers here, but we will be talking about pointers in a different
way in a context of this bubble sort. Now, what is a pointer? Pointer is something that points.
Now suppose there is a variable here,suppose the variable is named v and till now we have seen
that we can write declare the variable as int v. So, v has got a particular address may be that
address is 1000, 1000 is the address of v. Now, if I say int v equals 50; that means, in the address
1000 50 is written.

Now, suppose we have got this address v and which is an integer.

But I am not declaring v as such, but there is another variable p, which will always point to some
integer. So, p will point to this v. P is pointing at this v. In that case I can say p is a pointer to v
now. So, therefore, what did I say?I said that v is stored in the location 1000, now pointer p this
variable p therefore, stores the value 1000.

Now this v is of type integer. So, v is a pointer to an integer v that we know because I have
earlier said that v is an integer. So, I can very well say int v, but what is the type of p , p is a
pointer to v, which is an integer. So, we write that as int star p, what does it mean? It means that
p is a pointer to an integer, if I write it ,it is not concerned with v only. It says that p is a pointer
to an integer.

So, what is the value of p now? Value of p is 1000. What is the address of p the address of p?
Now where is this p ?This is in location 1000 and where is this ?This might be in location 2000.
Therefore, what is the address of p? &of p is 2000, we know that this and operator gives us the
address, we have encountered this during scan f when we were discussing about scan f right.

So, let us have this diagram to understand the concept of pointer suppose there are different
things written in different pages of the book.

This 1 page, this is another page ,this is another page and this is another page, each of these
pages have got a page number. Now I have got a table where suppose- this has got some content a, this has got some other story b, this has got some other story c, this has got some other story d.

Therefore, the content of each of this pages are the stories a, b, c, or d.But which page I am
looking at ?Suppose here is a table of page numbers. So, I have got a 4 pages. So, the pages are 1 2 3 4. Now, suppose I just want to come to this page number. So, this page number does not tell me what story is there, but this page number tells me that I have to go to this page. This entry is telling me, this particular page number is telling me that, I have to go to this page.This is telling me that I have to go to this page and this is telling me that I have to go to this page.

So, what are these? What are these things? These are nothing, but pointers to pages and what is a is a content of the page. So, a b c or d say is content of page 4 and these are pointers to the pages; that means, if I want to go to page 4- where should I go? Because this page may be
located at some other table may be, suppose this pages of a book are torn out and have been kept on different tables ok.

So, page number 1 is giving me the table address. So, that it is on this particular table. So, it can
be on table t 1, this can be on table t 2, may be the third page is on table t 4 and this is on table t 5
it is possible. If I want to read the first page I will come here -the first entry this is the point in to
table t 1. So, and I go to table t 1 and to find this particular page and read the content in that . So,
these are pointers to pages, but these pointers also have to be in some memory location -let me
draw the diagram in different way now ,suppose this is my memory and I have got 4 variables.

Suppose I have got 4 integer variables and each integer variable takes 2 bytes.I am showing 2
bytes here one after the other all right, this is the variable v 1, this is the variable v 2, this is the
variable v 3 and this is the variable v 4 .

Similarly let me just change the colour. Let this be in locations- v 1 is in location 1000 assuming
that an integer takes 2 bytes, this one is in location 1002, this one is in location 1004 and this is
in location 1006.

Let me extend my table bit, now suppose I have got here 4 integers. So here I have got p 1 is a
pointer variable- since it is a integer let me say- p 2 p 3 and p 4. I am not bothering about how
many locations it is taking.

I am now not bothering about this division here 2 bytes am just showing those 2 bytes together
that will be easier for me to write all right. So, here the p 1 is storing the value 1000 why? p 1 is
a pointer to this variable. So, this p 1 tells me not the value of v 1, but it tells me where is v 1
located.

So, 1000 is a position where v 1 is located. So, p 1 is storing that pointer and p 2 is say 1002, p 3
is 1004 and p 4 is 1006. Now these locations also have got address- suppose these addresses are
5000, 5002, 5004 and 5006 this 5006 ok.

So, please try to understand when I say p 1- what is p 1? p 1 is a pointer to an integer. So, int star
p 1; that means, that p 1 is an integer all right and p 1 is a pointer to an integer variable . It could
be a floating point variable. So, had it been a floating point number.

Now suppose each of them is a float. So, float v 1. So, v 1 is a floating point number. So, then if
p 1 points to v 1, then I should write float star p 1; that means, p 1 is pointing to a floating point
number .

So, since it is a floating point number ,if I say now &p1 what will I get? what is the address of p
1? what is the address of p 1 address of p 1 is 5000 and what is star p 1? What is the meaning of
this? Please do not be confused. This star and this star has got two different meanings, this star

means it is just saying that p 1 is a pointer, pointer to what type of variable? Pointer to a floating
point type of variable.

So, for v 1 am just writing -float v 1 so; that means, that v 1 is purely a floating point number not
a pointer, but when I say float star p 1, then p 1 is a pointer to some floating number. Now, what
is star p 1 in this case what is a content of p ?Content of p 1 is 1000 So, let me just repeat it once
again. So, we have seen in declaration something like int star p 1 int v 1.

Now; that means, p 1 is a pointer ,suppose located at location 5000 and p 1 is a pointer to a
variable v 1, which is also an integer- v 1 located at location thousand.

This two lines are just meaning these two things- this two pictures, this 5000 or 1000 this part is
not known to us, because that is known by the compiler not by us, but logically , this is the
picture, leave aside this 5000 and 1000 ,only these 2 parts are declared by this. Now if I say star
p 1; that means, the content of p 1, whatever is the content of p 1 -now if I make p 1 to point to v
1 in that case if I make p 1 point to v 1.

So, what will that be? Content of p 1 should be assigned to &of v 1. The &of v 1 will give me
the address of this and the content of p 1 will get that. Therefore, this 1000 will be written over
here; that means, this pointer is pointed to this v 1. I will not go in to further details of this right
now, we will come to this as an when the context comes later. Right now we this in mind let us
go back to the algorithm of bubble sort, what is being done on the algorithm of bubble sort.

Let us try to understand each of the functions -first thing is we have got this standard equation.
Now, first I will start with this function void bubble sort -bubble sort is void, because it is not
returning any value ,it is just sorting some element -what array? x array and the size of the array
is n, int ij these are 2 local variable because they are using used as indexes of these two loop. In
this loop what is happening?- for I assigned n minus 1 to 0; i minus minus; what does that mean?
That means, if I have an array here this is my array I have got I pointing here.

Because, that is the size of the array minus 1.So, i is pointing here and it will go up to 0. So,
gradually it will go in this direction up. That is what the first for loop is saying. First for loop is
saying that I is starting from the bottom and going up upto 0 as long as it is greater than 0 and
then for j equal to 0 to j less than i ;j plus plus.If xj is greater than xj plus 1; that means, what if
xj is greater than xj plus 1.

So, let us again go back to this j is starting from 0 and I am comparing this value 50 with the
value 2 with j plus 1.This is j plus 1 if xj is greater than xj plus 1, what would I do I would swap.
Let us go into here if xj is greater than xj plus 1 I am swapping xj and xj plus 1, I will come to
the swap function later am assuming that the swap is working correctly- that means it is
swapping them.

So, what is happening? So, this loop will go on- j equal to 0 then j will be 1 and in that way it
will go on. So, next when I swap it becomes 2 and 50. Now, I have got other values now j is
being incremented. So, now, this is becoming j and this is becoming j plus 1- in that way this
swapping will be done. Suppose this is 70. So, there will be no swap no swap.

So, let us see here, if this condition does not hold -swap is not taking place.I am going back to
this loop .Now, 70 remains here . So, now, j changes and j plus 1 is pointing here now there will
be a swap here. So, this is 12 say -12 and 70 will be swapped. So, 2,50,12 70 in this way I will
go on up to this point and next.

So, ultimately in this iteration ultimately I will have this heaviest element say 70 is the heaviest
element, then I will be decremented and I will come here and then from this zone again I will do
the same thing as I did till now . Exactly that is being done here. So, I will be doing this and then
I will decrement n little bit and I will go on doing this. I will be then looping- doing the same
loop again for 1 level less I mean the last element is already having the heaviest element. So, I
will do it among the remaining part.

So, this part this part is already covered. So, I have decremented it. So, I will be now playing in
this zone and once that is done this part will also be coveredI will be playing in this zone .Every
time am deciding on the zone , n, n minus 1 n minus 2 like that it is going on and every time I am
doing this loop for each of the pair wise element comparison and they are by am pushing the
heaviest element at the bottom. That is the code for bubble sort how it works this swap keeps a I
have not saying this swap. Earlier we have seen that if we do swap in any arbitrary way.

For example, if I want to swap 2 variables say I write swap int a, int b- let me do it here , if I just
do swap int a, int b and inside I use another variable temp, temp gets a , a is stored here a gets b
and then temp has been remembered there. So, b gets temp and so, this was my function return.

So, here suppose a (when it came) it was called with x and y s. So, main program called swap
with x and y and x was 5, y was 7 right. So, x was a location -here 5 and y was a location 7. Now
when it came here a was a local location and I know that the functions are called by value so, 5
was copied in a and 7 was copied in b and then by this temp became 5, b became 5 and b was
stored in a. This was stored in this -these became 7 and this again became 5 -all right.That is how
it was done.

So, a was 5 so, temp was 5. 7 went over here to a and here 5 was copied again here- this was
fine. So, this swapping was done by a by b and then when I returned no change is reflected in x
and y -that was the problem.

So, we will now see how the swap function can be implemented.Another point is I have just
done return and a function can return only 1 value. I could not return a and b to the main
function. So, how can the thing be managed. So, that after the swapping the result is reflected
back in the main function. We will see that in the next lecture.

So, we are discussing about bubble sort and we had looked at some notion of pointers. So, you
have now got the preliminary idea about pointers.

On this segment we have seen this part of the code, we have seen - this is the bubble sort
function on this side, we have got a function which is swapping 2 variables. I want to swap x and
y.

So, this swap function is taking x and y. So, we have seen earlier that in the normal case if we if
we swap in a function (suppose I have got a void swap xy)

(Refer Slide Time: 01:26)

Then we are shown (we used another variable int temp) that whatever swapping I am doing here
that is not being reflected in the main function, that we saw.Now what we are doing here let us
see here I am writing void swap, instead of writing x and y I am writing int star x comma int star
y; that means, what I am passing here is my swap function, here is my swap function and it has
got 2 input parameters a function has got always one output, there can be a number of input
parameters earlier it was x and y.

So, some variables x and y were having actual parameters being copied into them, but now I
have not used x and y instead I am using pointer to x and pointer to y.

(Refer Slide Time: 03:30)

That means, now I am in my main function -here is my main function or the calling function not
necessarily the main function. In this case it was called from bubble sort. So, the calling function
-I should not say main it should the calling function. The calling function has got 2 variables x
and y.

Now when I am calling this function void swap. So, I am actually having the function here -the
swap function. I am not passing the values of x and y, to be to be more natural let us make this
actual parameters are a and b.

So, somehow I am calling here swap in my calling function I am calling swap a comma b. If I
had done this then this value of a and the value of b would have been copied there, but instead
what I am doing now- I will not write this instead I will write int star a and int star b. So, I can
say here I am passing star a comma star b; that means, what? I am passing the pointers.I will I
will do it again, let us look at this say.Here I am passing the address. So, again let me do it in a
nicer way.

So, here is the calling function.

(Refer Slide Time: 06:09)

The calling function has got the variables a and b and inside the calling function I am saying
swap- what should I pass on I instead of saying a and b, I am saying and a comma and b .You
know what is and a and and b? And a means the address of a and b means address of b right. So,
I am actually passing the addresses of a and b. So, the address of a was say 1000 and this was
maybe 1500 .

Now here is my called function void swap int, now a and b have been declared- int star x comma
int star y. So, what is happening- what is being passed? Here and a is being passed and here and
b is being passed; that means, this address and this address are being passed 1000 and 1500 are
being passed.

Also I know here that what I am getting are the pointers to the variables that had to be swapped it was not int x or int y-let us go back to this once again. So, here you see I am calling xj and xj
plus1, in my bubble sort algorithm. In my bubble sort algorithm I had the array and j was here
and j plus one was here- this was already filled something and I am comparing. So, here is my i.
So, I will work in this zone and I am looking at two elements j and j plus one and I want to swap
them.

So, what I am doing is I am passing on the address of this here. So, suppose this address was
thousand and this address was 1002. So, this is being passed here. So, this is 1000 and this is
1002. Now what is happening here -temp is a local variable, see temp is not a pointer, temp is a
local variable. Suppose here the point was this was 50 and this was 2.

So, temp is getting the content of x right? So, 1000s content thousands content was 50, content of the pointer, content of x. So, the 50 is being copied here and then what is happening content of y is coming to content of x. So, content of y is coming to content of x.

So, this is becoming 2, this is being swapped and is becoming 2 and temp is coming as the
content of y. So, this is becoming 50. So, what is happening all the changes were reflected here
in the main body of the data. So, that is how we could really reflect the change on to the calling
function.

So, stated in another way it would be like this -let us say I have got a data here and here is my
calling function and here is my called function.

Now, there is some variable that is being used by the calling function say a; that means, this a is
somewhere here, this a has been referred here.It is not proper to show it here again. Now the
calling function is using the variable a somewhere here alright. So, when this variable is being
used as a parameter to this called function, instead of sending the variable -say some other
function I call and in that I pass on the address of that variable a.

So, that address whatever this address is -this is 1000,that is being passed on to this called
function. So, the called function on the other hand knows that its input parameter is say called
function is f -is int what I am getting is int star x; that means, what I am accepting as a called
function is nothing but a pointer to an integer variable.

Now so, the pointer to the integer variables -the 1000 comes up and here suppose it does
something with the content. Now here when I take this say star x; that means, x is a pointer x is a
pointer to an integer and when I take star x asterix x; that means, its a content of this and
suppose I do it star x plus 1; that means, the content of this address same address x was 1000 and
the content of that 1000 is being added. So, here it was 50. So, that is being added ,where it is
being added here. So, this is changing to 51.

So, this if you recall we had talked about two things when the functions are called we said that
usually c always calls by value except for the case of arrays, but here is an example where I can
also say this has been called by value of the pointer. So, in this case it is an example - call by
value of the pointer. That means, what I have copied it is only the pointer. Therefore, the change
that is being reflected is being reflected in the main program.

So, in that way it is also a call by reference. So, in that way we can reflect the change of the
function. So, if you ever faced the crisis that well I am writing a function, but I know a function
can only return 1 value, but I have got multiple values to return - this is a nice way in which you
can do it .

So, this is this we have a new concept we have learnt the use of pointers the notion of pointers
and how it can be used in the context of just learning another language. There is a bubble sort .
Once again we revise the bubble sort -let us go to the next one and will come back.
So, the main program (is taking a main function) is reading an array. This array is being read. I is an integer. Now for i 0 to less than 12 there were 12 elements here- print the array , it is calling bubble sort with the array being passed and the size of the area being passed here. Now we go to bubble sort; that means, I go to the earlier slide. So, what I had seen earlier.

So, there we go and call the bubble sort and the bubble sort in turn calls, swapping is done inside
the bubble sort and then we print the ultimate data all right.

So, what will be the time complexity.We have seen the time complexity in terms of the big o
notation at times. So, what is the worst case - let us once again recapitulate think of the algorithm that for something like this -first I had this size n.

So, initially the number of comparisons were 1 then worst case 2; I first compare between these
two, then I compare between these two, then I compare between these two. Now, depending on
the comparison I may or may not exchange all right may not swap, but I have to do n minus one
comparisons. So, first I do n minus one comparisons and if along with that I have done the
swapping. So, the first position is now filled up with the largest element.

Then again I have to start from here compare again twice,thrice.In that way I go on comparing
the second time and by now this number of comparisons is n minus 2. So, the second one will
also be filled up with the heaviest element and in that way I will go on ultimately last time is 1.

So, the overall if I add them the number of comparisons is this and that is of the order of n
square, because it breaks down to n square minus n etc.What is the best case? What will be the
best case? The best case is if you do not have to do any swap it is already sorted, but still you do not know that it is sorted you will have to compare them anyway.

Therefore, the best case will be the same. Can you make the best case with n minus 1
comparisons only? That we can think of later, So all these searching and sorting we were doing
was using arrays.

Now, just a word of caution about some common pitfalls with arrays in C -is that often we can
exceed the array bound without really noting of that. For example, array size has been declared
to be 10; that means, my indices are from 0 to 9 right. So, if I write a for loop like this and I try
to initialise it.

So, it will initialise to 1 0, then 1, then 2, then 3, till it is less than equal to 10. So, the tenth
element is here -that will also be put to 0, but that may be destroying some other memory
location therefore, that check is not there and c does not support array declarations with variable
expressions.

So, quickly if we summarise what we learned here.We are not talking about this in this course,
but what we have learned here is searching- we have seen and we have seen two very efficient
methods of searching. One is the linear search which is simple and the better method is saw a
binary search, but binary search is effective when the array is already sorted.

We have learnt about how to sort an array, we have particularly looked at two sorting
algorithms- one is selection sort, another is the bubble sort and while discussing about bubble
sort we have also looked at a very interesting way of communicating between a function a caller
function and the called function, when I have to communicate or pass on or return more than 1
variable to the calling function. There we are using the pointers.

So, we introduced the concept of pointers which are nothing, but the addresses of the variables.
So, instead of passing on the value I am passing on the address and whatever I am doing I am
doing on the address. So, that is another important thing that we have covered in this lecture.
Next, I think we will go to some other concepts of arrays .

Now, just to mention here we have seen that the complexity of these algorithms are of order of n
square both for selection sort and for bubble sort, but can we have it better? We have got two
very nice sorting algorithms; one is known as the quick-sort another is known as the merge sort
Quick sort and Merge sort, which reduces the complexity of sorting and are very popular
algorithms, but we are not discussing it in this course for those of you interested can learn it later.

Next we will be moving in the next lecture to discuss about how strings can be handled as arrays -that will do in a separate lecture. So, up to this for now and will continue in the next lecture ok.

Today, we will be having a look at how the techniques that we have learnt can be applied
to different Problem Solving and this will continue from this lecture onwards for a few
more lectures. We have learnt quite a few things we have seen the overall structure of the
C language.
We have seen the if then else if l structure the iteration structure, like the loops we also
know how the variables are defined, we have seen arrays how data can be stored in 1
dimensional array and 2 dimensional arrays, we have also seen functions. And the most
important thing about functions is that it enables us to take a complex problem and
divide it into different parts and solve each of the parts separately using functions. A
very important thing about functions is passing of the parameters and how the function
returns of value returns a value to the calling function.
We have also seen that there are two ways in which parameters can be passed from the
calling function to a called function, one is called by value another one is called by
reference in c language in general always call by value is adopted.
However, in call by value we have to copy the value of the data the parameter value the
parameter value to the argument value. However, for the case of arrays whenever I want
to pass a particular array at that point an array can be a 100 500 array or 10 by 10 array if
it be a 10 by 10 array then I will have to copy hundred values. So, that is not advisable
for that we just passed the array name.

And let us quickly have a look that the array name is essentially an address right and
array whenever we pass suppose there is an array or 2 dimensional 10 by 10 array all
right 2 dimensional array like this.

Now, all the elements I am not passing. So, it is a essentially it happened to be a 4 by 4
area. So, that is all the 16 elements I will not be passing. So, here is my called function
the function called function and on this side is the calling function, the calling function

and the array name is say a. So, the calling function refers to suppose let this function be
called f.
So, in from the body of the calling function whenever I am calling f, I am passing the
array say if it be an integer array into A. And here I just passed the array A and here in
this function body we have got say int A and just saying that the size of the or if it may
not be a it can be x also, int x something and the size of that and here int A and maybe n.
So, here I am actually passing the name of the array and the name of the array is nothing,
but the beginning of the address of the first element of the array. So, here I am actually
copying the address.
So, it is a call by reference in the case of an array. And in the last lecture we have also
seen that we can also use pointers to sort of establish call by reference. Another major
thing that you have to keep in mind is that suppose this array is 1 2 3 4 5 6 7 8 9 10 11 12
13 14 15 16. Now, these are organized in C in a row major form. So, it is stored in the
memory like 1. So, the rows first 2 3 4 then 5 6 like that. So, when I refer to the array A I
actually pass on the address of the first location of the array ok. So, A 0 0 in the case of
A 2 dimensional array points to this element and that is this element that is how we pass
on arrays.
So, for functions and we have also seen some applications of all these techniques that we
have learnt in particular we have seen how we can carry out search.

And we have seen two search techniques one is linear search another is binary search.
Now in linear search the complexity the time is proportional to the number of elements
whereas, in binary search it is reduced it is faster it is log of the number of elements to
the base 2. And search is a very fundamental problem solving technique in technique,
because suppose you have got the names of students in the class all right.
Here are the names Atul, Shyam, Gargi in that way the names are there and each of them
have got a roll number 1 2 3 4. Now you want to find out how many Shyams are there in
the class. So, you have to search this array and find out where Shyam is ok, maybe here
and there is another Shyam here. So, that is searching and counting both the things, but
you cannot avoid searching this array all right. It may be that along with that there is an
array of marks obtained by roll number 1 roll number 2 etcetera.
So, maybe this is 50 this is 70 this is 30 all right. Now here tell me I want to say now
they are in 2 arrays this is 1 array called name and this is another array called marks of
the corresponding students. Now I want to know how much what is the marks that Gargi
has obtained. How do you go about it what would be the first step in solving this
problem what is the marks that Gargi has opted, in order to do that I have to first I do not
know what is Gargi is roll number.
If I had known what is Gargis roll number suppose Gargis roll number is 3, then I
could have gone in the marks array and I could have taken marks roll number what if I
knew the roll number, roll number minus 1 that marks I could have taken as a result all
right, but I do not know the roll number if I had known the rule number 3 then I would
have gone to the second element. So, it is marks 2 would have been would have given
me the roll number, but suppose I do not know the roll number then what should I do?
First I will have to search this area and what would be my key what is my key will be the
screen Gargi, because I want to know the marks obtained by Gargi and what should I do
with this key I should carry out a search, it can be a linear search or it can be a binary
search let us for the time being assume that it is a linear search. So, we will be searching
and I will be finding Gargi here I am assuming for simplicity that there is only one Gargi
in the class.
So, I will take this and I find what will the search, if you recall what will the search
algorithm return me the search algorithm will return me the index of the position where

Gargi is located. And that position will be actually it will automatically come since this
positions will be marked as 0 1 2 I will get this 2 returned. So, I will get. So, I get the key
I search the array name this is a character array A care name size whatever size is say n
and the key.
And this search will return me the value position 2 pos equal to 2, then I will simply take
the value of marks I go to the array marks pos, which will be my result right. So, you see
we needed the searching. Now, while I was talking of searching this array I said that the
searching I am assuming this searching to be a linear search.
Would it be possible to sort this array using binary search, if you just think it over would
it be possible to search, it using binary search what does binary search require binary
search requires that the array be sorted right array be sorted.

So, an array like this, Atul, Amal, Gargi and Joy this is an array of 4 elements can I sort
it the type of sort if, I want to sort it I will have to organize it in increasing or decreasing
order let us assume that I am trying to do it in an increasing order. Now, this sort will be
this character array can be sorted in an way which is called the lexicographic sort.
That means I go I sort the character array according to the alphabets or the words as they
written; obviously, A comes first. So, therefore, A character A is smaller than character
B all right.

So, here between these two elements both of them has got A, but similarly t is greater
than m. So, in this sorting I will first check between these say a they are same think of
bubble sort I am trying to compare them in normally what we did we found that say array
x xj is less than xj plus 1 and then we did something.
If it was if it is the case no issue if it was the other way round I wanted to do a swap, but
in this case it will not be. So, simple I can take a string and compare these two strings as
to which one is whether they are same or not or whichever is greater, but another way
you can write a small function to compare I leave it to you I leave it to you that you now
know sorting techniques.
So, you should try to write a function that will sort a string of characters all right. So, e
and e are same, if they are same the function what will do it will now look at t and m
now m is smaller than t therefore, Amal is smaller than Atul.
So, Amal will come here and Atul will come here now between Atul and Gargi you can
see a is greater than smaller than G. So, Gargi is in a proper space please. Now if say for
example, I do not have Joy here I am having another name Gautam here. Now when I am
comparing between Gargi and Gautam G and G are the same.
So, they are equal no change next a and a are also same no issue. So, there is no change,
but r r is smaller than u, because r appears earlier than u, but in terms of our computer
code technology the Ascii code of r is less than the ascii code of you.
So, in both the ways it is meaningful. So, r is less than you therefore, Gargi is smaller
than Gautam. So, in that way I can carry out with another small function compare string
is greater say is you can write a function is greater 2 strings ok, care S 1 comma care S 2
2 strings will be passed on this function and this function will find out, which character if
S 1 is greater than is 2, it will just return if S 1 is greater than is 2 it will return A 1 if S 1
is greater than S 2 try to write such a function ok. Now, that is that I am giving you as a
home assignment all of you should try to do that and with a little effort I am sure you
will be able to do that.
So, I could have just as I had done in the earlier one, here in this thing I said that I will be
doing linear search, I could have done binary search also provided I had provided, I had
sorted them provided I had sorted them in a proper way and then with the sorted array I

could have done binary search. Now, will be also doing some problem solving within
this course will be doing some problem solving in the field of numbers or equations
mathematical problem solving, but before that in order to do this today let us have a
relook at the strings, we had looked at strings earlier as an array of characters.

So, let us have a relook at the whole thing today how can I represent an array of strings
like the one that, I was showing here and array of strings all these names Atul, Amal,
Gargi, and Gautam all these are nothing, but this is a string this is a string all these are
different strings. So, how can I represent them let us have a look at that.

Say I can I have got 3 strings one is spike and there is tom and there is jerry. Now these 3
strings I have to store and I am saying that each string can be at best 10 characters at
most 10 characters. And I am looking at 3 such names. So, it is an array 3 rows and each
row having 10 characters right. So, the definite that definition would be I named them as
char I could have done character array and it is 3 rows and 10 columns now I can
initialize that as spike as character S character p.
So, s comes here, p comes here, i comes here, k comes here, e comes here and that is the
end. So, it is backslash 0 I also put that and so, 1 2 3 4 5 6 4 places are still vacant 4
places are still vacant. Similarly for the next 1 is tom so, t o m back slash 0 and the rest
are rest 6 are all free all right, but my string has ended here. So, 1 way I is that I can
represent them in this way where, I specifically talk about the characters in the array and
terminate them with backslash 0. The other way I can do it is simply I initialize them.

As 3 10 the same array with 3 strings spike comma, tom comma, jerry. Now internally
even if I do that it is essentially becoming the same thing internally it is being stored in
the same way with 3 rows and each row having this characters s p i k e backslash 0 and
so and so forth, there can be more t o m back slash 0 and so and so forth here.
Also j e r r y and so, on I am sorry backslash 0 and so and so forth it is being stored. So,
both of them are equivalent I can do it in either of these ways alright. So, a string can be
represented in any of these ways.

So, we already know this again the name of the array is appointed to the 0th element of
the array. So, if I have this array s p i k e backslash 0, t o m backslash 0, j e r r y
backslash 0 when I am calling that charr the name itself is pointing to the first element of
this array. So, ch arr 0 0 it is pointing to that.
So, this and ch arr 0 0 are the same they mean the same thing ok. So, this you just like an
array this is also true here.

Therefore, if ch_arr points to the address 1000 ch_arr plus 1 will point to address 1010,
why the reason is again I have got this array.

And ch_arr is pointing ch-ar arr is pointing to the 0 element of the first row, if this is
1000. Then 1002, 1009 this array this location is 1009, because the size is 10 size is 10.
So, although s p i k e backslash 0 etcetera is there, then when I go to the next one ch
underscore arr plus 1; that means, whatever this pointer arrays the entire thing is taken 0
to 10. So, I am taking here it is taking all these 10 elements as 1 array it will be pointing
to the next one; that means, it will be 1010 ok.
Again if I make it ch-arr plus 2 it will come to this 1 all right that is how the pointer
works, but how can I get this character this will be ch-arr 0 1 that is pointing to this
element ok. Now this thing must be clearly understood. So, ch-arr points 0 th string or
the 0 th 1 dimensional array ch-arr 1 points to the first string or the first 1 dimensional
array I mean number 1 0 at first ch-arr 2 points the second 1 dimensional array.
So, each of them are 1 dimensional arrays and ch ar is pointing to each of these 1
dimensional arrays ch-arr is pointing to 1 one dimensional array. And as I increment the
pointer this pointer is going on increasing alright in general ch-arr I points to the I th
string of the yet 1 dimensional array clear.

The following program let us look at the program and the following program
demonstrates how to print an array of strings? Please take 1 minute to read this array a
program yourself and try to understand. It you can see here that I am starting with the
main function and although it is written in a 1 in a very cryptic way. So, my program
starts from this point and ends at this point, i is an integer ch-arr is again an array of 3
strings and each can be of maximum length 10. So, spike tom and jerry are there.
So, I can print I just print first way next line I go to next line and to next line. So, I just
put first way and then what do I do. So, I will print first way and then 2 lines have been
given blank, then for i 0 2 less than 3 i plus plus printf string, I am printing the string. So,
what will be printed string equals a placeholder for the string and then there will be some
tab 1 space and then.

So, the first will be string here some space and then tab this is tab.
So, I give some space and write address and then sorry string equal to string equal to
address equal to and there should be some space for the address and that format is
unsigned integer. So, it will become longer alright.
Because unsigned and signed integer a whenever I am putting suppose I have got 16 bits
for representing an integer. If it be assigned if I distinguish between plus 5 and minus 5
and keep 1 bit kept for the plus or minus then for the 16 bit I will be actually having 15
bits for this size, but if I make it unsigned then I can have all these 16 bits. So, I can
represent more numbers all right more numbers.
So, that apart so, string and address and then what am I printing here care I care plus i;
that means, 0 care 0 the first string and then I am again putting the care this, now what is
the difference between this care this and this is being printed in percentage arrays; that
means, the string will be printed and here in an unsigned integer what I am printing here
is the address of that string.
So, this string spike was here when I print this just the name of the array; that means, I
am in this format if I do I am printing the address of it therefore, the output will be
somehow like this ok. So, this is something to be understood very clearly that this array

when I am actually looking at this I am taking the content of the array otherwise I am
taking the array itself.

So, here is a program.

This program asks the user to enter a username if the username entered is one of the
names in the master list then the user is allowed to calculate the factorial of a number
otherwise an error message is displayed.

So, we have got sorry a master list of names now if you are a valid user your name is
there in the list. So, first what is doing it is including stdio dot h it is including string dot
h; that means, some string functions are also included I am defining the factorial
prototype the factorial function has been written later. Suppose this part this part is later
than the main function ok.
Now, the main is here and what is the main doing it has got some integer I and found is 0
initially the name is not found here and some n number for which I have to compute the
factorial, master list 5 by 20; that means, each of these each of these can be 20 character
long and there are 5 search. And I put the valid names as admin tom, bob, tim, and jim.
Now I am asking a name is so, I am and I am asking from the user enter user name now
the user gives the name. So, get s here you are getting a new function being introduced
here that is get s what is get s get care get ch, you know and here the get s means get the
string. So, in 1 short it is getting the string as the name.
So, name I am getting from the user some name say it is jim suppose the user enters jim.
Now for I equals to 0 to 5 why 5 there are all the 5 names are here if string compare
name and master list I, if this character this string and this string matches then found is 1,
otherwise I am again going in the fall loop.
So, at every stage of the loop I am trying to compare this name with this string here there
is no match. So, I come here no match no match in that way I come and find jim. So,
here ultimately I will get found and then I will break. Now when I come out suppose it
was not jim, it was say jimmy alright then I do not get a match here. So, I can come out
with found equal to 0 or found equal to 1, he found equal to 1 then welcome then
welcome exclamation and then the name it is printing welcome jim.
And asking please enter the number is entering the number for the factorial and then here
you see in this printf I have called the factorial, that factorial of the number is this n is
this so, I call factorial and this part you know. Now that this n and this n and may not be
the same I mean they are two different locations, but they same it could have been x also
in that case internally had it had to be x here.
So, this is being passed over here and the factorial is being computed all right. Once the
factorial is computed, now how the factorial is computed I will be discussing that later,

because here there is some trick forget about that trick now I will be discussing that later
that is recursion, which you have not yet discussed and after this I am coming back here
and I am printing.
So, the purpose of this program was to show how we can handle strings. So, these are
very common very common thing I mean you try to login in a machine right. And you
type in your login name and your password, if they do not match the system says login
failure now how does it do it internally.
Internally it has got a list of just like this it has got a list of all the users and it takes your
username and checks it with all these. That is a problem that is being solved a sub
problem that is being solved in the operating system and that is the basic principle is
depicted in this program alright we will continue with other problem solving approaches
in the future lectures.

Today, we will be looking at some real engineering applications of programming. We will see
how, whatever we have learnt till now can be applied to solve some interesting problems like
solving equations. One very common thing that we need in any engineering or science is to
represent data. One way of representing data is by in the form of a table right.

So, I can always represent some data as a table where say on one column it can be height or
depth and maybe as we go down, we go through some point and at different depths, we put
some sensor and get the temperature.

So, that I can represent in the form of whatever is a depth- 50 meters, some temperature, 100
meters, some temperature etcetera. So, if we need to represent any data in this form we know
how to do it? We know that as it looks here -we can immediately say we will be representing it
as an array. Whether I will be representing them using as 1 array 1 2 dimensional array or two
different array - will depend on the format of the data the type of the data.

For example if the depth is integer and the temperature is real, then up to the knowledge that we
have acquired till now will be representing them in the form of 2 arrays, 1 is an integer array
another is a separate floating point array . So, that is oneway of representing data as we have
done also in the case of students roll number and marks earlier. Another very interesting and
important thing is representing graphs.

For example, I want to represent a graph say this is some pressure and this is depth and as this
graph shows that it is not increasing in a uniform way with depth. There could be some graph,
which would be just linear. We call it linear, where along with depth this increases in a linear
fashion,here it is non-linear .

So, the question is how do we represent this sort of graph? Now you know that in this graph I
can also state that this is the X axis and my independent variable is x and the dependent variable
is y, then this graph essentially represents a function, which is y, a function of x. Now depending
on the nature of variation of the dependent variable with the independent variable, the nature of
the function will vary. This one will be a linear function right.

For example it can be y equals to some k x. This one is more complex I could have had a
quadratic function also this is a linear function. Now the question that we would like to first

address is that it is so very nice to draw a picture on a piece of paper; however, a computer will
not be able to just interpret this picture as we do then in that case how do we represent this graph in a computer. So, let us do it again.

So, I have got a graph let us say a linear graph and I can say that for different values of x what is the corresponding value of y? Now this is a linear one. If x and y are the same type I can also
represent them in the form of a table; that means, a 2 dimensional array, where one side, one
dimension is the variation of x on one column we have got the x and the corresponding y all
right.

What will be the number of rows? The number of data points of x that we take will be the
number of rows. How many?- n and this one is fixed to be 2. I can suppose that this is 5.0 and
this is 25. So, I have 5 here I have 25 here - this array is of type float now here it is ten. So, it is
50, it may be 15.

So, this one will be 30, because I am talking of a linear curve it need not be linear all the time.

So, I can also have a curve like this, say something like this and here again I have got the y and
here I have got the x. So, with a particular value of x say 5, maybe this 1 is initially. Let us say it
has risen a little sharp so, maybe it is 7 and if I go here. Now, please note that we usually take the
samples at equal distances. So, I take it as 10, but here it will not be doubling. it is becoming a
little more than that. So, 7 ,it may be 16. I go here now, you see the slope of this curve has
reduced right the gradient has reduced.

So, at 15 it will not increase that much, it will be 18, because it is still flattening out and here
there is a sharp change etcetera . So, this one also I can represent in the form of a table like say I have a 2 di