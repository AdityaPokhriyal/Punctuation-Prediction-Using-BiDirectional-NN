Welcome to the introductory programming course on NPTEL MOOCs. The goal of this is to learn how to code basic programs in the C programming language. Basically the aim of this course is to teach you how to solve problems using a computer. And by the end of this course, we will hope that you can write medium-sized programs – maybe running to a couple of 100 lines of code comfortably in the C programming language. Programming nowadays is considered a basic skill similar to mathematics that is needed across all disciplines like engineering, in the sciences, and nowadays even in the arts. So, little bit of programming skill is an enhancement to any other skillset that you might already you have. This course we will start from the ground up; we do not assume any prior experience in programming whether in C or in any other language. So, the focus will be to start from the basics; and to use C as a medium of program. A couple of words about the process of programming; it involves two basic steps. One is to define the problem; often you get real-world problems, which are not precise enough to write a program for. So, the first step would be to define and model the problem. And this is a very important step in large scale software development; however we will not focus on this as part of this course. During this course, you will not write large software system like the Indian railways reservation system; those are extremely complex problems involving multiple programmers. In this course, we will assume that the problem is well-defined and already provided to you. So, they will be precise and they will be fairly short and simple. So, this is the first step of programming, which is definition of the problem, which you can assume will be given. Now, comes the second step, which is to obtain logical solution to your problem. And what do we mean by a logical solution? A logical solution is a finite sequence of steps; do this first, do this next; if a certain condition is true do this; otherwise, do something else. This is called an algorithm. So, an algorithm is basically a finite step-by-step procedure to solve a problem. One way to visualize an algorithm is using a flowchart. If you are new to programming, it is recommended that, you draw flowcharts to define the solution to your problem. Experienced programmers very rarely draw flowcharts, but that is not a reason for beginning programmers to avoid flowcharts. So, defining a problem is there; then the process of coming up with an algorithm. This is a very important step in the programming process. And followed by this, there is a third step, which is to implement the algorithm in a usual programming language. So, is the concept of an algorithm a new concept? I would claim that, it is not. An algorithm is a very familiar concept; the most important example that you can think of are cooking recipes. Now, cooking recipes are written in a way that, they are almost algorithms. They are not quite precise enough for a computer, but they come quite close. For example, let us take an unnamed dish – a desert and let us look at how things specified in a recipe. And we will see that, this analogy is quite deep. There is a very strong similarity in the way that recipe is written and a program is written. So, usually, they will have a list of ingredients upfront. For example, you have ice cream, crushed cereal and so on. And then once you have all the ingredients in place, then you have instructions to say how do you start and how do you end up with the dish. Now, those instructions will be fairly precise; of course, you assume that, the person preparing the dish is a fairly-experienced cook, so that certain instructions need not be given in very precise detail. For example, you can say do this, heat oil and so on. And it is assumed that, a person knows how to heat oil. Even so you will see that, certain recipes are fairly vague and other recipes are fairly detailed. And in any recipe, you can see certain things, which are vague and will cause confusion to most people. For example, here is a term, which says try to make each scoop about as large as your fist. Now, that of course, is a vague term, because my fist could be a different size than yours. And then you will see that, in a formation that makes it easy do dip in order. So, this is fairly vague and it is not very helpful to a cook, who is making this for the first time. So, think of algorithms as similar to recipes, but mentioned in a more precise manner.  Another way you can be familiar with algorithms is when you have the – when you buy a make it yourself kit for a furniture or something like that; and you will be provided with a step-by-step instructions on how to assemble the kit. Often when you buy disassembled table or something like that, it will come with a sheet telling you how to start with the components and build a table. Those are also similar to an algorithm. So, let us look at a flowchart to depict a mathematical algorithm and we will use this flowchart to explain certain conventions about how algorithms can be described. So, every flowchart will have a start and an end; and it will have a finite number of boxes. So, this is the finite number of instructions that I was talking about. There are certain conventions in drawing flowcharts; the start and the end are often described in circles. Then there are ordinary boxes and then there are diamonds. We will shortly describe what they mean. So, suppose you want to write an algorithm for adding the first n numbers; all of you know how to do it. The point is how do you describe this step-bystep to somebody who does not know it already.  So, first you have to take what is the upper limit N and then you have to sum them up. So, one way to sum them up is start with an initial sum of 0 and then add numbers one by one. So, increment a counter from 1 all the way up to n. So, you start with I equal to 1 and then add the I-th number to the sum; and then increment I; if I is already N, then you are done; if I is not N, then you go back and do the sum all over again until you hit an I. When you reach I equal to N, you come out the program; print the sum; and end the program. So, this is a very simple flowchart. So, initially, if N is less than 1, you have nothing to do; if N is greater than 1, you start a counter from I equal to 1 to n and add the numbers one by one until you hit the N-th number. If you wanted to compute a slightly different problem, which is let us say the factorial of N, which is just a product of the first N numbers, the flowchart will look fairly similar; the only difference is that instead of adding numbers, you will multiply them. So, this flowchart is similar to the previous flowchart; you will first input in N, and then increment N until you hit N equal to M. If so you will finally, print the factorial; otherwise, you go back to the loop. So, here are the conventions used. The start symbol is often as a circle or an oval; the input symbol and the output symbol are often represented as parallelograms; and the normal operation boxes are represented as rectangles; and the test box to see whether you have hit a limit to test some condition in general, they are represented as diamonds. In this session, we will write another algorithm to solve a mathematical problem. If you do not know this algorithm already, that is fine; it is more for the purpose of demonstrating, if you know a solution, how do you come up with the algorithm to tell a computer how to solve it. The algorithm is for finding the greatest common divisor or the highest common factor, this is known under two names of two positive integers: m and n. So, this is an algorithm you probably know. How do you solve this? Let us first try a naive solution. And before writing an algorithm, let us see what do I mean by the simple solution of GCD. So, you are asked to find the greatest common divisor of m and n; take the smaller number n; and now you start looking for each number k between 1 and n, remember that n is the smaller number; in descending order, do the following. What you do is if k divides m and n, then k is the greatest common divisor of m and n.  And this is obvious by the definition of greatest common divisor; if k divides m and n, then it is obviously a divisor of m and n. Also we are coming in descending order; we start from n and go down to n. So, the first divisor that you hit when you go down is going to be the greatest common divisor of m and n. So, this algorithm obviously works. It will compute the GCD correctly, but it is very slow. And think about a very large numbers: m and n; and you will see that, it may go n steps before reaching the correct GCDs. So, compute the GCD of two very large numbers, which are relatively prime to each other; that means that the GCD of m and n are 1. Now, if you pick such a pair, this algorithm will compute the GCD correctly, but it will take n steps, because you have to go down all the way from n to 1 before you will hit the GCD. Can we do better? There is a faster way and it is a very old algorithm. The algorithm is due to Euclid. We will see a slightly modified version of that algorithm. So, before we go into Euclid’s algorithm for GCD, we will describe what it does and give you a slight intuition of why it works. So, consider the GCD of 8 and 6. Now, you can consider two rods: one of length 8, and another of length 6. Now, obviously, if a number divides 6 and 8, then I should be able to make a stick of that length, so that I can measure 6 exactly with that shorter rod; and I can measure 8 exactly with that shorter rod. This is the meaning of a common divisor, and we have to find the greatest common divisor.  So, first, what we will do is we will measure the longer rod using the shorter rod. Now, it may not measure the longer rod exactly. For example, in this case, 6 does not measure 8 exactly; there will be a small piece of length 2 left over. So, take that reminder. And now, repeat the process; now, 2 has become the shorter rod and 6 has become the longer rod. Now, see if 2 measures 6 exactly; it does. So, you are done. And then you can say that, 2 is the GCD of 8 and 6. The reason why this works is – by the nature of this algorithm, it is clear that 2 divides 6, because that is why we stop the algorithm. And also, we know that, 8 is basically 6 plus 2. So, it is obviously, a multiple of 2. So, it is a common divisor. And with a slightly more elaborate argument, we can argue that, it is the greatest common divisor. So, this is an algorithm, which is essentially due to Euclid. So, it was known for at least 2000 years. Let us pick a slightly more elaborate example. Let us say we want to find the GCD of 102 and 21. The process of taking remainder is what is known as the modulo operator in mathematics. So, 102 modulo 21 is the remainder of integer division of 102 by 21. So, the remainder of when you divide 102 by 21 is 18. So, that is the shorter rod for the next stage. Now, 21 mod 18 is 3. And that becomes the rod for the next stage; the shorter rod for the next stage. And 18 mod 3 is 0; that is when you stop the algorithm. So, when the modulo operator gives you 0 result; that means that, the shorter number exactly divides the larger number; that means that, the shorter number is a divisor of the larger number and you stop the algorithm. Now, you say that, GCD of 102 and 21 is 3. So, this is a slight modification of the classical Euclid’s method for GCD. And so, it is based on the following simple fact, which we have described. And you can prove this mathematically as well. So, suppose you take two positive numbers: a and b; where, a is the larger number; then GCD of a and b is the same as GCD of b and the remainder when you divide a by b. So, it is written by the equation GCD(a, b) is GCD(b, a % b). The modulo operator is represented as the percentage sign, because this is the convention that we will use in C. And this equation can be seen by our previous slide; a was the bigger rod; b was the shorter rod. This was the first stage. The second stage was when b is the shorter rod. And the shorter rod for the next stage is modulo – is given by the modulo operator. To prove this, you can start by considering the division of a by b and writing a as bq + r. But, we will not go into the proof. From elementary properties of natural numbers, it is possible to prove that, Euclid’s method correctly computes the GCD. Right now, we will move into how do we write the GCD algorithm in the form of an input. So, here is a slightly abbreviated picture. I have skipped the start state; but the start state is there. Let us focus on what happens during the algorithm. You have two numbers: a and b. The first thing to ensure is that, a is the larger number. The reason we do that is that, if a is the larger number, then the modulo operator is properly defined. So, if a is the larger number, then we are fine; we can go into the GCD algorithm. If a is not the larger number, you merely swap a and b, so that whatever is the larger number, you called it a. So, exchange a and b; means that you say that, the value of a is stored in a temporary variable; then the value of b is stored in a; and then the value of b is stored in t with the value of t stored in b. So, here is a way to exchange the values of a and b. So, ensure at first that, a is the larger number. Once you do that, you get into the code for the proper  utility in GCD. First you test whether b is 0. If b is 0, then there is nothing to do; a is the GCD of a and b; GCD(4, 0) is 4; GCD(4, 0) is 8, and so on. So, if the smaller number is 0, then there is nothing do in the algorithm; the algorithm is over; and you say that, print a. If b is not 0, then we do the Euclidean equation. You take a % b; store it in a variable g; then assign the value of b to a and assign the value of g to b. So, this corresponds to the operation of taking b and a % b as the next step. After you do that, you again test the condition whether b has now become 0. If it is 0, then we are done and a is the GCD; otherwise, we do another round of taking a % b and setting a = b and b = g. So, a, b and g are what are known as variables. And variables are used in programming to store exactly one value at a time. So, at any particular time, it will have one value; then after the execution of another instruction, it will have a new value and so on. Now, for the purposes of describing an algorithm, imagine that, the variable is a box; and it is a name of a box; and the value is stored inside the box. For example, a, b and g are the variables that we have used in the program. And they are the names for these integer boxes. So, if we are computing, let us say the GCD of 5 and 3, then you might start with a equal to 5 and b equal to 3. The second operation that we have used in the code is the assignment operation. So, this is what an example of the assignment operator. And when we do an assignment, what we mean is that, you take the left variable, which is g in this case and assign it the value of what is the expression on the right-hand side, which is a % b . So, assignment a = b replaces whatever is stored in a by what is stored in b. So, take the right-hand side; take the value of that; and put it into the variable that the left-hand side represents. For example, if a was 5 and b is 3; after a = b, you would take the value of b and put it in a. So, a will now become 3 and b will remain 3. Another small thing that we have used in the code is sequential assignment. So, if you write a bunch of statements one after the other, let us say separated by semicolons; then this means that, the instructions are to be executed one after the other in sequence. So, first, you do g equal to a % b; then you do a = b; and after that you do b = g. So, initially, let us say that a is 10 and b is 6; g is undefined. After you run the statement g equal to a % b, you take 10 modulo 6; you will have 4.And then a = b; the value of b will be stored in a. So, a become 6. And then b = g; the value of g will be stored in b. So, b will become 4. Now, let us just dry run the program or the algorithm and see how it computes the GCD of two numbers. So, I will denote the currently executing statement with an icon and I will call this the program counter. So, this is at any point, it is the next step to be executed. Initially, it is at the beginning of the code; where, you take the input. And we will have three variables, which will represent the current state of a program. So, suppose you want to compute the GCD of 8 and 6. So, you have a equal to 8; b equal to 6. You know that a is greater than b. So, you proceed. Now, you test whether b is 0. So, since b is non zero, you go into the main body of the loop. So, you do g equal to a % b; a = b; b = g, this step once. So, you will end up with a is now 6; b is 2; and g is 2. You again comeback to the discussion and test whether b is 0 or not; b is not 0. So, you go back into the body of the loop again. So, you have g to be a % b. So, 6 modulo 2 should be 0. And then you do a = b and b = g. You will have a equal to 2; b equal to 0; and g equal to 0. At this point, b is now 0. So, you say that a is actually the GCD of three numbers – of the numbers 8 and 6. So, you can ensure that, it computes the GCD correctly.  Once we are understood what algorithms are, we will start writing a few simple programs in the C programming language. Before we begin, we will give a brief introduction to the process of programming. When you are programming, you follow typically, what is known as the programming cycle and this contains three parts. One is the process where you write the program or edit the program, and after you are done editing the program, you save it and then you compile your program. If your compilation succeeds, you are ready to run the program. If your compilation fails, then you return to the editing step and correct the errors and compile again. Once compilation process succeeds, then you can run the program and check whether the output is correct. If the output is correct, you are done; if not you go back to the edit process. So, this is why it is known us the edit, compile, run cycle. So, you edit the program first, then compile it. If there are compilation errors you go back and edit it again, otherwise you run the program. When you run the program, if the logic is correct, then you are done. If your logic is incorrect, then you go back and make changes to the program, compile it and run it again. So, this is the process, that we have to follow in the, when we program. We look at each of the steps one by one. In editing, it is typically done in what is known as in editor. Now, editor is a program that lets you create a text file, make changes to the text file and update the text file, later save it. So, in order to create a program, pick up particular editor of your choice. If you are on Linux, I would recommend a simple editor like G Edit. If you are on windows, there is free editor called Notepadd + +. Be careful that this is not the usual notepad that comes along with the system. Write your code in, in editor of your choice and save it into a file. Let us call it Sample.c. Once your code is saved, you have to compile a program. Now, why do we have to compile a program? Why is this step necessary? The computed does not understand C per say, it cannot execute a C program or the individual statements in a C, in C language correctly. For example, let us say that in C you can write g = a % b. The percentage operation stands for modulo. So, this statement says that you take a % b and assign it to the variable g. Now, the microprocessor, the processor in the computer cannot execute this statement because it does not understand this C programming language. So, it translates it into an equivalent piece of code consisting of even more basic statements. For example, a, this is just for the purpose of illustration and it is not important that you understand exactly what is going on, but in a statement like g = a % b, can be translated into bunch of statements saying load data from particular memory location into particular register, load the second piece of data from another memory location to the second register, divide the contents of these two registers, store the reminder in a third register and then finally, take the result and store it into a third memory location. So, the simple statement that we wrote, g = a % b or g = a % b, becomes a bunch of basic statements, that the microprocessor can understand and then it execute these statements.  So, why not program in the microprocessor language or in assembly language? Writing programs in machine language is very tedious. One line in a higher programming language like C translates into multiple lines of machine language. So, writing machine language code is very long and it is very tedious and is particularly prone to errors. Also, they are not portable. If you write machine code for a particular processor, let us say, you are writing the code for an Intel processor and you translate it to an AMD machine, it might not work. Whereas, if you take your C code and compile it in another machine, it will run on the machine. So, compilers work as a bridge. What they do is, take a high level C programming language and translate it into the equivalent machine code. So, think of them as a translator. So, you, the input is a C program and then you give it to a compiler. The output of the compiler will be the equivalent machine program for whichever machine you want to run it on. So, compiler is a translator, which translates from C to machine code. How do you compile? We have just seen why we bother with compilation and on UNIX system or Linux systems, you can compile the program using the gcc compiler. So, gcc stands for the gnu c compiler. So, for example, if you have edited and saved your file as a Sample.c, you can just type on the comment prompt on the terminal gcc Sample.c. If your code does not have any errors, then the system will silently say, that the compilation is done and it will show you the prompt. If there are errors, the system will list the errors and so, you can go back to the editor, edit you code to correct errors and come back and compile again. As long as there are compilation errors, there will be no executable file created. So, the executable file is the code, is the file that you can finally run. And if there are compilation errors, the compiler will not produce executable code.  So, name your file as whatever you want, let us call it, yourfilename.c and then gcc yourfilename.c. It will produce the executable file. If you are on Linux, the executable file that it creates is something called a.out. If there are no errors and look at your directory, there will be a new file called a.out in your directory and we will explain the directory structures in another session, ok. Let us look at a very simple C program. Open your editor depending on which system you are in. So, let us write a very simple program. It is, it is very short. What it has is, are three lines of code and some punctuation. This is known as the C syntax. Let us examine this code. What this code does is, it prints a particular massage, which is, welcome to C.  And it has various components, you type it into an editor as it is, make no punctuation mistakes, syntax errors. Now, if you compile the program and you have typed the program correctly, then a new file called a.out will be created. So, if you type, gcc Sample.c and if there are no errors, it will just say nothing. If there are, if it says something, then there is a compilation error. Compilation creates an executable a.out and now you can run the program by typing, and this is important, ./a.out. So, this syntax is important, what you type is, ./a.out and then when you run the program it will say, welcome dot, Welcome to C, because that is what the program is supposed to do… Let us look at the program little more carefully. What are its components? It had three lines, the first line said # include <stdio.h>. So, it has multiple components. One is the first symbol, which is, has the first symbol, which is the hash. Please do not forget to include that. And actually, there is no space between the hash and the first i, so there is no space here. So, # include <stdio.h>. This line is supposed to tell C that please include the standard input-output library. The standard input-output library is what has the print routines, which will print output messages on to the terminal. So, if you want to have any input output component of your program, then you should include <stdio.h>. Include this line routinely in your, in the first line of your C file because in the course of this class, we will often need scanf and printf statements. So, we will often need input statement and output statements. So, include this by default. Now, if you look at the second line, we will have a function called main. And again, note the parenthesis here that is also part of the syntax. So, main is supposed to be a function. All C programs start by executing the main function and it starts from first statements of the main function. Now, what dose the main function have? It has a single line, which says printf Welcome to C. So, printf is the function called to output from a C program. So, to print a particular massage you enclose it in double quotes. So, whatever is enclosed in the double codes, will be printed. So, to repeat again, please note the extra punctuation symbols, which tell you, that these are valid C statements. So, all the underline statements are, all the underline symbols are important. So, in the line printf Welcome to C, this is what is known as a statement in C and statements in C end in a semicolon. So, this semicolon is also important because it tells you, that this is where the statements ends, what typical errors do we have when we code in C. Let us systematically enumerate a few common errors that could happen in even a simple program like what we have seen. For example, you could forget to include <stdio.h>. If you do not include the standard input library, then the compiler will give you an error message. You may forget to include the main function, then also you will get some error message. You could forget to include the semicolon in the statement, you could forget to include the braces, the curly braces in main or forget to close the double quote, open or close the double quote in the printf statement. So, these are a few errors that you could make even in a simple code like what we have seen. We have only three lines, but they could also have errors. I would advise you to try deliberately making these mistakes in your code, try compiling them and study the error messages. Once you are familiar with error massages, this will help you later in your coding, because when you see the error massages you can guess what errors did you possibly make in your code. So, go back to the code and correct it.  In this session let see another simple program, and try to study what is going on in there. So, here I have slightly more complicated program, then what we just saw. This has two printf statements; once is welcome to, and the second says C programming. So, it is slightly more sophisticated then the code that we have seen. So, to recap the first line # include <stdio.h>, tells the compiler to include the standard output library.  Then we have the main function; the open and close brackets immediately after name show that main is a function, execution always begins at the first line of the main statement. Then the body of the function the logic of the function is enclosed within two curly braces; the first curly brace signals - beginning of the function, and the last curly brace says that the function is over here. This particular name function has two statements; earlier be have just one statement. The each statement as I said before is terminated with a semicolon. So, this is the first semicolon, and this is the second semicolon. The first semicolon says that the statement printf welcome to ends that point, and then followed by the second statement. And the second statement is also terminated by semicolon. Every statement in C is terminated with the semicolon. Curly braces enclose a set of statement, and each statement in a sequence is executed in the exact sequence that we wrote in the code. Now, once we edit this in an editor save the file, now compile, and run the file. So, let us call it sample.c or you may rename it any file you want. And then once the compilation is successful, you can run it using ./a.out, and then it will print welcome to C programming, which was essentially the same messages as we seen before.  Let us try’s what happens when we execute the program. By tracing we mean step by step looking at each statement, and C’s see what happens when the program executes. We have what is known as a program counter, which says here is the currently executing line of program. The program counter stars executing at the first statement of the mean, for is of reference I have given line numbers in the code. Now this is given just for clarity. Now let us just see, what happens when we run the program line by line. So first we execute the first line of the code, after we are done executing the line 4. So, after we are done executing lines 3 and 4, the message welcome to will be printed on the terminal. This will be followed by the next line, so the next lines is C programming. So, after the next line executes, it will print C programming %. I given this in two different colors to highlight that one was printed by the first line, and otherwise printed in second line, otherwise the colors have nosing, no special meaning. The program terminates when the main finishes execution, and this is what is typically known as returning from the function, we will see this terminology later in the course. Now, when you code in addition to the statements which are actually executed, you may also give a few additional remarks; these are what are known as come program comments. For example, the lines a simple C program first print and second print; these are the comments in the code. So, whatever is highlighted in red in the code is what are known as comments. Any text between forward /*, and then later followed by a */. So, any text between successive /* and */ is a comment, and it will be ignored by the compiler. So, as far as the compiler is concerned a code with comments is the same as a code without comments. It does not effect the logic of the code. So, comments are not part of the program; however, it is highly recommend that any program you write, you should comment the code. This is show that other people can understand your code also you yourself looking at the code 4 months later or five months later, it is it may be difficult to understand what you wrote? Much before and comments help you understand the logical of the program.  Now, it is a very good idea to comment your programs, and for lager program it is a must to comment the programs. This is standard industry practice, and even if you participating in large programming project like free software projects, comments are highly encouraged, because it will understand other developers, other programmers to understand your code. So, we will try to follow our own advice most of the programs that we will see in this code, we will comment it, so that it easy to follow the logic of the code. Now, a few notes just as a main is a function printf is also a function. Printf is a library function which means that it is given by the C programming language, and we wanted to tell the compiler to include this library function. The statement which set that is this # include <stdio.h>. So, # include <stdio.h> is the line telling that I want the standard input output library, because that is the library from which I will get the function printf. Now what does printf do? Printf takes two arguments, just like arguments to mathematical function. So, it takes an input argument which in our first case was welcome to. So, this was the printf first printf statement in the program that we just soft. Now, this was enclosed in double codes, right. So, it was enclosed in open double quote, and then ended with a close double quote. A sequence of characters in double quotes it is what is known as a string constant. Now we can call the functions that we define or we can call the functions that the library provide. This is how once you define a function, you can call a function. Now we will see an additional concept, the printf statements that we have seen so far, we will print a message and it will print there. And then the prompt the terminal prompt will come immediately after the print. Now typically what we want to do this will print a message, then say tell the prompt to appear on the next line. So, for this we need what is known as the new line character. All letters digits, gamma, punctuation symbol; these are called characters in the C programming language. There are the total of 256 characters in C, 256 is 2 to the 8. So, for example this small letters a to z, capital letters A to Z, 0 to 9, the at symbol, other punctuation symbols like dot, gamma, exclamation mark, and so on; are all characters in C. Now in addition to this there are certain things call special characters. So, there is a special character call new line, in the C programming language it is denoted as \n. So, there are notice that there are two kinds slashes; /, and \ on your keyboard. And the new line character is denoted as \n. So, even though it is single character, it is denoted by two letters. When used in printf it causes the current output line to end, and then printing will start from the new line. So, it is something which says the current line has enter, now whatever you have to print, print it in the next line. The new line character \n is like any other letter, and can be used multiple times in any particular line. For example, if you have something to printfollowed by \n, followed by C, followed by something to print. Now this will be treated as, so many characters and then a new line followed by C. So, let see a particular example, if you have the old program that we just wrote, but we end each message which a \n. So, we have printf welcome to \n, printf C programming \n. When we compile and execute, we will see something new. So, when we run this $./a.out, it will print welcome to, and then the next thing to print is is a \n which is a new line. So, printing will start from the next line, and then it will print the next message with C programming. So, it will print that followed by new line. So, the prompt will appear on the line after words. So, new line character is something that is use to make your output messages a little more here. So, let us just conclude by saying one more thing about new lines, the new line character \n is like any other character, and you can use it multiple times even within single message. For example, if I do the same program, but let us say I have welcome to \n \n C \n. So, I have repeated occurrences of \n in the same message, what it will do is if will print the message welcome to, then it will print a new line, and then it will print another line, and then it will print C followed by new line. So, when you run program you will have welcome to new line, then the blank line, then C, then another line. So, new lines are just like a any other characters, the difference is that, because it is a special character, it is represented by two letter. So, it is not represented by single letter it is represented by \n. So, they are together one character in C, call the new line character. In this session we will see slightly more sophisticated programs. Recall that in our discussion about flowcharts, we talked about variables, which were conceptually seen as little boxes in which you can hold values. So, let us see how to write simple C programs in which we make use of variables. So, we will illustrate with the help of a sample program. So, we have this following program, which is very simple, read a Celsius temperature and convert it into the equivalent Fahrenheit temperature. This is something that all of you must know. So, the flowchart is very simple, you have an input C, which is the current Celsius that you want to convert. Then you apply the formula F, which is 9C/5 + 32. In this session, we well see how to write simple C programs, which makes use of variables. Recall that in our discussion about flowcharts we talked about variables, which were conceptually seen as little boxes in which you can hold values. So, let us illustrate a simple C program making use of variables with the help of a program. So, we have a small problem, which is convert a Celsius temperature into the equivalent Fahrenheit temperature. This is the formula that all of you must know. So, let us write a C program for it. So, we will draw the simple flowchart for doing the program. You input the temperature in C, in Celsius, convert it into Fahrenheit according to the formula 9C/5 + 32. Once you have done that, the variable F holds the Fahrenheit value, so you output the F. So, here is the simple flowchart that we want to implement. Now, how do we write the equivalent C code. So, we, in the flowchart we have seen, that we have two variables, C and F. These are the variables that we would want to implement in the C code. So, let us see how to do it. So, we write the following C program in which now we have two more components, one is the variable declaration, float centigrade and then the second is another variable, float Fahrenheit. So, centigrade corresponds to C in the flowchart and Fahrenheit corresponds to F in the flowchart. So, I write the following code, which is supposed to implement the flowchart on the left. So, let us say, that the input is 50 degree Celsius and then the Fahrenheit, the formula is exactly the same as what we have in the flowchart. We have 9C/5 + 32. Notice here, that these are arithmetic operators. So, the * arithmetic operator stands for multiplication, / stands for division and + stands for addition. So, this is exactly as in the flowchart except, that here in the flowcharts multiplication symbol is being swallowed, but in C you have to specify it using a * operator. So, Fahrenheit equal to 9C/5 + 32 is exactly similar to the analogous line in the flowchart. And finally, for outputting we will use printf statement. So, here is something new in the printf statement. We use what are known us format specifiers, this %f symbols are new and we will describe them shortly. So, let us look at the program in little more detail. So, we have two statements, which are of interest, in the beginning of the code, which are what are known as the definition of the two variables. Recall from are discussion on flowcharts that variables are boxes and each box has a name associated with it. So, you have two concepts associated with variable as far as flowcharts were concerned, one was the box and the second was the name of the box. Now, when we come to C, we will associate a third concept with variable, which is the type of the box. So, if you look at the first statement it says, float centigrade;. Now, this defines a variable centigrades. It creates a box capable of storing a real number and names the box the centigrades. So, the box is of type float. Type float means, that box can hold real number. Similarly, fahrenheit is also a box, which can hold real number. So, you declare that the type of that variable is float. So, these are supposed to be the first two lines of the code. Now, centigrades = 50 that is the line, which assigns the value 50 to the variable centigrades. So, once you execute the code, the box associated with name centigrade will hold the value 50 followed by the line, which computes the value of fahrenheit. So, fahrenheit equal to 9C/5 + 32. It is an, it associates an arithmetic expression. So, it evaluates an arithmetic expression, takes its value and stores it in the box associated with the fahrenheit. And as we just saw before, * is the multiplication operator, / is the division operator and + is the additional operator. Now, the brackets in an arithmetic expression are just like brackets in mathematics. So, they group together a particular thing. Now, let us just trys to the program. Let us see what happens step by step when we run the program. Let us say that we save the file as sample2.c and then run it as ./a.out. So, first we will have two boxes created, one for centigrade and one for fahrenheit. These can store float numbers. Now, what are float numbers? Basically, they are real numbers, which are saved by the microprocessor. Now, the microprocessor can store variable real number only using finite precision. So, this is different from actual real numbers that we encounter in mathematics. So, we have only a limited number of digits after the decimal point, but other than that you can think of them as real numbers. We will see floating point number later in the course in greater detail, right. For now, think of them as the machine representation of a real number. So, once you finish the declaration statements what you have are two boxes one first centigrade one for Fahrenheit and because you declare the types to be float it is under stood that those boxes will hold real number. So, let us execute the first executable assignment here. centigrades = 50 and you will see that the box contains 50.000 something. Even though we specified it as an integer, it will convert it into real number, floating pointing number and store it. Then this is followed by the calculation of the Fahrenheit value, and let us say that you compute 9 times 50 divided by 5 plus 32, it comes out as 122. After that line is executed, the box associated with Fahrenheit will contain 122. Then, the next line says, print, printf the temperature, there is no new line, so the next printf will start from where this printf ended and here you see something new, which is the %f symbol. So, these are what are known as format specifiers. So, the %f symbol say, that take the corresponding variable, which is given centigrades here. Now, print it as a float, print it as a real number. So, notice the difference between first printf and the second printf. The first printf just had a string between “, the second printf has two arguments, one is a string between “ and the string is %f and then the second argument is centigrades. So, it says take value of the centigrade and print it as a floating point number. So, it does that and you see 50.000 in the output. There is no new line. So, the next printf starts from the previous line where the previous printf left off, 50 Celsius equals, it prints that. And now, you have another format specifier. It says printf %f fahrenheit. fahrenheit is 122 and it will print it as floating point number or as real number. So, it will print it as 122.000 printf fahrenheit. So, the finial massage, that well be printed will be the temperature, 50 centigrade, 50 Celsius equals 122 Fahrenheit. So, the new thing we have seen in the program include variable definitions, how they have an associated type and similarly, how do we print these variables. So, we do not want to print the names of the variables, we want to print the, we want to print the content of the variable. We want to print what is stored in the box. For that we use the format specifiers like these %f.  So, let us briefly introduce what are types in C. So, variables are the names of the boxes in which to store values, but these boxes are special. Certain boxes can hold only certain kinds of values, so all boxes are not the same. There are different kinds of boxes. Now, types are basically saying, that a particular box can hold a particular kind of data. So, variables are defined with an associated type and we will use some basic types during the course of this program language tutorial. One of the two common type, two of the common types that we see in this program are int, which stands for an integer and float, which stands for a floating point number, which stands for real number. Notice, that machine can hold only a fix number of bits. So, that does not mean, that the integer can go from minus infinite to infinite. It goes from a certain vary small negative number to a very large positive number. Similarly, floating point also is limited by a particular range. This is because machines cannot represent arbitrary values. The type of integer can store all numbers from M+1,...0,1,...,M. So, there will be some large M, for which, for which defines the upper limits and the lower limits of the particular machine. Now, that limit may depend on which particular machine that you use. On a, on a 32-bit machine it will be 232 , M will be 232. A few final words about variables. Just like in a cooking recipe, you well never mention a step, which involves ingredient without mentioning, that ingredient is needed in the first place. So, you will never say, that use salt and if you look at the list of ingredients, you were, you will see, that there is no salt in the list of ingredients. Such recipes are considered bad. So, when you write a typical recipe, you list out all the ingredients first and then write the steps for the cooking. Similarly, in a program you define whatever variables that you need before those variables are used by any statement in the program. Always define a variable before use. Now, a word about names of variables in the C programming language. The names are consisting of numbers, letters and an underline symbol, an underscore symbol. And there is a particular convention that a variable cannot start with a number. So, the initial letter has to be a letter or an _, it cannot be number, but further can be either capital letter, small letter or numbers or an _. So, there are valid names like c_sq, csq1, c_sq_1. So, all these are valid. One thing to note is, that the names are sensitive to upper and lower case. So, for example, capital C Centigrade is different from a centigrade, which starts with a small c. So, these are two distinct variables that is the common source of errors when we start programming. Another thing to note or to watch out for is, that the assignment operation, which is equal to is not the same as mathematical equal. So, when mathematically we you say a equal to b, it means, that a and b are the same quantity. So, a equal to b is the same as saying b equal to a. This is not true in C. For example, let us say, that you have the statements b = 3; and then later you have a = 2; and further you have the statement a = b; So, the statement a equal to b will set a to b's value. So, b's value is 3 and that value will be copied to a. So, it will set a to 3 and b we will be unchanged. So, watch out for this. If, if you were expecting the mathematical operator, after the operation a = b, a and b we will have the same value, but that is not the case. The meaning of the symbol equal to is, that take the value on the right hand side of the expression and copy that into the box specified by the life side. So, copy the value in the right hand side to the variable on the left. We have seen comparison operators, like less then, equal to, less than or equal. to and so, on. We will see bunch of few more operators in this session. So, let  us consider the modulo operator which we have already seen in when we discussed utility in GCD. So, a % b gives the reminder when a is divided by b. So, suppose we have the following problem, we get a number a and we want to check whether the given number is divisible by 6. If it is divisible by 6 a % 6 will be 0 the reminder will be 00. So, we will write a simple code, you have int a, a is of type int. Then, scan the number using scanf( “%d”, &a). And then, you test whether a is divisible by 6 to test whether a is divisible by 6 you check whether a mod 6 is 0. If it is divisible, you say that input is divisible by 6 %d a. Otherwise, else, printf the input is not divisible by 6 very simple operation. Now, let us make it slightly more elaborate. Suppose, you have to test whether, this a slight variant. Suppose, you have to test whether a give number is divisible by 6 and by 4 two numbers. How do you do this? So, you scanf the number and you test whether a is divisible by 6. So, a % 6 is 0. If that is true, then you also check whether a % 4 is 0. If both are true, then you print that the given number is divisible by 6 and 4. So, percentage is divisible by 6 and 4 a. So, you can argue about this program and see that, if it is divisible by 6, but not by 4 then, it will enter the first if, but not enter the second if. Therefore, it will not print that it is divisible by 6 and 4. Similarly, if it is not even divisible by 6 it will not even enter the first if condition. So, you will in any case not print that it is divisible. So, convince yourself that this particular code will print a number is divisible by 6 and 4 if and only if the given number is divisible by both 6 and 4. Now, that piece of code was slightly long is there any way to write the same code with a fewer number of lines. And for this c provides what are known as logical operators. Now, there are three logical operators in Boolean logic which are Boolean AND, Boolean OR and Boolean NOT. So, there are three logical operations AND, OR and NOT and C provides all of them. So, the same if condition that we wrote before, we could have easily said if it is divisible by 6 and if it is divisible by 4 then print the output. So, for this C provides an operator which is the Boolean AND operation. So, the Boolean AND operation in C is given by two ANDs. So, by know you should be familiar with the fact it certain operations in C have repeated characters. For example, we already have seen the equality operations which was equal, equal. Similarly, the Boolean operation and it is actually the and symbol on the keyboard. But, you have to have two of them that represents the logical AND. So, this expression says if a % 6 is 0. So, this expression is what test for a is a multiple of 6. And this is the expression which test whether a is the multiple of 4. So, if both conditions are true, then you say that the given number is divisible by 6 and by 4. So, consecutive ampersand signs, that is the and symbols without any blanks in between is the C operator corresponding to the mathematical and the logical AND function. So, it takes two values as input and returns a 0. If any of the values is 0, if both values are 1 then it returns a 1. So, this is the same as the logical AND. If either of them is 0 then the result is 0, if both of them are 1, then the result is 1. So, the truth table for the operation AND is as follows if a is a non-zero value and b is a non-zero value, then C considers that both are true. So, the output value is of a and b is 1. If a is 0 and b is any value at all the output is 0 and b is not evaluated. So, this the same as logical end. The only think to notice that, if in evaluating a and b you already know that a is 0, then you know the result is 0. So, C will not bother to evaluate b. Because, it knows that the result is already 0. Every expression has a type a and b is of type int regardless of the types of a and b. This is because a and b is a logical assertion. The type of a logical assertion is that, it is either true or false, it that it corresponds to a Boolean value. Therefore, at the type of an a and then b regardless of what a and b are the result is always 0 or 1. So, it is of type int. Now, you can print the result as an int, you can say printf %d a and then b. Now, there are three logical operations as I mention. So, there is also OR in c it is denoted by two vertical bars which are there on your keyboard. So, a or b which is a || b evaluates to non-zero if either a is non-zero or b is non-zero. If both of them are zero, then the result is zero. So, this the meaning of a logical OR operation, if both of them are false, then a or b is false. If at least one of them is true then a or b is true. So, you can write the truth table for that. If a and b are 0 then the output is 0, if a is non zero and b is any value. Then, in already know that the output of a or b is 1. So, the output is 1 and b will not be evaluated. This is similar to in the case of AND. If a was 0 and b was any other value, then you know that the output of and is 0. Therefore, b will not be evaluated. Similarly, if here if a is non-zero, then you know the value is 1. So, b will not evaluated and as before a or b is of type int. So, the third logical operation is NOT. Now, NOT in C is denoted as the exclamation mark. So, let us see an example of that. So, NOT is the logical complement and it takes only one argument, this is different from the previous two that we have seen a or b and a and b both took two arguments it is not takes only one arguments. So, it is called a unary operators. So, NOT of a is an expression of type integer and the value is the negation of a. So, if a is 0 NOT of a will be 1 and if a is non zero then NOT of a will be 0. So, for example, if I want to say that a is not divisible by 3 I will just write NOT of a mod 3 equal to 0. You know that a mod 3 equal to 0 test for a being divisible by 3. So, negation of that it will say that the given number is not divisible by 3. Let us finish this by slightly complicated example which is that of leap years. So, I am given a particular year number and I want say whether the given number is a corresponds to leap year or not. Now, what is a leap year it is that you add a few years will have February 29th in February all other years will have 28 days in February. So, what is the logic of a leap year. So, roughly an average solar year is 365.242375 rotations. So, in particular is not an integer. So, we normally say that year has 365 days that is not quite true, this it is a rounding. So, how much are we losing. So, you can calculate it as follows. The remaining number after the decimal point is a roughly 0.25. So, at a rough cut let say that every 4 years. Because of this 0.25 you will lose one day. So, every year you are losing about a quarter of a day. So, if every 4 years you will add a day. Now, when you do that you go back to... So, just a minute. So, you have 365 point let us say 25. So, every 4 years you would lose about a day approximately 1 day. So, in order to compensate for that you add 1 day every 4 years. So, in 100 years you would have added 25 days. But, that is 1 day too much. Because, remember that this number is only 365.24 something. So, in 100 days you should have added only 24 days. But, now you added a 25 days. So, to compensate for that every 100 year skip adding the extra day. So, every 4 years you have add 1 extra day,, but every 100 years every 100th year you do not add that extra day, you skip it. Because, you would have added 1 more day then you. And then again you can look at what remains, what remains is roughly .24 which means that every 400 years if you do this adjustment you are losing about a day. Because, every 100 years you are losing about quarter of a day from this 0.2375 part. So, you do the same logic again every 400 years. So, every 400 years add an extra day. So, this is the logic of the leap year that we all know. So, how do you decide whether year will be leap year. So, the logic that I have outlined just now says that, if a year is a multiple of 4 then it is a leap year. But, if a year is a multiple of 100 as well then it is not a leap year. But, if it is a multiple 400 than it is a leap year. So, here is a pretty complicated expression. So, every 4th year is a leap year. But, skip every 100th year unless it is also a 400th year. And you can write this expression in C, it is slightly complex has you can imagine. So, if the first line the first expression says that, wise year is a multiple of 4. So, if year is divisible by 4 also the following should be true, it should not be a multiple of 100 unless it is a multiple of 400. So, it should not be divisible by 100 that should be true or it should be true that, it should be a multiple of 400. For example, if you have 400 then it is a leap year. So, what will happen is that year modulo 4 400 modulo 4 is 0. Then, what happens is that you have 400 modulo 100 that is 0. So, this is equal to 0 that is 1 NOT of 1 is 0. So, this part is entirely 0, but it is divisible by 400, 400 divided by 400 is 0. Therefore, this part is true, this or 0 or 1 is true. Therefore, the whole expression becomes 1 and 1. So, it is true. So, this logical expression slightly complicated logical expression encodes the logic for saying that the given year is a leap year. So, try this out yourself this is a slightly tricky expression. And convince yourself that, this exactly encodes the logic of the leap year. In this session, we will look at loops in the C Programming language. And we will start with very basic kind of loop which is known as the while statement.  So, the general form of a while statement this similar to that of and if which is that there is an expression and you say while that expression, then do this statement. So, the flow chart corresponding to the while expression will be, you test whether the expression is true or false. If it is true you do this statement, if it is false you exit out of the loop and execute the next statement outside the loop. So, if the expression is true in C that is the expression is non-zero, then execute the statement and go to the step outside the loop. If it is false then directly go outside the next statement after the while loop. This is similar if you recall to the, if block without the else. So, loops are a new thing that explicitly there was no loop construct in a flow chart, we just had this way of going back to the expression. But, in programming languages loops are such a basic programming need that in addition to the if block, you have loop construct as well. So, slightly different variant of the while expression will be that while expression statement 1 and then statement 2. So, the flow chart here is easy to follow if the... So, if first test whether the expression is true. If the expression is true then you execute statement 1. And then after you execute statement 1, then go to go back to the expression. If the expression is false then you go to statement 2. So, while the expression is true execute statement 1 and if the expression is false, then execute statement 2. So, the difference in the, if condition will be that if this was an if block. Then, if the expression is true you do statement 1 and you exit out of the while loop. And that is not done in the case of a normal while loop. After you execute the statement you go back to the expression. So, as long as the expression is true you keep executing statement 1 and if the expression becomes false then you execute statement 2. So, let us illustrate the use of a while loop with the help of a program. So, we will introduce a very simple problem which is, read a sequence of integers from the terminal until -1 is encountered. So, -1 signals that the input is at end. Now, what I want do is that sum up all the numbers until the -1 and output the sum. It is a very simple program. What you have to do is to read a sequence of numbers, until you hit the first -1 and then add this numbers and output their sum. So, let us first introduce the very simple loop which will do only the basic thing of reading the numbers until a -1 is encounter. So, how do you write the loop you have stdio.h. And then you declare an integer variable and read the variable. So, this is supposed to be the first number. If that number is -1 then you do not have to read any more numbers. So, if the number is not -1. So, if a = -1 is false then you read one more number. After you read one more number you do not finish the loop, you go back and test whether the loop condition is still true. So, you go back and check whether the second number you read was -1 or not. And then, you keep on reading it until you hit a -1. At some point when you hit a -1 you go back to the loop and the condition that a = -1 will be true. So, NOT of that will be false and you will exit the loop. So, read the first number if it is a -1 do not enter the loop; otherwise, keep on reading numbers until you hit a -1. That is the meaning of the while loop. So, let us just trace the execution of the loop on a sample input to understand how it works. So, in a box I will represent the memory location a and its current content. So, I run the program after compiling a.out and let us say that I enter the number 4. Now, you scan the number 4. So, memory location a becomes 4. Now, 4 is not -1. So, you enter the loop. So, then n let us say the next number is 50, you read the number into a. So, memory location a is now 15, 15 is not -1. So, you again enter the loop, you enter -5, -5 is not -1. So, you enter the loop again. At this point you enter, you scan the number into a and a becomes -1. So, you go back to the loop again and now the test that so, a = -1, so, naught of that is false. So, the while condition becomes false at this point you exit the program. So, this is a very simple part of the program that we want to write, recall that we want to read a bunch of numbers and sum them. And the end of the numbers is represented by a -1. Until now we have just read those numbers. In this session, we will continue the program that we were writing. Recall that, we were writing a while loop, which will read a bunch of numbers. And it is supposed to sum them up, until you hit a -1. In the loop that we have seen, so far we just read the numbers until -1 was encountered. So, let us now complete the program and compute their sum as well. So, for computing there sum, how do we normally do it? We will add numbers two at a time. So, the first two numbers will be added. Then, that sum will be added to the third number and so on, until you hit a -1. So, let us try to do that, in the course of a while loop. What I will declare is, I will declare a new variable s. So, here is the new variable s that, I have declared. s is supposed to the hold the sum of the variables that, I have read so far. Now, it is very, very important that, when you declare a variable, you should initialize them properly. In the case of a, we did not initialize it because, we were reading the first number, as soon as was declared. But, in the case of sum, you would use s to maintain the sum, as you read numbers. So, it is important that, you start with s = 0. So, the initialization step marked by this arrow is quite important. If you do not initialize it properly, then the sum may not be correct, as we will see soon. So, we keep a variable s, which is supposed to hold the sum of n numbers, sum of these numbers and initialize the sum to 0. Then, the difference from the loop that, we have seen so far is highlighted in red. So, earlier recall that, we were reading the number. And just testing, whether the number is 1, if it was not -1, you read one more number so, that was the loop. Now, inside the loop, what we will do is, we will keep up, running sum of the numbers that we have seen so far. So, initially s sum is initialized to 0. Then, if the first number is not -1, you add the first number to s. So, s will now be the first number. Now, read the second number. If the second number is not -1, you will enter the loop again. So, you will add the second number to s. So, s is now first number plus second number. And this keeps on going until you hit -1, in the input. So, let us continue with this. Let us try to trace the execution of this program, on a sample input and try to understand, how it works. Let us say that, I compile the program successfully and run the program. So, I run a dot out and let us as before, let us the first number be 4. So, after initialization, when you declare the variable a is undefined and s is also undefined. After the initial statement, s = 0, s is now 0. And then, you scan the variable a. So, a becomes 4, because 4 was the input. And sum is still 0. You enter the loop and you say, s = s + a. So, sum becomes 0 plus 4, which is 4. And you read the next number. Let us say the next number was 15. So, a becomes 15, a is not -1. Therefore, you enter the loop again. And sum is now 4 plus 15, which is 19. So, sum at any point of time is the sum of the number that, we have read so far. So, we have read 4 and 15. So, the sum is 19. Now, you read the next number. Let us say, the next number was -5. -5 is not -1. Therefore, you enter the loop again s equal to s plus -5. So, s becomes 14. Then, you read the next number. And let us say, the next number was -1. So, since the number read is -1. You go back to the loop. And this condition becomes false. So, you exit out of the loop. And then print that, the sum is let us say 14. So, when you verify it by hand, you would see 4 plus 15 plus -5 is 14. So, you have, the program has executed correctly. The important thing to note is, the final -1 is not summed up. So, that is, it is used as the end of the input and you should not compute the sum of the numbers, including -1. -1 is excluded. Then, the program executed, correctly.  We will introduce a few terminology associated with the notion of a loop. Each execution of a loop is known as an iteration. So, in the above loop, when the input was 4, 15 -5 -1, the loop runs for three iterations, corresponding to the inputs 4, 15 and -5. So, for input -1, the loop is broken. So, you do not enter the loop. So, you do not count an iteration corresponding to -1. So, you entered four numbers including the -1 and the loop executed three times. So, you say that, the loop had three iterations. So, this is a technical term associated with the loops. And here is a concept that, I will introduce to help you argue about the correctness of a loop. So, there is a notion known as a loop invariant. Now, a loop invariant is a property relating values of the variable that holds at the beginning of each loop. So, thus bit abstract let me just illustrate with the example, that we just saw. So, loop invariants are a good way of thinking about the correctness of loops that, you have to do. So, in our program what will be the loop in invariant? Let us look at the property of that, we are interested in. There are two variables in the program, s and a. And both of those variables are involved in the loop. But, the interesting property that we have relates to s. What is the property that, s holds with respect to the loop. So, we can see that, s holds the sum of all values read so far, except the last value is that true, the first time that we enter the loop? Yes, because s was initialized to 0. And you had actually read the number.  So, it is true that, s holds the sum of all values, except the first one. So, that is true, when you first enter the loop. And that, any point when you enter the loop, you sum the last value that was the read. And read one more number. So, you will see that, s still holds the sum of all values read so far, except the last one. So, this is the loop invariant in the program. And loop invariants help you, argue about the correctness of the loops. So, if the loop invariant is correct and the program maintains loop invariant, then the value of s when the program stops, will be correct. Why is that? Because, the loop terminates, because the last value read was a -1. And the invariants says that, s holds the sum of all values, except the last value. So, this means that s holds the sum of all numbers, except the -1. Therefore, when the program ends that is, you exit out of the loop, s holds the sum of all number that you were supposed to add. So, here is how arguing about loop invariant and seeing, whether loop invariant holds in the loop that you have written, helps you argue that the program is correct. We will see a few more examples, because loops are really important. Let us go back to the first problem that we discussed, which was the problem of computing the greatest common divisor of two positive numbers. So, the problem is to read the two numbers, find their GCD and compute the output. Now, we had a flowchart of the problem based on the fact that, if a >= b, then GCD(a,0) if b is 0, then GCD(a,0) is a. Otherwise, GCD(a,b) is the same as GCD(b, a%b), with a % b is a % b is the remainder, when a / b. So, let us now try to write the program in C using a while loop. So, we have to do a few preliminary things. So, let us call up the first half of the program. In the first half I declare three variables, a, b and there is another variable t, whose need we will see right now. But, let us say that I need an extra variable for now, let us just take it on faith. So, what I will do is scan two variables a and b. Now, recall in the GCD equation that we saw right now, we assume that a >=b. Now, what if the user is unaware of his condition and enter the lesser number first. So, he just entered the numbers in such a way that, a < b. So, we need to correct that, we need to make sure that a is the greater number. So, we need to exchange the values of a and b, if it is true that a is less then b. Now, how do we do this? So, the first thing to note to try will be to say that for example, if I say that let us say a was 3 and b was 4. And suppose, I just said a = b I want to exchange the values of a and b. I just said a = b and b = a. What will be the effect of this? Note that, this is the assignment statement. So, after I execute this line, b is 4 so, a will be 4, a = b results in a equal to 4. After the execution of this line. So, what this situation that we will have is that b equal to 4 and a equal to 4. And we will have no memory of, what was the original value of a? That is lost. So, it is just simply lost. So, this idea that we can exchange two values by just writing a equal b, b = a does not work. So, what is the correct way to do it? So, we have an idea known as the cyclic exchange and this is a really neat idea. The idea is that… So, how can I motivate it? Let us say that you have two rooms and these two rooms are full of steps. And I want to change the contents of the first room to the second and the second room to the third. One way I can do it is that I will move the contents of the first room to a different room. So, have a temporary room and then copy the contents of the second room to the first and copy the contents of the third room to the second. So, this is a very nice intuition and it almost is similar to what we need to do. So, we have two variables a and b that we need to swap. So, one thing we can do is, I will keep a third variable t. First what I will do is, I will copy the value of a to t. So, now I have a backup copy. Now, then I will say a = b,. So, at this point the value of b will be copy to the a, So, now, a is 6, b is 6. But, still we have a memory of what was a before? Because, the old value of a was told in t. So, in order to complete the routine, all you need to do is to copy the value of t to b and that can be a complete by the equation by the assignment statement b equal to t. So, this idea is known as cyclic exchange. So, recall the physical intuition of swapping the contents of two rooms which are almost full. You have a third room and you move the contents of the first room to the third room, move the contents of the second to the first and move the contents to the third to the second. So, this is similar to what we did. In the case of physical contents, we cannot copy, in the case of variables, we can copy. So, now let us complete the GCD program. We have just done the first part of the program which is to ensure that a is actually the greater number. If it was not the greater number, you swap or exchange. Now, So, after exchange we have ensure that a >=b. Now, we have to write the main loop for the GCD function. So, just by translating the flowchart, what we will do is while b is not 0. What you do is, you say that store the value of a and t. Assign a to b, a = b and b becomes t % b. Recall the equation was written as follows that. So, recall that the equation was GCD(a, b) is the same as GCD(b, a % b). So, when you assign a to b, the old value of a is lost and we can no longer do a % b. So, the way to do that is, you use the idea of temporary variable, store the old value of a and t, before you do a = b. So, that finally, a % b can be done by t % b. I do not want the new value of a, I want the old value of a. So, let us just trace the execution of this program. Let us say that I scan two numbers a and b and the user was correct in entering it. So, he actually enter the greater number first. So, we have 16 and 9, a equal to 16 and b equal to 9 and t is undefined. So, after you read the numbers, you just say GCD of… After these you enter a message which is printed message which is the GCD of a and b is,. So, GCD of 16 and 9 is and then you enter the loop. So, in the initial execution of the loop you have t equal to a, which will store t equal to 16, a = b, which is a will become 9. And then, but you want to compute the modulo 16 % 9, but 16 was lost in a, because a is not 9. So, you have do t % b,. So, 16 % 9 which is 7. So, you go back to the while loop and then you see that b is not 0, b is 7. So, you enter the loop again. T is equal to a,. So, t is 9, a = b,. So, a become 7, b becomes 2. Again b is not 0, So, you enter the loop again. So, t is 7, a equal to 2 and b equal to 1. Again you enter the loop, b is not 0, t is 2, a becomes 1 and b becomes 0 at this point, you exit the loop and at this point a that we ended with is the GCD of these numbers. So, 16 and 9 are relatively prime. Therefore, their GCD is 1. Now, let us think a minute about what is the loop invariant in this program? What is it that? We have a central while loop which computes the GCD. What was the invariant in that loop? So, for this I will just introduce a slight notation which makes it easier to discuss this invariant. So, let capital A and capital B be the original numbers that I input. And little a and little b represent the numbers which are involved in the loop. So, capital A and capital B are the original input and the invariant that I have is that at every stage, the GCD of the original inputs are the same as the GCD of little a and b. We call that little a and b are the loop variables involved in the loop. So, little a and b keep changing through the loop, whereas, capital A and B are fixed, they are the input. So, the invariant that I have is that every time you enter the loop, the GCD of the input where the same as the GCD of the variable. Now, this guarantees the correctness. Because, when you exit out of the loop, you will correctly compute. You exit out of the loop, because b equal to 0, and by the original equation, you know that when b is equal to 0, a is the GCD of a and b. So, this guarantee is correctness. Now, you could also ask other questions like, how many times has the loop run? And this question is big complicated, because you have to compute it based on the input numbers. So, such questions are of interest to computer science. But, we will not going to computing the efficiency or the performance of this code. But, it is also a very crucial question. So, we will see one more example for writing loops, we see as slightly trickier example and will cover this over multiple sessions. So, the problem is the following. We have to read as sequence of numbers until a -1 is read, -1 indicates that then the sequence of sent it. And the question is we have to output the length of the longest contiguous increasing subsequence. So, that is a lot of words let us illustrate it with an example. Let us say that the input is of the following numbers - 9 2 4 0 3 4 6 9 2, and then finally a -1. And we have to output the length of the longest contiguous increasing subsequence. So, let us say what do I mean by a contiguous increasing subsequence? So, I say that 9 is an increasing subsequence, then the next number is 2; 2 is less than 9. So, 9 and 2 cannot be part of a subsequence, where the numbers keep on increasing.  So, 2 is the start of a new sequence, again the next number is 4. So, 2 and 4 form an increasing sequence. So, you can continue increasing a sequence. The next number is 0, 0 is less than 4, so break the sequence there. Then when you look at then succeeding numbers 0 3 4 6 9; they form an increasing sequence. And the last number is 2, which is lesser than 9. So, the increasing sequence stops here. So, these are the increasing contiguous subsequences; contiguous means together occurring adjacent to each other. So, the largest of the longest contiguous subsequence is obviously, 0 3 4 6 9, and the length of that sequence is 5. Let us take another example 11 9 7 8 11 12 15 15 and -1. So, just to illustrate the point 11 is greater than 9. So, that cannot be an increasing sequence, 9 is greater than 7, so that is another the increasing sequence is just 9, but then 7 8 11 12 15; these are increasing. And I decided to stop here even though the next number was 15, because I am interested in and increasing subsequence. So, 15 and 15 are equal numbers. So, we break it. So, the longest increasing subsequence is 7 8 11 12 15 and its length is 5. So, this the longest contiguous increasing subsequence. So, here is a basic property given any sequence of numbers, we can break it into a collection of increasing contiguous subsequences. For example the numbers that the sequence that we have seen. So, 9 2 4 0 3 4 6 4 6 9 2, and that the length of the increasing, the longest increasing contiguous subsequence is 5. So, we have to write a program to do this, given a sequence of numbers find the length of the longest increasing subsequence. So, how do we do it? We do it in the way that we have been writing loops so far, like adding n numbers and finding this sum and so on. The idea was that you start from the first number and keep on adding the numbers until you hit -1 at which point you have this sum. So, the idea of this algorithm was that you start from the first, and you keep reading, until certain condition happens. We will adopt that idea to solve our current problem. So, what we need to do is to keep track of the current increasing subsequence. Let us say that it is denoted by s. So, before we get into the code, let see how we will do it by hand. So, initially the increasing subsequence is s, and let say that it is empty. After you read 9, you have an increasing subsequence which consist of exactly 1 number. So, s is 9. Now, the next number is 10; 10 is greater than 9. So, you extend this. Read the next number 4; 4 is less than 10. So, 9 10 4 cannot be an increasing subsequence, therefore you say that you break the subsequence there, so 9 10 is a different subsequence.  Now you start a new subsequence which is 4. So, the current subsequence is just 4. So, 0 is less than 4, so you break it there, the current increasing subsequence become 0. Read the next number 3, 3 is greater than 0. See you extend the subsequence s is now 0 3 4, 4 is greater than 3. So, the sequence becomes 0 3 4 and so on. So, what are we doing here? We are reading the read, we are reading the numbers integer by integer, and we are keeping track of the current increasing subsequence. So, this is part of what we want to do? Now, in order to decided whether we should increase the subsequence extend it or break the subsequence, and start a new sequence what we need to do is we should remember what was the previous number we saw, and what is the current number that we have seen. So, with two variables we can say whether the subsequence should be extended or should be broken at this point. So, if the previous number is less than the current number, then we should increase the we should extend the subsequence. If the previous number is greater than or equal to the current number then we should break the subsequence and start a new sequence. So, extend the sequence means add 1 to the length of the current increasing subsequence, and add that number to the subsequence. Reset means you start a new sequence of length 1.  So, from the current from the description that we have seen so far, we need the following variables, we need C which is for the current rate c number, p which is the previous number that we have seen, and length which is the length of the current increasing sequence. So, we store the previous number into p, store the current length of the increasing subsequence into length, and read the next number into c.  So, if the previous number is less than the current number. So, we take the true branch in which case we extend the sequence. So, the new number that we have read is part of the of the currently increasing subsequence. So, increase the length of the sequence by 1 and now we move lockstep. So, what we do is? So, we are a stage where suppose we have numbers 1 2 and 3, suppose p was pointing to 1, c was pointing to 2. So, since 2 was greater than 1, we extend the sequence. After extending the sequence, we have to proceed and see what will happen with the next number. So, when you do that you can do the following, I will extend the current sequence by doing the following, I will now set p equal to 2, and c equal to 3.  So, this is the idea that we will advance both the variables by 1 number each. So, that it is always true that previous is 1 number behind current. So, I hope this idea is clear that in order to ensure that p is 1 number behind current, you have to advance both p and c. So, assign p to c, this will advance p and then read the next number. So, that will become c. Now what happens if c >= p, then the new number is not part of the current increasing subsequence. So, you start a new sequence which is of length 1 and again do the same assign p to c, which is advancing the pointer and read the next number. So, here is the method that we will follow in order to keep track of the current increasing subsequence. Now what is left is to find the longest of all the increasing subsequences that we find. In this session we will try to code up the C code for finding the length of the longest increasing contiguous sub sequence. So, let us first examine what we need to do, we will write a code, and from the previous discussion we saw that we need at least three variables; one for a storing the previous number, one for storing the current number, and the third for storing the length of the current decreasing sub sequence. So, we start by declaring all those three variables and initializing length to 0. So, here is a new construct that we are seeing for the first time, which is that when you declare a variable, you can also initialize it immediately by saying len equal to 0. So, this is a very intuitive notation. So, this will declare a variable and immediately initialized it to 0. Once we declare these three variables, let say that we scan the first variable into previous. Now, let us focus on, on the main body of the program. If the currently read number is if the currently read number is ! = -1, then you say that you start with length 1. So, the length of the current increasing sub sequences 1, and then you scan the next number into curr. So, here is current number. So, this part of the code is just to initialize. So, if the current, if the first number is -1, then there is no point in getting into the program, because the its equivalent to the empty inputs. So, there is no increasing sub sequence to be found. So, you just exit out of the program. So, initially we just check to see whether the first number is -1 or not. If the first number is ! = -1, you scan the next number, so current will be the second number. And if current is ! = -1 while the currently read number is ! = -1. What you do is exactly the logic that we were discussing before. If the previous number is less than the current number then you extend the length by 1.  So, length equal to length plus 1 says that I am continuing the current increasing sub sequence by increasing its length. Otherwise that is current is less than or equal to previous, you break the sequence and say length equal to 1. Then we have this step previous equal to current, which is the advancing both variables by 1. So, previous becomes the currently read number, and current becomes the next number to be. So, recall from the diagram that previous and current were at some position, and we will advance both of them by 1. And when the loop condition is check the next time we will check whether the currently seen number is -1. So, so far we have coded up part of the logic, which is the part of the logic dealing with when the current when the next number is read do we extend the sequence or do we break the sequence and start a new sequence. So, this is just part of the work that we need to do to solve the problem. So, lets continue with the logic. So, let us start with a few boundary cases, and let see that whether these works. If it works we can try or logic on other cases. So, let us say that by boundary cases I mean may be very long inputs or very short inputs. So, these are cases where your code normally breaks. So, when you test your code it is always a good idea to check boundary cases. And one thing that makes programming difficult is that in or when we do things by hand, we know how to handle the boundary cases elegantly, but in a program unless you say how to handle the boundary cases, the program might break. And the lot of testing and the lot of errors come from incorrectly handling the boundary cases. So, it is always good to handle the boundary cases, let us try test our code on very small inputs. So, let us say that I enter a sequence 5 - 1. So, previous becomes, so length is 0; previous becomes 5 and then since prev ! = -1, I have used an abbreviation here which is the not equal to operator, this is the same as saying not of previous equal to equal to 1. So, previous not equal to 1 is the same as saying not of previous equal to equal to 1, its an operator in C, then you say that the len equal to 1, then you say that the length is 1, because you have seen 1, 1 number and scan the next number. The next number is -1. So, you scan the next number, and the next number is -1, so you break the sequence. So, immediately exit out of the sequence, and the length of the increasing sub sequence that we saw, so 5 is the only increasing sub sequence. And when we exited the length was 1. So, we handle the boundary case of an extremely small sequence, a sequence with exactly 1 element correctly. This gives us confidence that the code could be correct, of course we have handle only the boundary case. Now, we see need to test it for other cases as well.  So far the program is not doing any anything useful, because we are just extending the sequence and breaking the sequence. What recall that the what we was suppose to do was to fine the length of the longest increasing sub sequence. So, this is the main, this the main thing that we have to do in the logic. So, to do this what we do is something simple. We keep track of the maximum length sequence that we have seen so far, keep track of the length of the longest sequence that we have seen so far. Also we have the current sequence. Now all we need to do is whether to check whether the current sequence is longer than the previously known longest one. So, for this what we do is keep track of the maximum length that we have seen so far. So, this is a standard technique in program. And how do I do that. So, let us modify the program a little bit. So, earlier we resend out that we need at least three variables. Now in order to keep track of the length the maximum length that we have seen so far, I need a new variable. So, this part we have already done before. And here is the maxlen = 0. So, that is the new variable which is the maximum length that we have seen so far. When we start the program we have not seen any increasing sub sequence, and therefore the length of the longest increasing sequence, the current increasing sequence is 0; that is len equal to 0. And the length of the maximum length that we have seen so far is also 0.  Then you scan the new number; if the new number is not -1 you continue. So, length equal to 1, now max length equal to 1, because currently the longest sequence that we have seen so far is 1 1 long. You scan the num next number. If you… So, here is the main body of the loop, and what we need to do is the following, if the currently read number is greater than the previous number, we extend the sequence. So, this logic is the same as before. Otherwise which means that current number is that less than or equal to previous. So, we are starting the new sequence. So, the situation is the following we have some maxlen sequence somewhere in the past. So, maxlen is the length of the sequence that we have seen somewhere in the past.  Now we are scanning in the sequence we have a current sequence. And we have decided to break this sequence. So, we have we are now starting a new sequence starting at current. So, we are a this part of the logic. So, we have decided to start a new sequence, that is because the current sequences last number is greater than or equal to the current number. So, here is previous, and this is current. So, we are deciding to start a new sequence what we need to see is whether this sequence is longer than the previously known maximum length. If the sequence that we just stopped is longer than the previously known maximum length sequence. So, if maxlen < len notice that length is then sequence that length of the sequence that we just stopped. Then we say that maxlen = len. So, if the current sequence is longer than the previously known maxlen, what we do is that maxlen becomes the length of this sequence. Otherwise if the current sequence was shorter than the previously known maximum length, we do not do anything, so maximum length is the same…  So, when we extent the sequence we don’t have to do anything special when we  break a sequence, and we start a new sequence, then all we have to do is you check whether the currently say the sequence that you just saw was longer than the previously known longest sequence. If that is the case then the sequence that just ended is becoming the longer sequence we have seen so far. Otherwise you maintain the max length. So, just forget about the currently stop sequence. Now there is a... So, that this loop, and at the end we have to do slight tricky logic, it could so happen that the sequence ends with a longest sequence increasing sub sequence. In that case, we will never reset the max length. So, if the last sequence is the longest, you also have to handle the case separately. So, we will see an example where, if you exit out of the loop that is you have already seen a -1, you just have to check whether the last increasing sequence that you saw was in fact the longest. So, there is a small if block at the end to do that.  In this part we will just see, small tracing of this program on a sample input. So, that the logic of the program become slightly more clear. So, I have picked a particular input 3 2 1 3 5 -1, and you will see that the longest increasing sequences are 3. So, the increasing sequences are 3, then 2, then 1 3 5. So, 1 3 5 is going to with a longest increasing sub sequence, and let us see how our program will find that out. So, initially you have a bunch of variables which should be declare. So, len = 0, maxlen = 0, and previous and current are undefined. Then you first read previous. So, previous becomes 3, it is not -1, so you enter the if condition, at which point you set length and max length to 1.   Now you scan the current number. So, current becomes 2. So, remember that previous is now 3, and current is 2. So, current is not -1, therefore you enter the while loop. Prev < curr is false, because previous is 3 and current is 2. Therefore, you enter the else part, maxlen < len is false; both are 1. Therefore, you start a new sequence with length equal to 1. Now you continue the loop with previous becoming current.   So, previous is now 2 and current you read the next number which is 1. So, previous and current have both more 1 step. So, current is not -1, prev < curr is again false, because 2 is greater than 1. So, you enter the else part. Max length and length there is no change. So, you reset the length to 1, previous is current. So, current previous becomes 1, and you scan the next number which is 3. Now at this point previous is 1, and current is 3. So, the if condition is true. So, you extend the length; length increases by 1. Again you advance previous and current. So, previous becomes 3, current becomes 5. Again 3 is less than 5, so increase the length we are extending the sequence. So, the length becomes 3. Advance, so previous becomes 5, and current becomes -1 at this point you exit the loop.  And now you encounter the situation that max length, which is the length that we have seen so far, recall that it is one, but the length of the sequence that we just stop the see the input with is 3; that is that happen, because the longest increasing contiguous sub sequence, well was at the end of the input. So, it happen right at the end. So, when we exit the loop we have to do 1 additional check, we cannot simply say that the maximum length that we have seen in the sequence is 1, because max length is the length of the longest sequence we have seen before the current 1. The current 1 was the 1 that we just stop to with it had a length of 3. So, we just check, if max length equal to length is less than the length, then we set max length to be the length. So, once you do that max length becomes 3. This is just to handle the case when the longest increasing sub sequence is the last. Now you can exit out of the exit out of the if condition, and then print that the maximum length that you have seen is 3.  So far we have been using while loops in C, now C programming language also provides you other kinds of loops.  Let’s look at some of them. The first alternative loop mechanism in C that we will look at is what is known as a do-while loop? And so it is a variant of a while loop, I am the general form is what you see here, you have do statement followed by while expression. And here is an important syntactic difference which causes some syntax errors, when you code. The do while terminates within semicolon, where is the while loop does? So, the while loop has the following a form which is while expression, and then statement; the difference is that here the statement is occurring before the while the test expression. So, the way it execute is the following. We first execute the statement, then evaluate the expression. If the expression is true, you go back to step 1; that is execute this statement. If the expression is false, then you get out.  So, you execute the x statement then test whether the expression is true or not, if it is true you go back and the execute the statement again, so you loop. If the statement is false, you get out of the loop. The difference from while loop and do while loop is the following, you have statement that will be executed without testing the expression even once. So, when you start executing the loop, you will first execute the statement without testing the expression, and after testing the expression you will go back and test the loop expression, if it is true and you start executing the loop again. So, the first execution of the statement there is no test done for that. So, let us see the comparison between a loop while loop and do while loop. So, we will look at the following problem, you have to read numbers and output in integer until a -1 is seen. Now the difference is that in this problem you have to include the -1. So, read all the numbers up to an including -1, and print all the numbers. So, we will have the following programs using while loop and do while loop. Now the important thing to notice is that the while construct and the do while construct are equally expressive. So, you cannot right any more new programs using the do while construct, then you could using the while construct, but certain kinds of programs or easier using or shorted using the do while construct. For example let us all this problem using the while construct. So, what you do initially is, you declare a variable then scan the variable; if the variable is -1, you immediately exit out of the loop, and print -1 and finish the program. If the number is not -1, you print the value and scan the next number. If the number you scan this not -1, you just print it and repeat the loop. If it is -1, you exit out of the loop and print the -1 that you show. So, here is the logic using the do while loop, in using the while loop. And notice that when we existed out of the loop we needed a printf statement, and before you yes, enter the loop you needed a scanf statement. So, this was the structure of the program. This problem can be elegantly solved using the do while loop. What you initially need to do is to declare a variable, then scan the variable and print it any way. Either the number is -1 or it is not. In any case we need to print it.  So, go ahead and print it then test whether the number was -1. If it is -1, your done and you exit out of the program. If it is not -1, you go back and scan the next number and print it. So, this is a program that we have seen where you could do this same think with the while loop. The only difference is that the do while program is shorter. And please be careful about the syntactic difference between the while loop and the do while loop, notice the semicolon at the end this causes a lot of confusion when you compile the program it is easy to miss this. If you are new to C programming, you can strict to one particular loop. As I said before you cannot write any new programs that you can do is using the do while loop, then you could previously do using the while loop. So, you can write the same logic, you can write the same number of programs using the while loop, and the do while loop it gives you no further power. So, it is recommended that you stick to one loop pick while or pick do while whatever you do, but stick to that loop in when you right the program. When you are comfortable with one of the loops programming using the other loop becomes easy. So, let us try to solve a problem that we have already seen, which is to find the length of the longest contiguous increasing subsequence ending in -1. The difference that we have is that earlier we did not include -1 in the sequence when you computed the length of the sequence, now we will include -1. So, here is the program to do that and the logic - the core logic, so here is the initialization, and here is the loop logic, and the final check.  So, if you recall from the lecture which covered the problem solving the longest increasing subsequence, then you will see that the main structures in the code. The main lines of logic in the code are pretty much the same. All I have done is to change the while logic to the do while logic. And let see what that is accomplish for us. So, what this does is that you will scan a particular number, if the particular number is bigger than the previous number, then you extend the sequence. If it is less than or equal to the previous number, then you stop this sequence and started new sequence, this was the logic.  And when you start a new sequence the length is new start with 1. Then you say current equal to the next number, and previous equal to the number that was just red. So, the logic here is that the testing for whether the currently rate number is -1 is done at the end of the loop. So, is the first number is -1, you just do all this and then say that the length of the increasing subsequence is 1, then you test if the currently read number is -1 or not. If the currently read number is -1, then you are already done and you exit out of the loop. Then you check whether max length is less then length as before. difference between this logic, and the logic that we have seen before is that we do this execution without testing whether the currently read number is -1. So, automatically what happens is that if the number is -1, all these steps will be performed before we test that the sequence has ended. So, automatically we ensure that -1 is also included when we calculate the increasing subsequence. In this session, let us look at a matrix problem and the problem is given as follows. You have a bunch of lines of input. The first line of the input consists of two numbers, m and n. This line is followed by m lines, each containing n integers. So, this is supposed to represent the matrix of size m time m cross n. We have to calculate the sum of the squares of the sum of numbers in each row, that is quite a mouthful, let us look at the formula. So, what I want to do is, . So, once you do this sum, you square that and then do the  . So, i is an index which goes over the rows. In C, we adopt the convention that the first row is starting with 0 and so, it goes from 0 to m minus 1. Similarly, the first column starts with index 0, so it goes on till n minus 1. So, the input will be given as follows. The first number m represents that there are 3 rows, the second number represents the number of columns in each row and then this is followed by a matrix of size 3 cross 4. Now, the numbering is given as follows. For example, if you have , this means second row zeroth column. Note that, second row means we start with row 0, then row 1, then row 2 and zeroth column is this, the first column. So,  is this number which is 2. Similarly,  is first row, row number 1 column number 2, which is also 2. So, the desired output that we have is  and so on. So, how do we do this by hand? Let us just look at the calculation.   So, we have 4 7 11 2 1 1 2 4 and 2 9 0 minus 1. Notice that the formula that we have to calculate is i going from 0 to 2, j going from 0 to 3 squared. So, how do we do this? First, we sum the numbers in each column so, I will name that as j going from 0 to 3  and then square. So, if you sum all this, you see 11 22 242 which is 576 and similarly, this is 64 82 and this is 102, which is 100. So, what I have tallied on the right hand side is, for each row you sum the numbers take that sum and square it. And then finally in order to compute what we want, which is . In order to calculate this, all we need to do is to sum these numbers up and this turns out to be 740. So, notice when we did by hand, we did the following, we first calculated row wise, we summed over all the numbers in that row. Take the sums, square it. Then, you repeated the same operation for the next row and then for the third row. So, we have three numbers and then we added them in sequence. So, we will see how we will code this up?  So, what we need here is something called an inner loop or a double loop, we need a loop inside a loop. Now, the inner loop is doing what we did first? It is taking a row and adding all the numbers in that row, then squaring it. So, we need one loop to do the rowsum of each row. Once a row is finished, we square the rowsum. Once that is done, remember that once we tallied numbers on the right hand side and squared them. We have to add those numbers up. So, we need another loop, an outer loop to add these squares of rows sums. So, let us do this program in stages. First, let us write the inner loop, this is the loop, so that for a given row you sum up all the numbers in that row. Now, let us assume that we are at the beginning of a row and we have not read any numbers yet. Now, what we have to do is to start reading the numbers. So, we write a while loop. We declare four variables a, column index, then we need something for the rowsum and some integer variable for rowsumsquare. Now, what you do is you go along the row and add the numbers in each column. So, while the column index is less than n, recall that the matrix size was m cross n. You scan the next number, the next number is added to the rowsum and then increment the column index. Until you hit n, recall that the last column is n minus 1, because we start the column numbers from 0. Now, once you have done you have the sum of the numbers in that row and what you need to do is to square that number. So, we have rowsum times rowsum will be rowsumsquare. That completes the inner loop, which is what we did, when we added the numbers along a given row and then finally, squared the sum. Now, what we need is an outer loop structure over these. So, we have a code that reads the next n integers from the terminal and sums them. Now, what we need is some further code, that takes the output of the previous code and then sums all those numbers up. Remember, when we did this by hand, this was the second operation we did, we went over the right most column and added all those numbers up and that was the result that we wanted. So, how do we modify the code? So, let us what we need is something like this. Assume that we have the output available from the previous code in some variable called rowsumsquare. And we need a loop over that, which is going from rowindex 0 to m minus 1 and tallying up all the numbers in rowsumsquare. So, for each row you will end up with a rowsumsquare and you have to add all those rowsumsquare to get in. So, in this the rowsumsquare comes from the previous code. So, this is how we will visualize the outer loop. Now, note that this is not completely specified code. This is just a very intuitive picture, that instead of rowsumsquare, it should come from some inner loop which actually calculates it. So, we should plugin the output from the previous inner loop and this is the outer loop over it.  So, here is how we put these two loops together, we have a while loop inside the while loop. Remember that, this was the previous loop that we had written. So, this was the inner loop that we have written, where at the end of the inner loop you have the rowsumsquare. Now, at the end of the code what you will end up is the exact rowsumsquare of a particular column. So, you can imagine that after this inner loop finishes execution, the rowsumsquare is the correct rowsum is the correct square of the sum of the elements in the row. Now, the outer index does the following, you start from rowindex 0 and sum the rowsumsquare over all columns. So, this is the structure of the code. Let us look at the code in slightly more detail. We have a rowindex, a column index, a column sum, a rowsum and the rowsumsquare, a is supposed to be the current number that we are read in. Suppose, we know that the size of the matrix is m cross n. So, rowindex can go from 0 to m minus 1. So, the termination condition of this while loop is rowindex equal to m. Now, for all that you are currently at a particular row. So, you have to initialize the rowsum to 0 and the column index to 0. Because, for a given row you have to start from row 0 for a given row you have to start from column 0 and you go on, until column n minus 1. Also this previous rowsum should not influence the next row. So , for every row you have to initialize the rowsum variable. Once that is done, you go over the columns of that given row and you scan the numbers add the number to the rowsum and increment the column index, until you hit n columns, column 0 through n minus 1. When you read all the columns in that row, you have the correct rowsum. So, that rowsumsquare can now be calculated. Once rowsumsquare is calculated, you have the rowsumsquare for that particular row. So, add the rowsumsquare to the previously computed columns. So, If you go back and think about how you did this by hand, you can convince yourself that this is exactly the coding of the logic that we had earlier. So, let us try this on a small example to see exactly, how the code works? Suppose, the input is 2 3 followed by two rows of three numbers each. So, the input matrix size is 2 cross 3 and the entries are 1 0 minus 1 and 0 1 1. Let us see, how the code executes on this? So, the output should be 4, if you do it by hand and let us see, the variables are m, n, a, rowindex, column index, rowsum and square sum. Finally, the result should be in square sum. You start with rowindex equal to 0, column index equal to 0 and you scan m and n. So, you already know the size of the matrix, when you scanned m and n. So, m becomes 2 and n becomes 3. Now, rowindex is 0 which is less than 2. So, it starts the loop which reads the row 0. So, notice the arrow here, you are starting to read this particular row, the first row, which is row 0. Or you initialize rowsum equal to 0, column index equal to 0 and while column index is less than n, you scan the next number which is 1. Add a to the rowsum. So, rowsum becomes 1, increment the column index. So, it reach column 1 row 0 read that number. Add it to the rowsum, go to the second column and read the number and add in to the rowsum. So, once you are done, now column index is 3. So, just means that we have read all the entries in the row 0. So, we have got the correct rowsum. What we will do is, add the rowsumsquare to the square sum. So, rowsum is 0, 0 square to square sum, so square sum remains 0. Now, you go to the second row. So, increment rowindex. Now, rowindex is less than 2 rowindex is 1. So, it is less than 2 we are reading row 1 and you repeat the same execution. We reinitialize the rowsum to 0, column index to 0. and then, scan the next number which is 0. Add it to the rowsum, increment the column index, scan the next number which is 1 and so on, until you finish reading the second row as well. So, once you read the second row, you will find that the rowsum is 2 and square sum would be square sum plus 2 square which is 4. After you do that, you increment rowindex and rowindex becomes 3, which is greater than the given rowindex. So, you exit the loop. So, we have correctly computed the sum that we wanted. In this session we will see a very popular loop construct in C. We have already seen while loops and do while loops, will see that do while loops are not all that common in C code, when C programmers code. Among the most popular loop construction C is this, for loop. So, let say what it stands for? The expression for the general form of the for statement, the slightly more complex than that of a while loop. While loop was very simple, while as the certain expression was true, you execute the statement and when the expression becomes false, you exit out of the loop, for loop is slightly more complex. So, it has the following components, it has an initialization expression, then the test expression, this the expression corresponding to the expression inside the while loop and then there is an update expression, followed by the loop statement. This looks complex at first,, but it is quit intuitive once you start using it. The execution is as follows, first you execute the initialization expression, then you test whether the test expression is true or not. If the test expression is true, you execute the statement and then come back and execute the update expression. After you execute the update expression go back to step 2, which is go to the test expression. So, init expression is the initialization expression, update expression is the update expression and test expression is the expression, that is evaluates to either true or false. So, if you look at the flow of how the code goes, then it is first you start from the initialization expression, then you go to first you start from the initialization expression, then you go to the test expression. If the test expression is true, you go to the statement, then you go to the update expression and you go to the test expression again. So, the loop is here you test the expression, execute the statement, update and test again, initialization is done only once. So, this is the first step and here is the loop, this sounds bit complex at first,, but it is quite simple to use, once you get the hang of it. So, the execution of the for loop can be understood in terms of the while loop. The execution of the for loop is almost equivalent to the following while loop, you have the initialization expression before the while loop, then the test expression, while test expression, then you have statement and then you have the update expression. So, if you have a for loop you can write the equivalent code using while loop. So, if you say that I do not want to use for loops, here is how you have a for loop and you can write the equivalent while loop in the following way. Or if you have a while loop, you can write a equivalent for loop by looking at the this form and how it is translate to the corresponding for loop? Now, there why did I say execution is almost equivalent, we will see this later in the course. Whenever, there is a continues statement or a break statement, you will see that we need to modify this as equivalents between the for loop and the while loop. But, for now for with the features of see that we have seen so far. The for loop is equivalent to the while loop and we will have to modify this slightly later. So, the init expression maps to the first part of the for loop, the test expression maps to the second part and the update expression maps to the third part. One important thing to notices is that, the update expression is after the statement. So, we have the following first we execute the initialization expression, then we test whether the expression is true. If it is true, you execute the statement, update expression and then again go to the test expression, if it is true you execute statement, update and then test again. So, you initialize the expression then when the test the test expression if it is true, you execute the statement after the statement is true, after the statement is executed you update the expression and go back to the test expression. Because, that is how you execute it in the while loop? You first initialize, then test whether it is true execute the statement, update and then go back to the test expression. So, this is how a while loop can be translated to a for loop and vice versa. So, let us do some examples very simple think, let us say that print the sum of reciprocals of the first 100 natural numbers. So, what do I want to do? I want to do the following, I want to do . So, how would I do it? I would initialize a variable call sum, sum will be initialized 1 and then 2 sum I will add , then to that I will add  and keep on going until .  So, let see how to code this in C using the for loop. So, I have a variable call reciprocal sum and even though I am summing over integers, we know that the reciprocal numbers will be real numbers. So, in order to keep the reciprocal sum I need a floating point number, floating point variable and then I have an integer variable, which goes from 1 to 100. So, here is how I will do the loop? First initialize i to 1, if i <= 100, you enter the loop and do reciprocal sum equal to the current reciprocal sum plus 1 over i. After doing that you update by saying i = i + 1,. So, increment i. Once the increment is done, you test whether the new number is less than or equal to 100, if it is less than or equal to 100, you do the reciprocal sum come back update, until you reach 101. At the point where you reach 101 you test whether i <= 100 that becomes false and you exit. So, you will see that when you exit out of the loop, the reciprocal sum will be the sum of reciprocals of numbers from 1 to 100. So, here is how the for loop functions.  So, instead of 100 let us try to executed on a particularly very small number to see how this for loop executes. So, let us instead of summing from 1 to 100, let us sum from 1 to 4. So, first you have the initialization expression. So, i is undefined before you enter the while loop, reciprocal sum is of course initialize to 0. So, I can after initialization i will be 1, as soon as it is initialized we will test whether it is less than or equal to 4, 1 is less than or equal to 4 that is true. So, you will enter the for  loop, then you add to the reciprocal sum 1 over i, i is 1,. So, 1 over 1 is 1. So, reciprocal sum will be updated 2 reciprocal sum plus 1. So, reciprocal sum would be 1, then you go to the update expression, at this point you have i = i + 1, So, i becomes 2. Now, test whether i <= 4 yes it is and enter the loop. So, 1 plus 0.5 then go back to the update expression i becomes 3 now and test whether 3 is less than or equal to 4 it is,. So, enter the loop. So, you add 1.5 plus , 1.833 and. So, on, update again you have 4, 4 is less than or equal to 4 that is true. So, you enter the loop one more time and add 1 over 4.25 to the current number. So, you get 2.0833 and. So, on update again i becomes 5, at this point 5 is not less than or equal to 4,. So, you exit out of the for loop. Now, you say that print that the sum of reciprocals from 1 to 4 is reciprocal sum, which is 2.0833. So, even though the for loop looks complicated, once you start using it, it is very nice to right, you have a initialization expression, you have a test expression and then you have the update expression, that you should do after every execution of the loop, after every iteration you should have the update expression. As soon as the update is over, you test whether I can execute the loop one more time, if I can enter the loop update and test again and. So, on, until the loop condition is false. Let us take another example, you have two lines, the first line contains a single number m, which specifies how many numbers are there in the second line. The second line contains m integers and we have to just output the sum of the m numbers. Now, we know how to do this, we have already done this using a while loop, let us try to do it using a for loop. So, the sample input is let say the first line is 5 and then I have 5 integers on the second line. The strategy is very simple, you read the number on the first line into m and then have a variable called sum, which will start with the first number and keep on adding the subsequent numbers, until you have read m numbers initialize sum to 0. So, run a for loop from the first number to the mth number and keep adding the numbers to sum. So, this loop will run for m times. So, let us code this up, you have m, i, sum and numbers which are all integers. First you scan the number m, initialize sum to 0 this is important. Because, if sum is not properly initialized it is sum garbage value and you keep adding numbers to it, you will get garbage value as the output. So, initialize the number sum properly to 0 and then here is the for loop, what the for loop does is, you start with i = 0 and go on until i less than m. Now, you could also do the following could start with i equal to 1 and go on until exactly m. So, if you start with i equal to 1 you will say i less than or equal to m, you can adapt either convention, in C it is more popular to start from 0 and go on until m minus 1. So, you break the loop when i is equal to m. So, here is the test condition for the loop and then you have the loop body, which is you read the number and add the number to sum and after you have done that, you have the update expression which is i = i + 1. So, here is the how the for loop looks you start from 0 and go on until i becomes m, you add the number and just increment i, which is i is the number of integers we have seen so far. Let us do trace of this execution, you start you have this integer variables and you first read m which is 5, the number on the first line and then we do things in order, you have initialized sum to 0, you start with i = 0. Once you do the initialization expression i become 0, i is less than m 0 less than 5 that is fine. So, you execute the loop, scan that next number, which is 2 add it to the sum. So, sum becomes 2 now update, update is increment i,. So, i becomes 1 and test whether 1 is less than 5 it is. So, you read the next number add it to the sum,. So, this sum becomes 1 update again and keep repeating this, until you have read all 5 numbers. So, when you read the 5th number i will be 4, after that you add the 5th number to the summation. Once you done i will be incremented to 5, 5 is not less than 5, 5 is equal to 5. So, you will exit out of the loop, at this point you will have the correct sum,. So, the correct sum will be 25 and you exit on. So, the printf will come out on one line, it will say that the sum of given 5 numbers is 25. So, what I will recommend is, write the same program using a while loop and a for loop and see how you can easily go from while to for and for to while. The advantage of the for loop and the reason why for loop become,. So, popular among programmers is that, in comparison to the while loop, it is first of all it is easier to read. Because, you have all the initialization expression, the update expression and the test expression all on one line. So, you see what the loop is about. The second is that, it involves fewer lines of code, then the corresponding while loop. So, it is a very popular loop among programmers. Now, here is a syntactic convenient that C providers and let me make this remark as the final thing in this session. So, notices that we had to initialize two variables here. So, the first is sum was initialized to 0 and the second was that i was initialize to 0. Now, would not be convenient, if I could do this together and that is what C provides us. So, I have something known as the comma operator. So, the normal comma that we have seen. So, in order to initialize multiple variables at the same time, I can say sum equal to 0 comma i = 0. So, C will initialize the variables in the order, that it is given, first it in will initialize sum to 0 and then it will initialize the i = 0. So, here is a very synthetically convenient notation that C provide for as the advantage again is that you end up with fewer lines of code.  In this section, we will use the, for loop to code of the matrix problem. So, remember that we have seen while loop and we have seen a do while loop. Inside while loops we have written nested loops or double loops. So, let us look at a for loop which problem, where the solution involves a nested loop. So, the for loops are a good choice when the number of iterations is known in advance. So, a good example of such a condition is when you program for matrices, because the dimensions of a matrices are known in advance. So, let us consider a sample problem. So, the first line of the input has a number n now the matrix size is n X n and there are n floating point numbers in the matrix given row by row, each line contains a distinct row. Now, the problem is to compute the trace of the matrix, the trace of the matrix is the sum of the diagonal elements. So, it is defined as . Notice that the matrix row indexing starts from 0, similarly the matrix column indexing also starts from 0. So, let us write a c program to solve this problem. Now, you should be familiar with how we compute the trace of a matrix. So, for example, if that matrix is given as let say 1 2 3 4 5 6 7 8 9. So, the way we do it by hand is, look at the first row only this element goes into the trace. So, it is trace is 1 +, no other element of the row goes into the trace, in the second row the second element goes into the trace. So, it is 5 + and then no other remaining element goes into that trace and you go to the third row. And the third element goes in to the trace so, 1 + 5 + 9, this is how we do it by hand. You go row by row and then pick out for each row pick some element which goes into that trace only the diagonal element will go into the trace. Let us try to code this. So, in this we have two variables i and j which I will use to iterate over the row indices and the column indices n is the designator for the size of the matrix. For example, the dimension of the matrix is n X n. Now, a is the variable in to which I will read the current entry and then trace is the sum of the diagonal elements seen so far. I assume that it is an integer matrix, it is not general enough you can use a float variable as well. I will first scanf the size of the matrix n, the matrix is of dimension n X n. Once I have done that, here is what I was talking about in the previous slide, once you scan the number n you know that the matrix is n X n. So, the number of times that you are going to iterate is known in advance. So, the number of times that you have to iterate is known before you enter the for loop. In such cases the for loop is more convenient to write than the while loop. So, the outer loop is for each row from i = 0, to i = n excluding i = n you increment the row. Similarly, for j = 0 to n you increment the column index so, j is supposed to be the column index. Now, you scan the number a now if i = j remember that we wanted to add the only the diagonal elements. So, the diagonal elements will be when the row index is the same as the column index. So, when the row index is the same as the column index, you should add the corresponding numbers to the trace. So, once j becomes n - 1, you will fail the test j < n. So, we will exit out of the inner for loop, and you will go to the outer for loop. In the outer for loop you have i iterating over the row indices. So, you will go to the next row and do the same processing for the next row, until you hit row index n at which point you will exit out of the outer for loop. So, let us look at a sample input let say that you have 1 2 3 1 3 3 and -1 0 -1. Here, is a particular convenience that c gives you which I have used in this code. So, notice that this if block I did not put the braces. So, it could have been necessary to put the braces according to the syntax that we have discussed so, far. But if there is only a single statement in the if block then, we do not need to put the braces and it is syntactically correct to do so. So, let us just run the program on a sample input. So, we have some sample array 2 0 -1 1 3 4 -1 0 1. So, initially there is this number 3. So, you know that it is a 3 X 3 matrix. So, once you do that you know that n is 3 so, representing that it is a 3 X 3 matrix. So, then you start with i = 0 and go on until i less than n incrementing i by 1 each time i is 0 i < n, because n is 3. So, you enter the outer loop the first statement of the outer loop is itself a for loop, you start with j = 0 j < 3. So, you enter the inner loop you scan a number a, which is a floating point number and if i = j. So, remember that we are looking for diagonal elements. So, we are currently at this point and i = 0 and j = 0. So, we are entering we are scanning the zeroth element of the zeroth column of the zeroth row. So, that element has to go into the trace. So, i = j is true and then you say that trace = trace + a trace was initialize to 0 so, trace becomes now 2. Once you do that, you iterate the inner for loop. So, you go to the updates statement in a inner for loop j becomes j + 1. So, you go to the next column and the j < 3. So, you scan the next number 0 if i = j that is false now, because i is 0 and j =1. So, you do not execute the if statement and go to the update statement. So, j becomes 2, 2 < 3. So, you scan 1 more number which is -1, i is not j. So, you update again j becomes 3, now 3 is not less than 3, so, you exit out of the inner loop. When you exit out of the inner loop there are no more statements to execute. So, you go directly to the update statement in the outer loop which becomes i = i + 1. So, you are reading the first row, row number 1 you are finished reading row number 0. Again you scan the numbers when j = 1 that is the second number in the second row, you will see that i = j, because i is 1 and j =1. So, you will add it to the trace. So, that is 2 + 3 which is 5. So, trace gets updated and after you do that you scan the remaining entry in the same row, but it does not go to the trace, and then you have done with the row.  After that again you go to the outer loop you update the row index of the row index is less is 2 which is less than 3. So, you exit so, you enter the if condition and you execute the inner loop when i = 2 and j = 2 you will find an element which is -1 which will go in to the trace. So, the elements that will be added to that trace are when 2 3 and -1. Once you are done you get out of the inner loop and then you go into the outer loop and update it, but then i becomes 3 it is no longer true that 3 is less than 3. So, you have done reading all the rows. So, you exit the program when you exit the program you have the correct trace which is 4.  In this session we will see one more feature that is present in C associated with loops.  So, we will in motivate these statements using the concept of an infinite loop. Here is a drawing that supposed to be a representation of an infinite loop.   And a trivia, for example, the apple head quarters; the address is one infinite loop.   So, let us see what is an infinite loop? So, the basic or the simplest kind of infinite loop is when you have a while statement. And the test condition, you can see that it will never be false. So, remember that 1 is true in c. So, this statement means that you will enter the while loop, you will test the condition. The test is true, so, you will execute the statement. You will go back and test the condition again, it is again true, does not changed; it is 1. Therefore, you will enter the statement again. So, you will have an infinity loop. If the test is executed then the control enters the body of the loop, and this happens without any change. So, let us look at this simple while loop which is while 1. The statement is print f Hi! I am an infinite loop. So, if you will run this code, compile and run this code after you write the mean function and all that, then the program will keep on printing the same message over and over again. And you cannot exit out of the program. If you are running a Linux system you can press control c, and the program will exit immediately. But here is an infinite loop; it executes an infinite number of times. So, is there a statement which helps us to exit from a loop? Now, this is useful not just to handle infinite loops, even when you write normal loops it is important to have these constructs; they make your programming easier. So, c allows a programmer to explicitly break out of a loop using a particular statement known as break. When the break statement is encountered, the execution breaks out of the inner most loop. So, what is a loop? So far we have seen while loop, do-while loop, and for loop; later we will see a construct called switch.  So, whatever is the inner most loop, notice that we have talked about double loops, we have talked about the while loop within a while loop, we have talked about a for loop within a for loop, whatever is the inner most for loop within which a particular break occurs, it will exit out of that.  So, let us write a very simple program which reads all numbers still -1 is seen and adds them up; -1 is excluded. So, you will, you can write a while loop; you have written this before where the while loops test condition was somewhat most sophisticated. Earlier we wrote something like while, if you recall, if you, we had written a loop saying, while (!(a == -1)). So, this was the earlier loop that we had written.  And in this case, let us write a similar program, but with a simpler test expression which is just while 1. So, you always enter the loop, no matter what number you read. So, initialize the variable sum to 0, declare the integer variable a, and then you enter the while loop because the test is true; you scan a number; and here is a use of the break statement.  If the scanned number is -1 you break out of the loop; if it is not -1, you go to the next statement which is sum = sum + a. So, you add the number. Again you go back to the loop; the test condition is always true, so, you enter and read the next number. So, the net effect of the loop is that whenever you see a -1, it immediately exits out of a loop; otherwise, it adds that number to the loop. So, let us look at using a sample input. Initially, a, is undefined; it is just declared. So, it has some garbage value. And sum is initialized to 0. Let us say that the input is 5, 3, 2, -1. While 1, so, 1 is true; therefore, you enter the while loop; you scan f, the first number. So, a, becomes 5; a, is not -1. Therefore, you go to sum = sum + a. So, sum becomes 5.  And then you go back to the while loop; the test condition is still true, while 1. So, you read the next number 3; 3 is not -1. So, you add it to the sum; sum becomes 8. And you go back; the same thing occurs. So, you have the third number read which is 2; add it to the sum, and sum becomes 10. Then you read the next number; and now, a, is -1. So, what happens? The, if condition, the expression within the if statement is true; and you execute the statement inside the if condition, the statement is break.  So, recall that the rule of break says that exit out of the inner most loop. So, in particular, what is the inner most loop? You look, you starting from here, and imagine that you are going outwards towards the top of the program. The first loop that you will encounter on its way that is the loop that you will exit out of… In particular, break does not mean that exit out of the if condition; break means that exit out of the first loop that you see when you start from the statement and work outwards. So, that is this while loop. Break means you will exit out of that while loop and print this statement. So, you will print that the output is 10. So, let we have been dealing with integers for a long time. Let us write a small program using characters. So, here is a problem, and let us say that we are writing a very simple editor. Now, the editor has the following property. There are a particular number of maximum characters that you can read; maybe it is 1000. So, you can type in a bunch of characters until one of the two conditions occur; either you enter a blank line by itself which is indicating that I am done entering the text or you enter more than the maximum number of characters available.  So, recall, there are two conditions for exiting out of our so called editor; you can type a lot of characters, if your limit was 1000 and you exit 1000 then you cannot type in any more characters, and you exit. Otherwise, if you are within 1000 characters but you entered a blank line that is indicating that you are done, you have nothing more to enter, then also you should exit. So, there are two conditions. Let us try to write this code.  So, you have maximum characters. And let us say, I scan that. Then an, i, which counts how many characters I have read so far; so, i should initialize to 0. And then there is a current character, and then there is a previous character. So, I will initialize current to the new line character. Now, there is a particular reason for that which will become clear later. So, you should initialize current to a particular character.  And then what I do is, use the getchar function. So, getchar function reads a particular character from the input and stores it in some variable if you need to. Instead you can also say something like scanf %c, and some, into some variable. So, you can do either of these two things. And they are almost equal. So, you read one more character. Now, what should you do? You initialize by starting from 0. So, you have read no characters until now. And until you read maximum member of characters, so you execute this loop. Remember that I said that for loop is good when you know the number of iterations in advance. So, we know that atmost we will execute maximum number of character times because that is the maximum number of characters we are allowed to field. So, for loop is slightly better than a while loop. You can also do it using a while loop if you want. So, you say for i = 0, i less than maximum characters, i = i + 1. Now, we will do this programming style that we should be familiar with right now. So, previous becomes current and current becomes the next character; so, previous equal to current. So, this will store the current character into the variable previous. Then you read the next character using getchar. And as I said before, you can also write equivalently scanf (“%c”, & current). So, both these are almost equivalent that is a slight difference, but we will it is not important as of now. Now, if current is new line and the previous was new line, so, when will that happen? Suppose I write this is a sentence, I will explicitly represent the new line. So, when I press enter I will have a new line character here. And when will a blank line occur? When the next character is also new line. So, by a blank line what I mean is that the current sentence is over, so I press a new line; and the next character on the next line is also a new line; that is what is actually meant by a blank line.  So, when that happens then we know that an empty line has been encountered; and here is the important thing break because one of the conditions to exit out of that loop was that either at maximum number of characters is encountered or a blank line is encountered. So, you may not have encountered maximum number of characters, but you have encountered a blank line. So, you should exit out of the proof, exit out of the loop. Again the rule is that break out of the inner most for loop, inner most loop, which in this case is just for loop. So, you get out of that loop and printf a new line.  Now, as with many constructs in c, you can avoid break all together. You can write code if you have used break, you can right equivalent logic without using break. So, here is a standard way to do it. So, here is the code that we just dealt with. It had 2 exit conditions - one is that the number of characters that you read is greater than the maximum allowed; another exit condition was that you had entered a blank line. So, here we used the break statement.  And now I want to write an equivalent loop without using the break statement. And here is a very standard programmatic style. These are known as flags. So, flag is just a variable which indicates that a particular condition has occurred. Initialize flag to just 0. In our code, what flag is supposed to do is that it will indicate whether a blank line has occurred or not. So, let us first look at the body of the loop; without looking at the loop head first. Let us just look at the body of the loop. So, it is similar to what went before. Instead of the break statement, what I will do is, if I realize that an empty line has happened then I will set flag to 1; notice that flag was initially 0.  So, flag = 1 will indicate that an empty line has been seen. Now, I will modify the loop as follows. Remember that the test condition here is just that maximum number of characters has occurred. Instead, I will check for two conditions in the for loop. I will check that maximum number of characters have not occurred, and I will also check that flag is not 1 because flag is 1 means that a new line, a blank line has been encountered. So, I will check for both these conditions in the for loop itself. If either of them is true that is; sorry, if either of them is false that is if i is greater than or equal to maximum characters, or flag = 1, then the test condition will become false and you will exit out of the loop. So, here is a standard way to avoid a break. And notice that this condition is negated in the for loop because the condition in the for loop is the condition for entering the loop. So, to exit out of the loop you need flag = 1. So, in summary, what I want to say is that if you want to write a code using break, you can also write it without using break. One of the standard way to do it is by using a flag variable for whatever condition that we want to check. You can pick either of this style whichever suits you more. So, how do we decide whether to use the break statement or not? Sometimes the use of the break statement can simplify the exit condition. And on the other hand, it could also make the code a bit harder to read. What do I mean by harder to read? When I see the for loop in the code on the right hand side, it is clear that there are two ways to exit out of the for loop - one is i greater than or equal to maximum characters, the other is flag = 1. Just by looking at the for loop, I can say that, ok, here are the two conditions for which the loop will terminate - i greater than are equal to maxchar, or flag = 1. On the other hand, if you look at this left hand side code, I actually have to look at the body of the code to realize what are the ways of exiting out of loop. So, you have to understand the body of the loop in order to see what are the conditions for the loop to exit. It is not just i greater than or equal to maxchar. So, in that sense, the code with break is harder to understand than the code without break. It still recommended to use break when you have two or more exit conditions out of a for loop. So, typically programmers do use break and it is just a matter of style whether you we will use break or not; I myself prefer using a break. One final thing about the break statement; when you use break statement initially, it is important to notice that break causes an exit immediately out of the loop. So, remember when you have a for loop, the normal execution order is you initialize, then you test. So, this is step 1, this is step 2, then you execute the body of the loop that step 3, and then you update this is step 4, and then go back to the test condition. So, this is the normal execution order of the loop. When you encounter a break, you exit immediately out of the loop. In particular, when you break you do not go back to the update statement. So, let us examine what this code will do? You have, i = 0, i<10; increment i. So, you start with i = 0; i%2 will be 0%2 which is 0. So, it will say, ok fine, you need not get into the if condition.  Then i = i + 1; so, i equal to 1; 1 < 10; you enter the for loop; 1%2 is 1; so, you will break. When you break you immediately get out of a loop. So, when you print this then i will be 1. So, in particular, i is not 2, which is what will happen if you go back and update i = i + 1, before exiting out of the loop. So, the important thing to notice is that it is not 2, since i = i + 1 is not done when you break. When you break you get out the loop immediately without doing the update state.  We have seen the break statement, which is a statement used when you are in the middle of a loop and you encounter a condition and you want to exit the inner most loop. There will also be occasions in a program, when you are in the middle of a loop and you encounter some condition and then, you realize that you do not need to execute this iteration, you just can go to the next iteration. So, skip the current iteration. The break statement was, you encounter a condition and you say, I am done, I will exit out of the inner most loop. Here, it is not exiting out of the inner most loop, it just skipping the current iteration. For this, we will see the continuous statement and let us motivate this by an example.  So, continue the statement causes the next iteration of the closest enclosing for while or do while loop. Let us motivate it with a very simple example. Let us say that we are reading numbers coming in a stream and what we have to do is to skip the negative numbers. So, we have to read all the positive numbers and reading should be finally over, when you encounter some input which is not a number. How do we do this? Let us imagine that you have the main and things like that written and the central part of the code can be analyzed as follows. So, you have integer variable a and let us examine the code in closer details. So, what we need to do is, we may have an input sequence that looks like this, 1, -1, 2 and then .. So, let us say that the input sequence is something like this. What we will do is, we will do this scanf operation to get the numbers. So, scanf operation will read the first entry as 1, it will read the second entry as 1. The third entry as -1 and the third entry is 2 and so, on. So, that is what is scanf( “%d”, &a ), we are already familiar with this. But, what does = 1 mean? So, this is something that we have not uncounted. So, far the scanf statement has a return value, it gives you the number of inputs that was successfully read. For example, we are trying to read an integer in the %d specifier. So, when we try to read the first entry, it should succeed. So, this will succeed, when you try to read the second entry, it should succeed, when you try to read the third entry, it should succeed. In all these, the scanf %d will return a 1. Because, one entry has been read correctly. Here, it will fail, because it tries to read a natural number here, but what it see is a ., a full stop character and that is not a number. So, scanf %d will simply fail. So, this is what I said, it returns the number of conversions that have been successfully made. So, when you try to read an input like 1, -1, 2, . it was succeed in a first three scanf and the last scanf, it will fail. So, that is what the scanf is supposed to do. So, as long as you have read a number. So, while you have read a number, you examine whether it is a positive number. If it is a negative number that is, if a < 0, then you say continue which is saying that, I do not need to execute the remaining part of the loop. So, this part of the loop will be skipped, if a < 0. Continue means, go from here and start executing the next iteration of the loop. Let us go head and complete the code. So, let us modify the problem as a little bit, read the integers until a non digit is found. And let us do something with the positive integers. Let us say that we have to find the largest of the positive integers. So, what should we do? Again, let us try to do it by hand to get a feel for, what I will be doing? So, I have 1 -1 2 .. Let us say that I initialize the maximum to some reasonable value. Since, we are looking at the largest of the positive integers I can initialize maximum to 0. Then, I look at the first one, the maximum read. So, for. So, it is a positive entry,. So, I will update max = 1. Then, I read the next number and it is a negative numbers,. So, skip it. Then, I read the third number which is a positive number. So, I will update the maximum to 2. So, this is the part that we want to focus, if it is a negative number, skip. So, here is the code for doing that, while the currently read input is a number, that is why the %d succeeded and one entry was correctly read. So, if the number was read, check whether the number is negative. If the number is negative, continue. Continue means go to the next iteration of the loop. Do not do, what is remaining in the loop. So, if the currently read number is non negative, what you will check whether their current maximum is less than the new number. If it is less than the new number, you reset the maximum to the new number. So, this is the code that we have written similar to other codes that we have seen. So, you update the maximum number and go and read the next number. If the currently read number is negative, then we will say continue. So, we will not update the maximum. This is what the continue is supposed to be. Now, as in break you can also write equivalent code without using the continuous statement. So, let us try to do that and for doing that all we have do is, make sure that the maximum is updated only if it is a non-negative number. So, this says if it is a negative number, do not do the next statement. This says, if it is a non-negative number, then update maximum if necessary. So, it can be written with one more level of nested if. So, this is that if a is non-negative, then execute the next statement. Here. it says that if a is negative, then continue which means skip to the next statement. So, notice that these two conditions are the negations of each other. The long and short of it is that continue is not really necessary. But, if you have it, then it is useful and it makes the code clearer in certain occasions. What happens to continue in a for loop? Noticed that, for loop has the following form, you have for, then there is an initialization expression. Then, there was a test and finally, there was update and then, you have the body of the loop. What happens if you encounter a continue in the middle of the loop? In the case of a while loop, it is very clear, you go to the test expression, you go to the next iteration. The only contention is, in the case of a for loop, do you go to the update statement? And the answer is yes, then you skip the remaining part of the loop. So, this is the remaining part of the loop that you would skipped. When you skip that you go directly to the update statement. Notice that, when you do the break. So, if the statement has a break, you break immediately out of the loop without doing the update. In the case of a continue, you have to do the update. And as with the break statement, the continue statement is also redundant, you can program without using the continue statement as well. But, it is useful if whereas, already a few levels of nesting of the if statements inside it. We saw in the previous slide that, you could avoid continue statement by using an extra level of nested if statement. Now, if you do not want to complicate the code in that way, you can use a continues statements. Otherwise, in other cases you may want to exit out of the loop, in that case you can use the break statement. So, they are extra feature that the C language provides, they are not really necessary, but they are used with. Let us do a sample program using continue statements, I will introduce the problem initially, the problem is that of finding Pythagorean triples. By the way Pythagorean triples are numbers like are triplets of numbers like 3, 4 and 5. Because, you know that . So, the Pythagorean triples because there can be a right triangle, where let say the base 3, the altitudes is 4 and the hypotenuse is 5. So, 3, 4 and 5 could be the sides of right triangle, because they satisfy the Pythagorean identity. So, here is a problem we a given a stream of numbers and let us say there are n numbers. So, the initial number says how many other numbers there are. So, 8 says that there are 8 numbers to process, after you read n,n >=2, you have to read n integers and then you have to identify Pythagorean triplets occurring consecutively. By consecutively we will say that consecutive positive integers. Because, in the middle there could be negative numbers sees you have to just ignore them. For example, you have that 3, 4 and 5 are consecutive, positive entries in this data. Because, -3, -4 and -5 are negative numbers. So, consecutive in this context need not mean that they occur together, it just means that, if we ignore the negative numbers and between then they are together. So, we have to identify all such Pythagorean triples. So, in this case the Pythagorean triple in the input sequence is 3, 4 and 5. So, let us try to code it. I hope you see how it can be done? So, let us try to do it my hand. So, let us say that I have and then some negative numbers in between and so on. So, some positive numbers, some negative numbers in between till I find the... So, I have let us if four, six numbers. So, the input is of the following for what I need to do is, at any point I may have to remember some triple. So for example, the first triple that I will find is the following. So, this is the first number, this is the second number and this is the third number and what I have to do is to check whether, . So, this is what I have to check? Now, suppose that 1, 3 and 4 are not a Pythagorean triple, they are not. Because,  is not . Then, what do you have to do? You have to advance all these first, second and third variables. So, let us try to advance the third variable, the next interesting number is 5, because that is the next positive number. So, the next iteration should check for the following, this should be the third number, 4 should be the second number and 3 should be the first number. If you do that, then you know that  and you will indentify a Pythagorean triple. So, what we do is, that we have to shift all these variables, first, second and third by one positive entry. So, this is what we have to do, we have to remember three numbers, the current number that we have seen, the previous positive number that we have seen and the previous to previous positive number that we have seen. So, this is one situation where you need to remember three variables. And once you check whether the current triplets satisfy it, if you satisfy it fine. If you do not satisfy it, you have to advance the variables by one. So, first will take over second, second will take over third and third will go to the next positive number. So, this is the method of programming this, let us try to code this out. So, we will write the code as follows, we need three variables, the current number, the previous number and the previous to previous number. Currently will leave all of them undefined, n is the number of integers to read, i is we will eventually try to do. So, for the for loop we need a counter. So, I will basically count from 1 to n to ensure that n numbers have been read. I will also have an extra variable call count, i is suppose to count the numbers seen so for and count will count the positive numbers seen, so for. So, I need two half them in this code I mean in that. Now, after you do that you scan the n, which tells you how many numbers are there in the input? Now, a for loop has to go here which will do most of the work in the code. So, let us see what that loop looks like? So, recall what we did by hand, you will look at the current number which is the next number to read, if the next number is 0 or less than 0 you say continue. So, this is the application of the continue statement here. So, if says if the current number is not positive, you just go onto the next iteration of the loop. Now, here is some logic which is not easy to read, but we can motivate it the following, if the current number that I have seen is the first positive number. When obviously, then this was the first number that I have read. Therefore, there was no previous number and there was no previous to previous number. So, I will because this the first positive number that I am reading, then I will just set there the previous to previous number is the current number, also I have seen one positive number. So, I will say increment count, count = 1. So, if the current number that I have seen is positive and it is not the first positive number. That means, if count = 1 I already seen one positive number, then what to you do is, you know that there is a previous to previous number, you set the previous number to the current number and you continue the loop setting that count = 2, which says that I have seen two positive numbers. So, I have a previous to previous number and I have a previous number, now I will read the next number. This is because in order to identify a triple, you need at least three numbers. So, previous to previous and previous should already been to some positive values in the input, this is why we initially said that, we need at least two inputs. So, we will go back to the loop if count = 1, otherwise let us say that count is at least 2, so it is 2 or more. So, in this case we will just say that as for as count is consent I do not need to keep track of how many positive numbers are needed? It was used only to see that I have at least two positive numbers to begin with. So, that I can add the next number as the possible third number in the triple. So, I will not update count from now one, you can also do that, but count after words serves no purpose. So, I will say that count is 2 and I will just adopt the convention that it will remain to. So, I will seen at least two positive numbers, now I have also a third number in the current. So, you have previous to previous, you have previous and you have current. So, these are the three numbers that you have. So, what you have to check is, whether. So, that is what we will check, we will check whether previous to previous square plus previous square is equal to current square, if that is true then you have found the Pythagorean triple. So, you will just say that I will printf that I have found the Pythagorean triple, which is found by previous to previous, previous and current. Now, what I will do if the Pythagorean triple is found is that I will advance previous to previous by one. So, previous to previous will become previous, previous will become current. So, recall that figure that I first true and then we will go back to the loop. So, this is the code for kind identifying the Pythagorean triples and the encodes exactly the logic that we did by hand. In this session, we will learn about one more fundamental data type in C. So, far we have seen ints and floats. Ints are supposed to represent integers and floats are supposed to represent real numbers. We will see the third most important data type which is character. So, it is called char in c or char. C allows a character data type to be 1 byte that is 8 bits wide, and 1 byte can hold exactly one character. For example, a character may be a digit like 0 so, on up to 9. It can be lower case letter like a up to z, it can be upper case letter like capital A through capital Z and so, on. Similarly, there are other characters question marks and sharp and so, on. So, how do you declare a character variable, how do you assign it and how do you print or scan it. So, these are the basic operations that you can do with any data type. So, you declare a character variable using the data type char ch will declare variable of name ch and of data type char. In order to assign it to any particular constant, any particular character, what you have to do is, you write ch = ‘A’. So, this is how you would assign any character in constants. All the character in constants are supposed to be enclosed in this single code. For example, ‘0’ stands for the character 0 and not the number 0 and similarly, a within single code stands for character a. Now, how do you prints print a characters you can use the format specifier %c. So, recall that %d prints an integer and %f prints of float, we have the third fundamental data type which is character which can be printed using a %c. So, if you say print f %c ch, it will print a. There is also an abbreviator notation where as soon as you declare the variable, you can initialize it using character ch equal to a. This is similar to saying int I equal to zero. It is the same concept. Now, what can we do with a character data type? For example, we can assign character constants to those characters variables. Now, what does a character variable mean? Here is the first surprise. The value of a character constant is an integer that the machines represent, machine stores which is usually the ASCII set. What does this mean? The machine deals with fundamentally bits. So, you have a data field which is 8 bits wide and this is sequence of bits say 1 0 1 1 0 1 1 1. Now, here is the bit pattern and if you see that this bit pattern is a char, then the machine takes this integer, takes this bit pattern as an integer and looks up a table known as the ASCII set table and sees which character it is. So, the value of the character constant is actually an integer. What does that integer represents? The integer represents a particular entry in an ASCII character table and what entry is in that particular location, that is the character constant. So, think of it like the following. The character is just an uninterpreted sequence of bites. If you tell the machine, please read this as an integer, it will read this as an integer. If you read this, if you tell the machine please read this as a character, it will take that integer, go look up the ASCII table and see that this integer stands for the character c and prints that. So, by itself the bit pattern can be interpreted in multiple ways. So, here is a surprising thing which is different from natural language. There are certain natural languages where this does not typically happen with Indian languages, but there are certain languages where you have a character and how you read it depends on where you saw it. So, if it was in the middle of a text, then this is an alphabet. If you saw this in the middle of a numbers sequence, then it is a number. What happens in the machine is somewhat similar. You have a bit sequence and this thing is interpreted as a character by looking up the ASCII set. ASCII stands for American Standard Code for Information Interchange, and it is one of the popular encodings for characters used in computers. So, the code chart looks something like this. You have 256 characters and characters can be looked up in a table. The table entries are in hexadecimal so, base 16. We will come to that little in the course why basic 16 is convenient,, but there are 8 rows and 16 columns in the table. So, in base 16 notation, a stands for 10, b stands for 11, c for 12 so, on up to f for 15. So, this is what is meant by base 16 notation. So, let us look at what does the number 7 a represent. 7 a is row 7 column number 10. So, that is the number that I am interested in. What does 7 a represents? It means 7 times 16 plus 10. So, in base 10 notations, the number 76 let us say so, if I have this number 7 in base 10 notation, this; obviously, stands for the numerical values 7 into 10 plus 6. Similarly, in base 16 notation, 7 a stand for 7 into 16 plus 10. Remember that a is 10. So, you have 112 and similarly, hexadecimal 2 3. So, row 2 column 3 for example, hexadecimal 2 3 means look up 2 time 16 plus 3, the 35th entry in the table. Now, here is the structure of the ASCII code set that you use in c, the first 32 characters basically from 0 0 hexadecimal to 1 f hexadecimal. So, these 32 characters which are shaded, are what are known as special characters, and they are not printable. They are required by the computer for certain special purposes. Code 2 0 that is decimal 32, 2 0 is 2 times 16 plus 0. So, this particular entry corresponds to the space characters. So, this is just a blank space. Code 21 corresponds to the exclamation character and so, on. So, the printable characters in the ASCII code are hexadecimal 20, that is decimal 32 until 126. So, what is enclosed in the green parenthesis, these are all printable characters. Now, out of this, the capital letters start from x 41 which is 65 in decimal and go on up till decimal 90. Small letters start from 97 and go on till 122 and so, on digits 0 to 9 occur before any character. So, why we need this information? This is how the characters are stored in the computer and do we really need to know it?  The point is not that you have to memorize this table. You do not need to memorize the table, but you need to remember certain abstract properties of the table. We will make that precise in a moment. We do not have to say that the ASCII code for a is 65 or 42 that is a waste of our memory. So, let us just see what we can do with this table without really remembering what that table looks like. So, there are some ideas behind the design of the table, how the table is structured which c programmers can use. There is no need to remember that a particular character has a particular ASCII value. So, let us just recall. A character constant is an integer, namely the ASCII code for that character now which means that I will emphasize this with a very strange code. I can declare character ch and say char ch =‘A’ that; obviously, initializes the character to a. It assigns the value a to the variable ch, but I could also do the following characters ch = 65. Why 65? The ASCII value for a was 65. So, instead of writing it as a within single code, I can write ch = 65, and it will be the correct ASCII character anyway. Now, this means that the same character can also be interpreted as an integer if you really want to think of it that way. So, for example, I can say %f %c ch if I do it in print f, it will print it as. So, the first print f will print a, but I could also take a character variable and ask c to print it as an integer using %d, it will print 65. So, remember that the external form that we see in some sense is the letter a. The internal representation is the number 65 because 65 is the entry in the ASCII table corresponding to the character a. Now, one more thing is that you can print arbitrary numbers, even non-printable characters you can sort of print them using c and one way to do that is I can print any 8 bit character with a hexadecimal representation like \s, \x followed by the hexadecimal to digit. For example, \x followed by 7 is the bell character. So, let me go back a couple of times, couple of slides. So, if you look at the 7th entry in the ASCII table, it is represented as bell. It is a small bell in your system. So, if you ask the system to print the 7th character in the ASCII table, what will happen is that your computer will make a small beep sound. So, there are certain non-printable characters which can also be printed directly using… ok. Similarly, let say \xb is the 11th number in the ASCII table, it is a vertical space. So, if you print that character, it prints a vertical space. Similarly, if I ask it to print hexadecimal 41 using \x41 so, x 41 is 4*16 + 1 which is 64 + 1=65 and we just saw that ASCII value 65 was the character a. So, if I ask it to print ch which is hexadecimal 41 as a character, then it will print the value a. So, when you run this program, what it will do is, first because you ask it to print a bell character, it will beep once, it will ring the bell and then, it will print the second character which is a vertical space. So, it will print a vertical space and then, the third character was a printable character a, it will print a. So, you can ask the system to print arbitrary entries in the ASCII table. If it is a printable character, it will print that corresponding character. If it is non-printable character, it might take a suitable action. So, just for information sake, instead of printing it as \x followed by the x code, c provides certain escape characters, some special sequences as well in order to print these non-printable characters. First of all until now we have seen one such number which is \n. So, \n is the new line character. It is a non-printable character, but it corresponds to some ASCII corrected. Similarly, for the other non-printable characters, c has some escape characters. For example, back slash a is the bell character and so, on. In the previous session, we were talking about ASCII character set. And I said that,  we do not need to remember the ASCII table. But, we need to remember some general properties of the ASCII table. So, what are those general properties? First, we know that the initial 32 characters of the ASCII table are non printable characters. Then, the remaining or rather from ASCII value 32 to ASCII value 126 are printable values. Among them, you know that the integers, the digits are occurring together. Similarly, the capital letters occur consecutively, one after the other. And the small letters occur consecutively, one after the other. So, this is an abstract property of the ASCII code chart that, helps us in writing some useful code. We will see in a minute, what kind of use we can obtain using these general properties. Rather, than knowing the specific things like, the character value of A is hex value 41 or decimal value 65. This kind of information, we need not remember this. For example, let us write a small program that prints… In our previous session, we had said that, we do not need to remember the exact ASCII code of certain characters. We just need to remember some abstract properties of the ASCII table. For example, abstract properties like all the digits occur together from 0 to 9. All the capital letters from A to Z occur together in the table, in the alphabetical order. Similarly, all the small letters occur together in consecutive locations in the ASCII table. Also, another property that you can observe is that, the small letters occur after all the capital letters. Let us see, how we can write some interesting code using these properties. And not by remembering the exact ASCII code of certain letters. So, let us write a simple program, to print the alphabet. The ASCII codes of the upper case letters are consecutive and the ASCII codes of the lower case letters are consecutive. This is the property that, we will exploit in order to print the alphabet. So, for example, let us say that, we are going to print the letters of the alphabet in capital letters. So, for that we can use the following program using a for loop. So, what you have to do is, to initialize a particular character variable to capital letter A so, the ASCII character A. So, note that A within single codes stands for the character constant A. If you look at the integer value, then it is the ASCII code for A. We are not particularly interested to know, what exactly the number is. Now, we can write the for loop in an interesting way. We can say that, start from capital A and then, print the characters until you hit capital Z. And the update statement is, after printing go to the next ASCII letter. So, what this is doing is, starting from A and then, it will go to A + 1, which is the ASCII code for B. Then, it will go to B + 1, which is the ASCII code for C, so on up till Z. So, once you reach Z, it will print that character. It will update once more, where it is the ASCII character one more than, the ASCII character next to Z in the ASCII table. We do not really need to know, what it is. But, certainly it will be greater than the ASCII value of Z and at that point, we will exit the code. So, the output of it will be consecutively A to Z. Let us look at, what is happening here in greater detail. All the characters are stored as 8 bit integers. Now, they can be assigned as integers, incremented, decremented, etcetera because, essentially they behave like integers. So, suppose A has ASCII code 65, but we are not concerned about that. Now, so ch equal to character constant A, sets c h equal to 65. Now, ch + 1 is the number 66, which corresponds to the ASCII code of B. So, addition, subtraction all these can be performed on character values because, internally they are represented as 8 bit integers. Similarly, relational operations like less than, greater than, <=, >=, all of these also make sense. So, for example, if we use the relational expression capital letter A, ASCII constant A less than character constant B. Then, notice that A is the ASCII value 65 and B is the ASCII value 66.So, A less than B is correct.  Now, for realizing that A less than B is correct, we do not need to know that, A is 65 and B is 66. All we know is that, the abstractly in the ASCII table, the character code for A is less than the character the code for 6 because, B occurs after A. So, if it is 65 and 66 or it is 0 and 1, the answer is still the same. Now, let us write a few more interesting programs, where the spirit is that, we do not need to understand what the exact ASCII code of a letter is. But, just we want to remember the layout of the ASCII table. For example, suppose I want to write a conditional expression an if condition, which says that, if the given character is capital letter, then print that, it is in upper case. So, all I need to do is, if the character value is >= the character constant A and <= the character constant Z. Then, you print that, the given letter is in upper case. Again, please remember that we did not need to know that, this was 65 and this was, whatever it is 90. It could as well have been 0 and 25. It would still have worked because, all we are need to remember in the ASCII table is that, A through Z occurs in consecutive locations in the standard alphabetical order. From that we can understand that, if I write this if expression, it will print up the message upper case, only if the given character ch is an upper case letter. Similarly, let us say that, if you want to check whether a character is in lower case. You can analogously write, character is >= ‘A’ , ‘a’. And it is <= little z, in single quotes. If that is true, then you print that, it is in a lower case. Now, if you want to check whether a given character is a digit, similarly you can say that, it is >= the character 0. And this is <= the character 9. Now, here is a suttle point which I hope, you notice. The character 0 is the ASCII constant, ASCII character constant 0. So, it corresponds to some particular ASCII value. It is different from the number 0. So, this is something that... So, we are looking for the ASCII value corresponding to 0 it is >= that and <= the character value corresponding to that character 9. So, if that is true, then the given character is a digit. Now, here is a snippet that, I would advise you to take a look at it. And tell me, what it actually does. So, take a moment yourself and try to figure it out. So, what it does is, the given character ch, if it is a lower case letter. Remember, this is the example that we just saw. This condition checks, whether the given character is a lower case letter, a small letter between a and z, little a and little z. If it is true, then what you do is, add capital A - a, to the character. So, what does it accomplish? So, let us say that, we actually had c h equal to little a. Now, for the purpose of illustration let us say that little a, was ASCII value 100. I do not know, whether that is true. But, it is not important. That is, what I want to illustrate. Now, what does capital A represent. It represents some ASCII value let us say 65. So, if the given character was little a, what I would do is, I would say character = ch - 100 +65 Similarly, if ch was character constant b, I would still add ch = ch - 100 +65 So, it is adding a constant difference to the given character regardless of what, whether it was a or b. The additive constant that we are adding is still the same. And if you think about, what is happening it is adding, exactly the difference between little a and capital A. Notice, that the difference between little b and capital B is the same as little a and capital A. Why? Because, all the capital letters occur consecutively and all the small letters occur consecutively. So, suppose a minus z, little a minus capital A is… Let us say 35, then little b minus capital B will also be 35, because you advance one in each case. So, if you think for a minute, you will see that what this code does is… Take the ASCII code corresponding to the small letter. And add a constant difference. What is that difference? That difference is, what will take you to the capital letter, corresponding capital letter.  So, in short what this does is, to convert the given character in lower case letter to an upper case letter. So, if it is a lower case letter, it will convert it to an upper case letter. Otherwise, it does nothing. Now, let us think about, what we mean by scanning a character verses scanning an integer. So, let us say that I have two variables, in number and character letter. So, let us say that I am scanning now n, which is a number and the input was 12. So, when I say scanf( "%d", &n), I am trying to read 12 into an integer variable. Now, on a typical machine an integer variable may occupy 32 bits. or 4 bytes. So, it has 32 bits in it. And if you know the binary notation, you will see that 1100 in binary is the number 12. So, this is 8 + 4, which is 12. So, when you see that, the input is 12. And then, I ask in the c program, I am doing scanf( “%d”, &n). What will happen is that, n is an integer with 32 bits wide. And it will have the following pattern encoded into it. This is what, it means by scanning an integer. And if you try to print it out, it will try to interpret n as a decimal number. And it will print and the digit 12, here the number 12. On the other hand, for the same input, here is the difference I want to emphasize. If the code was saying, %c and letter, so scan the input 12 using the scanf statement, scanf %c and letter. What will happen is that, the c program is looking at the first character, which is the digit 1 and scanning it in. Now, character 1 is ASCII 49 it is not important, you remember that. But, it has some ASCII value, and that ASCII value 49 is 31 in hexadecimal because, it is 3 * 16 + 1, which is 48 + 1= 49. So, that character 1 is 31 in hexadecimal. And hence, what will be stored? Remember, that a character ASCII character is 8 bits wide. So, it will store 31 in hexadecimal. So, it will be 3. This is the number 3 and this is the number 1. So, when you scan the input into a character variable called letter. What will happen is that, letter will have the number, hexadecimal 31 or ASCII value 49, which corresponds to the number, which corresponds to the character constant 1.  So, this is the difference between scanning a given input as a number and scanning a given input using a character. So, when you scan it using a number, this entire thing will be scanned. It will be converted into binary and you will store it in an integer variable. When you scan it as a letter, it will scan the first digit only because, that is the character and then store the ASCII value, inside the letter variable, inside the character variable. So, this corresponds to the letter variable 1 within a single quote, the character constantIn the session, we will discuss operators and expressions. So, we have already used C expressions in our programs before. And expressions in c are similar to expressions in mathematics and they follows tools, similar to what mathematical expressions also follow. They are a basic unit of evaluation and each expression has a value. Say, that an expression returns a value of a particular type. So, let us consider a few example expressions. For example, I have the following, a is 3, b is 4 and I have a variable c, which is just declared to be of type A. And then, say that c = (a * a) + (b * b). So, the right hand side of the assignment operator, this is a assignment operator. And the right hand side is an expression and that expression has sub expressions, a * a and b * b within parenthesis. So, an expression can be made up of variables, it can be made up of constants. These are the atoms or the basic components of an expression. And sub expressions can be combined into bigger expressions, using operators. Now, operators can be unary that is, they take one argument operation. For example, on unary operators the examples can be , which is the unary -. For example, -3 is a negative number. Similarly, NOT operator that we have seen in connection with logical operations so, NOT of zero, for example, the logical negation operator. Both of these operations take one argument. Now, there is also the binary operations like +, -, *, etcetera. So, + takes two arguments. For example, an expression like 2 + 3 and here is the binary -. So, if I say 2 -3, this is actually a binary operator which takes two arguments, which are 2 and 3. Similarly, the binary multiplication 2 * 3 would be the product of 2 and 3. So, notice the difference between… It is the same sign for the unary - and the binary -. But, the unary - takes only one argument and the binary - takes two arguments. We have used the assignment operation many times and let us understand that in, somewhat more detail. For example, if you consider the expression b = b + 1. Now, if you remove the semicolon at the end. So, the statement is b = b + 1 semicolon. And if you omit the semicolon, what you get is an assignment expression, b = b + 1 without the semicolon.  So, how does the assignment operation work? For example, consider an expression like a = (b = 10). What does this do? So, assume that a and b are integer variables. Now, assignment assigns to the left hand variable, left hand operand, the value of the expression on the right hand side. For example, in this assignment operation there are two assignment expressions. One is the expression b = 10. And the second is the expression a = b = 10. So, the first assignment expression is supposed to do the following, assign 10 to b. So, what it does is, it assigns the value of the right expression which is 10 in this case to the left hand side operand that is one thing, it does. And also, it returns the value after the assignments. So, 10 has been assigned to b. And the return value of this expression is 10. So, we can now analyze a = b = 10, as follows. First, evaluate the expression in parenthesis. The expression b = 10 has an assignment operator. So, evaluate the expression on the right hand side and then assign it to b. Now, that operation returns. So, that expression returns a particular value, which is 10. Now, the original expression can be thought of as, just a = 10. This is evaluated as usual. So, you take 10 and assign it to a. And the return value of the whole expression becomes 10. So, when executing this expression, when evaluating this expression, two variables are assigns their values. One is b, which is assigned the value 10 and the second is a, which is also assigned the value 10. The assignment operation can be used to initialize a number of variables, in one shot. For example, if I write a statement like a = (b= (c = (d= (e=0)))). What does this mean? Now, here there is some ambiguity here, because we do not know which order to evaluate this. Should, we evaluate from left to right. Should, we evaluate from right to left. Does it matter? So, should the assignment be treated as the following, where a = b is done first, then, = c, then, = d and. So, on. Or should it be the opposite way right to left, where e = 0 is first done. Then, d = that, then c = that,. So, on until a. So, the expression is evaluated from right to left, in the case of the assignment operation. For example, the above expression that we just saw will be done as, a =… So, e = 0,  first and then backward, until a is assigned. Now, this is also the standard mathematical convention. We are not introducing a new strange rule, here. Why is this? First, we will evaluate the inner most expression, which is e = 0. So, e will be assigned 0, then the return value of this sub expression. So, this sub expression will return the value 0. So, this becomes d = 0, d is assigned the value 0. And the return value of this sub expression becomes 0. So, then we have c = 0 and. So, on. So, finally, every variable here will be assigned the value 0. So, the reason for doing this is that, if you try to do it in the opposite way, you will see that uninitialized variables are initialized to other uninitialized variable. For example, if you go from left to right, in the previous. This simply does not make any sense, because you have just declared a b c and. So, on. And when you say a = b, a and b are not initialized yet. So, this assignment hardly makes any sense. The basic rule of assignment is that, left hand side = right hand side. So, the left hand side is some value that can be assigned to. For example, this is a variable. The right hand side can be anything, variable, constant or it can be an expression. So, all these are valid assignment. So, what is an invalid assignment? So, a = 0 can be a valid assignment but, 0 = a. So, the assignment operation is evaluated, right to left. Now, we have the concept of associativity of operators. So, what does associativity mean? It is, we have just argued that, a = b = c = d = 0. An expression like that will be evaluated from right to left. So, it is as though, we have parenthesized the expression as d = 0, inner most. Then, c = that, then b = that and. So, on. So, on the other hand, if you take an operator like binary + the addition symbol, then the usual custom is that you parenthesis from left to right. So, the evaluation is done, a + b first. Then, that sum is added to c. Then, that is added to d. So, the assignment operation goes right to left. The addition symbol operates left to right. So, this concept of associativity of an operator tells us, the order in which we evaluate the operations, if there are multiple occurrences of the same operator. So, the first there are multiple occurrences of the = sign. In the second, there are multiple occurrences of the addition symbol.So, associativity rules tells you that, if there are identical operators in an expression, in which order do you evaluate them? Do you evaluate them from left to right? If you do, then it is called a left associative operator. If you evaluate from right to left, in the case of, for example, the assignment, then it is called a right associative operator. Binary - is also left associative. For example, a - b - c - d is evaluated as a - b, then c then - c, then - d. So, for example, if you say 10 - 5 - 15, what will be done is 10 - 5 and then - 15. So, this is 5 - 15, which is - 10. Whereas, if the parenthesis had been in the opposite way, it would be 10 - 5 - 15, which case it could be 10 -, this is - 10 which is 20. Notice that, this is not how you are supposed to do it, even in mathematics. So, the way that c does handles the associativity of the binary operation, is correct. So, the correct parenthesis is 10 - 5 and then - 15. In general, for every operator c defines an associativity. So, let us see the part of the associativity of operations in c. There are several operations that we have seen,. So, far. The parenthesis, the Boolean naught, the logical naught and the unary -, the binary multiplication, division and. So, on. Addition symbol, comparison less than, less than or = and. So, on. Equality, logical AND, logical OR and then the assignment operator. We have seen, all these operations,. So, far. And of this, the typical associativity is left to right. There are couple of exceptions, one we have already seen. Assignment operation is right to left. The unary operations are also right to left. Most of the other operations are left to right. So, if you think for a little bit, you can see that the associativity for unary operations is also easily seen to be right to left. That makes more sense. So, the idea is not that you should memorize this table but, you should understand. Given the table, can I understand, what will happen with an expression? How c will evaluate it? It is not that, you should remember this. But, rather if you are given the table and an expression, can you correctly calculate what the value of the expression will be. This one more concept that we have to understand, before we really understand how c evaluates expressions, that is the concept of precedence. So, what do we mean by a precedence? Let us pick a expression which involves multiple operators. Like for example, in this expression you have two operations, the assignment operation and the addition operation. Now, how do we know, how to evaluate this expressions. So, what are the two ways in which the above expression can be interpreted, the first way is you could say a = b and then say + c or you can say a = b + c. To decide which of the above possibilities to really do, c also defines what is known as a precedence between operators. So, we have already seen in the notion of associativity which is what happens, when the many occurrences of the same operator occur in an expression. Precedence on the other hand is to mediate between two different or multiple different operations in the same expression. So, let us see what is an example of using precedence. So, in c the + operation is given more precedence than the = operation. So, I really want to interpret this expression as a = b + c. So, this is how I want to interpret their operation and not as a = b + c. So, I want to avoid this and I want to do it in this way. So, one way I can ensure that is by saying that, please do b + c first, then take that result and assign it to it. So, one way of doing that is to say, whenever = and + appear together give more importance to +, do that first. So, proceed means going first. So, + has a greater precedence over assignment + and - have the same precedence and both have the same associativity we have seen this, addition and subtraction have the same precedence,, but multiplication and division have a higher precedence. So, if I want to evaluate a complicated expression, let us say that a + b - c * d % e / f. So, suppose I have a fairly complicated expression, what I can do is, what are the operations here? So, the operations are +, -, *, % and /. Now, according to the precedence I know that *, % and / have equal precedence about + and -. So, I know that these operations have to be done before + and -. So, they have a lower precedence. So, these have to be done first,, but among them how do you know which to do first, for that we use the left to right associativity of these operations. So, as for as with in the same precedence is concerns, let us just simplify this situation in a little bit and think of them as the same operation, their different operations of the same precedence. But, I will just the thing a little bit to say that, let say that they are the same operation, all of them have left or right associativity. Therefore, I will according to the associativity rule I will do c * d first, then that % e and then that / f, because that is what the left to right associativity it says. So, by precedence we will know that these three operations have to be done first, among them how do you do this, * occurs first when you scan from left to right. So, c * d has to be done first and then the % operation and then the / operation. So, and once you done there then you come to + and -. So, currently once we have finished with this, you will have some situation like this, c * d % e / f and then on the remaining side you have a + b - this. And now you have to decide, which may you will do the + and -, again we know that they have the same precedence. So, let us found a little bit and think of them as the same operator, both of them have the left or right associativity. So, I do a + b first and then the -. So, with in the same precedence level, you will decide which operation to do first purely based on the left to right associativity. So, let us take a look at the precedence of associativity table. Again I want to emphasis is not to memorise, it is just that if you are given this table, you should be able to understand how an expression is going to be evaluated? So, parenthesis is above all because once a parenthesis an expression, then you really saying this is the order that I want. So, it over writes any other precedence or associativity rule. Then, you have the unary operations which have the second higher precedence, then the arithmetic operations, then the comparison operation, logical operators, assignment and so, on. The comma is an operation we will see later. So, with in the arithmetic operations multiply, divide and % operator have higher precedence over + and -. + and - have higher precedence over relational operations, like <, < or = and so, on. So, we will see a few examples of how to use this table to understand what will happen with an expression?So, let us take 10 + 5 * 4 % 2 and assign to a, let us examine what will happen here. So, what I will do is I will make a list of operations. So, they are =, +, *, % and then precedence I know that multiplication and % have very high precedence. Then, the next level is + and then assignment has the least precedence. Now, both of these occurring in this expression * and %, how do we decide which goes first, both of them have left to right associativity. So, whatever happens first in the looking from left to right, we will do that first. So, among all these operations we know that 5 * 4 will happen first, then this will be followed by % 2 and then this will be followed by 10 +. And finally, the last which is that you do all these operations get the value and assign it way. So, this is the way in which the above expression will be evaluated. So, the above expression corresponds to giving the parentheses in the wave that we have done. So, once you do that a will get the value 10. Let us see a few more examples of expression evaluation in C; what kinds of expressions are allowed, what kind of errors do people usually make, and so on. Let us say that we have given an expression a = 1, b = 1, c = 2. And then we have an expression a < b and then b >= c. So, this is the expression that we want to see how it will be evaluated. So, let us just go through it systematically. The operations on are <=, then we have the logical AND operation the >= symbol. Of these, the relational comparison operations <= and >= – have greater precedence over the logical AND. So, the precedence will be AND. And among operations of the same precedence level, we have left to right. So, whatever happens first when looking from left to right will be evaluated first. So, these two operations have the same precedence. So, we will have (a <= b); then (b >= c); these have to be done first and then AND. So, this will be done first, this will be done second, and this is the third operation. Conceptually, using just precedence and associativity rules, this is how the expression should be evaluated. So, when we evaluate it, a < are = b is 1 < are = 1. So, that is 1. b >= c is 1 >= 2. So, that is 0. So, this becomes 1 and 0; in which case, it is 0. Now, let us look at a few tricky examples. So, if you have an expression of the following form, if a = b > 1; then c = 1. So, let us see what happens here. We will do the same thing; operations sorted by precedence is… There is greater-than symbol, which has a higher precedence over the equal-to symbol. So, the expression a = b > 1 will be evaluated as b > 1, because that has higher precedence. So, this goes first. And then a = b > 1. Now, b is 2. So, b > 1 is 1. So, you have a = 1. And a = 1 is an assignment expression. It assigns the value 1 to a. And the return value is 1 because a is assigned to 1. So, then this whole if expression becomes if 1 – c = 1; in which case, we know that, c = 1; that statement will be executed. Now, typically, what is expected… The typical programming style is to say something like a assigned to b; and if that result is > 1. So, we may want to deliberately violate the precedence. How do you do that? So, C does it some way; if you do not parenthesize it, you can always change the order of evaluation in C by introducing parenthesis, so that the meaning is very clear. So, if you do not parenthesize it, then a = b > 1 is the same as a = b > 1. But, what if you really want to do a = b and then that > 1? So, that case, you parenthesize it. Why? Because parenthesis has the highest precedence. So, whatever is within parenthesis will be evaluated first. So, = b will be evaluated first and b is 2. So, a will get the value 2. So, the assignment a = b will have returned the value 2. And 2 is > 1. So, it will execute ((Refer Time: 05:17)) One particular way in which such an expression can be seen; we have already seen such an example is – you read all integers from the terminal until a -1 is read. So, suppose the input is of the form 3 2 -1; and then let us say dot or something of that sort. So, what this expression does is scanf returns a value, which is the number of tokens that – number of inputs that, it was successfully able to read. So, if you try to read a character as an integer, it may not succeed. And so, as long as you have correctly written the integer and the integer is not -1, then you do a particular ((Refer Time: 06:19)) So, this is the kind of expression that is often used; where, you assign some value to a using the assignment statement. Or, maybe you want to check the return value of a function whether it is positive or not. And based on that, you want to write a condition. So, the logical and operation does operates in the following way. It evaluates the left operand first. If this condition is false, then you know that, the whole expression is going to be false. If at least one of the terms is false, then you know that, the whole thing is false. So, it will not even evaluate the second operand. On the other hand, if the operation is true, then it will check whether the second operand is true. If the second operand is also true, then the whole expression is true. If the second operand is false, then the whole expression is false. This method of evaluation is also called short-circuiting because it may not evaluate the whole expression in order to get the result. So, if I know that, this expression is false; then there is no need to evaluate this, because I know that, the whole expression is going to be false. Here is a common mistake that people do, because this is similar to mathematical notation. When you want to check a condition that a is between 1 and 5; what happens if you right 1 < a < 5? Because this is the way we do it in mathematics. C will apply the precedence and the associativity. In this case, it is the same operation. So, only associativity applies. And according to associativity, it is left to right. So, this will be evaluated as 1 < a < 5. Now, a is 2. So, 1 < a is false. So, this becomes 0. So, the whole thing is 0 < 5. So, it is true. So, if you execute this code, it will eventually become an infinite loop, because this is an expression that always evaluates to true. Now, what you probably mean is that, I want to check that, a is between 1 and 5; a is 2. So, the correct way to write such an expression would be 1 < a and a < 5; that will check the betweenness condition. So, notice that, this is different from the way we normally write in mathematics. This is how we would write such a test in mathematics. But, that will cause an infinite loop. This is because C will apply the precedence and the associativity rules and not what you think it should do. Now, let us look at can there be expressions, which make no sense? We have seen several examples, where you can always make sense out of it. So, let us take this expression. Again, list out the operations; see you have = =; then you have the % operation, which is highest precedence; then you have minus; then you again have an =; and then you have a +. So, these are the operations in the expression. So, what needs to be done first? b % c. And then you have -a; and then you have a + 1. This is by following precedence and associativity rules. Now, we come to the assignment statement. Assignment statements are done right to left. So, the first thing that you would try to do is the following. So, you try to do the… So, here is a sub expression; here is a sub expression; here is a sub expression; and here is a sub expression. So, it is like assigning four terms. And the innermost thing will be done first; the rightmost thing will be done first. So, the rightmost assignment is b % c -a is assigned to a + 1. Now, this is a syntax error. So, what happen is as we just discussed if you work out the whole assignment; if you workout the whole expression, it becomes something like this. And somewhere when you work out the assignment from right to left, you will see that, it is trying to assign a number -3 to -7. That does not make any sense. The left-hand side of an assignment statement should be an assignable value, which is essentially a variable. And in this case, you are trying to assign a number to another number, which does make sense. So, here is a syntax error. We will conclude the discussion on operations with one more operation, which is quite common in C; which is the ; operator. Now, this is not very common in mathematics. But, let us just discuss what does it mean in C. So, let us say that, we have two expressions: expression 1 and expression 2 separated by a ;. Now, think of the ; as an operation just like any other operation like + or minus. So, it must have a precedence it must have an associativity and so on. So, what will happen when we have an expression like i + 2 ; sum = sum -1. So, how does it follows? First, you evaluate the expression 1. So, first, in this case, you evaluate i + 2; then you evaluate sum = sum -1; and return the value of the lost expression. So, the whole – the ; operation is involved in an expression called the ; expression. Every expression has a value and the value of the ; expression will be expression 2. So, what if you have multiple expressions? You figure out what is the associativity of the ; expression. The ; expression associates left to right. So, this expression will become scanf and so on; sum = 0; i = 0. So, this… For the first ;, this is expression 1 and this is expression 2. So, this expression evaluates to the result of sum = 0; which is 0 as we know. Now, the second level is you have 0 ; i = 0. So, the first ; expression is evaluated and its result is expression 2 of that expression, which is a value of sum = 0, which is 0. So, the outer expression becomes 0 ; i = 0. The value of that expression is the value of expression 2 in that bigger expression, which is the value of i = 0. So, here is how you will apply the rule that, it is the value of the second expression for a more general expression involving multiple commas. So, what you do is – first, evaluate the first expression and it has some value. For example, in this case, it is an assignment expression. So, it will have value 0. And then the second expression is evaluated. And the value of ; expression is the value of the second expression. Note that, you may… At first sight, you may see multiple commas in the same expression; but the way you do it is that, you group them using associativity rules into a sequence of ; expressions, where each ; expression has exactly two terms. This is what we did in the previous example. Now, ; expression is very convenient, because you can do things like when you want to initialize multiple variables in a for loop for example, you can just say sum = 0, ; i = 0. It will initialize both values at the same time; both variables at the same time. So, ; are evaluated left to right. This is what I just worked out an example of the following form. So, if you have multiple sub expressions in a ; expression; if we have multiple ;, what you do is you associate them just like you did with + and star; you have multiple ; expressions. And then group them two at a time. So, it becomes two ; expressions. And then evaluate them. Now, the ; expression has the lowest precedence of any operator in C. So, if you have an operation like a = a + 5 ; sum = sum + a, what will happen is you do this expression a = a + 5; then do this expression sum = sum + a. And then evaluate the ; expression. And therefore, when you have a ; expression, you do not need explicit parenthesis, because the precedence takes care of it; it has the lowest precedence. So, it will never get swallowed into a bigger expression, which involves other operations. So, it will always be evaluated at the end. So, just to remind you, here is the table once again. And notice that, as we discussed the ; operation is the lowest precedence and the associates left to right. This is also a slightly different meaning of the ; in C. We will just mention that in passing. There is also the normal separator. So, the separator can be seen in multiple occasions in C. When you initialize an expression; when you say sum = 0, ; = zero, ; j = 0; this is not the ; expression; it is just a separator as in English. So, similarly, when you call a function, you have ; to separate out the arguments. That does not mean that, the arguments are inside a ; expression. Here ; is just a separator as in English. And it is always clear from the context whether a ; is a separator or an operator. As an operator, it has a particular value; as a separator, it does not do anything other than saying that, this first and then this. So, we have seen several operators in C and discussed the concepts of precedence and associativity. And what is important is – given the precedence and the associativity tables, can you understand an expression; see whether it is a valid expression, and if it is a valid expression, what will be its value. In this session we are going to introduce a new concept of programming in C called functions. So, initially, let us just try to motivate why we need functions, and then we will try to see whether programming becomes easier, if we have functions. So, let us say that, why do we need functions? There are essentially two different reasons for it. And I will mention these reasons one after the other. The first reason is to break up a complex problem into simple sub problems. All of us, for example, like to drop to do less saying that these are the things I wish to accomplish today. So, step 1, you know, get to college, step 2 - attend classes, step 3 - finish home work or something like that. And then each of those main task will have several sub task. In order to get to college, maybe you need to renew the ticket subscription, get on the bus, get to college, and so on.  So, each of those higher level task involves several search smaller sub task. And conceptually, it is cleaner to say that these are the big level things that I want to do. Each of those big level task have several sub tasks, so that I can think of it, what I want to accomplish in a layer wise manner. So, this is something that we do intuitively. We always break up complex problem into simpler sub problems so that we can analyze the simpler sub problem and perform it completely, and then come back to the bigger problem. So, we need to solve it each separately.  And the main tool for this programming in C which allows you to accomplish breaking up a complex sub problem into simpler sub problems is what is known as functions. So, this enables you to do what is known as modular programming in c. And functions are not new. We have already seen three functions in particular - main was a function that we always wrote, and then we have printf and scanf which we use for outputting and inputting respectively. So, let us just motivate the notion of functions by using the second motivation that I was talking about.  So, suppose, you have, you want to say, I want to compute , which is , correct? So, this is the definition of n choose k for  as it is known. Now, suppose I want to write this, n code this into C program, so I will have, let us say, a main function. And then inside the main function I will have, let us say, three variables – a, b, c, and then float result because the result of a division will be a float. So, I will have, what should I do intuitively, one way to do it is I will have a block of code which says it will calculate n! which is the numerator, then I will say that a = n!; at end of this, let us say, that a stores n!.  Then, I will have another block of code which says that I will calculate k!. And then this will say, let us say, b = k!. And the third block of code will calculate n - k!; let us say, I will store this in c. And then I will say, ok result = , some code that looks like this. And you would notice what is inconvenient about it; all these three blocks of code, once we complete it, will look very similar. They are all calculating the! of a particular number. But, there is nothing in c, which will, that using the features that we have seen so far, which will tell us that this code, this code and this code are essentially the same, and I need to write that similar code only once. So, there is no simple way to use loops to accomplish these. So, it seems like this redundant business of writing similar code again and again can be avoided. So, this is the second motivation for introducing the notion of functions which is basically to avoid duplication of code. So, here is a side benefit of functions, avoid code replication. We have already seen loops to some extend avoid code replication. But, here is a newer method to avoid code replication in a greater unit. So, the second reason why we write functions is to avoid writing similar code again and again.  So, let us try to write functions by motivating it with the help of an example. This example will show the benefit of how we can avoid code duplication using functions, and also how we can breakup a complex problem into simpler sub problems. So, in this I will introduce the problems similar to what have we seen before. We have a sequence of numbers. The first number tells you how many inputs there are. And then what we need to do is to pick out the numbers which are relatively prime in these sequences. So, two numbers are relatively prime if there gcd is 1. So, 16 and 7 are relatively prime; 4 and 6 are not because they have a common factor of 2; 6 and 16 are not, they have a common factor of 2; 16 and 7 do not have a common factor other than 1; 7 and 8 are similarly relatively prime; 8 and 9 are relatively prime; 9 and 10 are relatively prime; and 10 and 11 are relatively prime.  So, these are the relatively prime pairs. And we need to write a function which given a sequence of these numbers count how many pairs, how many successively occurring numbers are relatively prime to each other. In this case there are 5 such pairs. So, in this problem we can clearly see that there is a sub problem which is, given two numbers are they relatively prime? That is one sub problem. And if we have the solution to that sub problem then we can compose the solution to the whole problem as follows. Given two numbers, I check whether they are relatively prime. If they are relatively prime I will increment the count of the relatively prime pairs I had seen so far, otherwise I will skip to the next pair and see whether they are relatively prime. So, for each new pair of numbers I am seeing that is the sub task of checking whether they are relatively prime.  So, let us say that suppose we have a function; a function is something that we will see in a minute. Suppose we have a small component which will perform the task of testing iscoprime a, b. So, iscoprime a, b, that function will take two numbers a and b and check whether they are relatively prime or not. If a and b are relatively prime it evaluates to 1. It is, we say that it returns 1 if they are relatively prime; and if they are not co-prime to each other, if there not relatively prime, then it has to return as 0. So, it has to evaluate to 0. Now, associated with every function there are three concepts. We will see them one by one. There is this declaration of a function which says what does the function look like, what is the type of the function. So, the declaration of the function will be written in the following way. It will be written as int iscoprime ( int a, int b ). This means that iscoprime is the function name, and then it takes two arguments - a and b which are of type int; so int a and int b. If we had written another function which takes a float a and int b, we would say, function int, float a, int b.  So, in this case we are taking two integers as arguments, so you have to say, int a, int b. A small syntactic point that you have to notice, that, you cannot abbreviate this as int a, b; so that is not allowed. Each variable needs to have a separate type signature. So, these are called the input arguments. So, that is the second part of the declaration. The first part of the declaration, the first, which says that, it is an int, is actually the type of the return value. So, the return value is 1 if the pairs is co-prime, and it is 0 if the pair is not coprime. So, the return value is an integer. So, we need a function name, we need a declaration of the input arguments. The arguments need to be named, and the return value of the output.  So, let us say how do we design the higher level function? So, here is how you use functions when you program. You assume that the function is already available to you, and it does what it is supposed to do. Using that how do I build the solution to the whole program? So, in this case, let us just assume that we have written int iscoprime; we have written that function. And we are interested in, how do we build the solution to the entire problem using that?  So, how do you do that? Use, have a flow chart which reach numbers one by one. And count is the number of co-prime pairs that you have seen so far. So, you check whether you have seen n numbers. If you have not seen n numbers then you read the next number and check whether the previous number and the current number form a co-prime pair. So, you give iscoprime prev current; it will return 1, if they are co-prime. So, that will get added to the count. If there not co-prime, they will, it will return a 0. So, count will remain as it is.  Once you do that you say prev is = current, and indicate that you are going to read the next number. This is similar to other problems where we scanned this bunch of numbers and did some function based on that. The new think here is the iscoprime function which we just assumed that it is correctly written, and it does what it is supposed do. So, this is the function declaration. Now, how do you code this up? You basically code this up in c, just as you did it with other program, other functions like scan f. You just say, count + iscoprime previous current. So, this is how you can encode the flowchart including the function called as a C program. Now, let us come to the interesting part which is, how do we design the int iscoprime function? So, the top is the declaration part of the function where I say that what is its type. So, the function name is iscoprime. It takes two variables a and b; a is of type int, b is of type int. And it is supposed to written in integer value. So, that much is clear from the type declaration the type signature so called of iscoprime.  Now, what you do with it? You say that, so this is the classic gcd code; you declare a t variable; if a is less than b, you swap a and b. And this part of the code is just calculating the gcd. This is code that we have seen before. And at the end of that, a, will become the gcd. If a and b are co-prime then a, will be 1. If, a, is any number greater than 1, then they are not co-prime. So, if, a is = 1, you return 1. And for returning, you use the keyword return. So, you return the value 1; otherwise you return the value 0. So, this is how you write the function iscoprime. So, now we have to put both these go together. So, I will say, include <stdio.h>; this is the first line of the code. Then I will have the source code for iscoprime. So, I will write that. And afterwards write name function, so that, when main calls iscoprime function, then we already have the code for iscoprime available. First this line, then the iscoprime function, and then the main function. So, let us look at the function in somewhat greater detail; a and b are what are called the formal parameters of the function. They are viewed as variables. Now, the formal parameters are visible only within the function. So, we say that their scope is inside the function.  Now, there is, this is what is known as the declared definition of the function. Every function can be called. Notice that we have already called the functions like print f and scan f. So, once you define a function you can call a function; calling a function will be evaluating that function with particular arguments; you can do that. So, when you call a function you execute the function with the given arguments. So, 5 becomes a, and 6 become b. Once a function call is encountered what happens is that formal parameters are mapped to actual parameters. So, a becomes; so the value 5 is copied to a, and the value 6 is copied to b. This process of copying values is known as parameter passing. Then what you do is, you store the return address of the call. The return address is the line of the main function where the function was called. So, let us say that it was called in the second line of main. Once the function finishes it has to come back to this point.  Now, in addition, we also create a box for storing the return value. At the end of function either 1 or 0 will be returned. So, we also need some space in memory to store that return value. So, to look at it in slightly greater detail, so let us say that iscoprime 9, 4 is called in step 20 a. So, this is the address; 20 a by which I mean it is line 20 and some location a. So, now, you have to allocate the space for the return value; store the return address and pass the parameters. Now, at, when you pass the inputs, 9 and 4, the space is allocated for, a = 9, and b = 4. This is the process of parameter passing. So, we visualize the memory as a stack. So, when you start the programs you start executing from line 1 of many; so x is initialized to - 1. And then you come to the function called iscoprime 9, 4. So, when you execute this you do the following: you allocate the space for the return value, you pass the parameters and then execute the function, and finally pass back the return value.  So, when you execute the function you imagine that the stack is now divided into a separate space. So, here is a clean separation between the memory that is required for main. So, above here is main, and below here is the memory required for iscoprime. So, in that I have stored a box for return value. I have stored the return address which is 20 a. And then I have, a = 9, and b = 4. Now, I will execute the function as though memory is limited to here. So, I will declare t, and then execute the gcd algorithm. So, this is stuff that we have seen before. And finally, a is the gcd which is 1. If a is 1 we have to return 1. So, the value 1 will be copied to the return value, and that is the value that will be passed back; so x will be 1. So, the return value will be copied back to the main function.  When comes to C functions, we have seen the following concepts. One is the declaration in the definition of the function by which I mean the declaration is what type is the function? What are the input arguments? What types are the input arguments? And what is the result return type? So, these form the declaration. Definition is the logic of a function. So, this is what is known as the declaration and the definition of the function and we do it only once. So, function is defined only once. Once we define a function we can of course, call the function multiple times. So, definition is done only once and calling can be done any number of times. Now, we refer to a stack which is, what is the central concept in executing a function. Stack is just a part of the memory, that goes only in one direction. So, that is what it is supposed to mean. Basically, you can think of it as a stack of boxes or a stack of paper on a table or a stack of a plates. So, it grows in one direction. So, the stack grows as the main calls of a particular function, that function calls a different function and so, on. And you can imagine the stack is growing upwards or growing downwards. It does not matter. As functions get called it either grow keeps growing upwards or keeps going downwards. We will usually represent it us keeping growing downward. So, let us look at this function that we were talking about earlier. So, n choose k is n factorial upon k factorial times n minus k factorial and let us try to code this up. We know that factorial is something that we will need over and over in this program. So, let us say that I write factorial as a function. So, factorial takes an integer and returns an integers. So, the declaration is int fact int r, r is a input argument and the return type is int. Now, inside that we will write the code for factorial. All variables declared inside the factorial or local or private to the factorial function, they cannot be seen outside. So, the input argument as well as any variables declared inside factorial or private or local to the factorial function. So, I have i and this encodes the logic of factorial that we have seen earlier. So, you start with the product equal to 1 and keep on multiplying the numbers, till you reach r factorial. So, once you reach r you return the r factorial. This logic is something that we have seen before. Now, we will see how do we put this together in order to produce the function. So, what we need to do is? We will just encode this solution that we have. So, it is (fact(n)/fact(k))/fact(n-k) . So, here are the encoded just a logic.  So, I will add slightly larger code, this is not proper c code. I let us say that I have three extra variables which have declared of int t1, t2 and t3. Now, t1 will be factorial of n, t2 will be factorial of k and t3 will be fact(n-k) , have separated this out. So, that, I can clearly explain what happens when the code executes. Let us say that I want to calculate 4 c 2. Now, first when the program starts executing, you start with code on the first line of the main. So, you scanf n and k. So, n is 4 and k is 2. Now, use do t1 = fact(n) . So, when t1 = fact(n)  is called, what you do is, you set up the return value and return address. So, return value is not yet decided to return address is 5, because, you have to go back to line 5 of the code. So, that is why the return value is 5. Also what you need to do, you need to copy the parameter value which is 4. So, this is the actual parameter 4 and you have to copy it to the input argument r. So, r is the input argument, r should be assign to the value n here, n is 4. So, that is known as passing the argument. Now, once that is done the code can be seen us jumping to factorial. So, as soon as the function is called, you actually pass the execution to the factorial function. Now, inside the factorial function you have two in local variables i and ans which is answered. And we start executing the factorial function. So, let us see what happens, when we execute the factorial function. So, far we have passed the arguments and so, on. Now, I have just hidden the part of the stack that was used for name. And let us focus just on the factorial function. This computes the factorial function, that we are familiar with this nothing new here. So, it has a variable I which keep track of how many times it has loop has executed and r is notice 4. So, you compute the factorial of 4. Finally, when r = 4 ; ans = 24  now, this 24 value we say return the answer value. So, answer value is 24. So, this will be copied to the return value location. So, the return value will get the value 24 and now jump back to return address. So, return address is line 5. So, will jump back to line 5 and there we will say that t1 = 24 . Only the return value is copied back to the main program all other things are irrelevant. So, the correct way to imagine what happens. When the function has returned is that, the stack that was allocated to main to the execution of fact is completely erased. So, once we go back to main as soon as the function returns back to the main. You should imagine that the entire stack is deleted, and only the memory that was originally allocated to main remains.  So, the correct way to think about a function executing, you can imagine that, you are main and you have a friend, who can calculate factorial for you. Now, you can ask your friend to calculate factorial for you and things are done in a very hygienic manner. So, what you do is, you write on a piece of paper the number 4 and give it your friend. Now, your friend is another room. So, he has at his disposal some black board. So, he looks at the number 4 and using the private local variables that he has, which is i and a result or answer, he calculates the factorial of these numbers. Once see does that, he copies the result back on to a piece of paper. So, 4 factorial is 24 and brings it back to you. Before he does that, he erases the black board and he will bring back the number 24 on a piece of paper. Now, you can imagine that the space that your friend used to compute 24 has now been wipe clean. And all that remains is the value 24 which you can copy back on to your note book. So, this allegory tells you exactly what happens in the case of function execution. You write down what you want the factorial of on a piece of paper, pass it your friend, he will go to a separate room. And he will calculate whatever he wants. Once he does that, he will clean his black board, right down the result on a piece of paper and bring that paper back to you. So, as far as you are concerned you are least bothered with how he is computing the factorial function. All you want as the result. And this is the basic way to thing about functions. You should be able to reason out a bigger program by saying, what does as a smaller program, what does as a smaller function do regardless of how that function does it. Now, let us get on with the remaining execution. We have just computed factorial of 4. Now, we need to calculate factorial of 2 and factorial of 4 minus 2. So, we go to the next line, the next line also involves the call to factorial of k. So, we do the same things again, we save the return address. Now, the return address is 6. Because, we are executing line 6, then we create a box for the return value and pass the parameters, and finally, jump to the called function. So, we do all that we have some memory for main. But, we allocate a new space in the stack for executing factorial. At this point return address is 6. Because, it is a second factorial that is being called, r is 2, because, k is 2 and you execute the factorial function. So, you again go to the factorial function and calculate 2 factorial, 2 factorial is 2. So, that will be transferred back to the return value And now you can imagine that, you will get back to the address 6, where t2 will have the value 2. So, once you do that again the thing to imagine is that, this slate is wiped clean. And all the memory that you allocated to the stack is now free. So, all once you are back in main all you have as the memory for me. Now, there is the third call to factorial. Fact(n-k)  and it is done in exactly the same manner without much elaboration. So, it will create n - k is 4 - 2 which is also 2 and the return address is 7 equation n. And once you do that, it will execute the factorial code again, and calculate the factorial of 2 which is again 2 and return to line 7. So, 2 will be copied as the return value and once the execution finishes, you return to line 7 of main program. At this point, you say that t3 = 2. And you can imagine that the stack allocated to factorial is now erased. So, at this point main has t1 = 24 , t2 = 2 and t3 = 2. You have all the information that you need in order to calculate your result. So, you calculate (24/2)/2 and the answer is 6 which is 4 choose two. So, this illustrates how do you write a function? How do you define a function? And how do you call it? And what actually happens when you execute a main function? So, the execution of a function can be visualized as a stack. A stack is a part of memory, that is allocated as private to a new function that is being called. Once that function finishes execution, the stack is erased and you go back to the previous function. And you go back to the calling function. We have been talking about designing programs using functions. And the general  philosophy is that, you have a large task that you want to accomplish and you break it in to sub task, may be each of those sub task are split it in to smallest sub task  and so on. So, break them until some sub task can be easily solved by single function. And then, you put all these function together in order to solve the whole problem. So, design your program from top down, big task decomposing into small task and so on. And debug your program or make sure that they are free of errors from the bottom up. So, test each functions thoroughly and then test the overall program. In this, we will discuss a few technical details about how C executes its functions. In particular we will see how C passes arguments to it is functions, and also how does a return values. When passing arguments will talk about issues like evaluation order, in what order are arguments evaluated, if there are multiple arguments. And we will discuss what are known as side effects. So, let us start by considering a very simple example. I have very simple function called sum which just adds up two variables x and y which are integers. Therefore, the return value is also an integer. Now, inside the main program I will call a = sum(a,b). A is 1 and b is 2. And then, you will sum this up and the return value is assigned to a. So, this is suppose to do 1 plus 2 3 and a is assigned the value 3. So, after passing the parameters sum is called with x as a, which is 1 and y as b which is 2. So, sum returns 3. So, the return value is 3 and the 3 is assigned back to a. So, when you print it, the output will be 3 followed by 2. So, this is simple enough. Now, let us try, slightly more tricky example. So, here is the novelty in this example. Some instead of being declared with x and y are now being declared with two variables called a and b. The main program also has two variables, named a and b. So, what will happen here? The output is the same as before. So, 3 2 if you compile the program and execute it, it will be same as before. So, what really happened here? After passing the parameters sum is call with a as 1 and b as 2. And so it returns a value 3 assigned to the a of mean. Now, these variables are called a and b in main and they are called a and b in sum as well. Now, the variables a and b inside sum are different from the variables a and b inside main. So, the scope of these variable is mean and the scope of these variables a and b is the sum function. So, in other words the a and b inside sum has scope just this function, they are not visible or addressable outside especially in main. So, if you want to think of it, you can think of them as sum.a, sum.b. So, they are the a variable belonging to sum and the b variable belonging to sum. So, even though you would think that this a and this a may get confused they are actually different variables. One is the a variable belonging to main, and the other is the a variable inside sum and they are different, even though they have a common name.  So, now let us a try a slightly more elaborate program, what happens if you have sum(sum(a,b),b), this is the program. In this case what will happen? So, first evaluate the in a program, in a function sum of a b. So, a is 1 and b is 2. So, that will return 3, then you add b again to it b is 2, you have 5 as the total sum. So, the total the complete output is a will be assigned 5 and b is still 2. So, this is similar to evaluating a normal mathematical expression. One thing that we need to take care of is to handle expression with side effects. Now, what are expression with side effects? So, let us classify expression into two kinds, one is what are known as pure expressions. So, they are the normal mathematical expression, like a- b * c/d and so on. Similarly evaluating function, these normally do not have any effect other then returning you the value. So, they will they will be correctly evaluated and they will return some value, other than that, they have no effect. Now, expressions with side effects change the state of the program. For example, when I execute an expression a = a +1. Now, this is an expression, it has a value. So, let us say that a was 1 before a = a +1. A plus 1 has value 2 and a is assign the value 2. The state of the program involves, for example, what values are stored in the variables. When you execute the expression a = a +1, the value of the variable a changes. Contrast this with previous expression, like a minus b star c slash d. You can see that, unless you assign to something no variables value is changing, it will just evaluated and the value will be return. Here, the value will be returned also variable a is changing. Here, in this second function you have two arguments, two function f. The first is the expression a = b +1, the second is an expression b = a + 1. This might sound like a very strange way to code. But, you know that any expression can be given as arguments. So, in particular assignment expressions can be given as arguments. For example, a = b +1 is an assignment expression, which is given as an argument to the function. Now, such expressions are called expressions with side effects, because, the change the state of the program. When you have side effects you should be careful. For example, what will happen in the following program? You have function int minus(int a, int b) and it returns b - a. Now, in this program main calls the minus function with two expressions as arguments a = b +1 and b = a + 1. They are expressions with side effects, because, once evaluate these arguments, you know that the variable a will change in the first expression and the variable b will change the second expression. So, what will happen in this program? So, how should we evaluate it? The general rule is that all arguments are evaluated before the function call is made. So, before the function is executing, we know that a = b +1 and b = a + 1 both will be executed. But, and here is the major problem, we know that both have to be executed. But, C does not specify in which order they have to be executed, so, it was the left to the compiler. So, let is evaluate it in first in left right order. So, this expression first and then b = a + 1. So, what will happen then? a = b +1 b is 1. So, a will get the value 2, b = a + 1 will be executed after that a is now 2.  So, b will get the value 3. Now, you execute minus. So, you will return 3 - 2 which is 1 and b has value 3. So, this is the expected output. But, when you run it on some machines, you may get the output -1 3. So, what happened here? Now, this happens for example, when the compiler would evaluate it right to left. So, when you evaluate it right to left what will happen is that b = a + 1 will be executed first. So, b = a + 1, b gets the value 2 plus 1 3. And then, you will execute a = b +1, b is now 3. So, a gets the value 4. So, when you call minus of 4 comma 3 minus will return 3 -4 which is -1. So, in this case you know that b gets the value 3, a gets the value 4 and the result will be -1. So, what was the mistake? The mistake was that we assume that both arguments will be evaluated before the function is called. But, we assume that it will be evaluated left to right. And the first expression will be evaluated before the second expression, that is the reasonable assumption to make. But, c does not guarantee you that, c leaves this decision to the compiler. Now, compilers may evaluate arguments in different orders. For example, a very common order is right to left. So, both answers like 1 and 3 and -1 and 3 are both consistent with the c specification. Now, this is the very troubling is scenario, what should we do? So, we should write this function in such a way that, they do not depend on whether the arguments are evaluated left to right or whether they are evaluated right to left. So, write expressions in such way, that they are free of side effects, when you pass them into functions. So, how do we do that? We can do the following. For example, if we really wanted the left to right order, that is if you want a = b +1 to happen first and then b = a + 1. Why not write them explicitly that order in the main function. So, first this will be executed then b = a + 1 will executed. So, a will get the value 2 and then b will get the value 3. So, minus ( a, b) will execute as 3 - 2 in which case you will get 1. So, the important thing to note is that, in this particular function called, the arguments do not have any side effects. Because, we explicitly coded them up before to specify that, this is the order in which I want. If put it here, then it is up to the compiler, the compiler can do whatever is best in for several criteria. So, now let us come back to what the  function, we have the function definition which is the entire function. The logic of the function is what is known as the function body. And the heading is what we call the type signature. The type signature has for example, two arguments a and b these are call the formal parameters. Now, we focus on the return expression. So, return followed by some expression is the only mechanism for returning the value from a function. If the type of return expression does not match the declare type of the return. So, if for example, a is of a variable which is different from int. In this case they are the same, then it is fine. But, otherwise the return expression is converted to this type and then returned. So, it might lead to some undesirable variable. Now, we have discussed parameter passing’s in when passing parameters in c, the values from the calling function are copied to formal parameters in the called function. So, the actual parameters are converted to the formal parameter type and separate copies made. So, this is known as call by value. So, formal parameters and local variables are the function are accessible only within the function, we have already see in this. And memory for the formal parameters and the local variables of the called function will be erased as soon as function returns. So, executing return any where inside the function will immediately return from the function. And transfer control back to the calling function at the specified return address So, when you execute there are few things keep in mind. Whenever, you execute any return expression, it will cause the function to immediately return. Now, main is a function so, we can use return statement inside main what; that means, the main will immediately stop execution. That is the whole program will stop execution. Now, when you return a particular value, the calling function may choose to ignore the value. For example, let us say that I write some dummy function int f and it takes two argument float a and int b and we some code here. And then, I have the main function in which I have two variable int x and float y. Then, I have some code and here is the interesting thing, I call f(y,x), y is an float x is an int. So, I am find, but this function returns an integer value. But, I am not assigning it to anything. So, I am not saying something like x = f(y,x). So, this is not required. So, if this is the case, then why call the function in the first place? This is, because the function also may have side effects. So, remember that side effects are something some expressions, we change the state of the program. So, functions may have side effects, your already seen one such function which has the side effect for examples, scanf. So, the side effect of calling scanf is that the input from the keyboard is copied into some variable. So, function may have side effect, this is why you can call the function and choose to ignore the output or the return value. Now, just for curiosity sake executing return will calls the function to immediately return to the return address. Now, the return value if you omit it, then the return value is unpredictable. So, here is a example, you should in general avoid doing things like this. But, just for completeness, I am supposed to return a float value instead if I just say a return, the program will compile. But, when you execute some unpredictable behavior may result. So, the printed value in this case can in general will not predictable. With the concepts we have seen so far, let us design a sample program. So, the… What we … The problem that we want to solve is we want to write a program that reads the input line-by-line, and counts how many lines has the user input. Program should terminate when the end-of-file character is encountered. So, we will try to solve this problem. By the way, the end of file is a character, which you can enter using control-D if you are running Linux. So, the flowchart at the very top level can be envisioned as follows. So, we will just check has the end-of-file been reached. If the end-of-file has not been reached, you read the next line. If it is has been and check again. If the end-of-file has been reached, then you halt; otherwise you read another line. So, here is the very toplevel picture of what we want to do. So, this design is just meant to read the input lineby-line. So, it is a very vague flowchart, but at the top level, this is what we want to do. So, let us say more details about how we are going to accomplish this. In particular, we want to see how we can read and put line-by-line. So, here is the top-level design. And now we are going to essentially expand this box. We want to say how do we read the next line. So, let us design the read next line box. So, the read next line box, first you read a character and then you check whether the character read is new line character; that means that the user has pressed an enter. So, the line is ended at that point or the user can enter a bunch of characters; and instead of pressing enter, press control D. So, the user can enter end-of-file. If either of these are true, then the line has ended. So, you halt. Otherwise, if the character is neither new line nor end-of-file, then you read the next character. So, here is the design for the function to read the next character – next line. So, you read character-by-character; after every character, you check whether a new line or an end-of-file has been encountered. If either of them happen, then the line has ended; otherwise, you go back and read another character.  So, let us start by writing the top-level function. So, let us translate the top-level function into code. So, here we will introduce a new concept called what is known as a forward declaration. So, when you define a function, you can either give the logic – the full function body when you define the function or you can just say that, here is what the function will look like; here is the type signature; basically, it is taking no arguments and it will return an integer value. And I will terminate that statement by using a semicolon; which says that, this function… I will currently just say the type of the function; I will define the function later. This is done, so that we can write a function, which uses this particular function. So, when we write a function, which uses that function, the type of the function should be known. For that we can just declare the type of the function. This is what is known as a declaration of a function. Unless you define the function, you cannot use it; but in order for another function to just see what the function looks likes, declaration is sufficient. So, let us design the top-level function. So, we declare this function that, we will use in this function that we are about to write. So, this user function will be called read all lines. Now, in that, we will keep a line count initialized to 0; and then I will keep a flag called isline. Now, what this will do is we have to check for whether an end-of-file has been reached or not. For that, I will use the function feofstdin. We will see that in a minute. While the end-of-file has not been encountered, you say that, read next line; read next line will return a 1 if a line has been encountered; otherwise, it will return a 0. So, line count will be incremented by 1 if I read another line; otherwise, it will remain as it is. Finally, you return the number of lines read. So, this is a realization of the flowchart on the left. Now, there are a couple of things that require explanation. First is that even though the read next line function has not yet been defined, just based on the declaration, I can say that, it is going to return an integer and I can use the integer here.  The other thing is what do we mean by feofstdin? So, what do we mean by the function feof? So, feofstdin is a function that is part of the stdio library. We have already used other functions from that library. For example, printf and scanf. Now, the feof function – what it does is – it returns a function; it returns a value 1 if the end-of-file has been encountered in the input argument. So, stdin means that, I am using the standard input, which is the keyboard input. So, if and end-of-file has been entered via the keyboard, then feofstdin will return 1. So, stdin is usually the keyboard input. And usually, if the user enters the control D character, then feof will say 1, because end-of-file has been entered.  Now, let us design the function to read a line. We earlier wrote a function, which assumed that, there is a function, which will read the next line; and based on that, I will keep on reading lines until the end-of-file is encountered. So, we are now about to write the bottom function. So, we want to read a line. So, we have already drawn the flowchart for that. Now, let us try to make it into code. So, we have to design a few variables; we will have int ch for reading a character; we will come to that in a minute; then we will keep a count of how many characters have been read. And let us write the basic loop. So, we will just write the loop corresponding to the flowchart; ch will be getchar. So, get the next character. And while ch is… While the read character is neither end-of-file nor new line, you should keep reading characters. So, if neither of this is true, then you should read the next character, which is what the flowchart says. A slight… a small point here is that, getchar returns an integer. This is a technicality because end-of-file is negative 1. ASCII characters if you remember, go from 0 until 127 or something like that; whereas, end-of-file is defined to be -1. So, because of this -1, you cannot keep the return value of getchar as a character; it technically has to be an integer. Now, this is a technicality. So, keep that in mind. Now, we need to do something further in the loop. So, we will complete this in a minute. So, what should we do inside the loop? This should be character. So, what is this function supposed to do overall? We have to return a 1, if the number of characters in the current line that we have read is at least 1. So, if the current line contains at least a character, then we have to return 1. For example, if the user just entered a new line, which is just press the enter key, there is a blank line. In that case, we would not say that, we have read a line, because it was a blank line. So, if there is at least one character, which is neither new line nor end-of-file in that line, we have to return a 1; otherwise, let us say we return a 0. So, one way to do that is to keep a count of the number of the characters we have read. So, for every character read, we will keep a count of every character, which is neither end-of-file nor a new line; we will keep a count of characters. So, notice the way that, the loop has been return. So, if the first character is a new line, it will not enter the loop. Hence, count remains 0. At the same time, the way the loop is returned; count will count exactly those characters, which are neither new line nor end-of-file.  So, now, let us decide what should be the return value. We have to return a 1 if the number of characters in the current line including new line is at least 1. So, if count is greater than 0, we can return a 1. If exactly 1; if the last character was end-of-file without having any other characters, then will return a 0. So, how we do that? We can check whether at least a character has been read by just checking the value of count.  So, if count is greater than 0, then at least one character has been entered; otherwise, for example, we can also say that, if the user has just entered a blank line, then also we can say that, one more line has been entered. So, that is up to the way you want to do it; you can also take the stance that, maybe a blank line does not count as a line. If that is the case, then you do not have to do it; but in this case, let us just assume that, if at least a character has been entered, which is either a normal character on a new line, we will say that, return 1. If the only character entered in that line is end-of-file, we will say that, there is no more new line. So, what we have to do is return count greater than 0; this tells you how many non-new-line, non-end-of-file characters have been entered. So, this should be at least 1; or, there is exactly one character entered, which is a new line. So, neither these cases we will return a 1; otherwise, we will return a 0.  So, we can put these programs together by concatenating all the code that we have written. Notice one thing that declare the function first; we use the function here. So, here is a top-level function, which will use read next line. When read all lines uses read next line; read next line has not been defined yet. So, you can go here after read all lines has been defined, you can define read next line. So, here is a function here. So, this is function 1, this is function 2, and finally you have made. Read all lines does not need any forward declaration, because when main uses read all lines, it has already been defined. That was not the case here. When read all lines used to read next line, read next line was not defined yet. That is why we needed a forward declaration. In this program, you can reorder the code such that read next line code can be written before in which case you do not need the forward declaration. But the concept of forward declaration is useful for later discussion. So, I have just introduced that.    This session will learn about arrays in C. Now, what is the word array mean, it means a grouping or a collection of objects. So, for example, you could say that he could not dismiss the array of facts. So, that means, a collection of facts and it also implies a regular order or arrangement that is in the case of a series. So, what do we mean by an array? And why do we need it?  So, let us consider that I have a bunch of numbers say 1,2,3,4 and I want to consider them as being part of the sequence. Let us say 1 , 2 , 3 , 4. So, the first element is 1 and so on. Now, I want them to be stored and one way I can do it is that, I can store them in to separate variables. For example, I can say that a is 1, b is 2 and c is 3 and d is 4. But, when I do it in that way, they are separate variables and the relationship between those variables, the fact that b comes after a and things like that is something that the programmer knows, but it is hard for somebody else looking at the code to figure out. Often we need to store sequence as a sequence itself.  So, an array has the following properties, one it is a collection of objects of the same type. Second, is that it has some size, some finite size say n there are n elements in the array and the third is that, I should be able to selectively update only a single element in the array. By which I mean, suppose I have four elements in the array I should be able to say that, I want to replace the third element by 5. So, 3 will be replaced by 5 without touching the other elements, that is what the third thing is about The first thing says that I want a collection such that it is a collection of objects of all of type integer and not of any other type. And the second says that, it has a some finite size so, it is not an infinite collection, so, that is what an array is supposed to do. Now, let us see how we can define arrays, will try to motivate why arrays are needed by introducing certain problems. And I will try to convince you that it is easy to do using arrays and whereas, it was difficult to do without using arrays, using only the facilities in c that we have seen so, far.  So, an array is defined in c, similar to how we define a variable. If we had an integer variable we would say int a semicolon instead of that when we declare an array we have int a 5. So, this would declare that it is an array containing 5 integers. Now, one thing that is certain about arrays in c is that, the five integers which makeup the array will be allocated consecutively in memories so, they will happen one after the other. Also one think to note is that, arrays in c start with index 0 so, the first element is a 0. So, if we have an array of five elements it will go from a 0 to a 4. So, have we seen arrays and mathematics for example, you can think of vectors similarly matrices these are all arrays and c arrays will have similarities to mathematical vectors and mathematical arrays. But, note that in mathematics, it is customary to start from index 1, here it is from index 0. So, the boxes are addressed as a 0 to a 4 these are called the elements of array. The array is the whole collection of boxes and each box in it will be called an element of array.  Now, let us consider a simple program using an array. So, I mentioned that the third requirement that I want for in array is that… So, that first requirement was that all elements of the array are of the same type. Second requirement was that, it has a finite size and that the third requirement is that I should be able to selectively update only one element of the array without touching the other elements. So, let us see a program where we can do all that. So, here is a simple program it declares an integer I and integer array a five and then a for loop. So, let see what the for loop is supposed to do. So, the for loop starts from i qual to 0 and then goes from i = 0 to 5, filling in the elements by sing the statement a[i] equal to i. So, let us  see what that is supposed to do.  So, this is the notation a i is the notation used to address the elements of the array. So, notice the similarity here a 5 when you declare it say's that it is an array of size 5. a[i] is saying that I want the I th element in the array. So, when i = 0 it will refer to the 0th element in the array until i = 4. It will go on and till the fourth element of the array. So, a of 5 similar to a of 5 the way we row declare the array say's I want the ith element of the array. So, the variable I is being used as an index for a, that means, if I say a[i] will pick the ith cell, in the ith element in the array. Now, this is similar to the mathematical notation a subscript i, which is what we normally use for vector and matrices.  So, let us run through the program once to see what is doing. So, first we declare a 5, which is five consecutively allocated integers in the memory. And we also have a variable i, i starts with 0 and for this 0th iteration a[i] is allocated let say i + 1, so, a 0 will be 1 then we update i. So, this statement becomes  a[1] = 1 + 1which is 2. So, and then execute it a 2 becomes 3, a 3 becomes 4 and a 4 becomes 5. So, notice that because we have indices, and indices can be numbers, they can also be replaced by integer expressions,, this is the trick that we have used here. So, a a[i] goes from a 0 all the way up to a 4.   So, one thing is, we have to take care of the size of the array. For example, if we have an integer array of size 5x this means that 5 integer variables named x0 to x4 are allocated. Now, the variables x0 to x4 are integers and they can be assigned and also they can be operated on, they can be part of other expressions and so, on. Now, what about arbitrary integers, we know that 0 to 4 are valid integers what about 5 and so, on. What happens to x5, x66 something like that. Similarly, what happens what will happen if I right x[-1] what are these valid. So, the answer is no, you cannot in general assume that indices other then 0 to 4 make any sense. Your program may crash and this is the most important thing in c programing when we use the array it is the main part of it, because it is not even guaranteed that a program will crash. So, you may run the program once with x of 5 let us say and the program will work fine. And you will be under the false impression that everything is correct in our program, but the next time you run it, may be your program will crash. So, it is not even guaranteed that it will crash, if it is guaranteed that it will crash, then of course you can know that there is an error, and you can go back to the code. In this case you just you have to be careful when you write the code. So, x 5 x 6 and so, on are undefined, these are names, but there are no storage location that they correspond to, so, you should not access them.  So, if you ask a very specific question, shouldn’t I access them are can’t I access them. So, what will happen if I write a code like this where I declare an integer array of size 5 then I know that x0 to x4 are valid location they are the first five locations. But the problem comes with statements like x[5] = 5 x of 6 equal 6 5 and 6 do not refer to valid locations in the array so, what will happen. So, the initial statements up to x[4] are all fine, but the last two statements x[5] = 5 x[6] = 6 lead to arrays will it compile? Yes, if you just give the source code, with these erroneous locations it will compile, but c compiler does not check that the indices are within the proper range. So, it will compile and the compile will not tell you that there is anything wrong with there, but when you run a program the program will give something called a segmentation fault it may are may not give that. So, this is one of the most notorious errors when you program in c. So, we will see this error in greater detail when we understand something called pointers. But in general when you exceed the bounce of the array, when you go beyond the locations permissible in the array, your code may crash and the code will crash usually with the error segmentation fault. So, if you run the program and if you see a segmentation fault this is a good indication that may be you are referring to locations in your array that do not exist. So, you should go back and rectify the code, but the danger is that, it may not always crash. So, the only way to be really sure is to go through your source code and examine it.  Your program may crash, so, we have seen certain aspects of arrays in c so far.  So, for example, let say that I declare a character array str of size 5, so, it has five characters inside it. And let us say that I use the variable I as an index into the array. So, str[0] to str[4] can be addressed using the index i. So, if I have the index, I know that I can set particular values as str[i] = ‘a’. Since, i is 0 this will set the 0th element in the array to character a. Similarly, if I say ch equal to str[i + 1] it will take whatever is in the first cell in str[1] and assign it to the variable ch. So, we can set particular element in an array like this. Similarly, we can also read the value in an element and then assign it to something else. So, these are possible with the help of an array now let us consider a particular example, which is the problem is as follows. We want a character array let say a size 100 and then we have to read input which is from the key board and store them in the array, After we have stored it we should stop, once at least hundred character have been written, because that is array size or when the user first end a file. Remember that you can press <Ctrl-D> to enter the end of file.  Now, what we have to do is take the error, take the array and print it in the reverse order. Now, if you think for a little bit you can see that it is difficult to do this without an array. Instead of an array, if you are storing it in a single character, there is no way to store hundred characters in one variable and then print them in the reverse order right. Because the first character has to be printed at the end and last character entered has to be printed first. So, you need to remember all the characters, this is an intuitive reason why arrays are important for this problem. So, what is an example problem let say that we have m e or then new line then Moo <Ctrl-D>. So, when you reverse it, you will have oom then the new line then or emn and so, on. So, you have to reverse everything input. Similarly, if you have a string what you have to output is the exact reverse of the string including the spaces.    So, this is what we just mentioned, the end of file character is usually -1. So, it is not a valid as key value. So, the code at the top level looks like this, we have the logic to read a next character into the ch using getchar, and then we have a let us say while loop which says that, while the character is not the end of file ant the number of characters read count is less than 100. You store the character into the array increment count and then read the next character. So, please look at the structure of the loop very carefully the s is a character array. So, technically it cannot hold end of file, but then if you think about it little bit you will see that we will never encounter the situation where, you will store end of file into the s array, because suppose first character is end of file then we will not even enter the loop. Now, at any point when we enter end of file, it will be at this point right we will read the character only here, before storing it into the array we will actually check whether it is end of file. So, we will not accidentally set the array to -1 at any point, so, character array suffices. So, think carefully about the way this loop has been interpreted.  In particular, if I had just done this as the last line before the loop ended then, you would run into problems because you could store the end of files character into the s array by mistake so, just think about that issue. Now, here is an initial design and so, the overall design is that first you have to read into the array and then you have print it in reverse. So, let us make the read into array little bit more precise. So, we have ch = getchar() and because you are using the getchar function we have int ch, because it could also be an end of file. Now, the while loop says that while the ch is not end of file and the number of characters read is strictly less than hundred increment. So, you first set s[count] equal to the character read,, the increment count and then get the next character. So, this loop keeps on filing characters into the character array until you see either end of file or you have enter 100 characters.   So, this is the array that we were doing and so, here is the code for printing the characters in reverse. So, here is the pseudo code where we said print s of I instead of that in c we have a particular function which will print the character which is put char. So, due to this the dual function of getchar. So, put char takes an character as an argument and prints it on to the standard output. So, you have int i i is set to be count -1 because that way we will get the last index of the character in the array and then you start counting down until use print the first character and till the end of the array ok.  So, putting these two together, you have the read into array part and then you have the reverse part print in reverse part. So, when you put these two together the first thing you do is, bring all the declarations together.  So, this is the declarations for read into array as well as print to put together. Similarly, first you have to print, you have to put the code for the read into array part and then the code for the print in reverse part ok.  So, let us trace the execution for a small sample input. So, then we have the input is hello and then the user presses <Ctrl-D> for end of file, let see what will happen. So, you start reading into the array. So, s[count] with count equal to 0 starts setting the array. So, s 0 will be h and then h s 1 will be e and so, on. So, once ch becomes <Ctrl-D> the end of file character you will exit the loop. So, the character array is hello.    In this lecture will just talk about how to initialize arrays. So, recall that we have  defined arrays as follows, if you declare an array float w[100], it will declare an array of floats 100 floats consecutively allocated in memory. And we have also mention the fact that there is a separate box w, which will point to the first location in the array. So, it contains the address of the first location. In num[10] will declare and integer array of 10 integers plus one box which will hold the address of the first location, and so on. So, the arrays names, the cells of the array or the elements of the array are index from w[0] through w[99] the indices start from 0. And we also mentioned that conceptually there is a separate variable called w, the name of the array which stores the address of w[0].   Now, it is not important that we use numbers as the size of the arrays, we can also use constant expression; for example, we can say float w[10 * 10]. So, instead of saying 100, we can give an arithmetic expression which evaluates 200, and this has the same effect it will evaluate an array of 100 elements staring from w[0] to w[99]. And there is a separate box called w which move to the address of the first location, but what about using variables or variables size arrays, this is feature that we often which we had. So, what do I mean by that? I could declare the following code int size, and then float w size and I could say scanf ( “%d”. &size );. So, user enters the size of the array, and then I can enter 10 elements in to the array for example, but here the size of the array itself is a variable which depends on the user input. And we often wish that we would we would be able to allocate variable size arrays, but this is not allowed in Ansi C, it is allowed in the latest versions of C 99 C 11 and so on. We will avoid this feature for the purposes of this course, let us assume that array means they are declared to be of constant size. By constant size you can give the size as a particular number or you can give it as a constant expression, that is an arithmetic expression involving constants, but not general expressions.  Now, let us just look at how can we create an integer array num and also initialize it to particular values; for example, I want the num array to look like the following, it contains 7 cells having the values - 2, 3, 5, - 7, and so, on. Now I know that if C did not allow me to initialize arrays when I declared it, I could declare the array as int num 7 and then I will just write num[0] = - 2, num[1] = 3, and so on until num[6] = 11. So, here is a way that I can create an array and ensured that this state is reached, but is there more convenient way of doing it. Can I start of the array with these contents. So, C allows you two ways do it. The first is I declare an int num[] and then specify what are the initial values, so - 2 so on up to - 11 within {}.  So, this is one way to that C allows you to do this. The initial values are placed within curly braces and separated by ,, the size of the array need not be specified. So, I need not say that num[] has size 7, it will allocate an array with enough space to hold 7 integers. Array elements are assigned in the order that you specified. So, num[0] will be - 2, num[1] will be 3, and so on. So, it is done in a reasonable manner. This also another way to do it, which is slightly different from way above, I can declare the size of an array. So, I declare an array of size 10, and then give this initial value. What will happen in this case, is that it will make sure that the size of the array is at least equal to the size of list that I have given. So, I have given 7 elements, and I have declared an array of size 10, 7 is less than 10. So, it is fine. So, I can declare an array of size 10, I should give a value, I should give values at most 10 in number. So I can give a 10 or below. In this case, I give 7 numbers. So, what happens is that, array is initialized in the order elements given num[0] will be - 2, num[1] will be three and so on, until num[6] will be 11. 7 elements are filled; the remaining 7 elements are unspecified. So, they will be initialized to 0.  Now let me just remained you that if I had just declared an array int num[10], and then put a semicolon. So, I had just declare an array without saying any initialization at all, then you should assume that the array contains or arbitrary values, you should assume that array contain Junk values, but if you initializes an array of size 10, and give only 7 initialization values, then the C standard gives you the guarantee that the remaining elements are initializes to 0. So, they are not junk.  The recommended method to initialize an array is to give the list of initial values, and let the compiler decide what the size of the array it should be. So, if you give 7 initial values, it will decide that the array is of size 7. Now is the following code correct, if I declare an array of size 100 num and give four initial values. So, this is correct, it creates num as an array of size 100, the first four entries will be initialized as given. So, num[0] will be 0, num[1] will be - 1, num[2] will be 1, num[3] will be - 1, and then num[4] until num[99], they are all set to 0. So, after the initializations the array will look as follows; the first four values are what we given and the remaining value are 0’s. Now is the following code correct, num[6] = and then you give a list of 7 values to initialize, is this correct? The answer is no, it will not compile. So, if you right this code, and compile it using gcc, it you will get a completion error. Why is that? We have declared an array of size 6, but we have given 7 initial values. So, there is no way to do this. So, the rule of thumb is that either give no size for the array, and let the compiler figure out or if you do give a size it has to be at latest 7, which is the number of values that you give, it can be 10, it can be 100, but it cannot be less than 7. Now just like size can be not just numbers it can also be constant expressions, we can also have constant expressions as initialization values ok.  So, for example, I can give num[] = 109, then the character value A, character value A means it will take the ASCII value of A, 65 or whatever it is. So, the first number will be 109, the second number will be 65, let us say if the ASCII value A is 65, and the third value will be 7 * 25 * 1023 + ‘1’. So, whatever the ASCII value of the character one is let say 90 or something. So, it will be added two this, constant expression, and it will be initialize to that value; num[] two will be the result of evaluating this expression. So, the type of each initialization constant should be promotable or demotable to the array element type. So, the each value in the initialization list should be compatible with let us say integer, because we have declared the array of size of type integer. So, what do I mean by that, for example I can initialize an array num[] with initialization list 1.09, then , A , 25.25. So, this is ok, because the floating point values can be downgraded to integers. So, may be this will be initialize to one then whatever the ASCII value, A is let us say 65, and then 25. Now, these are about constant expression. What about expression involving variables when we initialize an array. So, can we do something like this. int curr = 5, and then the num[] array is initialize with {2 , curr*curr+5}, will this work. The answer surprisingly is yes that it will work on most compilers. So, the ANSI C allows constants expressions, and simple expressions for initialization values. Now simple is of course dependent on which compiler we are using. So, if you write a code, and compile using gcc with such an initialization may be or code will compile, and the movement you compile your code with a different compiler it may not compile.  So, earlier I had said that the size of the array cannot be initialized using variable expressions. In ANSI C that is forbidden, but the initialization value, so the value that goes in to the array can involve variable expressions, this may or may not be supported. So, it is safe to assume that both the size of the array, and the initialization value can be done only using constant expressions, even though some compilers allow simple initialization values using variable expressions.   Now how do we initialize character arrays? Character arrays can be initialize like arrays of any other type, suppose we want the following array. s[] = ‘I’ , ‘ ’,’a’, ’m’,’ ‘, etcetera. So, I can initialize it just like a initialize the other array, I will not specify their size of s and then give this characters, I am DON. So, this is another way to specified and the last character is a null character, but C ‘also allows you to define what are known as string constants. So, we can also write s[] = “I am DON”, but now with in double quotes. So, this is known as a string constant, the null character is an implicit ending character inside a string constant. So, it is automatically added to the int. Now the string constants in C are specified by enclosing it in double quotes.  In this video, will talk about initializing character arrays which are a special kind of arrays and has more features then, when it comes to initialization as compared to arrays of other type. So, they may be initialized just like any other array and suppose I want to initialize an array to the following values, the first is I second is a space character then a then m and so on. And the final character is a null character which will be given as ‘\0’ now we can write s. So, character s = [ ] without specifying a size and then followed by the list of characters. Notice that each character is enclosed in single quotes right. So, the space character is a ‘ ‘ and so on until the last which is a null character, which is ‘\0’. But C also allows us to define what are known as string constants. So, in order to initialize an array a character array I can also write character s[] = “I am DON”. So, I am DON is a string constant in a every string constant that is a string enclosed in double quotes the null character is automatically added to the end. So, I want you to note this difference that, here we explicitly gave a null character at the end here we do not have to give that. Now C; C string constant are specified by enclosing some text with in double quotes for a example, “I am a string”  Now, we will talk about how do we prints strings we have used sting constants many times. So, just take a moment to think back to see whether you can figure out where we have used string constants. So, we have used for them for example, in printf and scanf the first argument of a printf or a scanf was always a string constant, because if you recall we had some text in which involved special characters like new line. It involves formats specifiers as like %d, but whatever it was, it was a bunch of characters. So, it was a text inside a pair of double quotes that is a string constant. So, the first argument is the string constant followed by what all arguments we want to print. Similarly, even for scanf we had some say formats specifier enclosed in double brac double quotes, so, that is a string constant and then you say and value. So, strings are printed using the %s option. So, any of the basic data types in C can be easily printed using the printf statement if you give the correct format specifier. So, if you have a string constant you can print it using the %s option. For example, if I want to print the string “I am DON” then what I can do is I can say printf(“%s”, ”I am DON”). And this will print I am DON which is exactly what I wanted to print. Now, what if I initialize a character array character str[ ] without specifying the size. I initialize it using a string constant I am great DON within double quotes. Then I print it using printf( “%s”, str), will this work? And the answer is yes it will work, because C will consider this as a string constant and it will print it using %s and you will get the correct output. So, state of memory after definition of this string in example two is that, it has a list of all these characters ‘I’,  ‘ ‘, ‘a’, ‘m’,’ ‘ and so on and note the implicit null at the end. So, even though the double quotes ended just after n when you stored it in an array there is an implicit null that is inserted at the end of the array. So, when you print it will print until the null character. So, null character itself at the end of the string is not printed when you print it using %s.   Now, let us look at the following fragment to understand slightly in a deeper way what %s thus when you print it using printf. So, suppose I declare an character array using character str[ ]= “I am GR8DON”. So, this is initialized using the string constant which means that after the last end, there will be a null character in the array. Now, I initialize i I said str[4] = ‘\0’ note that there are 11 non-null characters in the string constant. So, this goes from str[0] to str[10] followed by str[11] which is a null character. So, now, I said str[4] = ‘\0’. So, somewhere in the middle of the string I put a null character. What will happen if I print it using printf %s? So, let us see what happens here I declare the array and initialize it using a string constant. So, it has all these letters followed by a null at the end. Then when I said str[4] = ‘\0’ what it does is it goes to the fourth location in the array and changes that to null. So, what that does is there was a space there before, but now you insert a null character there. After the null character there are other non-null characters and then there is a second one. What will happen when you print? It will just print I am and stop that it will not print the remaining characters and why does that happen? So, string of C as for as C is concerned is a sequence of characters terminated by a null, this null is not part of the string. So, they may be non-null characters after the first occurrence of null in str, but they are not consider part of the string str their part of the character array. But when you look at str as a string it is just till the first null character. So, when you print it using %s only the part until the first null is printed. So, that is considered the string the character array is bigger.   So, it will just print I am and stop there. So, do I lose the characters after the first null and where do they go? Well, of course they do not go anywhere they remain where they were. So, what is the new state of the array? The new state of the array is I am and then there is a null and then there are some other characters. So, if I print it using %s it will only come up to I am and then stop there. So, is there any way to print the remaining characters? Of course, there is a way right. So, if I print that using %s I will get I am, but I could easily write a loop like this. I will say int i and then for i = 0, until 11, i++ and then putchar(str[i]). So, this will print the character str[0] str 1 and so on up to str[11], regardless of whether that character is null or not if it is null it will do something, but it will still go on to the next character. If you run this what you will see is, it will print the first character which is I, then it will print the second character which is space, then it will print the third character which is a. So, these three are printed as they are and then m and the fifth is a null character. What do you mean by printing a null character? It may not print anything. So, it may be just kept, but then it goes on to the next character GR8DON and there it stops, because it does not print the eleventh character. So, the null character in this example is not printed. Now, the way the null character is treated on different terminals may be different. So, on some Linux terminals if you ask to print null character it will just not print anything, but other character terminals may print them in different ways.    In this video, we will *t with a topic that is considered one of the trickiest concepts in C. These are what are known as pointers. We will just recap what we know about arrays, because arrays and pointers are very closely related in C.  The memory allocated to any array has two components. First is there are a bunch of consecutively allocated boxes of the same type. And the second component is there is a box with the same name as the array. And this box contains the address of the first element of the array. So, that let us be clear with the help of concrete example. So, let us consider a particular array of size 10 declared as int num[10]. Conceptually, there are 10 boxes from num[0] through num[9]. These are all containing integers. Plus there is an additional eleventh box – num. So, it has the same name as the name of the array. And it contains the address of the first location of the array. So, it contains the address of num[0]. These are num[0] through num[9] are located somewhere in memory. So, maybe this is memory location 1000. So, num contains the number 1000, which is supposed to indicate that, the address of the first location in the array is 1000 or num points to the memory location 1000. So, conceptually, this gives 11 boxes, which are 10 integer boxes plus 1 box, which holds the address of the first box. Now, we represent the address of a box x by an arrow to the box x. So, addresses are referred to as pointers. And this is all there is to C pointers. Pointers in some sense are variables, which hold the addresses of other variables. That is an exact description of the concept of pointers. Now, we will see now what that means and what can we do with pointers.  Let us just step back a minute and say what can we do with a particular box or particular variable in memory, which is an integer. So, that is very simple. For example, you can scanf into that box; you can print the value in that box; you can do arithmetic operations on that box like plus, division, %, and so on. And you can do this for each of the boxes from num[0] through num[9], because each of them by itself is in integer. But, we will also see a new operation, which is that, you can take the address of a box. So, we have already done this when we did scanf. So, we mentioned & of a variable. So, we will see these & operator in somewhat more detail. So, suppose I want to take the address of num[1] and store it in an address variable ptr. So, what I am essentially saying is that, you can say ptr = &num[1]. So, num[1] is an integer box; it is an integer variable; & of num[1] is the address of that integer in memory. So, you assign it to the variable ptr. But, every variable in C needs to have a type. What is the type of ptr? And how do you declare or define such a type – such a variable? Now, ptr holds the address of an integer. In C, you denote that by saying that, the type of ptr is int *. So, here is a new type that we are seeing for the first time. We are saying ptr is of type int *. Just like you can say that, if I have int a, you can say that, a is of type int. In this case, we can say ptr = &num[1].  We have discussed right now we have int num[10], int *ptr, and ptr = &num[1]. So, ptr is the pointer to an integer. But, what does ptr = &num[1] really mean? So, let us look at the memory status once we declare this array. So, we have num, which is the address of the first location. And then we have somewhere in memory, we have 10 consecutive locations corresponding to the array – num[0] through num[9]. Now, I declare int *ptr. So, I create a box. Now, this box is supposed to hold the address of some integer variable. So, ptr is of type address of an integer box or more commonly referred to as pointer to integer. The statement ptr = &num[1] says that, now, points to num[1] or ptr contains the address of num[1]. And pictorially, we denote an arrow from ptr to num[1] just like I denoted an arrow going from num to num[0], because the name of the array is a pointer to the first location of the array. The name of the array is a box, which holds the address of the first location of the array. Similarly, ptr is a box, which holds the address of num[1]. So, we say that, ptr points to num[1]. And we denote it pictorially by an arrow.  The program status is like this – state is like this. Now, suppose I add one more statement after all these three statements; I say scanf(“%d”,ptr). Now, earlier when we declared an array and we read into an array directly, I said that, you can do the following. I can write scanf(“%d”,&num[1]). So, this will value whatever the user input into the first array using the & operator. Now, ptr = &num[1]. So, it is a reasonable thing to ask – can I say scanf(“%d”,ptr)? There is no & operator here because ptr is &num[1]. This was our original statement and this is our new statement.  And the answer is yes, you can do it. Suppose the input is 5, does num[1] become 5? So, scanf(“%d”,ptr) really does work like scanf(“%d”,&num[1]). So, it reads the value input by the user and it looks up ptr. So, it is an address. So, it goes to that address and stores it there. So, now, we can clarify a long standing mystery, which is the & operator in the case of scanf. So, we can say that, scanf second argument is a pointer; which says where should I put the input by the user? For example, if I have float variable and I scanf as %f and then sum address of a float variable, it is done similar to reading an integer into an integer variable. What scanf takes is an address of int variable or float variable as it may be. If you have a %d, then it takes a pointer to an integer variable and takes the input value by the user and puts it into that address. So, as far as scan f is concerned, it does not matter whether you gave it as &num[1] or whether you initialized ptr to &num[1] and then gave ptr. It is an address and it will put the integer input by the user into that location. So, num[1] indeed does become 5.  So, the location of the num[1] is now containing the value 5. Now, what else can you do with a pointer? Num is an array; it is of type int [ ] – pair of square brackets. And in C, the box num contains the address of the first location of the array, which is num[0]. So, internally, as far as C is concerned, the address of num[0] is just like address of any other integer location. So, the type int * can be interchanged with int [ ]. So, you can think of num itself as just a pointer to an integer; or, you can say that, it is a pointer to an array; which gives you the additional information that, the next 10 values are also integers. If you just say pointer to an integer, the next location may be something else. But, internally as far as C is concerned, an array name num can also be treated as pointer to an integer. Now, here are some other interesting things that you can do with pointers. Whenever you declare a data type, you also define what all operations can you do with a date type. So, 2 and 3 are fairly simple; we have already seen it with integers, floating points and so on. You can do simple arithmetic + and - with pointers. You cannot do * and /. You cannot do that. But, you can do + and -. Similarly, if you have two pointers, you can test for = =, you can test for <, you can test for > and so on as though you are comparing ordinary integers. So, 2 and 3 are what we have seen before; except that, in 2, you cannot do multiply and / and %. All these things are not done with pointers. But, addition and subtraction can be done. But, there is a new operation, which is dereferencing a pointer. We have not seen this operation before with earlier data types. (Refer slide Time: 11:10)  What is dereferencing? Let me pictorially represent what it does. Suppose you have int *ptr and int a. So, a is an integer variable and ptr is a pointer to int. If I want to store the address of a int ptr, I do it as follows: ptr = &a. So, this means that, take the address of a and store it in ptr. So, now, you can say that, ptr points to a. Now, I can also think of a reverse operation; which is ptr contains some address. Go look up that address; so that will be an int. And store that value in int.  So, that is what is known as the * operator – a = *ptr. This means that, ptr is an integer pointer. So, ptr will point to a location, which contains an integer. *ptr will take the contents of that location and store it in a. So, this is known as the dereferencing operator. So, the address operator takes an integer variable and stores the address in a pointer. The dereferencing operation takes a pointer; looks up that address; and stores the value in a. So, you can visualize the & operator and the * operator as sort of reverse operations of each other. & takes an integer and takes the address of that; * takes a pointer and takes the value of the address pointed to that.  Dereferencing a pointer therefore gives you the value contained in the box pointed to by the pointer. The dereferencing operator is *. So, if I say printf %d * pointer, what it will do is – look up the location pointed to by ptr. In this case, it is this integer box. The contents of that box is 5 and it will be printed. So, the output will be 5. Not for example, the content of ptr. So, the content of ptr may be like 1004; it will not print 1004; but what it is supposed to do is look up the location 1004; it contains the value 5; print that value. So, *ptr is the box num[1]. And printing it gives you the output 5. Now, can I consider a statement like *ptr = *ptr + 5? This is perfectly legal. What this will do is *ptr is an integer value. It is equal to 5, because look up this location ptr; that is an integer; take that value; which will be 5. So, this will be 5 + 5 – 10. And where do you store it? You store it in the integer variable corresponding to *ptr. The integer variable corresponding to *ptr is num[1]. So, I would have normally said num[1] equal to *ptr + 5; but num[1] is the same as *ptr. So, I can say *ptr = *ptr + 5. So, this will look up that location; add 5 to its contents; and store it in that location. So, num[1] will now become 10.  Similarly, you can consider other examples. For example, I can consider a statement like num of 2 equal to *num + *ptr. The novelty here is that...  In this video let me, so some cool stuff which is pointer arithmetic which helps you to understand the relationship between pointers and arrays in C.    So, let us consider in array declared as follows int num, and then it has 5 numbers in the initialization list. So, the array will be initialized as follows; there are 5 consecutive integer locations in memory with the given elements + there is a 6th cell which points to the first location in the array. So, num points to the first location in the array. If num points to the first location, then you can do the following operator num + 1. So, num + 1 with point to the integer box write mix to the integer box pointed 2 by num. And we also know that arrays are consecutively located. So, the integer box next to num is exactly num 1. So, num + 1 points to num[1]. Similarly num of num+2 points to num[2], and so on. Until num+4 = num[4]. So, this particular box, for example, num[4] can be accessed in two ways; you can write num[4] or you can write *(num+4). Can you tell me the output of the following printf statement. So, think about this for a minute, you have 3 integers to print using %d %d %d, and what are to be printed are *(num+1) *(num+2) and *(num+3). So, think about it for a minute…  Now, let us look at the slightly different array. What happens if you have a character array. So, I have char str array which is initialize to let say given string BANTI is a nice girl, and then I have a character pointer. So, char *ptr and it is assigned str + 6, it is initialize to str + 6, what will happen here? What is different about this example is that, earlier I said that in an integer array + 1 for example, would go to the next integer location in memory. So, wherever num was num+1 would go to the next integer location here, str is a character array. So, it has to go to the next character location, and that is exactly what it does. So, what is printed? Lets first consider the state of the memory. So, you have an array which is a character array, it starts from str[0], and goes on up to str[20]. So, there are 19 characters followed by the null character. Why is the null character there, because I initialize the two a string constant; every string constant has a null character implicitly at the end. So, this is the straight of the str array. Now I say that I declare a pointer, the pointer is pointing to a char. So, it is a char * pointer and what is the location it points to it points to str + 6. Str is a point out to the first location of the character array, and + 6 would jump 6 character locations away from str[0]. So, you would reach this character. The important difference between this example at the previous example is that, if you declared an integer array + 1 would jump 1 integer location + 6 would jump 6 integer locations. Here since such a character array str + 6 would jump 6 character locations. So, how the + operator is interpreted in the cases of pointer depends on what array am I pointing to right now? Now what will happen with the printf statement? So, if I say printf % as ptr what will happen? So, ptr points to str 6. So, printf will print whatever string is starting from that location until the first null character. So, it will start printing from this i, and then go on tip printing till it reaches the null characters. So, the output will be just is a nice girl. So, when you want to printf it is not important that you start from the absolute beginning of the array. We can start from arbitrary location in the character array, and if you say printf %, it will start from there and go on and print until the first null character.  So, let us look at it once more. So, it was the code that you had, and let say that the onedimensional array for this seek of convenience, I will just… So, it like this. It is actually in a row, but here is the first part, here is the second part, and so on. So, when I say str, str is a character array, and ptr + 6 would goes 6 locations away from the first location. So, str is pointing to then first location in the array, it will go to the 6th location in the array ptr, and ptr is pointing to the 6 location.  So, you can ask more expressions do the make sense, can I say str + 5 is the this location. Similarly can I say str + 10 is this location, and so on. So, these are all correct expressions. Now can you tell the output of printf % ptr -5, we have talked about + operator on pointers. So, it will whatever the nature of array that the pointer is pointing to it will jump n locations away from it. So, if I say ptr + n, it will jump n locations of that type away from it. So, by the same logic can I argue that if I do -5 ptr -5 can I say that it will go 5 locations previous to what ptr is pointing to right now. And the answer is yes.  So, it will behave exactly as you expect. So, ptr is pointing to this location, here is the previous location. So, it will jump to 5 locations before the location pointer 2 by ptr, I will happens to be A. So, the location which is str[1], that is = ptr-5. So, if you printf on that location, it will say BANTI is a nice girl, that is the output.  Before I proceed this one thing that I want to emphasize, and it is often not emphasized when you see online material on pointer arithmetic. C pointer arithmetic is not suppose to be meant for navigating the array, meant for navigating arbitrary locations in the memory. So, you cannot take a pointer. Let say character pointer and just say pointer + 1000. It will give you some location in the memory, but the behavior of the program will be undefined. So, the c pointers are well defined, pointer arithmetic using C pointers are well defined only when the pointers are pointing to locations within an array. So, within an array + n will take you n locations away from the given pointer, -n will give you -n away from the give behind the given pointer and so on. Whatever type the character of whatever type the given pointer is pointing 2. So, the main point of lecture was that if you have let say for example, and integer array int num 10, then num of 5 which is the array notation is exactly equivalent to *(num+i). And I am not saying this that you can think of num of 5 as *(num+i), it is not an analogy this is exactly what C actually does. So, num of 5 is translated to *(num+i). So, arrays and pointers in c are very intimately related.   So, here is the stuff that we have seen about pointers. First we have defined what is a pointer? A pointer is just a variable that holds the &another variable. We say that pointer points to another variable. And depending on what variable it points to, the type of that target, we say it is an int pointer or a character pointer or a float pointer and so on. So, this is the first thing what is a pointer? And then we have seen what all can you do with a pointer; what are the operations that you can do in a pointer. So, if you have a normal variable, you can take the &that variable using the & operator. If you have a pointer, then you can dereference the pointer by using *(ptr). That will go to the location pointer 2 by ptr and take the value of that target. Further we have seen pointer arithmetic involving + and -. And I have introduced you with the caution that they are meant to navigate within arrays; they are not meant to navigate to arbitrary locations in the memory. If you do that, it may or may not work. And further we have touched up on the intimate relationship between arrays and pointers in C. As captured by the formula, array[i] is *(array+i). A special case of this is to say that the name of the array is an &the first entry in the array. For example, array[0] is the same as *(array+0). We have seen this and think about them once more to get comfortable with the notion.  In this video, we will talk about how pointers interact with functions. When we introduced arrays, we first said here are arrays; here is how you write programs with arrays. And then we introduced… Here is how you pass arrays into functions. Let us do that the same thing with pointers. So, here are pointers. And how do you pass them to pointers? Before coming into how do you pass them to pointers, we will go into – why should you pass pointers to functions. So, let me introduce this with a very standard example. This is a classic example in C. How do you exchange two variables? We have seen the three-way exchange; where, I said that, if you have three rooms: A, B… I have two full rooms: A and B.  And then I want to exchange the contents of these rooms; then I can use a third room. First, move the contents of A to T; that is your first move. Then move the contents of B to A; that is your second move. And then afterwards, A now contains the contents of B; and B is empty; T is containing the contents of A. So, the third move is – move T to B. So, the net effect will be that, B contains the whole contents of A; A contains the whole contents of B; B contains the whole contents of A; and T is empty. So, this was the threeway exchange, which we did within main function. This is long back when we discussed GCD algorithm.  Now, let us try to do that using a function. So, I have a swap routine, which takes two integer arguments: a and b; and it is meant to exchange the values of a and b. So, inside main, I have a = 1, b = 2. And I call swap a and b. And swap a and b – what it does is this three-way exchange that, we have discussed. Now, just to test whether things are working, I have a bunch of printf statements, which says what is the value of swap, what is the value of a and b after swap has executed. Similarly, when I come back, I will just print the values of a and b to see what has happened after swap. So, when you call swap and you output it within swap, it is very clear that, a = 2, b = 1. So, the three-way exchange would work as you expect. And you have whatever was passed, which is swap1, 2. So, it will exchange those variables and it will print a = 2 and b = 1. Now, within main, a was 1 and b is 2. Now, when you print these statements inside main, surprisingly, you will find that, a = 1 and b = 2. So, the effect of swap is completely absent when you come back to main. Within swap, they were exchanged. But, when you come back to main, they were not exchanged. Why does this happen? This is because remember that, some space is allocated to a function; and whatever space is allocated to the swap function, all the variables there is erased – are erased once you return from the swap function. So, within swap function, a and b are exchanged. But, all that is gone when you return to main. So, passing integer, float, character variables as parameters, does not allow passing back to the calling function; you have only the return value to return back. Any changes made within the called function are lost once this function returns. So, the question is can we now make a new function such that work done within that function will be reflected back in main.  Now, here is an intermediate solution. We know that, if we pass arrays, then work done in the called function will be reflected back in the calling function. So, you could think of the following intermediate function. So, if I have int num 2 and then I say that, num[0] is 1, num[1] is 2. This is in the main function. And then I call swap of num. Now, we will call it swap1(num); I have a new function. Now, what swap1 does is – so int swap1 int arr. So, suppose I have this function; inside that, I will just say that, I will have an intermediate variable t; and then have t = num or arr[0]. Then arr[0] = t; arr[0] = arr[1]; and arr[1] = t. Suppose I have this function. And now, you can sort of argue that, this will also swap the two cells in the num array. So, the dirty trick that I am doing is that, I want to swap two variables; instead, I will say that, instead of these two variables, I will insert them into a array of size 2; and then call swap1 on that array. Now, what swap1 does is – it will exchange – it will do the three-way exchange on the array. Now, I know that because of the way arrays are passed in C, any change that happens to the array arr inside swap1 will be reflected back in main. So, when I print these num array back in main, I would see that, num[0] is now 2 and num[1] is 1. So, this is an intermediate trick in order to write the correct swap function. But, you will agree that, this is a kind of a dirty trick, because in ordered to swap two variables, I created an array; and then depended on the fact that, swap will change the array in such a way that, the change will reflected back in main. So, is there a nicer way to do it? That is what we are interested in. And the answer is let us just think about that array trick. What we did was – when we passed an array, we were of passing the &the array.  This is how arrays are passed to functions. So, now, let us just take that idea that, we are passing the address. So, let us try to write a swap function, where you are passing the &variables instead of the variables themselves. So, here is the correct swap function. And what I write is void swap. So, void is a new keyword that you will see; but it is not a big deal; it is just a function that does not return a value; it just performs an action without returning a value. So, such functions you can write it as void – void swap int *ptra, int *ptrb. So, ptra and ptrb are pointers. Now, inside the code, you have something that looks like a three-way exchange. It is very carefully return, because the obvious way to quote the function is not right. So, you have to be slightly careful; you have to declare an integer variable. Now, t contains *ptra; *ptra = *ptrb; and *ptrb = t. The obvious way to write it seems to be – you declare an integer *ptr t and then do this. It is not quite right; we will come to that later. So, here is the swap function. And how do you call the function? You declare two integer variables in main: a = 1 and b = 2; and then pass the addresses using &a and &b.  So, let us just trace the function. You have two variables in main; a = 1, b = 2; and call swap(&a and &b). Now, just to denote that, these are addresses, I will say that, these are… a is situated at location 1024 in hexadecimal. So, this is some location in memory – hexadecimal 1024. And this is some other location in memory; b is say at hexadecimal location 2000. Now, do not be distracted by the hexadecimal notation if you are uncomfortable with it; just write 1024 in an equivalent decimal notation; and you can say that, it is at that location. So, it is at that location. And I am representing the location in hexadecimal, because it leads to shorter addresses. And this is also an address. So, when I will take &a, I will get 1024x in… When I take the &b, I will get 2000x. So, this is the &a. And it is located at memory location 1024 when represented in the hexadecimal notation.  What happens when you call the swap function? So, here is the state of main. And when you call the swap function, a new bunch of memory – a new block of memory is allocated on the stack. So, first, the formal parameters are copied their values from the actual parameters. So, ptra will get &a, which is 1024; ptrb will get &b, which is 2000. Now, I declare a new variable t; t = *ptra. So, what does that mean? ptra is an address – dereference the address; which means go look up that address. So, it will go to this location and get that value. So, t will now become 1. And the next statement is somewhat mysteries; please understand it very slowly. So, on the right-hand side, you have *ptrb. This means dereference ptrb. So, we are saying ptrb is address 2000; when you dereference it, you will get the value 2. Now, where do I have to store that value 2? For that, dereference ptra. So, 1024 – dereference it; you will go to this box. That is where you have to store 2.  So, 2 will go to that location. So, what has happened due to that is that, a in name has now changed. Why? Because within the swap function, we were dealing with pointers. So, as a result of the statement *ptra = *ptrb, it has taken 2 from the main functions b and put it back into the main functions a. And that was accomplished through variables inside swap. So, think about it for a while. And the last statement of course is *ptrb = t. So, dereference ptrb and put the value 1 there. So, here is a three-way exchange that works through variables only in swap. But, since they were pointer variables, you ended up changing the locations in the main as well.  And once you return, all the memory corresponding to swap will be erased. But then when you to main, a and b will have changed. a and b were 1 and 2 before. Now, a is 2 and b is 1. So, it has correctly swapped. Now, as an exercise, I said that, the obvious way to write the swap function is as follows. Void swap a int *ptrb; ptra and int *ptrb. And then I declare int *ptrt. And then I write these statements. This is a very obvious way to code swap. This does not work. So, try to draw these pictures as we have done with a swap function that actually worked. Try to draw the picture of what happens in main and what happens in the swap function. And understand why this particular swap function does not work. One final word about passing pointers to functions; C has something called a call by value mechanism. What is meant by call by value is that, when you call a function, remember the original picture that, your friend came with his note book and copied down the numbers in your page. So, your friend created a separate copy of your arguments; then computed what had to be computed and returned you a value. That picture is essentially still correct. Even though you are now dealing with functions, which can manipulate memory inside main, the passing mechanism is still call by value. It is just that, what is being copied are the addresses. So, when you manipulate the addresses through dereferencing, you end up changing the location inside main. So, even with pointers in C, what happens is call by value.  Since pointer arithmetic is a tricky concept let us solve one more problem to try to get comfortable with that notion.  So, the problem here is copying a sub array into another array. Now, let us explain what that means?  Suppose, I have written a function copy_array() which has three arguments an integer array a[ ] and integer array b[ ] and n which is the size, I want to copy n successive index elements from a and put it into b. So, a is 0 through a n - 1 have to be copied to b. I can easily write it in the following function has int copy_array int a, int b, int n and then I have one variable to keep track of the index and that variable goes from 0 to n, for i = 0, i < n, i = i + 1 and then I simply say b[i] = a[i] within the loop. So, this would copy whatever a[i] is into the location b[i]. So, once the loop executes, I would have copied n elements from the array a to the array b. But, this is not general and I want to solve the following problem, I have two arrays let us name them from( ) and to( ) and I want to copy n numbers from the array from[ ] to to[ ]. But, I have an additional requirement, I want to copy n elements from index i. So, the earlier code solve the problem from index 0 in general I want to copy from index i of from[ ] in the elements into the locations starting at index j in to[ ]. So, the earlier function assume that i and j were both 0. In the general function I want arbitrary i and arbitrary j. So, I need a declaration like the following, I have int copy_array_2. So, this is the second function I am writing and I have from i to j and then n is the number of elements to copy. So, what I have to do is from i from i + 1. So, on up to from i + n - 1 have to be copied to to[j], to[j+1] so, on up to to[j + n - 1]. So, for the purposes of this lecture let us just assume that from[ ] and to[ ] are big enough. So, that you will never ever over suit the arrays by taking i + n -1 and j + n - 1. Can you write this function? Now; obviously, you can write a separate function to solve this. Now, the trick is can you use the copy_array() function, the copy_array() functions copied n elements starting from index 0 of a to index n - 1 to the array b starting at index b [0] to b[n – 1]. So, that is what is it means. And this should be strange, because if you think about it in a mathematical way, you are saying that a general function is being solved in terms of s particular functions. So, you are reducing a general case to a special case at sounds a bit strange. But, we can do this with pointer arithmetic.   So, here is a problem that I have and I want t[j] = f[i], t[j + 1] = f [i + 1] so, on upto t[j + n – 1] = f [i + n -1]. So, let us try to see what happens in this function? Suppose, I call copy_array_2() from name, using the arrays f, t, i, j, n and that function nearly calls the old copy_array() function, using f + i, t + j and n. So, this state of execution at the start of copy_array_2(), let say that f [ ] is an array with say 10 elements and t[ ] is an array with say 10 elements arbitrary and what I want is I also assume that i is 2 and j is 4. So, I want to copy 5 elements starting from the second location or the third location in f f[2] onwards to the fifth location in t onwards. So, here is what I want to… So, I want to copy this - 1, - 1, - 1, - 1, - 1, to t [4] onwards. So, I will copy them here, so, 5 elements are to be copied.  Let see; how our, function is able to do this. So, t + 4 is this location f + 2 is just location. So, what I am calling is the old copy_array() function with f + i,. So, f is the address of the first location of the array. Therefore, f + 2 using pointer arithmetic is the second integer box after that. So, it is pointing to f[2], similarly t + 4, t + j in this case is pointing to the fourth location after the location pointer 2 by t, t is an array. So, t points to the first location in the array therefore, t + 4 will point to the fifth location in the array. So, when I say f + 2 f + 2 is a pointer 2 here and t + 4 is a pointer 2 here and I am calling copy_array() function with these as the arguments and n is the number of elements I want to copy.  So, here is the state just before I call, copy_array() function. Now, for example, this particular box has several names, the most common name for it will be f[3]. But, I can also write it as *[f + 3], this says jump 3 integer boxes after f and then dereference that address. Now, if you are comfortable with the notion that let us say f[i] is the same as *[f + i]. If you are comfortable with that notion, then you should be easy to see that (f + 2)[1] is just *[f + 2 + 1] . It is the same formula that I am using and this happens to be f + 3, which happens to be f [3]. So, *(f+3) would be f[3] and so, on. So, this formula that f[i] is the same as dereferencing the address f + i, f[i] = *(f + i) is applicable even for more strange looking expressions. (Refer Slide Time: 09:to6)  Now, here is a trivia about c, that because of the way it is defined. So, if you say that f[i] is the same as *(f+i), then you could think that this is the same as *(i+f). So, I can write this as i of f never do this, but it will actually work. So, f[i] you can also write it as i of f. For example, 3 of f and it will also work, because internally c translates it to *(f+i) and we know that *(f+i) is a same as *(i+f). So, never do this, but this helps you to understand that f[i] is being translated by c into this format.   So, now, that we know this, similarly you can argue about *(t+4) and (t+4)[0] and. So, on all of them refer to the same box.  Now, let us see what happens when we call copy_array(). So, we have the stack space for copy_array_2() and copy_array_2() calls copy_array(). The formal parameters are a and b, a copies the address it was passed to, it was passed the address f + i. So, a points to f + 2, similarly b points to t + 4,. So, b points to this. Now, as for as copy_arrays concerned it is not too bothered by the fact that, it was not passed the absolute first address of the array. It will think that whatever address it has been passed is the start of an array and it will work from there. So, copy_array() does not bother the fact that, I was given the second element of the array, rather than the first element of the array and so, on, it will work as though the array started from there. And here is where we are exploiting that fact so, you now copy n elements from this location to this array, so, n is 5.   And when you execute the loop, it will start from this location copied to t + j then f + i + 1 will be copied to t + j + 1 and so, on. So, it will copy these five locations to here in the t array.  And after you do this copy_array() returns and every variable that was allocated to copy_array() is erased. But, then because of pointers it was actually working with the arrays in copy_array_2(). So, even when you erase all the memory allocated to copy_array(), once you return these arrays would have been changed. These five locations starting from f + 2 have been copied to these five locations starting from t + 4. So, changes made to b[] by copy_array(), is still maintained after you returns to the calling function copy_array_2().  In this lecture will see some more pointer arithmetic operators, and we will introduce those by talking about them through a problem.    So, the problem that I have is that of reversing an array. So, we have to write a function to reverse an array, and let say that the declaration of the function is void rev_array (int a[ ], int n[ ]). Now if you have to reverse an array, what is one way to do it you take the array copy to into another array, and then copy back in the reverse fashion. So, you have an array a[ ] copy all the values in to b[], and now you copy those values back to a in the following way that the b, b is last value will go to a[0], b is second value last value will go to a[1] and so on. Now, let us try to do it slightly more cleverly, we want to take an integer array and reverse the array in place. That means that essentially using no extra space. So, do not use and extra array in order to reverse it, reverse it within a itself. So, the array before calling reverse array will look like a[0] upto a[n-1] in this way. And after calling reverse array it should look like a[n-1] a[n-2], etcetera up to a[0], and we doing that we should not use an extra array.    Let us try to code this up. So, how is the reverse array return first I need... So, remember how we did this by hand, we exchange the 0 th location with the last location, then we exchange the first location within second last location, and so on. So, it is easy to code, if you have two pointers; initially one pointers starts to at the beginning of array, the second pointer is to the last of the array exchange those values, then the first pointer goes to the next location, and the second pointer goes to the previous location, that is how you did it by hand. So, let us try to code that up I will have a pointer *b, which points to the last element of array a + n - 1. Now, the loop is as follows, I will discuss this in a minute while b < a. So, remember in the example by hand, we had to exchange till we reach the middle of the array. How do you find the middle of the array, I will just write it as b > a, and I will explain it in a minute. So, while this is true that you have not a ((Refer Time: 04:25) the middle of the array. You exchange swap a and b, here we use the swap function which we have seen in the previous lecture. So, for example, it will swap the 0 th element with the n - first element. After that is done you increment a and you decrement b. So, the design logic is that a initially points to that first element of the array - the left end of the array, and b points to the right end of the array.  So, we are seeing a new concept which is relational comparison between two pointers. If a and b are pointers to variables of the same type like int *a, int *b. We can compare them, compare these pointers using =, and not =. This can be done for arbitrary locations a, and b as long as those locations are of the same type. So, a = b is true, if and only if a and b are pointing to the same location; that is natural to expect. Otherwise if they are pointing to different locations a not equal to b is true. Now there is another case, if a is pointing to an integer let say, and b is pointing to a float then equal to and not equal to are undefined. So, notice that even though this behavior looks natural, it is natural only if there pointing to this same type. So, here are operations equal to and not equal to.  What about less than less than or equal to greater than greater or equal to and so on. And this is surprising, because here is something that you do not expect. You cannot compare less than less than   equal to on arbitrary locations in the memory. We can compare a and b using less than for this they must be pointing to the same locations in the array. Earlier when we discussed + and -, we were saying that + and - are well behave the only when you are navigating within an array. Similarly, when we are comparing 2 pointers using greater than greater than or equal to less than less than or equal to, then they should all be point then a and b should be pointing to the same array, different locations in this same array. If that is true then a < b, if a is pointing to a location which is before b in the same array. Similarly a < or = b yes true if a is pointing to a location which is b or before b, and so on. So, for example, we can say that if you have an array int a[10], then a + 1 < a + 2, that is clearly true. Because a + 1 is pointing to the location one in array and a + 2 is pointing to location two in the array.  So, if you have an array for an example let say a[0] through a[9], and ptra is pointing to location one, and ptrb is pointing to location three. Then ptra < ptrb here the comparison is well defined and it is true.   But on the other hand let say that ptra is pointing to a[1], and ptrb is pointing to b[1]. In this case ptra < ptrb is undefined, because their pointing to two different arrays. So, may be in memory a is lead out before b and so on, but that is not what the < or = operation is supposed to do. It is suppose to compare pointers only within the same array.   So, with this understanding let us understand how the reverse array works. So, in the first iteration, you have an array a[ ], let say that array is 101, 21, and so on, it has 6 locations. And we will run through that trace of the execution for an even length array, and I would encourage you to create and odd length array, and trace to the executions to ensure that the code works for odd length arrays as well. So, in this lecture will do it for an even length array. So, a is initially pointing to the beginning of the array, b is pointing to the end of the array, a + n - 1 will go to the end of the array. Now b < a that is true. So, we will enter the loop and in the first iteration we will swap a and b.    So, it will go to the swap function, and this is the swap function that actually works from the previous video. So, you can assume that a[0] will be swapped with a[1]. So, they were initially 101 and 0, and after swap they will be 0 and 101. Come once that happens a advances by one integer location b goes back by one integer location. So, this the state after the first iteration. In the second iteration you start with a at 21, and b at - 101, again b < a, so is swap.    So, 21 - 101 becomes - 101 and 21, so they are swapped. And you advance a by 1 and you take back b by 1, again b < a.   So, you go to the third iteration. In the third iteration this the state of the beginning of the iteration, and the swap these contents. So, you swap - 1 and 121 it becomes this becomes the state of the array, and once that is done b over suits. So, b b goes before a, and a go goes after b, swap denoted there with two colored arrows. So, here is the b arrow, it goes to location 121, and a arrow goes to location - 1. When this happens b is now < a. So, this means that you have cross the middle of the array. Therefore, you should stop now. So, now b < a, and the loop terminates, and we have seen that this correctly reverse the array. So, here is how the reverse array works, we have seen the concept of relational comparison operators using pointers. How do make sense when they are pointing to locations with them the same array, and how that can be used to write code to using arrays.  In this video, we will see the sizeof operator, which is a slightly advanced topic, in relation to pointer arithmetic. This is explaining, how pointer arithmetic freely works. And it is also important to understand one topic that, we will see later on and called malloc.  So, the sizeof operator and note that, it is an operator and that highlighted that in red, it looks like a function call, but it is not. The operator gives the number of bytes that any value with the given type occupies. So, sizeof is an operator which takes the name of a type of as an assigned argument, it can also take other kinds of arguments, we will see that. So, you could ask, what is the sizeof an int? What is the sizeof a float? What is the sizeof a character? And the answer, the value that it will come out to be will depend on some particular machine. So, the reason why we use the sizeof operator is that, it helps you to write the code that is general enough for any machine, we will see, what that means? So, right now you just returns you the size of any given data type.  So, the sizeof operator has an effect on the way data is allocated and the way details allocated depends on the machine, we will see that. So, for an example if you have a character array, the cells are 1 byte apart. So, sizeof operator returns you the number of bytes that a data type occupies. So, in the case of a character, the character occupies 1 byte. So, if you have a character array declared as char s[8], what you have are, 8 cells and each of those cells occupy a width of 1 byte. So, let us say that the character arrays starts at hexadecimal address 1000. So, the next cell will be at the next byte, which is byte address hexadecimal 1001. And this goes on until the last cell which is hexadecimal 1007. So, this contains a null terminator character array with the letters s u c c e s s and then followed by a null. What happens with an integer array? So, in an integer array, sizeof an int is 4 bytes. So, the successive elements of an integer array are 4 bytes apart. So, let us say that I have declared an integer array as int a[4]. This means, that a 0 let us say, it starts at hexadecimal address 2000. Then, a 1 will start 4 bytes away, because the size of an int is 4 bytes. So, it should start at address hexadecimal 2004 and I have sort of indicated it pictorially I want to say that a character is a narrower data type than an integer, an integer occupies 4 bytes. So, the next integer cell, the next integer element in the array will start at hexadecimal address 2004. The third element will start at hexadecimal address 2008 and the last at hexadecimal address 200c. So, notice that I should have started it at 2012. But, 12 in hexadecimal addressing scheme is c. So, in base 16, c is the same as decimal 12. So, that is why I have written it as hexadecimal 200c.  Now, let us look at pointer arithmetic in greater detail with our current understanding of the sizeof operator. So, suppose you have an int *pointer. If you have an int  *pointer and then you want to say that ptr + i is equal to, what it should? So, notice that + make sense, when you are navigating within an array. So, ptr is let us say pointing to some cell within the array and ptr + i should go to the ith cell after ptr, that is what, it should do. Now, the i th cell after ptr means the i th integer after ptr. So, we should skip 4 i bytes in order to reach the i th integer cell after ptr. So, thus is what we have written here ptr + i is the byte number, ptr + i*sizeof(int), the machine addressing goes in terms of bytes. So, in order to jump to the ith integer cell, we have to know, how many bytes to skip? And the size of an integer is 4 bytes. So, this means we have to skip ahead 4 i bytes, in order to reach ptr + i. Now, if have we declared character *ptr, then ptr + i is supposed to jump to the i th character after ptr size of a character is 1 byte. So, ptr + i*sizeof(char) would be ptr + i*1, it is the same as ptr + i. So, notice that let us say that, machine understands only byte addresses. So, in order to execute ptr + i correctly, we have to tell which byte should I go to, should the machine go to? And in order to do that, you utilize the sizeof operator. So, since we have declared character *ptr, you know that it is sizeof character, i*sizeof character those many bytes I have to skip. In the previous case, I have declare int *ptr. So, in that case I have to skip i*sizeof (int), in order to reach the correct cell. So, here is the actual reason why ptr + i would magically work correctly. Whether, it was an integer array or it was a character array? This is because, at the back of it all, you translate everything to byte addresses using star sizeof whatever type. So, in general if you have type *ptr, then ptr + i is the byte number ptr + i*sizeof (type). So, this type is the same as the declared type of pointer, ptr is a pointer to that type. Therefore, you multiply it with sizeof(type) and this is the general formula for pointer arithmetic. Now, one of the side effects of that or one of the consequences of this kind of addressing is that, array + i is *(array + i) and it will correctly jump to the i th location in that array, regardless of whatever type the array was. Why is that? Because, array + i is then translated to array + i*sizeof whatever type the array has been declared to be. So, you will correctly jump to the byte address corresponding to the i th element in the array. So, here is how array arithmetic in c works, in full. What do we mean by this? Let us see that with the help of an example.  Suppose, you have an integer array declared as int a[10] and it starts at the address 2000. And I want to know, how is it that you get this third element of the array a[2]. So, a[2] we know is *(a + 2), a is a pointer to the first element of the array. And you have to now understand, how + 2 is executed? So, + 2 should be the content located at byte address a + 2*sizeof(int). Why is this? A is been declared as integer array. And in c, integer array has the same type as int *. So, a is a pointer to int. Therefore, we know that, we have to do a + 2*sizeof (int). Whatever the argument is, it will do 2*sizeof the type pointer 2 by that pointer. So, we will do a+2*4, which is hexadecimal address 2008, a was 2000. So, if you have an array int a[4], let say and it started at address 2000, then you will jump to array address 2008. And this is the reason, why c arrays start at index 0? Because, it is a very easy formula, a[0] would be *(a+0), which is simply *a. In that case, you have the consistent explanation, that the name of the array is a pointer to the first element of the array, you do not need a special rule to do that. Think of what would have happen, if arrays started at 1. Then, a[2] would be a+1*sizeof(int). So, a[n] would be a + n - 1 times sizeof whatever and that is an uglier formula than what we have here. So, it is better for arrays to start at location 0, because it makes the pointer arithmetic easier.  So, in summary the sizeof() operator is used in pointer arithmetic and we will see one more common use of the sizeof() operator, very soon.  So, the general usage is you can give size of an expression. What will it do is, it will take the type of that expression. So, if I say sizeof(10), then 10 is an int,. So, it will execute sizeof int and let us say that, on a particular machine it is 4 bytes. Similarly, you could also say sizeof type name. So, for example, I could say sizeof(int). Rather than giving an integer as an argument, I could also say sizeof(int), where int is the name of the type and it will return 4 on some particular machine. A less common usage is, you could give sizeof array, if the array is some particular array and it will return you the size of the array in bytes and this is important. It will not return you exactly the number of elements in the array, it will return the total size of the array in bytes. What do I mean by that? If I say, int num[10] and then I say sizeof(num), it will return is 40 because, there are 10 integers, each integer occupying 4 bytes. So, in order to calculate the number of elements in the array, for example, you could do the following, you could say sizeof(num) / sizeof(num[0]). So, this would evaluate to 40/4 which is 10. So, size of the operator on the array does not exactly give you the number of elements in the array, it will give you the total number of bytes in the array. But, if you also know how many bytes, the particular element in the array occupies, then you can easily figure out the size of the array, in terms of the number of elements. So, also note that c does not say that, an integer is 4 bytes or float is 4 bytes and so, on. What it specifies is the relationship between the sizes of various types and we will not get in to it, right now. But, just keep in mind that the size of a particular type is depended on, which machine you are running the code on.  In this video, we will discuss slightly advanced usage of pointers. Even though, the title of the first slide is, how to return pointers from a function? That is just a motivation for introducing a slightly more advance topic in pointers.  So, let us just see what is the problem with returning a pointer from a function? We know that, any variable can be passed as argument to a function, can be declared as a local variable within a function, and can also be a return from a function. So, is there something and we have already seen that, in the case of the swap function how we pass pointers to a function and what new kinds of functions does this enable us to write?  Let us examine that in slightly greater detail. What happens when we call the increment function? Inside the main function, we have an int pointer p and then it is declared, it is not pointing to anything and immediately, you will call increment(1). So, you call increment(1), n is a local variable in increment, it is the argument. So, n is 1 and then, you declare a temp and then, you declare a pointer to temp,. So, there is a ptr. Let us say that, temp is a address hexadecimal 1000. So, ptr contains 1000 and it points to temp, temp is at address 1000. Now, in the next statement you increment temp, you set temp to n + 1,. So, n is 1 and temp is 2. Now, ptr points to temp and now, I will return ptr. So, the return value is 1000, which is the address of temp.  Now, what happens when you return to main? As soon as increment finishes and we have said this several times before, as soon as any function finishes, the memory with that is allocated to the function is erased. So, when you return to the main function, what happens is that, you have p and p will contain the address 1000. So, it is meant to point to temp. But, the space meant for temp has already been erased. So, p is pointing to a junk value in memory, it is pointing to an arbitrary location in memory. So, this is known as a dangling pointer. Hopefully, the picture is a representative of a dangling pointer. The fact that, it points to a location, which is no longer meaningful. Notice that, what I am talking about is the ideal situation, when you code it in c and try to run it, may be p does point to the location with address two. This is because, c may not be aggressive in re cleaning the memory. But, you should always assume that, the safe thing is to assume every location that was allocated to increment is erased immediately after increment returns. In practice, it may not be the case,, but you should never assume that, you still have the temp variable. In general, what you will have is a dangling pointer. Because, p points to a location which no longer contains any relevant information. So, when you print p, you will have a danger. So, how do you return pointers from a function? So, we have seen what a dangling pointer means? And here is a very silly function, which will create a dangling pointer. Now, what is the problem with this function, it returns the address of a local variable temp. But, temp is erased as soon as increment n returns. So, the return value is not a meaningful address to the calling function, which is mean. Can we get around this?  So, the main problem here is that, anything that is allocated to the called function on the stack is erased as soon as it returns. Is there any way at all to meaningfully return pointers to new variables? Then, use a new concept that is a globally accessible memory called heap, we have already seen a stack. Now, we will understand what a heap is. So, roughly the idea is that, if you allocate value on the global memory, it is not erased when the function returns.  I will explain this with the help of a slightly a broad analogy. Hopefully, this is indicative of what actually happens with the heap? So, think of executing a function as writing on a classroom blackboard, when a lecture is going on. Once the function finishes execution, which is like the class is over, everything on the blackboard is erased. Suppose, you want to retain a message after the class is over. Now, the solution could be that you can post things on a notice board, which is global to all class rooms. So, it is common to all class rooms. So, things on the notice board are not removed as soon as a class is over. If you write something on the blackboard, which is similar to storing something on the stack, as soon as the class is over, it will be erased. So, if you have something to communicate back to another class, may be you can post it on a notice board. Now, the notice board is globally accessible to all class rooms. The black board is like a stack and the global notice board is like a heap and contents on the heap is not erased, when the function finishes.  So, how do you allocate things on the heap? There is a standard library function called malloc, in the file stdlib.h which can be used to allocate space on the heap. Roughly, this is what it does, if you ask for malloc(n), there n is an positive integer, it will allocate n bytes of memory on the heap and it will return a pointer to the first location of the allocated space. Now, that pointer can be converted to pointer of any type, malloc just allocates n bytes. Now, you may want to interpret those bytes as n divided by 4 integers. In that case, it will return a pointer,. So, you convert that pointer to an int pointer. Let us see an example I may have an ints pointer for ptr and now, I want to allocate 10 integers on the heap. How do you I do that? I will allocate 10 * sizeof(int). So, this will allocate on some particular machine, let us say 40 bytes and it will return an address of the first location. Now, that address I want to treat it as an integer address. So, I will convert it to an int as int * and then malloc (10*sizeof(int));. So, this style of writing code means the code portable. Because, suppose you write the code and on a machine, where integer was 4 bytes and you take your code and go to a bigger machine, which has 8 bytes as the size of an integer. Then, you compile the code on that machine and your code will still allocate 10 integers. Why? Because, on the new machine sizeof(int) will be automatically 8. So, it will allocate 80 bytes. So, in order to write portable code, you can use sizeof(int), instead of assuming that, integer is 4 bytes. So, I want to allocate malloc (10*sizeof(int));, this will allocate 10 integers no matter, which machine you do it all. So, and it will return you the address of the first byte in that allocated space, that address you convert to an integer array, integer pointer. Here is, how you allocate memory on the heap.  So, when we think pictorially, think of heap has a separate space in the memory. In this case, ptr will be allocated some space on the heap. Let us say 10 integers on some particular machine, it will say 40 bytes and it will return the address of the first byte. Now, that first byte you treat it as a pointer to int, that is done through the conversion int *.  Now, it is nice that you can allocates space on the heap. But, in order to be hygienic, you should also remove the allocated space, once you have done with it. There should be a reverse operation to allocate and that is free, it is in the same library, stdlib.h. And if I just say free(ptr) and ptr was originally allocated using malloc. Then, it will correctly remove,; however, many bytes were originally allocated. So, let us say that I have int *ptr and then ptr, I allocate 10 integers on the heap and ptr is the address of the first allocated location. Now, I may do a bunch of processing here and once I have done, it is just nicer me to de allocate things on the heap. This is like, saying that things on the notice board once some condition occurs, where you know that the notices no longer needed, you just remove that posting from the notice board for that, we use free of ptr. Now, notice the asymmetry here, malloc took the number of bytes to be allocated free just wanted to say, which pointer is to be free? It does not ask for, how many bytes to free? So, you can imagine that malloc does some kind of book keeping, where it says that I allocated 40 bytes and that was return to ptr. So, if I just say free(ptr) it automatically knows that, 40 bytes are to be free, you do not have to give the extra argument saying, how many bytes to free? Once you free the pointer, you just set it back to null, this is just a safe practice and it is not absolutely necessary,, but it is recommended.  So, let us solve our earlier problem using malloc. Our earlier problem was that, ptr was pointing to some location within the stack. So, as soon as the function returned, the return address no longer meant any meaningful address. So, let us now solve this problem. I have included stdlib.h, because I will allocate memory on the heap. So, the increment function is modified as follows strictly speaking, I do not need a temp variable any more. I have an int pointer and I will use the pointer to allocate one integer on the heap, this is a really wasteful practice but, it just illustrates a point. So, it will allocate one integer on the heap and then, return that address and treat that address as int *. Now, I will use * ptr = n + 1 to dereference that location on the heap and set the value to n + 1. Once I am done, I will return the ptr I will return the address on the heap.  What happens here is that, the increment function ptr points to some location on the heap, using malloc. So, one integer is allocated on the heap and when you say, *ptr = n + 1’s, then the location in the heap will contain 2.  And here is the catch, earlier p was just dangling, it was just pointing to an arbitrary location in the memory. But, increment allocated something on the heap and returned that address. As soon as increment returns, the stack is a waste. So, everything that was allocated on the stack for increment is erased,, but things that are allocated on the heap remain. So, p points to a meaningful address on the heap, then once you are done you can say free(p) and things will be erased, when you print it, the output will be 2.  Malloc and free are prone to a lot of errors and a lot of programming errors in c, can be trace back to incorrect use of malloc and free. So, there are some categories of errors for example, you may forget to malloc in the first place. So, you will lead to dangling references or dangling pointers, as we saw in the first example. Now, you could allocate some space. But, you may not allocate enough space, that is a very common error. Commonly, you could allocate of by one errors I wanted to allocate really len + 1 number of bytes. But, instead I allocated only len number of bytes. Another very common error is something known as a memory leak, which is that you allocate things on the heap,, but you forget to free memory after use, this is called a memory leak. Notice that, if you allocate space on the stack, it will always be cleaned up as soon as the function returns. So, memory leaks usually happen, when you malloc space on the heap. But, you forget to free them, once you have done and a lot of software ships with memory leaks and this is a major concern in the industry. This is also an obscure error, which is freeing the same memory more than once. This is uncommon when a single programmer is working on a code. But, when multiple programmers are working on the same piece of code, you may end up freeing the same memory twice, this will lead to some run time errors.    In this lecture let us look at an application of malloc and free to solve some problem that we are interested in. So, the problem that I will define is to write a function to return the duplicate of a string; a string is given us the argument and you have to return the duplicate of that string. So, we have to write a function to take a string as input and return the copy. Now let us assume that the input string is s, and it ends in a null character. Assume that we can find the number of null non null characters in the string. So, this is will be refer to us the length of the string. What we will do is allocate length + 1 characters. So, there are length non null characters, and then one more for storing the null characters. So, we will allocate len + 1 characters on the, heap using malloc, and we will copy the contents of s to that space on the heap. And finally, return the address of that location. So, that will be the t th the new array. So, notice that the original array may be on the stack, and the new array the duplicate array will be on the heap. Let us write this function.       So, I will call it duplicate it takes one array which is the same as a pointer. So, I can declare it has char *s or char s with square brackets, it does not matter. So, I will just declare it has a character *s, and what will it return? It will return another array, and array is the same as a pointer. So, I will return character star. So, the input argument is an array, and the output is also an array. I will declare 3 variables; i which is for the loop, len which will store the number of non null characters in s. So, let us be very specific, I do not want to store the number of characters in s, because I want to say that I do not want to count null.  Now if you want to count null as well in the length then you will modified the code, but typical convention is that when you mention the length of a string, you do not count the null character. I will also declare a char *t. Now the code proceeds and stages; first I have to write a loop to find the length of the string, I can write a very simple loop to do that I can say for i = 0 as long as s of i is not null, do increment i. So, as soon as I see the first null in s, I will stop. When I exit out of the loop, I will be the number of non null characters in s. So, I can say len = i. So, in the first step of the function, we just find the length of the string excluding the null character at the end.  Now comes the important thing, we have to copy that array to somewhere. If we copy that array to the stack itself that is if I copy that array to some space within the duplicate functions stack, it will be erased when I return. So, I should allocate the space on the heap. I can allocate space on the heap using the malloc function. So, let us look at the malloc function. I want to allocate a bunch of space on the heap, how much do I have to allocate, I have to allocate len + 1 number of characters. In other words, I have to allocate len + 1 times sizeof a single character; these many bytes on the heap. Notice that it is not len times sizeof(char), because if I allocate only that much then I will not have to space to copy the last null character. So, I should the input is a null terminated character, it is duplicate should also the null terminated. So, I should makes space for all characters including the null character on the heap. So, I will allocate (len+1) * sizeof(char) many bytes on the heap, it will return you the address of the first byte and that address I will convert to a char star. So, malloc returns a kind of an unsorted. So, here are these many bytes. Now it will return you the address of the first byte that was located, now I want to treat that as a character pointer. So, I will can do that using the casting operator. Why do I have to do that think about it for a minute, because you want pointer arithmetic to work. When I say t[i], I should correctly execute star of t + i. So, go back to that lecture and understand why it is important that you know the it is not just a byte address, it is a character pointer. Once you do the allocation, you can copy s array into t array. We do not really care about the fact that t is not on the stack, t is on the heap, because copying is done exactly the same way. So, I can say i = 0, i < len, i ++ t[i] = s[i]. And then finally, this will copy all the non null characters, and finally I will say t[i] = null, the last character will be the null character. Now, if you want to understand it in slightly greater detail understand why the character star cast was required in order for t[i] to work properly. Once I have done copying the array, I can just return t, and I will not leap it will not lead to a dangling pointer because t is allocated on the heap. So, let us pictorially understand what happens during the execution of this program. I have main function, and I allocate a char array. Now this is allocated on the stack. As soon as I declare a character array and initialized it with in main, it is allocated in the stack corresponding to main. So, s is a pointer to the first location in the array. And I declare another *t, and then I call t = duplicate(s), I should return a separate copy of s. Let see what happens in the duplicate function? We do allocation for all the local variables all that, but important thing is that we have s and t which are new pointers. Now s is the input argument to duplicate, and it will be pointing to the array in the main function, because I call duplicate(s). So, duplicates s will point to the same array as the s of mean. So, it is pointing to the array on the stack, Now as soon as I allocate memory for t on the heap, which was step 3 of duplicate, I would say t = (char *)malloc( (len+1) * sizeof(char) ). What is len here? len is 6; there are 6 non null characters len + 1 is 7. So, I allocate 7 characters on the heap, and its return address will be cost to a character pointer. So, t is now pointing to this space on the heap. Now, once I am done ((Refer Time: 08:33)) creating the space on the heap, what I can do is, I can copy the location the s array into the t array on the heap. So, once that loop executes it will look like this, here is the s array inside main, here is the heap the array allocated by duplicate, and you will just copy t[i] = s[i] for. So, you will copy ‘s’ ‘a’ ‘m’ ‘p’ ‘l’ ‘e’, that is within the loop. And then finally, I will say that t[6] = ‘\0’. So, here is an array of size 7, it has a 6 non null characters and the last element is null.   And then once I am done, I will return from duplicate. Again keep in mind what is erased is the stack. Everything that was allocated to duplicate on the stack is erased. Those s t and the local variables in duplicate no longer exist, but the work that was done by allocating on the heap that still remains. So, the return value t, that is return value which is the address of the array in heap will be assign to t. So, t now points to heap. Notice how it executed s was allocated on the stack, and the effect of the duplicate function will be that, the duplicate of the array will be created on the heap.  So, notice what we understood about the sizeof operator. Sizeof operator was use to know the number of bytes need at the stored data type. It is used in pointer arithmetic, it is used in array index calculation, and it is also used when allocating memory on the heap, because malloc needed to know how many bytes to allocate. And suppose I have wanted to allocate 10 integers, instead of me saying that on this machine I know that and integer is 4 bytes. So, you go ahead in allocate 40 bytes. The problem with doing that is you take your code to another machine, and that machine integer is 8 bytes; and your code will no longer allocate sufficient space. So, the real way to write portable code would be to say 10 times sizeof int, that code will work regardless of which machine you execute on.  So, here is the use of sizeof operator when you call malloc, it helps you to write portable code which will execute on any machine. So, we have seen that allocating memory on the heap can be done using malloc, we have understood what it means to allocate memory on the heap the difference between stack and heap; stack is erased as soon as a function returns, heap is not erased when a function returns you have to explicitly say that i ((Refer Time: 11:39)) now freeing that using free function. Again remember the asymmetry within malloc and free; malloc needed to know how many bytes you allocate, free just needed to know which pointer to de allocate, which pointer to free. Did not want to know how many bytes to free, it does that automatically. And to repeat common errors using malloc you could forget to malloc. Now you could not allocate enough space in heap. For example, in the code that we have just seen, suppose you are allocated just len number of characters instead of len + 1. Then you would not have enough space on the heap to copy the last null character. So, you will violet that t is an exact duplicate(s). Now you could forget to free memory after use, this is called a memory leak, and you could have the sub square error of freeing the same memory twice, that leaves to run time errors.   Now, recursion is usually something that is completely new. it is a new way of thinking about problems that might sound unfamiliar at first, but eventually it is a more natural way of solving problems than other techniques. So, we will carefully examine what recursion means. So, this is the video of a media player having a copy of itself inside the video and it goes on forever. We will see what does this have to do with recursion.  So, recursion in English means roughly say again i am function defined in terms of itself are called recursive functions. Now, this is not completely accurate. We want to say that functions defined in terms of itself in a particular way, these are valid recursions. Recursion is a powerful tool for program construction and for thinking about and reasoning about functions in general. So, it is a general purpose technique of programming, and you can do any kind of program using only just recursion. We will not see such general types of recursion in this course, but we will see fairly common examples for recursions.  So, for example, let us consider a very simple function which will search for a key within a given array and we know how to write this. What i will do is, i will take an integer, initialize it to 0, for i = 0 to n. N is the size of the array. i will increment i and if at any i, i find the key, i will return 1 indicating that i have found the key. if i have not found the key and i have reached the end of theory, i will return-1. This is a typical way to search for a key inside a given array. Now, we will approach the idea of recursion by looking at a recursive solution to this. Hopefully, while seeing this program, we will get an idea of what recursion means.  So, what do we mean by a recursive solution to this, right. Rather than defining it and describing abstract properties of recursion, why not let write an actual program which is defined in the recursive manner and through these kinds of examples will eventually get the hang of recursion. So, we have to write a function search it will return whether a key is found or not. if the key is found, it returns 1. if the key is the not found, it returns a-1 and you have to search an array a of size n for the key. Now, we have written this function just now using loops. Now, let us write this using recursion.   So, let us say that i will in some unspecified syntax, this is not going to be valid c, but this is just so that we see the idea in a very clear manner. i have to search for an array of size a of size n for key. Now, if the array is empty that is n is equal to 0, you can have more conditions here. N can be < 0 as well, but let say that empty array is n is equal to 0, then you say that i have not found the key because it is an empty array. So, you give back the value-1. So, n = 0 implies the value to be returned this-1. That is what this notation is supposed to stand for. Suppose n is not 0, so, this means that an array is non-empty. Now, how do we solve this, recursively right. So, this look for the first element whether it is the key or not. if the first element is the key, we do not have to do anything further. We know that the key is present in the arrays, so you return 1. So, the key has been found and you return 1, and now is the big step for recursion. How can we search for the key in an array of size smaller than n? So, if a[0] is not equal to key, then this means that key can be somewhere in a 1 through a n-1 or it is absent in the array. in any case what we now have to do is search for the arrays starting at a 1, so by a 1 this is not strictly c notation. What i mean is the sub arrays starting at a + 1. So, search in the sub array starting at a + 1. Now, the sub array has one element less because we already know if you are here that a 0 is not equal to key, so there are only n-1 element in the smaller sub problem. What do we have to search for, we have to search for the key. So, this says that either the key is present as the first element of the array or you have to solve the sub problem of searching in the sub array of size n-1 for the same key. So, here is the key to thinking about a problem in recursive terms. What you first do is, consider the case when you have the trivial array which is the empty array in this case. So, we have the base case and then, these are the recursive case. So, the recursive case consists of doing something at size n. So, in this case, it is search whether the first element is the key or not. if it is true, then we do not have to do anything further, we have found the key, otherwise solve the sub problem. Now, the sub problem is a smaller copy of the old problem. So, this is what is known as the inductive case or the recursive case. The reason i am calling it inductive case is that recursion has very tight connections to the idea of mathematical induction. if you know how to write a proof by mathematical induction, what you normally do is you consider a base case. So, you have a theorem and you want to prove this by mathematical induction. You consider the base case probably n = 1 or n = 0. These will be the base cases for an association about natural numbers and then, if the base case is true, then you say that i assume that the problem is true for size n and now, i want to prove that the theorem is true for size n + 1. This is how a mathematical induction proof looks like and in the case of a recursive program, there is a very tight analogy. Recursion in fact is just a mathematical induction in the context of writing programs. We have to solve a problem. First we will see what is a problem in the base case and the base case is a very trivial case usually, but it is important that you think about base case. You say that if the array is empty and then, i will return-1 because the key cannot be in the array. Then, you say that i will now define the problem of size n in terms of a sub problem of size n-1 for example. So, we will solve the same. We will solve the bigger problem in terms of a smaller copy of itself and this is the key to thinking about recursive programs.  Let us code this in c. So, we code this in a very straight forward manner. i will write a int search, int a[], int n which is the size of the array a, int key which is the key we are searching for. if n = 0, then return-1 because the key is not found. This is the base case and otherwise n > 0, so you can search for a 0 is equal to key or not. So, you can search for whether the first element is the key. if it is, then you have found the key, otherwise what you do is you call search a + 1 which is the sub arrays starting at size 1. The sub array has size n-1 and key. So, when you search or write a recursive program, there are a few things that you want to check. The first is that the base case is properly handled. The second is that when you define the sub problem, you want to ensure that it really is a sub problem because if you solve the problem in terms of an equal size problem or even a bigger size problem, your program may not terminate. We will see this in a moment. So, this part which is highlighted in green which is calling search itself, but on a smaller sub problem is a + 1 n-1. This is what is known as a recursive call to the same function. So, we have seen functions that can call other functions. Now, we have seen functions which can call themselves and this is what is known as recursion.  Let’s see how this function behaves. Now, before we go into the execution trace of this function, i want to add a word of caution. The actual way to understand recursion is not to think about the stack and how functions are calling other functions. The real way to understand recursion is to think about this program as a problem defined in terms of sub instance. But in any case we will just see the execution of this function through the stack trace just to get comfortable with what happens at the back of all of this. So, let us do a quick trace. Suppose we have an array 31 4 10 35 59. it is an array of size 5 named a, and we are searching for the key 3. Now, we know that this key is not present in the array, but let see how the function executes. So, first we call search(a,5,3). A 0 is 31 which is not the key. So, it calls search a + 1 4 because now we are searching in the sub array of size 4 for the same key. So, that is in effect, the same as calling the same search function on this sub array highlighted in grey. This is because the answer to search in the whole array is now the same as answer to the search in the sub array. That is what the recursive statement is. Now, (a+1)[0] is 4 this is the first element of the sub array. A 4 is not 3 and a, and at this point you call the sub sub problem which is search a + 2, the sub array of size 3 for the key 3. Here is the sub array of size 3 and you are searching for 3 in this sub array. Again the first element of the array is 10, which is not 3. So, you call the sub problem of this which is a + 3. Now, the array is of size 2 and you will search for 3 and this goes on until you find that you have exhausted the array. Finally, the array is of size 0 and you will finally say that since the array is of size 0, i have not found the key. So, you return-1.  Let us just look at this stack of function cause and see how it looks like. Search(a,5,3) is called by mean and let say that it has some return address. We do not care about it right now, but search(a,5,3) calls search(a+1,4,3) and the place to return is some line in search function. This calls the sub sub problem a + 2 3 that calls a + 3 2 that calls a + 4 1, and that calls a + 5 0 at which point you realize that the sub problem now is empty and then, you return a-1. So, at this point you have reached the base case. if n = 0, return-1. So, that will return a-1. Where will it return to? it will return to the function which immediately called it which is search(a+4,1,3). So, this guy gets a-1. Therefore, it just returns that-1, return the value of whatever is returned by the sub problem, ok. So, it is-1 and that-1 gets returned. So, it gets bubbled up all the way back to main, and main you can realize that the element is not present in the array because the return value of search(a,5,3) was-1. At this point, the call stack terminates.  So, what was special about the recursion call stack? it was just that most of the stack was involved by a function calling itself over and over, but each time the function called itself, it was calling on a smaller version of the problem. Here is how, you think about a very simple program in terms of recursion. Earlier, we saw how to solve this using iteration which was using a loop and we have seen the problem how to be solved using recursion. Now, a word of caution, we will see this in further examples. it is very important that you handle the base case properly. Now, this is something that we are not used to in normal way of thinking. When we think about solving a problem, we are thinking about solving substantial sizes of the problems. We are not concerned too much with what happens with an empty array, what happens when n is-1 and things like that, but even in this problem, we know that when we call search(a + 5,0,3) we know that the function terminated because we had a base case which said that if n equals to 0, then return-1. if we did not have this case, you could see that probably it will go on calling itself infinite number of times. So, just like when you are writing for loop or a while, loop you have the case of infinite loops. in the case of recursion, you can have an infinite recursion and you have to guard against that. The only way to guard against that is to get the base case correct. So, here is something in counter intuitive about programming recursive functions. You know almost half of your intellectual effort is in handling the base case properly, and only the remaining is involved in solving the recursive case.   In this video will look at linear recursion in a bit more depth, while I describe what I mean by linear recursion. We have mentioned earlier that when designing recursive programs, think about the problem in recursive terms, do not think in terms after stack that is used in execution. When it is actually executed that will be a stack created and use for the execution, and that depth of recursion is a term which means the maximum size of the stack, while you execute the program on given input. The memory used by the programs includes the local memory of the function, + the depth of the stack.  .  Let see with an example. We will consider actually two examples; one for even length array, and another for an odd length array. Let say that a is an even length array with six elements and we want to reverse it, using the function reverse a[6], and we have to do it in a recursive way. So, what you do is first swap a[0] with a[5]. And now what is the sub problem left be solved. We have to solve reverse of this intermediate array, which starts from a[1] and contains four elements. So, we have to reverse the array with starts from a + 1, and there are four elements to be reversed. So, in one step even though we have only a single call to a sub problem, we have actually reduced the size by 2. Now use a reverse or rather swap a and a[1] and a[4], and now the sub problem that remains is, to reverse this sub routine which is a + 3, and you have two elements to reverse. So, you do this, and in this point you have a sub array which starts at a + 3 and has zero elements to reverse. At this point that is nothing but. Now, for in odd length array let us take a very small array which contains three elements, and we have to reverse it. What you do is, you reverse you swap b[0] with b[2]. At this point you have a sub problem which has exactly 1 element, and you do need to reverse that array, that arrays it is soon reverse. So, the problem just stops there. So, notice that difference between the even length array the odd length array. In the case of even length array, the step, just before the last step involved an array of size 2, and you still had to reverse that is array. In the case of an odd length array this, the last of involves has a single length array, which is soon reversed. So, you do not have to do anything. So, there are two base cases to worry about; one is where the sub array is of size zero, and another is where the sub array is of size 1, 0 corresponds to even length arrays, and one corresponds odd length arrays.  Let us write this code now. So, we have reverse a containing n elements, and we have return type void, which means that this function is not going to return you value, but it is going to do something. So, if n=0 or n = 1 return, because in that case a is, it is on reverse; otherwise you swap the first element with a last element, that is this operation a and a + n - 1. So, notice that swap is a function that takes two pointers to int and exchanges them. Once you do that you call the sub problem, which is reverse(a + 1, n – 2). Notice that unlike the previous examples we have discussed, the sub problem reduces by 2 insides. Even though you have a only single call, the sub problem is not of size n - 1, it is of size n - 2. So, look at the case of the odd length array and the even length array that we have seen before. And you can notice that the sub problem reduces by 2 in size for every step. Now what is the depth of the stack. you know that ruffle n upon to calls will be done, because you start at a size n, the next call will be of size n - 2 and so on until you hit either one or zero. So, you can work out that there will be about n/2 steps, before you reach one or zero. The accurate expression is, ceiling of the expression n / 2 + 1. So, many calls will be there, before you hit 1 or 0. So, each function call will take, let us a constant among space and there are about n/2 function calls. So, the stack depth is n/2, and therefore, the wholes space which is stack depth times the number of variables at each function that will be about n/2.  So, now let us consider a third example which is, computing the size, the maximum of a particular array. For concreteness let us consider in integer array, and we have to compute the following function int max array. It takes two arguments; one is the array itself, and the second is m, which is the number of elements in the array. Again let us think about the problem recursively, we have return loops to solve the problem earlier, but now let us think about it in a recursive manner. If the array contains 0 elements, then what is the maximum. So, here it may be slightly counter intuitive if you are saying for the first time. The maximum of an empty array is some large a negative value. Think of it has minus infinity. Why do we do this this is, because let us take a concrete example 1 2 3. We know that the maximum of this array is three. Now, what happens when you take a larger array or list of numbers. So, what happens if you take, let us keep this unspecified a is an int. You know that if a is less than 3 then the maximum of this array is going to be three. If a > 3 then the maximum of this the second one is going to be greater than that. So, in any case, whatever be the nature of a you can always say that maximum {1 2 3} a is going to be >= the maximum {1 2 3}. Now what; that means is that, if you take a larger set, its maximum is always going to be >= the maximum of a sub set.  Note that this is independent of a, because you can analysis my cases, if a <= 3 then this maximum will 3 itself and 3 >= 3. If a > 3, then this maximum is strictly greater than the previous maximum. So, maximum is always monotone according to the sub set relation. Now this means that what will be the maximum of the empty set. The empty set is a sub set of every set. So, no matter which s I pick, maximum s has to be >= maximum of the empty set. This means that a reasonable value for maximum of empty set is minus infinity. So, the set... So, this is a reasonable convention; that is why when n is of size zero, we returns some really large negative value. By which I mean the absolute value of the number is really big, because we are trying to say that it essentially minus infinity. If n is of size 1, then you just return a[0], because the array contains only 1 element, it is maximum will be a zero. If n has size at least 2. Now we are in business, we have to solve the problem in terms of a sub problem. So, here was an example where the base cases had to be really thought of, but now we are at the case where we are thinking about the recursion. So, what is the recursive step here.  So, let us take a concrete array. We have array a, which contains the numbers 2 4 3 7 5 23, - 3 and 9, some concrete array. And I want to calculate the maximum of the array a in terms of some sub problem. The natural sub problem that we can think of, is the sub problem of finding the maximum of this sub array, which start from a[1] and goes on until the last element. So, recursive call should be something like max array a + 1, and there are n - 1 elements in it, because we omit the first element. Now, maximum value, how can we solve the whole problem in terms of the sub problem. Suppose we note what is the maximum value in the tail; a + 1, 2 containing n - 1 elements. The maximum of the whole array will be the greater of the two numbers, which two numbers, the maximum of this sub array and a[0]. So, maximum value is the large of a zero and the maximum of the tail sub array, which is a + 1 to a + n - 1. Now in order to compute the sub problem we called a recursive call to the same function, looks for the max array from a + 1 containing n - 1 elements.  So, in this example, the maximum of the tail sub array will be 23. And let say that a zero is 25. So, the maximum of the whole array will be the greater of the two numbers 25 and 23. So, in this case, the maximum value will be 25 which is a[0].  So, now let us write this code. So, the recursive function is very simple, and this is one of the reasons why people like to write recursive functions, because from a recursive function it is very clear what the function is going to do. Usually recursive functions are shorter than their loop versions, and they are easier to understand when you read someone else code. So, let us solve max array using the recursive function in c. We have int max array, because it is finally, going to return in int value which is the greatest value in the array. Now you have an int array a, and n is the size of the array. Let say that we set some max val if n is 0, then the maximum is simply something like minus infinity. Let us keep it a very large number - 9 9 9 9 9. So, - 5 9, some large value does not matter, and then if n = 1 then the array contains only one element and therefore, it is the maximum. So, you just return a[0]; otherwise n is at least 2. So, in this case, you say that the maximum value of the sub problem is max array a + 1, n - 1. So, this is the maximum of the tail array.  Now once you have the maximum of the tail array, the maximum of the whole array is the grater of the two numbers which is a[0] and max val. So, we return max{a[0],  max val}. Now max is a function that is already there in the standard math library in c, but if you want to write it, it is not a difficult function to write it, you can take two integers and return the greater of the true integers. Now we can think about is a better then the loop version of the program. The advantage of the recursive program is that, it is easier and in some sense it contains fewer number of lines then the loop program. The disadvantage is that it takes subs more space while executing. So, the questions are how much time does the function take, how much space does the function take. So, these are things which are concrete and can be measured, there is also software question which is, how you see is set for programmer to look at this function and understand what it does. In the second criteria and it is the recursive function that is course. In the first criteria it is often the iterative function, the loop function that is course.  So, please think about the questions, and you can work through it and say that in order to solve max_array of an array of size n. Let us take an array size 8, you will see that these other recursive calls it will make (a + 2,6) so on up to (a + 7,1), and when you hit an array of size 1 you get to one of the base cases, which is that when you have an array which contains a single element, the maximum is the only element in the array. So, once you hit here, you will start returning. So, the maximum depth of function calls in this will be the size of the array. So, you can say that stack depth is n.  Now, recursive programs are general programs, just like look loop programs are general programs. You have return loops even before you saw what are arrays in C? Similarly you can write recursive programs which deal with general data, not just array data. And in all of these questions, you can ask the following question how much time does the function take, and how much space does the function take.  We will see an example for a recursive function, that will read n numbers and returns the maximum. Before we came to know of C arrays, this is the kind of loop functions that we used to write, we would take n numbers. So, first you will read how many numbers to read, then you will read exactly those many numbers and find their maximum using a loop. Now Let us try to do that using recursion. We are not going to use any arrays. So, what we have to do is, write a function to read_max, it takes n elements. And the logic is the same as finding the maximum of an array, but we will do it without using arrays. How do you do this. If you have zero numbers to read then you return minus infinity, or some approximation, some large negative value; otherwise you read the first number. If n = 1; that is we have to read only one number, then you just say that x the maximum; otherwise n >= 2, and we have read one number.  So, you say that return the maximum of the two values, which is x and what goes inside, inside you have to solve a sub problem, which is the sub problem of reading n - 1 numbers and returning the maximum. Go back and compare the program with finding the array maximum, and the recursion works exactly in the same way. So, we will read n - 1 numbers, and return the maximum of those, and then you compare maximum of the first number and the maximum of the sub problem. This is exactly as before except that we did not use any arrays. And how do you call this function, you just declare a main function with n, you scan it how many numbers to read, and call the function read max n. Finally, it will return the maximum of the n numbers read and you just print the value.   Now, there are other functions which are typically return in a recursive manner. We just saw that you can use recursion with arrays. We saw problems where, you do not need to use arrays, but you can still write a recursive routine. We now will come to arithmetic functions, and many arithmetic functions are of an recursively defined. For example, let us take to function Euclid’s algorithm, and you can write the GCD function as follows. You first ensure that a >= b using the swap function, and then you just call gcd(a,b). And gcd(a,b) is defined a recursively as follows. If b = 0 then gcd(a,b) = a. If b is non zero then you just return gcd(b, a%b). So, this is how you write recursive GCD routine. And I will make the clean that this routine is cleaner, then the iterative routine. In the iterative routine, remember we had to use an intermediate variable, which will store the value of, let say a and then did a careful three way exchange in order to accomplish b, a . a % b.  Here the code is very simple, if b is zero then we know the gcd(a,b) = a. If b is non zero then we know the gcd(a,b) is gcd(b, a%b). So, it is a very concise way of writing the function. Now you can ask the question which is better, is the recursive formulation or the iterative formulation. Logic is the same, so it will take the same number of steps. So, the time taken will roughly be the same. And we have also made the clean that there recursive version is easier to understand. The disadvantage may be the following that, the recursive function may use very deep stack. So you can ask the question like how deep will be the stack in the case of the recursive program. So, in the following video, we will talk about more general kinds of recursion. In this video and the previous video, we have seen recursive problem. So, it can be solve by one call to a sub problem, and we will see more general kinds of recursion. Thanks.  In this video we will look at slightly more general way of defining problems through recursion.   We will, for the lack of a better name, I will call it just two-way recursion. These are problems which are solved by calling two-sub instances. This is the picture of a family tree, and we will see that the call stack for a two-way recursive functions looks somewhat similar to a family tree.  Let us revisit a problem that we have seen which is to find the maximum value in an integer array. We saw that the stack depth in our earlier solution was order n, because each problem of size n called once at problem of size n - 1. Now, can we reduce the depth of the stack from something close to n to something smaller than n.  So, here is an alternate way to look at the problem which can be described in a very simple way. Instead of looking at the maximum of the first element and then the tail, what I can do is, take an array of size n and split it roughly in 2 halves. So, there is left half and a right half, each of size n over 2.  Now, imagine that you have the solution for the greatest element in the first half, let us call that x. And imagine that you have the greatest element of the right half, let us call that y. Now, whichever is greater among x and y, is going to be the greatest in the whole array. And this is the idea that we are going to implement right now.  So, divide the array into about 2 equal halves. The first half is 0 to a n/2  -1; this contains n/2 elements. And the second half is, a n/2, so on, upto n - 1; this is the right half. Now, recursively find the maximum element of each half. And let us say that you have x which is the maximum in the left half and y which is the maximum in the right half, then you just return the larger of x and y, that should be the largest element of the array.  While doing this we have to take care of the base cases. This is as before for the linear case; when n = 1 then the only element in the array is the maximum element, so, return a[0]. If n = 0 that is the array is empty, you return minus infinity. So, let us consider a concrete array; a, is an integer array with these elements.   Just to remind you, the linear version was done as follows: if n = 0, you return something like - infinity, a very large negative value. Now, if n = 1, you return a[0] which is the only element in the array. Otherwise, you have atleast 2 elements. And earlier what we did was, you call the sub problem, a + 1, so, the array which starts with the second element in the array. And now the sub problem has n - 1 elements because you are considering a 0, the first element as a separate thing.  Now, what you want it to return was maximum of whatever was returned in the sub problem. So, let that be some maxval. And whichever is greater, a[0] and maxval, that is going to be the greatest element in the array. Now, we saw that the stack depth for this problem was n because size n problem is being reduced to a size n - 1 problem. So, in each step we are reducing the size of the problem by 1, and increasing the stack depth by 1. So, in total that stack depth would be n because there will be about n calls or n - 1 calls; however, you want to count.   Now, let us look at the two-way recursive version. So, here is the algorithm that we discussed; and let us just code this up. So, we will have int max_array; and then int a, which is the array containing n elements. And let us say that we have some constant - infinity, we have defined elsewhere in the program. Later we will see how to do this. Let us say that if n = 0, you return - infinity, some large number, some large negative value. And if n = 1, you return the only value in the array. So, these are the base cases as before. The changes here; if you have at least 2 elements then you return maximum of the values returned by the 2 sub problems. What are the 2 sub problems? The first is the left half of the array which starts from, a, that is the, at the first location in the array, and contains n / 2 elements.  Then we need to compute the maximum of the right half; how do we find the right half? So, we need to skip, n / 2 elements, which went to the left half, to get to the first index in the right half. So, we do that by saying, a + n / 2. If, a, is the address of the first location of the whole array then a + 1 / 2, is going to be the first address of the first location of the right half.  And how many elements does the right half contain? n / 2 elements went to the left. Therefore, what we are left with is n – n/2. So, notice, how we call the left half starting from, a, and containing n / 2 elements; and right half which is starting from, a + n / 2, and containing n - n / 2 elements.  Now, let us examine whether this is better than the previous recursive call, where we reduce the problem of size n to a problem of size n / 2. It was called linear recursion because we called one sub problem in order to solve the whole problem. Here, we have, we are roughly dividing it into halves and then calling 2 version, 2 sub problems, each of size about n / 2. Now, surprisingly, we will see that there is a huge improvement if you do this. And this is one of the most elementary tricks in computer science which is called divide and concrete; and here is a very simple example of that. So, if you look at the concrete array that we had, and we call, max_array(a, 8), because this contains 8 elements. Now, we say that it will recursively call 2 sub problems which is maximum, max_array(a, 4). So, that will be the first 4 elements starting from, a 0. And then max_array(a + 4, 4), which are the 4 elements starting from, a 4 which is the fifth element in the array. Now, let us just look at the stack. Now, notice what types I repeatedly mentioned which is that in order to think about a recursive problem you just think about the formulation of the problem, and then what you have to convince yourself is if I solve the sub problems correctly then I will get the correct solution to the main problem. So, I will have, I will divide my work into 2 sub problems.  So, both of them will report their results back to me. Now, what I have to do is to figure out how do I put these 2 solutions together in order to solve the whole sub problem. So, think about it in terms of the design of the algorithm, and not about the execution stack. But, we will show why this is a major improvement over the linear recursion version of the same solution by looking at the stack.  So, let us just look at the stack; max_array(a, 8), calls, max_array(a, 4). Now, the way function calls in c works, you will go to the second half of this problem which is, (a + 4, 4), only after max_array(a, 4), is completely done, right. So, let us now see how, max (a, 4), will execute? It has 2 sub problems again. And let us look at the first sub problem which is, max_array(a, 2), that itself has a sub problem, max_array(a, 1). In order to abbreviate I will just put at dot there, but that dot is supposed to signify max_arr. Now, once you have solved this, suppose this is the base case, now it contains only 1 element, so, the only element is the maximum; so, it returns that value to, max_array(a, 2); that is one of the sub problems for, max_array(a, 2). So, now, this, max_array(a, 2), calls the second sub problem that it has, which is, max_array(a +1, 1). Again, it is a base case; it contains only 1 element; that single element is the greatest element in that.  So, you have 2 values now - one coming from the left and one coming from the right. And you just compare these 2 values, and that will be the greatest value in the first two elements of the array. So, once you do this, you return; and one you return, you get the value, max_array(a, 2). So, suppose, all of that happens, and then you return to, max_array(a, 4). At this point, this function will call its second component which is, max_array(a +2, 2), and the recursion continues.  So, as soon as a function returns its stack will be erased; I am showing that by dimming out that particular function call, ok. And this proceeds. So, once this value is obtained you can return to, max_array(a + 2, 2). Now, this function is finished because it has called both its sub problems. So, this will return. And this problem has returned, has finish with both its sub problems. So, you will, after this function is done you will eventually unwind all the way back up to the top.  And now, we are ready to call the second sub problem of, max_array(a, 8), which is max_array(a + 4, 4). And. you do it similarly. Now, one thing you can notice here, is that, at any point the active path, what are active on the stack, the functions which are not yet returned are the highlighted entries in the call tree, ok. So, for example, at the very end the call stack contains 4 functions. Before you eventually return and compute the loss, compute the maximum of the whole array, the worst case depth of the stack is 4. And we had 8 elements, so, you would thing that based on this experience that the depth of a stack is about n over 2. But, if you think more carefully about it what happens is that, at every sub problem, at every level, I am dividing the problem by 2.  So, the depth of the stack is the maximum length part in this tree. And at every step of the tree I am dividing the problem by 2. How many times do I have to divide in by 2 in order to reach 1, that will be the depth of the tree. Equivalently, you can think about, how many times do I have to double in order to reach n if I start from 1, that is the bottom of way. So, if I start from 1 and I double every level, how many times do I have to double in order to reach n, that is the solution to the equation 2x = n. So, what I have to find is, how many times do I have to double? So, how many times do I have to multiply 2 with itself in order to reach n? And you will see that the solution is log2 n. So, this is going to be the height of the call graph or the call tree. (Refer Slide Ti me: 13:29) So, the stack depth here is about, 1 + log n, that is approximately correct, which is a huge improvement over n. If you think of n as something like 1024 which is 210, we are saying that the stack depth is about 10. Notice that, in the linear case we would have a stack depth of about 1024, instead we are doing about 10. So, this is the huge improvement in the case of stack depth.  So, with a very simple idea which is instead of solving one sub problem of size n - 1, what if you split it into 2 halves, roughly about size n/2. You will see that you get a huge improvement in the stack depth. This is one of the simple ideas that we repeatedly use in computer science.  Now, there are standard arithmetic functions also which can be defined in terms of the two-way recursion. A very classic example is Fibonnaci numbers. So, for example, they are defined as, F0 = 1, F1 = 1. And for n >= 2, they are defined as Fn = Fn - 1 + Fn - 2. So, if you code this out, so, a very simple function, int fib(int n), if n = 0 or n = 1, you return 1. Otherwise, you return Fibonnaci, so, fib(n - 2) + fib(n – 1).  So, it is a very simple arithmetic sequence which is defined in terms of a two-way recursion. So, this is the very simple way to write it, but it is a very inefficient way to do it. So, we will see why it is inefficient in a moment.   If you just think of how you trace the function, in the case of a later, of a concrete Fibonnaci number; let us say, we want to calculate the fifth Fibonnaci number. Now, that depends on fib(4) and fib(3); fib(4) depends on fib(3) and fib(2); fib(3) depends on fib(2) and fib(1), and so on. So, this is the call graph that you will have, the call tree that you will have if you consider the calculation of Fibonnaci 5.  Now, what is the problem here? You will see that many computations are unnecessarily done multiple times. So, if you look at Fibonnaci 2 in the call graph, it is evaluated multiple times. So, Fibonnaci 2 is evaluated when fib(3) is called. It is also called when fib 4 is called. And fib(3) is called in a different context. When you want to calculate fib(5), even there fib(2) is called. So, you will see that fib(3) is called 2 times, fib(2) is called 3 times, and fib(1) is called 5 times, and so on.  So, we are unnecessarily repeating the work. And there is tricks in computer science to alleviate, to remove this kind of unnecessary work. But, that is strictly, it is not an idea that strictly falls into the concept of recursion, and is slightly outside the scope of this course. So, we will not cover this in this course, but I just want to point out that even though it is natural to consider this arithmetic sequence in terms of two-way recursion it may not be the most efficient way to do it. In this video will look at multi-dimensional arrays.  In particular, let us look at two dimensional arrays. Because, that will give you an idea how multi-dimensional arrays work. Initially, let us look at them as arrays and in a subsequent video will look at the connection between multi-dimensional arrays and pointers.  So, multidimensional arrays can be defined in the similar to the following, you can say double mat[5][6] or int mat[5][6] or float mat[5][6], this is similar to the mathematical notation of multidimensional arrays are matrixes. So, let us look at the first example, we have that the definition states that mat is a 5×6 array of double entries. So, this means that mat has 5 rows, each row contains 6 entries and all the entries are of type double. Double is what is known as double precision floating point numbers. And if you are doing a lot of floating point computations, then instead of float you could use double because, you might need a lot of precision in your computation. So, the matrix 2D array might look like this, this looks like a mathematical matrix of size 5×6. So, it has 5 rows, rows 0 through row 4 and each row has 6 columns, column 0 through column 5.  Now, the i j th member of matrix is accessed as mat[i][j] this is slightly different from the mathematical notation. In mathematical notation you will write matrix and then a square bracket and then you will write i comma j followed by close bracket. So, this is different in c, you would write the indices separately in their own square brackets. Now, the row and the column numbering begin at 0, this is similar to one dimensional arrays we saw that one dimensional arrays start with index 0. Let us look at a function which prints the input matrix. So, I have a function it returns void. So, it does not return anything it just performs an action, which is to print a matrix. Now, the function is called print matrix, it takes a double matrix mat of size 5×6, 5 rows 6 columns each. I first declare i and j, i is suppose to iterate over the rows and j is suppose to iterate over the columns. Now, how do you iterate over the whole matrix. Well, first you would take each row i. So, you need an i outer loop for that based on the variable i. I will go from 0 to 4, so the for loop goes from 0 until you hit 5. Now, for each row what do we have to do, we have to take the elements in the column. Now, the columns are numbered 0 through 5. So, for each i th through we have to take column 0, column 1, column 2, column 3, column 4 and column 5. So, all these entries and then you have to print that entry. We have just mention that the i j th element in the matrix is accessed as math i j, i in square bracket and j in square bracket. Therefore, you will say printf(“%f”, mat[i][j]). So, this will take the entry in the i th row, j th column. One more thing that is worth noting is that, even though you had a double matrix, you still print it as %f as though you were printing a float and the language will take care of printing the double precision. So, here is the loop to print the columns of a row. Once you are finished with the row, you would a print a new line. Because, then you can start at the beginning of the next line for the next row, so here is the loop. So, what the loop does is prints the i th row, row starting from 0 and ending in 4 and for each row print each of the 6 columns 0 through 5. Now, at the end of the each row you would print a new line. So, here is the code to print a matrix, the lesson here is how to access the i j th element. You would access it as mat[i][j]. Now, the dual operation of printing is of course, reading in the input from the user, we have done it using scanf. So, let us try to use scanf to read in elements which are input by the user.  Now, one of the things with the scanf is that the argument to which variable we have to read it in, we usually give and x, if you have to read it into a particular variable x when we will say scanf whatever format it is and then say and x, which says the address of x. Similarly, I could guess that in order to read to the i j th element of a matrix, I would need &mat[i][j] and that is actually correct, you do not need a parentheses here to right.  So, let us look at the code and the code looks exactly as the print routine, except that we are now scanning a number. So, you have an outer loop which will go through all the rows and then in inner loop which will go through the columns of the i th row and how do you scan. You says scanf(“%f”, &mat[i][j]). So, remember if it was just a double variable instead of an array, you would have just said & of the variable name. Similarly, we have &mat[i][j]. Again, note that even though we have a double array, you read it in exactly as though it were a float array, using %f format. So, read in the i th row and i th row goes from 0 through 4 and for each row read the j th column, column goes from 0 to 5. Now, the way this scanf works, the scanf with %f option will skip over the white space and it will skip over any white space. So, in effect what it means is that, if I had to enter a matrix of size 5×6, I can enter it in multiple ways, I can enter it in the most natural way which is 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 and so on. So, 5 rows each row has is entered in a line and each line has 6 entries, so let us call this may be 10 and 11. So, each row has 6 entries and there are 5 rows, this is a most natural way to enter it. But, as for as scanf is concerned any white space will be skip. So, instead I could just enter one number in one line. So, I could enter it one number per line and it put be read exactly in the same manner, that is a property of scanf.  So, it really does not matter whether the entire input is given in 5 rows of 6 doubles or just 30 doubles each number in a single row by itself. So, that is you both of them are fine. We have seen how to print an array. We have seen how to read elements into an array. Now, let see how to initialize a multi-dimensional array.  So, we want to initialize let us a 4 by 3 array in the following way, it should be 1, 2, 3, 4, 5, 6, 7, 8, 9 and 0, 1, 2, let say this is the array that I want to enter. Now, we have seen initialization of one dimensional arrays, if I let say int b 3 how did we initialized, we could initialized it us 0, 1, 2. So, we summary of this is that, it is a list of numbers separated by commas and the list is enclosed in curly braces, this is the case for a one dimensional array. So, it is natural to generalized the notation in the following way, if I have to initialize a 4 by 3 array, I can just say curly brace. And so here is a list of elements and each element is basically a row. So, what is a number here will be a row? So, it will be a list of rows and each row being an somewhat like an array, each row will be given by a list. So, the array initialization on the right hand side is exactly the array that is shown here. So, it will come out to 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2. So, the notation is consistent and it is a generalization of the one dimensional array notation.  So, there are some initialization rules, similar to what we are seen for one dimensional arrays, values are given row wise. The row number 0 is the first entry, number of columns needs to be specified, we need to know how many columns there are? Now, value of each row is enclosed in {} and the number of values in a row, may be less than the total number of columns, this is allowed. This was similar to how we saw that, even though you had declared the size of an array, you could give one dimensional array, you could be less than that number of values as the initial values. The remaining values will just be 0, same case occurs in the multidimensional array. So, let us watch an example, if I have an array a number of rows unspecified, number of columns 3. But, each row let say I have 3 rows, each row does not have exactly 3 elements, one the row 0 has just 1 element, row 1 has only 2 elements and so on, it will be initialized as 1 0 0 because in row 0 I have given only 1 element. So, that will be the first and the remaining will be 0, 2 3. So, I am short of 1 element that would be 0, 3 4 5 I have 3 columns and I have given 3 values. So, it will be initialized as 3 4 5. So, the initialization on the left hand side results in the matrix on the right hand side, here is all initialization words.  Now, let us look it access mechanism in somewhat greater detail. So, let us ask the following question, instead of matrix 5×6 I have return and function to read a matrix of size 5×6, can I give a 6 by 5 matrix? So, this is a matrix of 5 rows, 6 columns each instead can I give a matrix of 6 rows 5 columns each, the total number of elements is till 30 would it be the same or would it be even a matrix of [10][3], 10 rows 3 columns each all of these have 30 elements. Now, as for as c is concern are all these the same, the answer is that no, it is not correct neither it should be. But, we will say that the answer depends on the way the array elements are accessed. So, will see this in greater detail.  So, in order to motivate there let us introduce the problem of passing an array to a function and let us look at the issue in greater detail. Suppose, I want to take two dimensional array of type double [5][6] and print the sum of entries in each row. So, this is similar to a matrix program, that we have seen much, much before given a 2D matrix, for each row you have to find the sum of elements in each row and just print it out. So, in mathematics this is often called marginal's. So, let us just compute the marginal's, we have a function void marginal's, it takes matrix [5][6], it has int i j, i is over the rows, j is over the columns and I also have a row sum variable to keep track of the sum of a row. So, what do I do, I have an outer loop which goes through all the rows, for each row I initialize the sum to 0. Now, for each row I have to some all the elements in the i th row. So, I have to sum all the elements in the columns j 0 through 5 of matrix i j. So, I will go through the elements and add them into the row sum. Once I am done with the last column of row i, I have the row sum for row i and I will print that. So, this printf is happening in the loop for row height. Now, let us look at a slight modification, we say that instead of printing 5 rows I currently have only 3 rows of entries available. So, can you print me the row sum of the first 3 rows, instead of all the 5 rows. Now, this is very simple let us just modify the function a little bit, it takes an additional parameter saying, how many of the initial rows do you want me to sum? So, that is an additional parameter, let us call it n rows.  So, here are the number of rows for which I have to take this sum. And that function is a very small modification of the function that we have already seen. The difference is that, we now take n rows which is like, how many rows do we have to add and then for i = 0, earlier I would go from i = 0 to 5. Because, the matrix had 5 rows, but in now I will just say I will go up to n rows and the logic is the same as before, nothing else changes. So, his strange things he completely ignores the number of columns, for as for as the c languages concern, if you have a 2D array, the number of columns is crucially it has to be specified. But, the number of rows is not really important. So, c completely ignores the 5 part, the number of rows. Now, this means that we could pause less than 5 rows into the same function. Since, we are not checking for example, that encloses <= 5.  So, let see an example here is the completely surprising example, that this code is the same as before, though only difference is highlighted in read, that I have now omitted what is the number of rows? Please relate this back to codes, that we used to right for arrays. Earlier, I said that for an array, you do not need to specify the number of elements in the array, when you write a function taking an array as parameter I could just say int arr and then empty pair of [ ] with no size in between. So, we have a similar phenomenon for 2D arrays, except you are not allowed to omit both rows and columns, you have to specify the number of columns. But, you have the flexibility that you are allow to omit the number of rows. So, the number of rows is not important, you could omit it and just given empty pair of brackets and the code will work as before. So, this means that the above program actually works for any k × 6 matrix, where k could be the number of rows. And this is because c does not care about the number of rows, only about the number of columns and y is this asymmetry, why is said that it case about the number of rows, but not the number of columns, will see this using the two dimensional array addressing.  Let say that I have return code for computing marginal's and it takes these parameters double mats empty pair. So, the number of rows is un specify, the number of columns is 6 and then it takes an additional parameter n rows, which says how many rows do should I add. And then I am calling this function, suppose I have define the function elsewhere and I am calling this function from name. So, I declare a matrix 9 by 6 and then I will call marginal's on just the first 8 rows not the 9th row. So, I passes subset of the rows, this is 5. Because, I have declared as matrix of size 9 by 8, but I am passing only 8 rows to marginal's and that is fine, I can passes subset of the rows. What is definitely not fine is, suppose you declare a matrix of size 9 by 6 and say that I want you to find the marginal's of the first 10 rows, then this is unsafe. Because, it is true that the marginal's function does not really care about the number of rows. So, it will work for any k × 6 matrix. But, you cannot hope to pass arbitrary junk values to that matrix. For example, you have just declared a [9][6] matrix. Now, the 10th row of the matrix is basically invalid. So, if you pass it you could expect your code to receive a segmentation evaluation, when your run the code. So, when it processes the 10th row what it, it was basically cross the limits of the array. So, the code may have a segmentation evaluation. So, note the difference between saying that it could marginal's could work with arbitrary k × 6 matrices, it is till true that if you pass junk values to the matrix, your code will crash. If your code is a valid matrix, then you can pass an arbitrary number of rows inside the matrix. So, the summary is that as with one dimensional arrays, you should allocate your array and stay within the limits allocated, within those limits the number of rows does not matter. But, it does not mean that you can over suit the limit and hope that your code will work, it may not and it can crush. In this video, we will look at the relation between Multi-dimensional Arrays and Pointers.  And this is by for one of the trickiest topics in the entire course.  And you can code multidimensional arrays without actually understanding the exact relation between multidimensional arrays and pointers. But, understanding this gives you a better grasp of how C treats multidimensional arrays. So, we will now discuss how pointer arithmetic works with two dimensional matrixes. Because, as soon as we had discussed one dimensional matrix, the next thing we did was we discussed the relation between pointers and 1D arrays. So, let us try to see what is the relation between pointers and 2D arrays. Now, this is more complicated than it looks at first sight. And you can do a lot of matrix computations by not understanding this. Except that, understanding this gives you a better grasp for what is happening. We have seen that, when you declare a 2D array as a parameter to a function, then you should specify the number of columns, but not the number of rows. So, let us look at a function which makes an identity matrix, an identity matrix is a matrix that has one along it is diagonal and zero every where else. So, we have void make_identity10(double m[ ][10]). Since, identity matrixes are square matrixes, this essentially says that the code will work for a 10 × 10 matrixes. Then, I have a for loop going from i  =  0 to 10 and a for loop going from, for the columns going from j  =  0 to 10. And the code just says that, if I am at a diagonal element that is i  =  j, then m i j is 1 for all other elements, m i j is 0. So, this creates a matrix of size 10×10.  Now, this is a very strange code. Because, it is a function that essentially makes exactly one matrix. It would have been nice, if I would have a function that can create arbitrary size identity matrixes. For example, if I wanted a 20×20 matrix, it looks like, I have to write another function make_identity20(double m[ ][20]), the rows are unspecified, the number of columns is 20.  So, let us go back to, how do I address the i j th element in a 2D array? Now, we can view it as a 3 × 5 matrix of integers, something like this. So, it may be an array 0 1 2 3 4, that is row 0 and 5 6 7 8 9, that is row 1, 10 11 12 13 14, that is row 2. So, this is the matrix view which is 3 rows, each with 5 columns, this is the standard view. But, internally C views this as a long linear array of size 15, in what is known as the row major form. So, let us just look at what it is? Internally, C looks as loops at the array in the following form. It is basically C 0 through 14, lead out in a single row. So, this is the row major view, it is called row major, because first all elements of row 0 will be lead out, then all elements of row 1 will be lead out. And finally, all invents of the lost row will be lead out. But, it is lead out as a linear way. Now, the natural question to ask is, in that case is a 2D array really at the heart of just a 1D array. So, the difference between a 2D array seen in the row major view point and an actual one dimensional array will come in the pointer arithmetic.  So, as I just mentioned there are two views, the matrix view and the row major view and both views are correct. So, if I have the matrix view, mat is a pointer to the first row. So, mat + 1 will be a pointer to the second row and mat + 2 will be a pointer to the third row. So, row number 3 or row indexed with 2, in the row major view point, here is the difference mat points to the first row and mat + 1 should point to the second row. So, we cannot say that mat is pointing to the first element here and mat + 1 should point to therefore 1. Now, that is not what happens? It has to be consistent with the matrix view. So, the pointer arithmetic mat + 1 should point to the same element, regardless of whether you are looking at it using the matrix view point or whether you are looking at it using the row major view point. So, mat + 1 will still point to 5 and mat + 2 will still point to 10. So, these two view points are consistent.  Now, here is the difference with one dimensional arrays. So, we have just repeated the viewpoints here, the matrix view point and the row major view point. Now, had mat actually being a one dimensional array, mat would point to the first element in the array. Therefore, mat + 1 which should point to the second element in the array. So, that is not what happens, it is actually the row major representation of a 2D array and mat + 1 should skip exactly 5 elements, because that is the size of the column. So, mat + 1 should skip 5 elements and go to the element mat 1 0. So, here is we just of why you need to know the number of columns? Because, in the row major view point I have to implement mat + 1. So, I have to say how many elements should I skip, in order to get to the first element of the second row? And that number is exactly the number of columns in the array. So, the number of columns in the array is 5. So, to get to mat plus from, from mat, I would to skip 5 elements. Similarly, to get to mat + 2 from mat + 1, I would to skip exactly 5 elements. So, this is the reason why the number of columns is an important information. Because, that tells me in the row major representation, how many elements do I have to skip in order to get to the correct entry in this second row or third row? So, here is the pointer arithmetic for the row major representation. And notice that, this is considerably difference from the pointer arithmetic for a 1D array, in a 1D array, array + 1 will go here, the first element of the array.  Now, can you try to guess what will be the type of mat? So, here are four candidates and let us go through them to see, what is the most likely candidate? And we will see this in a greater detail, int *mat, mat is a pointer to int. Now, we have seen that, that is approximately an array of integers and that is definitely incorrect. Because, this is supposed to be a 2D array, not an array of integers. Pointer to pointer to mat, we have an seen that so far and that looks like a likely candidate. So, what about the third and the fourth? The third and the fourth looks confusingly similar. What do they mean? So, here is a hint, the array indexing operator [ ] has higher precedence than *, the dereferencing operator. So, in this case the first says that, so what is this mean? The first declaration is actually int *mat[5] and the second declaration is int (*mat)[5]. So, what does this say? So, let us compare with the standard declaration like float arr[5]. This means, that array is arr is an array of size 5, each entry of type float. Similarly, this means the matrix mat is an array of size 5, each entry being a pointer to integer. So, it will be some matrix like this, it has five elements and each of them is a pointer. So, here is the view point for declaration 3. Now, what about declaration 4?  So, there let us see this, so let us compare it with a standard declaration like, let us take a standard declaration like int arr[5]. Again, this says that arr is an integer array of size 5. So, it contains 5 elements, each of type int correspondingly, what this means is that *mat is an integer array. So, here is an integer array containing 5 elements, these are integers. Now, this means that if we deference mat. So, mat is a pointer to an array of size 5 and this is exactly the actual representation of a two dimensional array. So, notice the difference between these two representations, the first says that mat 5, mat is an array of 5 entries and each entries is a pointer to an int, so it look like this. So, it is an array of 5 pointers to int. The lost declaration says that, *mat is an array of int of size 5. So, mat is a pointer to an array of integers of size 5. So, here is the difference and we will argue that the fourth definition is essentially what we want and we will see this in a greater detail.   So, let us understand these type expressions in greater detail and we will see this in the further video also. We particularly pick on one representation here. So, we have argued that the 2D array is similar to the last declaration here, I eliminated the most obviously wrong declaration, which is in *mat, that is basically a one dimensional array. So, I have just eliminated that, we will examine all the others. What I have just said is that a 2D array is similar to the last declaration. But, even the previous two declarations do make sense. And there may be situations, where you need to use such variables. Let us examine them in greater detail.  So, let us look at the first one which is int **mat and it means all of the following equivalent ways. So, all of these are an equivalent ways of looking at the same thing. You could say that a matrix of type int ** or you could say that matrix is a pointer to a pointer to an int. Since, arrays are pointers approximately, you could also say that mat is an array of pointers to int and this is also commonly called array of arrays. So, you have mat int **. Now, this is a pointer to an array of integers. Now, every pointer to an int is essentially a pointer to an array, you can look at it like that. So, you can say that mat will point to an array of pointers and this array of pointers, each of them may point to a different array. So, you dereference mat once, you will get a pointer to an integer and again you deference once more, you will get the actual array. So, what happens when I do mat + 1? It will go to the second entry in the array of integers. Now, that may be a different array all together. So, mat[0][0] is similar to **mat, this is just a way, address arithmetic works. And both of them are addresses, both of them are pointing to this location, both of them mean the content of this location. Similarly, *(*mat + 1) = mat[0][1]. So, in the case of one dimensional arrays we have just mentioned the equation that arr[i] is the same as *(arr + i). And what we are saying here essentially is that, mat[i][j] is the same rule applied twice. So, I could say mat[i] = *(mat + i). So, that will give me an array and then, I need the jth element of that. So, you can again do *(*(mat + i) + j). So, these are two ways of looking at this array.  So, mat + 1 will be the next element in the pointer to integers and it is the same as and when you deference it, you will get another array. So, in order to get the first element of this array, I could say mat[1][0] or using the pointer notation, I have *(* mat + 1), these are the same and similarly for other elements of the array. So, one of the advantages of this kind of int **mat is that, I have freedom in both dimensions. You can see these as the rows of a matrix and these as the columns of a matrix. If you see that, then you can see that I have a lot of freedom here, first of all the number of rows is not limited. Because, it is just int **mat, I could have any number of rows here. Now, another main advantage and the reason why this is somewhat popular is that, the length of row 0 need not be the same as the length of row 1, these are just pointers to integers. So, the first pointer to integer may be pointing to a row of size 2, the second pointer may be pointing to a row size 3 and so on. So, the row lengths need not be the same. So, think of an array where row 0 is two elements long and row 1 has three elements in the row and so on. So, if you have extremely ragged arrays, then int **mat is a nice representation to take.  In this video, we will look at one of the other expressions.  In particular, we will look at the third one, which is int *mat[5]. So, if I had written int arr[5], this means that array is an integer array of size 5. So, similarly I can read int (*mat)[5] as star mat is an integer array of size 5. So, in other words mat is a pointer to an array of size 5, array of int of size 5. We can look at in this way and let us see, what this really means.  So, we can picturize in this way, if you dereference mat that is, if you take *mat, you will get some array of size 5 of integers. Now, let us look at the pictures. So, mat may be pointing to some array of size 5, which means that the next subsequent location will be another array of size 5, if it is a valid address. Now, for the first location we can refer to it as mat[0][0] or it is the same as (*mat)[0] or it is the same as *(*mat). So, remember the general formula that we had was, if I have the notation mat [i][j], I can look it up as *mat. So, first let me translate mat [i]. So, that we have seen that this is simply dereferencing mat + i, that address. So, now we have one more subscript. So, in order to decode that, I will do the formula for a second time, so, this + j. So, remember that this is the general form. So, similarly if you have mat[0][0], I can write it as *mat[0] or I can write it as  *mat, because i and j are both 0s. So, this is just a special case of the general form, mat + 1 points to the second row of 5 integers. So, remember that the type of mat is, it is a pointer to an array of size 5 of integers. So, the next pointer location when you do mat + 1 goes to the next array of size 5. So, mat + 1 is another array of size 5. In particular, it may be the second row of a two dimensional array, where you have 5 columns, mat + 2 will be similarly the third row and so, on.  So, mat[2][3] for example, if you apply the formula, it will come out to be *(*(mat + 2 + 3). Notice that, all boxes are allocated in this example.  Now, mat + i points to the i th row of 5 integers and *mat is an array of size 5, this is what we have seen. Now, you can in order to get comfortable with a notation, you can look at these formulas and try to decode. Like for example, you could try, what is the arithmetic way of representing the location mat[1][1]. So, you can see that it is definitely the first case, where it is *(*mat + 1). So, that is definitely true, because this is just the formula that we just now discussed. But, if I do not decode both the subscripts, I decode only one subscript using pointer arithmetic and leave the other subscript as it is, then I know that it is also equivalent to 3. So, 3 is also another way of representing it and tried to convince yourself, why the second is not correct?  Now, let us understand this in somewhat more detail by considering a tricky question, we have a function int search. So, here is a function int search, int a, int n, int key. So, what does this function do? It will search for key inside array a of size n, a is an array with n elements and you have to search for it, search inside for it for the element key. If it is found, then you return the index where it is found, if it is not found, you return -1. Because, -1 can never be a valid index in an array. So, when you return -1, you know that it is not present in the array. Now, can we use this, a function to search inside a 2D array. So, we are using a one dimensional function, in order to search inside a 2D array. Now, the basic idea is that we can search row by row, each row of a two dimensional array is somewhat like a one dimensional array. So, we will call search multiple times, once for each row in the array, until we either find it or we are done with all rows. The algorithm is, search it row by row. Now, the question is which of the following is actually doing that? So, we have three expressions, search(mat + 1, 5, key), search *(mat + 1, 5, key) and which of these will do it. Now, let us look at second, mat is pointing to an array of size 5. Therefore, mat + 1 is also a pointer to an array of size 5, when we dereference that, we get an array of size 5,. So, that is the right type. So, the first argument to search the second statement will be an array of size 5. So, therefore, the second call is valid. What about the third call? Again, mat of 1 is simply *(mat + 1), if you translated into pointer arithmetic. So, the third line is just the second line in discussed, instead of using pointer arithmetic notation, we are using subscript notation so, 2 and 3. In fact, are equivalent, so, 2 is correct. Therefore, 3 is also correct. Now, think about why statement 1 does not make sense. So, mat + 1 is actually a pointer to an array of size 5. Therefore, it is not the right type, it is not an array of size 5, it is a pointer to an array of size 5. So, it is not the correct type and therefore, the first call is not valid, the first option is a big delicate. So, I would encourage you to stop here and think about, why it is not correct?  Now, let us utilize the function in order to write our routine to search inside a 2D array. So, once again we are utilizing a one dimensional search routine in order to search inside a two dimensional array. So, let us say that, we are given this int search function which can search inside a one dimensional array for a key. Now, I will write a 2D function, a function which can search inside a 2D array. Now, the correct declaration of the function would be int *mat[5], int n rows int key, n rows is going to be the number of rows in the array. Key is the key, we are searching for and int *row and int *col. So, I want to focus on the first argument and the last two arguments. The first argument says that, I will pass you a pointer to an array of size 5, this is exactly what we should do because, then a two dimensional array can be just traverse by using mat + 1, mat + 2 and so, on. So, here is the correct type declaration that should accompany the 2D search routine, n rows is just the number of rows, key is the key. Why are we saying, int *row and int * column? We want to return two things, if a key is found, we want to return it is row index and it is column index. Now, unfortunately a function can return only one value. So, how will you return two values? So, we will say that we will not return two values. What we will do is, give me a pointer and I will write in that address, the correct row and the correct column, if it is found. Here is a standard way in C, where you might encounter a situation where you need to return two values and instead, what you pass are the pointers. The algorithm is what we have discussed before. You check each row of mat using the function search. If search returns success, then that will be the column index in that row, because search is searching inside a 1D array. So, wherever it returns that will be the column index in the i th row. So, now you say that the column index is that and the row index is the i that I had. If it is not found in any of the rows, you return -1.  So, let us write the function, we have an i to go traverse for the rows, we have found = 0, this will be the flag indicating whether the key is found or not. And initially, you just set *row = -1 and *col = -1 to indicate that I am not yet found it, found the key. Now, you write the main loop which is going through the rows one by one. You start with row 0 and you go on, until both these conditions are true. That is, you have not seen all the rows, i is less than n rows and you have not found the key, so, not found. What should you do to the i th row? I should say that search the i th row. So, the way I say it is, search *(mat + i). This is the same as saying search mat[i, 5], which is the number of columns and key, which is the key that I want to search for, the return value is stored in *call. So, you dereference call and store the return value there. Now, search can return either you if the key is found, it will return the correct column index or it will return -1. So, you just check for that, if *col is a non-negative number, then you say that it has been found. So, you say that the row = i, So, *row is i and found is now 1. So, at the next iteration you will exit out of the loop, because you have found the key. And then, the last statement in the loop will be just to increment the i variable. Finally, if you have done with all the rows and if you have exited out of the while loop, you check whether you exited out of the while loop, because you exhausted all the rows. So, there are two conditions to exit the while loop, one is i >= n rows, that is one condition. The second is that found = 1, if you exited because, found =1, then you can return the correct value without any problem. If you exited before, if all the rows were exhausted and you still did not find the key, then you have to say that column is -1. So, here is a brief code which will do this. So, this code utilizes our understanding of two dimensional arrays as basically an pointer to an array of size 5 and here is why the number of columns is important. Because, in order to do mat + 1 correctly, we need to know how many bytes to skip and this is crucially depended on the number of columns. The number of rows actually does not matter. Because, you can keep on incrementing the rows as long as the array is valid. The number of columns is important, because that is how you get to the next row.  In this video will look at the last possibility with respective multi-dimensional arrays in pointers, this is known as an array of arrays.  In order to understand this, let us just look at something we are comfortable with, if I had just a float arr[10] elements, then how would I read this, I will say that array is arr is an array of 10 floats. So, this is how I would read it, if I have more complicated declaration like char* as strings. So, notice that the precedence for this [ ], is higher than that of the precedence for *. So, this would actually be read as strings is an array of 7 character stars. So, that is how it could be read, because 7 would bind closer to strings. So, strings will become in array of size 7 and what type is it, it is char *. So, you replace float with char * and it is roughly the same phenomenal. So, the pictorially you can think of it like this. So, you have 7 cells in strings and each entry is a char *. So, each entry is a character pointer, you can think of it as a string, you can think of it is a character array whatever. So, here is the pictorial representation. Let us look at why we would need such as structure and what is the advantage of it? This is very popular structure almost as popular as two dimensional arrays themselves.  So, let us look at what it means for when we allocate character* an array of arrays. So, we may want to let say store the names of several movies. And one of the things is the there is no maximum limit to the name of a movie and it can be as long as we want it can be as short as you want and suppose you want to store all of these is in a data. So, let say that we have char *movies and I declare it as an array of arrays and it contains the first array is Don 2, the second is Ra.one and. So, on. Now, how will we do this, So, one way to do this is you say that movies is pointing to an array of arrays. So, movies + 1 is pointing to another character array, movies + 2 is pointing to another character array and. So, on. So, this is how we pictorially represent it, there are three entries and each entry is a character pointer. So, it can point to any character array what. So, ever. And here you see the distinct advantage of this kind of representation over 2D matrices. Why? Because, in 2D matrices the whole point was the number of columns was fixed, that is how the pointer arithmetic worked. Here, the number of columns in one row can be different from the number of columns in another row. So, this representation is actually more useful when you have what are known as ragged arrays, that is one row and the next row may have very different lengths. And here is natural situation of storing strings when you need such a facility.  So, let us see what this means type of the variable movies is a pointer to a pointer to character or char**. Now, type of *movies is char*, because you dereference one level and type of **movies is char. So, let us look at it once more. So, *movies has type char *. So, in particular *movies will be this array, it is pointing to this array. So, **movies will be what is it according to the general formula, this will be *(*(movies plus 0) + 0). So, this will be the pointer arithmetic version of accessing this cell which contains D.   But, instead you could also write movies[0][0]. Similarly, in order to get to the last cell here, you could say *(*(movies + 5)), it is the particular application of the general formula.  The second row will be *(movies + 1) again try to think in which ever notion your comfortable with. Because, you can also right this as movies 1, you will get the same result. So, *(movies + 1) will come to the second row and you have *(*(movies + 1) that would come to the first element in the second row and. So, on. So, *(movies + 2) would be the third array in the structure and here is how you access different elements in the third array. So, notice the picture is slightly different here, even the representation suggest that, these rows need not be contiguous in memory. So, then location after this row n's need not be this row. So, the second row can be located arbitrarily far away in memory, the advantage due to that is that these rows can be of different length, they are not packed as in the 2D array.  Let us look at this particular thing in detail. So, that you get comfortable with in. So, suppose you have that array and I considered what is printf(“%s”,  movies [2]), movies 2 will be the third character array, that is present in the structure. So, it will print Krrish 3. Similarly, movies 0 will print the first string and if you say printf(“%s”, *(movies + 1) by pointer notation, this is the same as the subscript notation movies[1]. So, that would print Ra.One. Now, what happens if you have put char *(movies + 1 + 1). So, again if you are more comfortable with a subscript notation, you can translate back in to the subscript notation, this will become movies[1][1]. So, what it will print is, this letter which is small a, similarly for the last one. So, it will print whatever it will print the i. So, here is a whereas...  Array of array is now allows us to have a two dimensional structure with different number of elements per row and this is the advantage that it has. Now, let say that we want to right a very natural program, which is it takes a number between 1 and 12 and it prints out what is that month name corresponding to that number. So, I want to store in months and here is the problem different months have different lengths. We right now saw is solution to this problem, which is to store arbitrary length a strings in one structure, we would make an array of arrays. So, you can say that char *month_names[ ]. So, this is an array of arrays of character and then you can just initialize it to the month names, you do this and then I will write the code. So, you can write the code in anyway. So, you can say that 0 is January and. So, on up to 11 is December. But, maybe it is more natural to say that 1 is January and. So, on up to 12 is December. So, I will check if the given month index is between 1 and 12, then I will print the month name month minus 1. So, if you give the month as 1 you will print month names 0 which is January, if you give the month as 2 you will print month names 1 which is February and so, on. Now, if the month is not in this range it is in invalid month. So, you just print that an exist, So, here is a very simple program with illustrates what advantage you get out of this kind of array of array structure. You can store with in the same data structure different strings of completely different lengths, this is not possible in a 2D array because, all you have to calculus something like the maximum column length. So, the maximum width month name for example, it could be September and then all the other names have to have exactly that width.  So, let us look at this the array of arrays picture is like this, you have an array of characters stars. Now, each of those characters stars may be pointing to different months. In this every month is exactly three characters long,, but you get the picture basically in this these rows can be of different lengths. So, contrast this with two dimensional arrays, where the chief feature of the two dimensional array is the following, you have to specify the number of columns. So, the number of columns have be to specified and no matter what the exact string is, it will occupies 7 characters now. So, the remaining will be null fill or something. So, also notice that pictorially I have tried to represent it, the very next memory cell after the first row will be the beginning of the second row. So, after row 0 it will immediately start with row 1. Whereas, in the case of array of arrays row 0 and row 1 may be located arbitrarily for apart in memory. The only connection is that the pointers to these rows are consecutively located in the pointer array, that is not the case here, it is actually located together in memory and it is represented in row major fashion, where each row will take exactly 7 letters. So, I hope the limitation of the two dimensional arrays in this case is clear.  So, you can try a few exercises in order to understand this notation a little bit, this concept of array of arrays a little bit better. So, let us look at the types of various concepts. So, if I have month, month is actually a char **, it is an address. So, if you want to print out month, I mean it is very rare that you need to print out month, you would use something like %l u, which is long unsigned for printing the unsigned long int. What happens if you access *month? Now, you dereferencing one level below. So, it will be a char *. So, now, if you print percentages *month, it will print January. If you print a **month, you have dereference two levels and you will get the first letter of the first array, which is j and you can try out a few other thinks, you can say the *(month + 1). So, one way you can do it is you translated to subscript notation and try to see what it will print and there are... So, I would encourage you to try out these examples, in order to get that translation between arrays and pointers correct.   So, here is wrong picture, but it short of gives you an idea of how to look at these structures. So, if I have int array[2][3] you can think of it as the number of rows is fixed and the number of columns is fixed, this is not actually what happens in C, in C actually the number rows does not matter, the number columns matters. But, you can for a moment to make it easier to think about, think that if you declare it in this way, this is when the number of rows is fixed in the number of columns are fixed. So, in particular if you know beforehand that you data structure has a fixed number of rows and fixed number of columns, then it is probably better to you said 2D array. Now, if you have int *arr[3], now this means that arr is a pointer to an array of size 3. So, here the number of columns is fixed. But, the number of rows is variable, it you can have any number of rows, on the other hand the third case int *arr[3]. So, it is an array of 3 elements each of type int *. So, you can see that this is one situation, where you have 3 pointers,, but each of them can point to arrays of arbitrary length. So, this is a situation where the number of rows can be seen as fixed and the number of columns is variable. And the general case can be int **, which is where the number of rows and the number of columns are both waiting. So, you can think of it and this way, this is not a correct picture. But, when you want to modal data, this is probably and you know that you are in a situation, where the number of columns is variable. But, the number of rows you know beforehand probably you should go for array of arrays. If you are in a situation, where you know that the number of columns is fixed, but you do not know how many data there are, then you can go for int* array of size 3. So, you can go for the second alternative and so, on. So, this picture is not quite accurate,, but it is indicative of the usage.  In this video, we will look at a few basic things about file handling in C. This is a vast topic in itself and we will see just the basics of this. So, let us begin by describing what are files.  Now, you would think that the most natural way to define what a file is, it is a set of bytes or a collection of bytes sitting in secondary storage, like may be your hard drive, may be your CD ROM drive or DVD drive or something, it is known as a secondary storage device. But, the actual description is that, any addressable part of the file system in an operating system is a file. Now, this includes extremely bizarre strange things. For example, /dev/null in Linux, this stands for nothing. So, if you write to /dev/null, it is like discarding the data. Similarly, /dev/urand, this is the random data device. If you read from here, you will get random data, /dev/audio is speakers. So, if you write some data into that, it will be heard on the speakers. And of course, plain old data files, for example, in a home directory you may have /home/don 2/input.text. So, input.text is just a collection of bytes. So, we will not bother with defining what a files is, but it is something that can be manipulated using the file system interface. So, you can open a file system interface to that file, you can read from that file, you can write into that file, you can close that file and so on.  Now, recall that in one of our earlier lectures, I said that there are three files works which are available by default to all c programs. So, these are standard input stdin. This is associated usually with a key board and this is where scanf, getchar, gets this kinds of functions get their input from, it has file descriptor 0. Similarly, standard output stdout is where printf, putchar, puts all these functions output the data to. This is usually visible on the terminal under screen, this has file descriptor 1. We also have a third file, which is known as standard error. This is the standard error console and which has file descriptor 2. Usually, you can print error messages to stderr. We have not seen how to print error messages to stderr, so far we will see that in this video.  Now, how do you read input using standard file descriptors, but from sources other than key board and so on. So, for example if you are running a.out and you want to take the input not from the key board, but, from an input file. You can say /a.out < input file, this says that the input is coming from the file, input file. So, this is the input file as the source, instead of the key board. Similarly, if you want to redirect, so if you want to redirect the output to a particular output file, instead of the screen, you can says /a.out > out file. So, this will use the out file as the output instead of the terminal. And if you want to output something the error messages to error file, you can say /a.out 2 > error file, 2 stands for the standard error console. So, if you say redirect this to this file, you will say ok. The standard output should get the standard output messages and the standard error messages should go to err file.  So, Linux gives you some facilities to take input from other files using the standard input and the output. So, what you say is that, instead of the standard input, you can use this <, > arrows, in order to redirect input from some file or output to another file or error to another file. So, this is the facility that Linux gives you. But, consider the general situation, when you have a program, you want to read the input from multiple files and may be output to multiple files. So, this is the general situation, we just saw how to take input from one particular input file, how to output to another output file using the redirection operator, the < and > operation on Linux? So, the redirection mechanism is provided by the Linux shell and is not a part of the C program in language. So, is there a way to do it in C itself, rather than using the facilities of Linux. So, can we read from other files, other than the standard key board? Can we write into other files, other than writing on to the screen, standard output and so on.  So, we will look at the general scheme of file handling in C, all these functions that I am going to talk about are in stdio.h, itself. So, you do not need to include any more files. So, if you want to open the file for reading or writing etcetera, we need to first open the file. The three standard files stdout, stdin and stderr are available to the program. Any other file, you have to open the file. And the function to do that is fopen takes two arguments name and mode, we will see what these are soon and it returns something called a file pointer. A file pointer is a pointer to a structure and that structure contains a lot of information about the file. For example, where is it situated, the current position being read in the file. So, may be you are read 1000 bytes and you are about to read the 1000 and first byte. So, it has that information and various maintenance information, about the file. Now, in order to read or write into the file, you can use fscanf or fprintf. These are the analogs of scanf and printf, which allow you to right to an arbitrary files. It takes three arguments, at least two arguments, the first is the file pointer, where you want to write the file, where you want to read from the file and so on. And then, there is a format specified, just as a normal scanf or normal printf and then further arguments. So, the difference here is that, whereas scanf and printf started with a format specifies, we have an additional file pointer in the beginning. So, compare with a scanf and the printf, the first argument fp is missing. This is because, scanf just assumes that the file it has to read from is this standard input. And printf assumes that it has to print to the standard output and to close the file, you say fclosefp. And notice the way, the fscanf, fprintf and fclose work, they do not take the file name as input, only fopen takes the name of the file as input. Whatever fopen returns the file pointer, those are the arguments to fscanf, fprintf and fclose. This is because, once a file has been opened, all the information that fscanf, fprintf and fclose need are already in the structure pointer 2 by fp.  Now, let us write a very simple program, it takes the names of two files and what it does is, it first prints the contents of the first file and then prints the contents of the second file and these will be output to the standard output. What is the algorithm? It is very simple, you have to first read the file names, then open file 1, if open fails, we exit. Now, you print the contents of file 1 to stdout, after you have done, you close file 1. Then, you open file 2, check whether open has succeeded, if it has failed, we exit. Then, print the contents of file 2 to stdout close file 2 and that is it.  So, let us see what each of these steps in slightly more detail. How do you open the file? We open it using a standard call called fopen, fopen takes two arguments, the name and the mode as character pointers and returns a file point. The first argument name is the name of the file and the name of the file can be given in short form. Suppose, you are already in a directory, where that file is situated. Then, you can just give the name of the file. For example, input file or you can give the full path name of that file in the operating systems. So, for example input file may be in the directory /home/don. So, in that case you can give the name as /home/don/input file. So, this will be the full path file, either of this is accepted. Now, the second argument is the mode, this is the way in which you want to open the file. So, what are the common modes? For example, if you give r, this will open the file in read only mode. This is, if you want to just read a file and not write to that file. There are also other situations, where the medium itself may not support writing. For example, if you have a CD ROM disk then you cannot write to that. So, it can only be opened in a read only mode, if you give w, this is the write mode. Now, the first write happens at the beginning of the file. So, if the file already exists, it will be over written. If a file does not exist, so this is the name of a new file that we support commonly is known as the append mode, we specify that by saying the mode is a. So, if you open the file for append mode, then instead of writing at the first location of the file, it will write at the end of the current file. So, if the file does not exist, then it will start from the first location. If the file exists, it will go to the end of the file and start writing from there. So, append does not overwrite the file.  We have seen the arguments of fopen. Now, let us look at what it returns? If successful fopen returns what is known as a file pointer. This is later used for fprintf, fscanf, fclose as I just mentioned. If unsuccessful, the file may be you try to open a nonexistence file for reading or you try to write to a file which cannot be return to. For example, it is a file sitting inside a CD ROM drive and you are not allowed to write to it. So, if you try to open the file in write mode, then you have a problem. So, for whatever reason if the file open does not succeed, then the fopen returns in null and it is always a good idea to check for these errors. So, just try opening a file and always check whether it has return the null.  So, let us write the program that we were discussing, which will take two input files and print one file and then print the other file. So, the program is fairly simple, we have a main function, we have two file pointers *fp1 and *fp2. And then, two file names filename1 and filename2, you get the filename1 from the input, you get filename2 from input using gets functions. Now, what we have to first do is, write the contents of the first file. So, try opening the file, so if (fp1 = fopen(filename1, “r”)). Because, we just need to read from the file, we do not need to write into it. So, open it in r mode, if it is successful that is, if it is or rather if it has failed. So, if it has returned a null, then you just say printf that it has failed. And here is for the first time, we have seeing how to print to this standard error. So, stderr is any other file is similar to any other file, you can just say fprintf stderr. And then, opening file failed filename1. So, we try to open filename with filename1 as the name, but there was some error. So, you print that to the error terminal, which is stderr. Now, once you do that will call the function copy_file(fp1, stdout). So, here is a function that we will write, which will copy from a source file to a destination file and what it takes are pointers to those files. Once you have done, you close the file 1 and then, you repeat the whole process, the exactly the same process for file 2. So, try to open it, if there is an error, you print the error message to stderr, then copy_file(fp2, stdout) and finally, close the file. Once you have done, you can return from main. So, now what is left is, what is this copy file function?  So, let us look at the copy file function. Now, there are two ways to start writing any function which takes files as arguments. One is you can take the file name as the argument itself and within the function, try to open the file. So, you will get a file pointer and you can start reading from the file using fscanf I am writing to the file using fprintf, this is possible. It is somewhat more convenient to say that I am assume that the files are already open and I am getting the file names as the point using file pointers. So, this avoids duplication of work, the main does not have to open the file. And then, every function has to open the file again and again. Instead, what you can just say that, I assume that the caller function has already is a file open and I will just take a file pointer as the argument. So, let us look at this function, it is a void function. So, it does not return anything, it just performs an action, it is name is copy file takes two arguments, fromfp which is a file pointer to after to the source file and tofp, which is file pointer to the designation file. And what is a function do? We have a character c and here is a function, we will see in a later video. But, right now it just checks whether fromfp has encountered enter file. So, feof just tells you whether you have done with the from file. So, if you are not done with a from file what you do is, you scan one character from the from file, so fscanf(fromfp, “%c”, &c). So, this will read one character from the source file fromfp and read it into the variable c. What we have to do is, to print that to tofp. So, you say fprintf (tofp, “%c”, c). So, this is exactly like scanf and printf, but taking one extra argument. So, in the case of scanf you just says, what is the source file that is the file pointer argument. In the case of fprintf, you have to take the designation file which is tofp, that is the extra argument in that expression.      In this video we will see some more common file operations; these are by no means the only file facilities that C provides you, but in common programming practice these are the functions that people of in use. So, we have seen this in the code that we wrote. The first function is feof, and then it takes a file pointer. What it does is, it is checks whether you have encountered end of file while operating on fp. So, maybe you are trying to read the file, and you have already reach the end of file. So, if you have already reach end of file, that is if EOF is set, then feof returns a non zero value. If feof is not set, that is you have not completed the file yet by seeing end of file, then feof returns 0. So, in order to check whether a file has still has some data, you can just say not of feof fp. So, that will check for the fact that the files still has some data.  Now here is some couple more interesting functions whose who they are very useful, and a call by commonly use whenever we deal with files. For example, we can have something called fseek. fseek is a function which allows you to start reading from, our start writing to arbitrary locations in the file. So, often we may want to read into the 10000 byte directly, and we do not want to be bother with reading the first 9999 characters discarding them, and then coming to the 10000 th character. This may be lot of wasted time. It will be more convenient, if I can directly jump to the 10000 th location in the file. So, is there a function that allows to you do to that yes, there is just thing call fseek. Now what it takes is the file pointer, and it takes two arguments; one is known as an offset, and the other is known as the origin.  So, let us look at the offset and the origin in greater detail. So, suppose I want to read from the 10 th byte of the file. So, I could say fseek, and suppose by file pointer is fp, I will just say let say I want to read from the 10 th point from the beginning of the file. What I can say is SEEK_SET. So, if I do this what will happen is that? It will start from the beginning, SEEK_SET is the beginning of the file. So, it will add 10 bytes to from the beginning of the file, and it will start from there. So, if I know that I want read from the 10 th byte, then I can say that start from the beginning of the files SEEK_SET says origin of the beginning of the file plus 10 bytes. So, this is 10 bytes from beginning. Now, there are other situations, for example you might want to say that I want to start from the 10 th byte from the current location. I have already read many bytes. Now I want to skip the next 10 bytes.  So, is there way to do that again what you can do is, if you say fseek f p and let us say 10 itself, but SEEK_CURRENT. So, there is a typo over here, this is just CUR. So, if I say this, then what I need to do is what it will perform is, it will say 10 bytes from the current position. So, I have already rate 100 bytes from the file, and then I say fseek 10 bytes from the current location. What it will do is jump to 110 th location.   Now I could also say something like... So, here is a very common situation, I want to start reading from the 10 th byte from the end. So, I want to regardless of the size of the file I want to jump to the end, and then rewind 10 bytes and start from there. So, in that case I can say the origins SEEK_END. So, that is the end of the file and where do I start from SEEK_END plus something does not make any sense, because it is it will refer to something that does not exist in the file. So, you could say SEEK_END -10. So, this is 10 bytes before the end of the file. So you can use fseek in several ways and is a very convenient function, because it allows you to jump to arbitrary location in the file. And it will work as long as the target location origin plus offset is a valid location in the file. Now there is also something called ftell, which will tell you the current position in file. So, if it will take a file pointer as the argument *fp, and it will return you where in the file your currently at.   So, with this let us take a look at a few more modes in the file operations. So, when you open the file we saw that you could open it in mode r w a. Now there are also some other special modes that see give see, for example there is something called r+. This says you can a open file for reading and writing. So, this is essentially an update mode. w+ will be write an update. So, create an empty file and update that file. And there is something call a + which is appended update, this is somewhat strange. If you do any fseek after you open the file in a + mode, then the read will be effected. So, suppose I am at 100 th location, I have write 99 bytes, I am at the 100 th byte. If I read, if I now do an fseek to 10 bytes ahead. So, now I will be at the 110 th byte.  Now there are two possibilities now, I can read from here or I can do and fprintf, fscanf will start from the 110 th byte, it will be obey the fseek. fprintf will always print at the end of the file. So, that is the append part of it. So, fprintf is always output is always at the end of the file, and reading will be depended on any fseek that you do. So, fseek will never affect the where you print, it will always be the end of the file. So, a + is a very special for it. These are some additional file operations that you might find useful while coding in C.   So, in this lecture will talk about structures and C, which is syntactic feature that C  provides in order to define new data types.   So, let us look at the motivation. Till now we have used the data types that C language has already provided like int, float, character, and also we have seen data types like arrays and we could define arrays of end arrays of character and so on, we have also seen pointers which can hold the address locations of other variables. Now, what if we want to define our own data types using the data types that are already available. So, if you want to define custom data types does the language provide any feature to do it. Before we reach there we will just take a look at why you would want to define such a data type. So, let say that we have designing a geometry package, and we want to define a point on the plane as having a x coordinate and a y coordinate. Now thus a easy way to do it if you have arrays, you could hold a point inside an array of size 2.  Now you would keep the first coordinate in the the x coordinate as the zeroth element in the array, and the y coordinate as the first element in the array, this is one way to do it. Another way is to keep two variables point underscore x and point underscore y, and these are the x coordinates and the y coordinate of a single point, this is another way to do it. But in both these solutions this no way to indicate that these two are in intended to be the x coordinate and the y coordinate of the same point. That programmer has to impose considerable discipline in coding in order to maintain this meaning. So, is there a more natural way to do it in C. So, we want to define a point data type, and a point data type internally has two integers; one- two floating point, one in x coordinate and another a y coordinate.  So, now we will define a structure as a collection of variables with a common name. Now the variables can be of different types, this is unlike arrays. We know that in an array you can hold multiple values in a contiguous sequence, but all the values have to be on the same time. So, what is different here with structure is that you can hold multiple values in the same data type, also the same data type can hold multiple sub types within itself. So, structural variables are called fields. So, let us look at a example structure, we define something called a struct point, and it has an int x and a int y coordinate.  And how do you… This is the data type notice that the data type declaration has a semicolon at the end. Now how do you define a variable with this data type, you can say struct point pt. So, pt is one variable that is of data type struct point, you cannot say point pt you have to say that it is a struct point. Now how do I assign values to this data type. So, structure is a composite data type that is two internal components; one is x, and the other is y. So, in order to say that the internal components will have certain values I need to say how to you get to these internal components, and this is done by the dot operator. So, you can say pt.x=1, that would assign the x field inside the pt structure to 1. Similarly pt.y=0, what it will do is it will take the y field of pt structure and assign it to 0. So, the internal memory representation after executing the statements will be that pt is a structure; it has two sub fields - x and y, and x will be assign to 1 and y will be assign to  Now as far as C is concerned this structure data type that you define is just like and data type that it provides. So, user defined data types especially structures at ((Refer Time: 04:57)) more or less in the same way as an ordinary data type. And we will see that with an ordinary data type there are multiple things that you can do with it, you can initialize you can declare a variable to be of that data type, we have seen already how to do it? You can initialize a variable of a particular data type, we will see how to do it? Similarly you can pass a data of a particular type to a function, and return a variable of that type from a function, you will see that all these are possible with structures as well. So, we will see these with examples. Now struct point is just a type and it can be use like any other standard C data type; even though you as a programmer have defined it. For now how do you define a structure, usually you define all the structures that you need at the very top of the file, just of the #include. Now, you know that with the standard data type you can define and array of the data type, if you have you can declare array of int, array of characters and so on.  So, you would write a loop, for example of the following form. So, you would say for i = 0, i < 6, i = i plus 1 and pts[i].x = i. So, pts[i] is the ith element in the array. In the elements in the array are of type struct point. So, pts[i] will be a struct point variable, and that variable has 2 fields - x and y. So, I can say pts[i].x = something i, and pts[i].y = i. So, at the end of execution of this loop the result will be of the following form pts 0 is a structure, and its x and y coordinate are 0; pts 1 is another structure, its x and y coordinates are 1, and so on. So, what are the characteristics features of an array, that it contains cells which are contiguously allocated, so they will be allocated one of to the other in memory, and each cell is of the same type as the others in the same array. So, both those are maintained. These structures will be stored one after the other in memory also everything in the array is a struct point. So, an array of structs is similar to an array as ints except for the fact that within a cell you will have values that can have subfields.  (Refer slide Time: 08:34)  Now we will see what else can you do with structures. Just like a variable of a int data type, you can return it from the function. If you declare an int x, you can say return x. Now let say it can be a right functions which can return struct point. So, the theme of this lecture is that user defined structures at treated by c pretty much the same way as the standard data types. So, the behavior should be consistent, you should be able to return a value of a struct of type struct from the function, let see an example. So, here the user defines a struct point, and then when you run the program, you say can give two integer values - x and y, and I want to create a point struct with subfields x and y which the user has input. So, I have return a function called make_point; make_point takes two arguments int x and int y, and what it returns is a variable of type struct point. So, this is the return type of the this whole name is basically the return type of the function, the name of the function is make_point. Now how do you define it? So, for example, you can define a variable temp of type struct point, and then say temp.x = x, temp.y = y, and return temp. Now, if you forget about this code, particular code, if temp had been an int variable, you would say return temp. If the function was if return type int. Here it is the function is returning struct point, and you would do it exactly in the same way as a function returning int. So, what else can we do with a normal data type, you could for example pass it as a parameter two or function. So, if you have int variables, you can pass functions taking int arguments. Similarly can you right functions taking struct parameters, and we will see that is can be done, yeah.   So, we will take an example that is fairly easy to understand. So, you take a point p and calculate the norm of the point p. So, what is the norm of the point p? The norm of the point(x, y) in the Euclidean plane is simply . So, you will just have to calculate a function which does this. For this we will use the math library in C. So, I will say include<math.h>, and then I will defined a function norm of struct point p. So, let us call this norm 2 and less ignore why it is call norm 2. So, it is just a function that takes a point p and calculates the norm(p). So, for this what do I do? I will say that returns square root. So, sqrt is the square root function provided by math.h. So, return sqrt(p.x * p.x + p.y * p.y).  So, the in the main what you would do is user defines user gives an input x and input y. You make a point using the earlier function that we wrote make_point x y. So, pt will be a point with x coordinate x, and y coordinate y. Now for that point pt you define norm2(pt). So, norm2(pt) here you would pass a point a struct point as a parameter, and the function with calculate the norm of the func of the point and return the norm. So, the way you would passes structure is the same as the way you would pass an int or a character or something.   (Refer slide Time: 12:54)  Now let us takes the game a bit further. You know that I can you know that you can defines structures whose subfields are standard C data types. Now, if user defined data types, user defined structures are of the same category as standard data types then I should be able to defines structures whose internal fields or themselves structures. So, we have seen structures whose internal fields can be basic data types, now will see structures whose internal fields are structures themselves. So, let us look at a very reasonable use case in which this can be occurring. So, suppose you want to extend your geometry package, and you want to define a rectangle. Now a rectangle is define by two points; two diagonally opposite points, let say the left bottom and the right top; these two points define a rectangle So, the left bottom and the right top are themselves points. So, they have some fields which are x coordinate and y coordinate.  So, again you would use the dot notation, so, is a very consistent representation. So, I would say that in the inside the code of name, I would say struct rect r and then I would say r.leftbot . x = 0, this says that the take the left bottom subfield of r. Now, since that is a structure r.leftbot itself has subfields which is x and y, it is x coordinate is assign to 0. Similarly r.leftbot . y = 0 and so on. So, I will say that this rectangles left bottom is 0, and is 0 0 - and its righttop is 1 1. So, after running this code, this is the state of the memory. So, I will have a rectangle r, and its leftbot.x = 0, its leftbot.y = 0, its righttop.x = 1, and its righttop.y = 1. (Refer slide Time: 15:47)  And now we will also see how to initialize structures. So, we know that normal basic data types like int, char, and all that when you declare a variable, you can also initialize, can you initialize a user defined structure in this way. So, the wave define it is similar to the way you define you initialize arrays. So, initializing structures is very similar to initializing arrays, enclose all the values of the fields in braces, and the values are given in the same order that you they are defined in the structure. Suppose you have struct point int x and int y, how would I initialize it I would say struct point p = {0, 0}. So, this means that the first field int point, that is x is assigned 0. The second field that is y is assigned 0 as well. Similarly if I say struct point q = {1, 1}, it is says q.x = 1 and q.y = 1 Now, you can do the same thing with nested structures. So, this is very nice. So, if I want to define a rectangle. Remember that a rectangle has two 2 fields, which are themselves structures their points. So, if I say r = {{0,0},{1,1}}. What happens is that r first field which is the left bottom, it is will get the value (0, 0); that means, that it is the left bottom subfield x will get 0, and the left bottoms y will get 0. Similarly the r is second field is the right top, it will get (1, 1). So, righttop.x will be 1, righttop.y will be 1 as well. So, this is how you would initialize an a initialize a structure as very similar to initializing an array. The only thing to remember is that the values must be given in the same order then they are declared in the type declaration (Refer slide Time: 18:10)   Now we know that variables can be assign to other variables. So, natural question is can struct variables, we assign to struct variables, and the answer is s, suppose you have a rectangle r whose left bottom is 0, 0, either initialize it you are assign the values, and it is righttop is 1 1. So, I define another variable s which is also a rectangle, and if I say s = r. Let see what happens? So, at before the assignment r is as follows. So, you have x 0 0 x xy 0 0 and x y 1 1 left bottom on the right top, and s is uninitialized it has just been declared, but the no value has been assign it.   So, this is the state before the assignment. When you do s = r it is very nice, what it does is s is leftbot.x will be assign 0, s is leftbot.y will be assign 0, s is righttop.x will be assign 1, and .y will be assign 1. So, what happens is goes into the, it goes into the structure r and copies it entirely in its full depth into s. So, it is not just that a left bottom and right top are copied its internal fields are also copied into s. This lecture will continue our discussion of structures. So, if you remember are earlier lecture we were saying that user defined structures or user defined types which will be treated by C, in pretty much the same way as the basic data types.  So, will continue on that theme and look at topic on pointers to structures, we know that for a basic data type you can define a pointer to that type, I can declare int * or char * and so on. Similarly does it make sense to talk about struct points * for instance.  Let us look at an example were it makes sense. So, let us go back to the example of struct point and struct rectangle from the earlier lecture. So, let us say that struct rect has two points, which are leftbot and righttop and both of them are struct point. Now, we want to calculate the area of a rectangle. So, you have a rectangle r which is initialized to {0, 0}, {1, 1}. So, leftbottom will be {0, 0} and righttop will be {1, 1} and I want to compute its area. Now, the area function is defined as follows, it is a function that returns in integer, it takes as parameter a struct rectangle and it does the following, it does (r.righttop.x – r.leftbot.x) * (r.righttop.y – r.leftbot.y). So, it does that particular function and it returns it. So, we know that we can pass structures as parameters and also return structures from functions, but is it efficient to pass structures or to return structures? And the answer is usually no, because copying a structure involves copying all it some feels. So, generally when you caller function the value has to be copied onto the functions scope and we have seen this when discussing functions. So, when you pass a structure the entire structure has to be copied. Similarly, when you return a structure the entire structure that was created inside the function has to be copied back, this is usually and expensive operation. So, one way to get around it is to pass a pointer to the structure. So, what should be done to past structure has function in an efficient manner.  Now, one way to do it would be to define, what is known as a pointer to a structure, how do you define a pointer to a structure, you define it pretty much the same way as pointer to any other data type had this been an integer, you would declare int *pr. So, if you want to declare a variable which is a pointer to a structure, you would define struct rect *pr. So, pr is a pointer to struct rectangle. So now, how would you pass the argument, you would say address of the rectangle r. So, you would say area and the parameter is address of r. Now, inside the function earlier you remember it was *pr.righttop.x, now pr in this case is just a pointer to a rectangle. So, we have to access the variable in that address, how do you do it using the * operator, this is the same as addressing any basic data type, you would say that *pr would be the variable in that location. So, in this case it would be *pr, *pr would be a struct rect and that struct rect .righttop.x – (*pr).leftbot.x and so on. So, the lesson here is that instead of passing structures, you pass pointers to structures and now whatever be the size of the structure. So, you have a struct rectangle which inside has two points and so on. So, you may want to pass a very large structure and copying that will take a long time. But, instead what you do is, you pass just a pointer, now regardless of the size of the structure only one pointer is copied. So, this same principle goes for returning structures as well, when on a structure from the function what you would do is to return a pointer to that structure. Of course, now the structure has to be allocated on the heap rather than the stack.  Now, let see how the memory depiction of this looks like. So, pr when you define struct rect *pr, pr is a pointer to a structure of type rectangle and then what is happening here is there, if you want to access the y coordinate of the left bottom, you would say ((*pr).leftbot).y. So, it will come to the leftbot field of rectangle and pick its some field y. So, ((*pr).leftbot).y would refer to this location in the memory. Similarly, ((*pr).righttop).y would be this location in the memory and so on. So, you can address the sub fields of address the fields of a structure using pointer.  There is one syntactic convenience that C provides you, because addressing structures is a fairly common occurrence. And because in this case by associativity, you cannot omit the parenthesis, you cannot say *pr without parenthesis, because it means pr.leftbot and * of that. So, that is not what you want, you want to say that take the structure in the location *pr and take it is leftbot. So, in this case by it is associativity and precedence rules, you have to include these parenthesis, you cannot omit them and this is inconvenient. Therefore, C provides a syntactic convenience, which is pr arrow, arrow is actually two characters it is a - and a >. So, pr - > leftbot is the same as within bracket (*pr).left bot. So, there are two ways to address the fields of the location pointed to by pr. So, pr is a pointer to a struct rect you can access its leftbot by saying (*pr).leftbot or pr - > leftbot. Notice that, these two characters - and > is just a single operator and they have... So, - >, that is the - > operator and . have the same precedence and both are left associated.  Once we know structures and pointers to structures, we can introduce some very important data structure called link list. So, we will first see what link list are, how to operate on them, and then argue why link list are useful.  So, let us just introduce this notion called self referential structures. So, we are defining a struct node that has two fields - one is an int data, and the next field is the surprising one, it is a pointer two type struct node. So, this data structure, this c structure is called a self referential structure because internally there is a pointer to an object of the same type. So, in that sense it refers to some other object of the same type. So, it is called self referential.  So, an example would be like this where the data field has 10, and the next field points to something else which should be a struct node So, then field next is of type struct node; now, there is a subtle point to be emphasized; instead of struct node * had I return struct node next then this is not allowed, because the definition of struct node has an internal struct node inside it, so which essentially has infinite size. So, we are cleverly avoiding that by including just a pointer to the next node. So, using this structure we can define what is known as a singly link list. So, an example of a singly link list structure would be where we have pointer which we will call the head of the list, head points to the first struct which is 4, which as data 4; and it is linked to another struct which has data 2, that is linked to another struct which as data 1, and so on. The last struct in the list will be linked to null. So, there is only one link from each node, hence the name singly link list.  So, the fact that the next field is null indicates that that is the last node in a link list. And a link list is always identified by its head which is the pointer to the first node in the link list. Once we reach the first node we can travel the list by using just the next links. So, once we have a link to 4, we can always say, 4, 2, 1, -2, and so on. So, the list is made modeled by the variable called the head that points to the first node in the list. And if the head is null then that means the list is empty. And then you have a bunch nodes; and when once we reach a node with the next field null then that is the last node in the link list. Now, let us look at certain simple operations on singly link list. Suppose you want to insert a node at the front of the list, so we have a list, 4, 2, 1, -2, and we want to insert something else in the beginning. So, what you do is you create a new node of type struct node and set its data field to whatever number that you want to store. Now, add it to the front of the list; we will see how this can be done.  So, suppose that the head is now pointing to 4, and the list is 4, 2, 1, -2, and you want to add a new node, so 2 is the node, the data field is 2, how do you add? You do two operations – first you say that 2 is next is the first node in the old list. So, that would insert 2 here. And then now the list has changed because the first element is now 2, so head moves to 2; head was previously 4 and head now moves to 2. So, this is abstractly how you would insert a node at the beginning of a list.   So, now, let us try to code it and see. So, first we need a code small function to make a node with the given data. So, we will say, struct node * make_node in 12. Now, we will create a pointer struct node * temp, then use one of the malloc function called calloc; so 1, size of struct node. So, this will allocate memory enough to create one node. Now, this, that memory its data field will be set to val which is what we are given as argument to the function and then you return the node. So, we have created a node; and how do you insert in the front? Once you have, once you receive an value to be inserted at the beginning of a list. So, the list is identified by the head. So, we have to create a node which contains the value and insert it at the beginning of this list. So, what we do is we first create a node with the value using make_node function; now temp next is set to head; so this link is activated. So, 2s next will be 4. So, that is the first step. The second step is that the head now has to move to 2 because the first element in the new list is 2, not 4. So, I will just say, head = temp, and return head which is the head of the new list.   And now, you can call this function multiple time. Suppose you want to start with an empty list and insert -2, then insert -1, then insert 2, then insert 4, then insert 2, you can call these functions one after the other. So, I can just say struct node *head = insert_front (2, insert_front( 4, insert_front(2, insert_front(1,insert_front(-2,NULL))))). So, this is the function; this is the sequence of functions and this is the list that you will end up with. So, once you have the function to insert at the beginning of a list, you can use that function multiple times to build up the list.  Now, let us look at some useful functions to be done on link list. So, once you have a link list it will be good if you can search the link list to see whether an element is present or not. So, we will look at a very simple algorithm. So, we want to search for a particular key that is an element in a singly link list. So, how do you do it? Abstractly, what you do is you start with the head, see whether the data field in the head node is the key that you want.  If it is, then you are done and say, that I have found it; if it is not what you do is, you go to the next node through the next link and then search; ok, you said the data field of the next node if it is you are done; if it is not, you search and follow the next node. You follow this procedure until you reach the last node. Suppose, you have not found the key even in the last node, and you follow the next link and it is null; so once you reach null then you know that you have reached the end of the list. So, you cannot take null next that will cause your code to crash. So, once you know that your node is null, you can end the search and then say that the key is not present in the list. Here is a flowchart corresponding to that; you start with *curr = head; now, is curr null, if the curr is null then that means you have reached the end of the list and you have not found the key. So, if the curr != NULL then there is data still to be searched. So, you see whether curr data is equal to key; if it is yes then you have found the key, otherwise you follow the next node link to go to the next node in the link list; and again, repeat the procedure, and you can code this in a straight forward manner.  So, I will write struct node *search; I need the head of the list and I need the key. You start with *curr = head. If curr !=NULL && curr ->data != key, you follow the next link, curr = curr->next, and you repeat the procedure. So, when you exit the list either curr will be null or curr data will be key. So, what is the condition when you reach the return? So, if the key is absent then you are returning null, if the key is present you are returning the pointer to the node, pointer to the first node that contains the key. So, convince yourself that the code works.  Now, let us look at slightly more involved operations. We have seen insert at the head of the list and that was fairly simple, now suppose you want to insert into the middle of the list; you do not want to insert right at the front, you want to insert somewhere in the middle. Now, there are two cases here. If the list is null, that is the easy case; if the list is null then insert in the middle is essentially insert at the front. So, we already have seen the code for that.  Now, if the list is not null, now it is a new algorithm. So, let us look at an example. So, suppose the list is 4, 2, 1, -2, and I want to insert a node 5 after node 2. So, how do I do it? 2s next link was 1. And what we need to do in this case is I want to say that I have to insert this node 5; 5s next node will be 1; that is, so think about this as it link in a chain. So, you need to disconnect this link say that 2 is now connected to 5, and 5 is then connected to 1. Now, the only thing to be noted is that the links have to be detached in a particular sequence. So, first I need to say that 5s next is 1, and then I need to say that 2s next is 5. So, convince yourself that the opposite sequence where I say that 2s next is 5, now your code will has no way to proceed because you have lost the how to traverse from 2 to 1. If you say that 2s next is 5, then 5 has no way to know what was the original next node of 2. So, you have to do it in a particular sequence - 5s next is 1, and then 2s next is 5. We will see this code in a minute.   So, what we do is we want to insert after a node, so pcurr is the node after which we have to insert; and pnew is pointing to the new node that we have to insert. If pcurr is null, then essentially the list is basically pnew; this is a case that we have seen before. If pcurr is not null, that means the list is not empty, then what you do is, the new node’s next node is, pcurr’s next node. So, 5s next node is the old 2s next node which is 1. So, 5 next will be set to 1.  And after that I will say, pcurr->next = pnew; then I will say that pcurr which is 2s next will be set to 5. So, convince yourself that if I swap these 2 lines, if I swap the lines order then the code will not work. So, see this for 5 minutes and you convince yourself that that will not work.  So, let us just see how this works. So, initially, let us say that I want to insert after 2, and new is the new node. So, initial state is something like this; the 5s next node is pointing to something, maybe some arbitrary location. Now, after line two that is pnew -> next = pcurr -> next, this is the state of pointers. Please look very carefully. So, 5s next will point to 1, and then this point 2s next is also pointing to 1. So, there are 2 nodes whose next is 1 which is fine because we have not completely inserted 5 into the list now. Now, at this point, I will just detach 2s next and make it point to 5. So, there we go. So, after step 3 you have essentially inserted 5 into the list.   Now, let us look at some syntactic conveniences that c provides you. So, repetitively you are typing the struct node, and things like that is it is just too much to type, and c allows you to define short names for types. So, if I want to say, like struct node * I want to use the name list node. So, I will just say struct; instead of struct node *head, I will just say list node head. So, it is a shorter way to do it.  So, how do I write this? This is using what is known as a typedef keyword in c. So, if I say, typedef struct node * list node, what it means is that list node is another name for the long type struct node *. So, this is something that you may use if you want to. It is not something that is that you should use, but it is just convenient. So, if I say, list node head, this is the same as saying struct node *head, curr.   Now, let us see why link lists are important. So, first of all it is one of the first non trivial data structures that you learn. In earlier days when c had only fixed size arrays, link list was important when you needed variable size storage. Nowadays, c has variable size storage, so you can, in arrays, so that is not so important any more. But, here is one important thing, one difference between link list and arrays which are very important.  Like, insertion and deletion in link list are fairly cheap. In the case of an array, so if you want to insert an element at position k in an array, you have to copy all elements from k to n -1, to the last element in the array; move each of them backwards, makes space for it, and then insert the k th array. So, this involves, in the worst case, it involves moving all the elements of the array by one element, one position each.  Similarly, for delete; suppose, you want to delete an element from array, then what you have to do is, you have to take the remaining elements of the array and move them one position to the left. So, this will involve moving n elements in the array if array has n elements in the worst case. Whereas, note that in the link list case, to insert or delete any element, a new node, whether at the beginning or in between, it just takes one operation; the other elements need not be manipulated.  So, let us just quickly see how to delete a particular node in a link list. So, we will just say that 4, 2, 1, -2, is the link list, and I want to delete this particular node, is that possible? So, I cannot straight forward delete this node because the previous nodes next element should point to this guys next element. So, if I want to delete 1, what do I have to do? I have to say that 2s next node should be -2.  But, in a singly link list there is no way to go back; from 1 you cannot easily get to 2. So, this is slightly; so deletion requires slightly some more information. So, if I can delete a node, if I also have a handle a pointer to its previous node, then it is very easy to say that 2s next node will be -2.   And that is what we will do. So, we will say that let us have a delete function, t node is the node that I want to delete, and ppnode is its previous node. And what I will do is, if there is a previous node I will say, previous node’s next is the current node’s next. So, 2s next link will go to -2. If there is no previous node then I will say that, t equal to at the current node’s next; and then once that is done, you delete the current node, pnode. So, this is how you would delete an element from the link list.  So, just recap searching in a link list will take order n time, in the case of a link list, that is you have to search all the elements in the worst case which is the same in an array. Now, suppose you sort an array, you have faster search techniques available; you can do binary search in an array. Unfortunately, in a link list, even if you sort the link list, there is no way to do a binary search in the link list; why is this? Because you cannot reach the middle element of the link list in one shot.  In an array, you can just say a mid, and it will go to the… So suppose you say thatmid = 0+ n-1/2, you can go to the middle element of the array. But, there is no way to do that in a link list, you have to go one after the other. So, sorting does not help in searching when you are looking at singly link list. But on the other hand, insertion and deletion are very quick in a link list, whereas they are very slow in an array.    In this lecture, we will see slightly more advanced data type, then a singly link  list. We will briefly go over one or two functions to manipulate the data structure. The principle of manipulating the data structure for the other operations is similar.   So, in the case of a singly link list, we have seen that every node has one link to its next  neighbour, and we have seen this problem in a singly link list that if you are at a current node in a link list, you can always go forward, but there is no way to go back. There is one the only way took get to its previous node is to start all over again from the beginning of the list and traverse until you reach a list traverse, but traverse until you reach the previous node. So, we can easily remedy this by thinking of a data structure, a slightly more involve data structure where every node has two links; one... So, look at this node 2. So, it has two links; one is two it is neighbour successive neighbour. So, it is it is next node, there is another link which goes back to it is previous neighbour. So, in this data structure there are 2 links per node, therefore it is known as a doubly link list. And this list, obviously you can go from a current node, you can go forward or backward, so easily… So, now the variation is this in each node has three fields; one is a pointer to the previous node, the second is the data in the node, and third is the pointer to the next node. So, how will the definition look like, it will say something like struct dllnode, doubly linked list node, it will have one filed which is data in data let us say, and then two nodes - struct dllnode next, and struct dllnode previous. So, one to the go to next node and another to go to the previous node. Now we will need two pointers typically for a doubly link list. One is the pointer to the beginning of list which is usually called the head, and then another to the end of list which is usually called tail. So, I will use a type def in order to the short term the name, I will just say typedef struct dllnode * Ndptr. And then I will say that the list has two node pointers; Ndptr heads, and node pointers last. So, doubly link list. Each node in the doubly link list has two list; one to its previous node, and another to is next node. And the list itself has two pointers; one to the beginning of the list - call the head, and another to the end of the list - call the tail.  So, now a doubly link list is another data structure notice that we have seen two or three data structure so far arrays are one, which see already provides. We have already seen singly link list, now we have seen a third link list - third data structure which is a doubly link list. Now data structure has data and a bunch of operation defined on it. So, let us look at a typical operations that can be defined on a doubly link list, and we will go over the implementation of two or three them. So, Ndptr head. So, this is a function that should return the head of the list. Similarly node point of tail, they should return the tail of the list. Insert before, so this is like a insert before node in the case of a singly link list. So, here we are given a current node and we have to insert before a current node in the doubly link list.  Notice thus this was difficult in singly link list, because there was no way to go from a current node to a previous node. We could always go to the next node. So, if I say that here is node and insert before that node in a singly link list is a difficult. You need some extra information, but in a doubly link list you have the current node and you can use the previous link in order to go before that. Insert_after_node also can be done this could also be done in a singly link list.  And then you can think of several other common like, you can think of a make node, you can think of a make_list with us single with a single node pointer two by pnew. You can make an empty list, you can check whether I given list is empty, you can a write functions to copy a doubly link list to an new doubly link list, you can concatenate to doubly link list. You can do a deep concat, we will see this in a features slide, you can append to link list, and so on. Similarly we can have insert, since we have insert functions we can also have delete functions, you can delete a particular node, you can extract a node in the sense that. So, delete would take out a node and free the memory allocated to the node, extract would just take out the node from the link list, but you retain the node, you can deleted entire list, and so on.   So, let us look at a couple of these functions; other functions can be return in similar manner. So, suppose let us take insert before load. This was a function that was not easy with the singly link list. So, I am given a link list L, and given a current node pcurr, and a new node to insert before the current node. So, what are the things to check? If the list is empty then insert before the current node just means that you create a new node, and return the new list. Now, if the head of the list is null, then you just say that now the new list contains only one load, L head will point new, L tail will point a new. So, if the list itself was null, then what you do is you create a new node, now the new list contains only one elements. So, the head will point to that and the tail will also point you that, and you return that. Now you come to the non trivial case, suppose there is a list; and the list has some elements. So, if pcurr is not equal to null then what to you do is, sorry if pcurr equal to null then you return L, this is an error. If pcurr is not equal to null then what you do is the following.  So, now you have to insert pnew in to the list. So, how do you do this? So, we say that the new nodes next will be... So, we are trying to insert pnew before pcurr. So, the new nodes next will. So, the new nodes next will be pcurr; pcurr previous will go to pnew. And so the pnew next will go to pcurr, and pcurr previous will go to pnew. Similarly we have to say that the previous node, the node before pcurr it has to point to pnew. So, pcurr previous that nodes next will good point to pnew, and then you return the new list, so this can be done by looking at pointers and handling pointers carefully.  So, now let us see how to delete a particular node in a list. So, if you have to delete header of the list, then if there is a list you just delete the header, and you just free the entire list. Now if you have to delete a particular node in the middle of a list, what do you do? So, let us look at the various cases. So, in case one the node that you want to delete is the head of the list. So, in this case suppose you want to delete p, what would you do? You would make head point to the next element and free(p).   So, this guys previous will be set to null. So, now it does not point anything and then you win free(p). So, this is the first case, where p the node to be deleted was the head of the list. Similarly, if you want to delete the tail of the list. So, now what should you do here, the tail should go to p previous. So, in case two when p is the end of the list that we want to delete. Then tail should go into previous. Now this guys next to will now point to null, because we are going to delete this node.  And finally we will free(p). So, L tail will go to p previous, L tail next will be null, and then finally you will free(p). So, we have seen two easy cases; one is delete a head, and other is delete a tail, and now we will see the difficult case where p is an intermediate node. So, in this case what we will do? So, we will we have to remove this node. So, p previous next node should be the next node of p previous. So, this link should point to the node after p. So, that is the first thing.  So, we will make this point to the node after p, and this node previous should point to the node before p.  So will reset the links. Now, if you look at the link this guys next is the one after p, this guys previous is the one before p. So, now p can be safely removed. .  So, this is how you would delete a node in the intermediate list. So, if there is the next node, then p next previous will be p previous, that is this backward link. And if there is a the previous node then p previous next will be p next, that is this forward loop. And finally, after that you will free(p). So, this is how you would be delete a node from a link list from a doubly link list, and other operations can be done in a similar manner and some of these operation will be asked in their excise problem that you will be assigned. Similarly, you can think of an extract node, the code will be exactly identical to before except at the end, you will instead of freeing p, you will return p. You do not free the p node, we will just the return the p node. . Now, let us look at one more example, how do you attend append one node to the end of the list. So, first we will check that the node is pointing to a normal node, if it is pointing to a null node that is nothing to be the done. So, there is nothing to be appended. So, you have return. Now, if there is a list, then what to you do is if there is no need list what you do is you make an list with only one node which is p. Now if there is a list, you can in order to append the node at the end, what you could do is call insert_after_node(L, L>last,p) So, append will be the same as insert the node p at the end of the list. So, you will say insert after L last, what is the node to be inserted p? So, if you have in insert_after_node or an insert before node, you can do this to implement other functions. So, this is the brief introduction to doubly link list which are similar to singly link list, but facilitate forward as well as backward traveling from a current node, using that you can implement more functions easier than a singly link list. At the same time, it has all the advantages of a singly link list in the sense that if you want to insert a node, it can be done using a constant of number operation, if you want to delete a node it can be done in the constant number of operations. So, those advantages are similar to a singly link list. At the same time the disadvantages are also similar to a singly link list. In the sense that if you want to search through even a shorted doubly link list, you have to search through all the elements.    So, one of the basic principles is to separate the function prototype declarations from the function definitions. We have seen that when we have a function we have two things to do - one is to declare a function which is just the types involved in the function, and then the definition of the function which is actually the code of the function. So, one way to structure it, one principle in structuring is that we will separate out the function prototype from the function definition.  Now, place all prototype definitions, structure definitions, typedefs, so just the declarations, you will place it in a file with suffix .h. So, right now we have been coding in a file call .c. So, right now what we are proposing is that the declarations alone we will place it in a separate file with suffix .h. You have already seen such an example which is stdir.h, we never bothered about what is inside a stdir.h. Now, we are talking about how to write these header files.   Now, we will see why separate .h and .c? Programs that use the doubly link list need to know only the declarations actually. These are, think of these programs as the consumers of this code. Now, it does not need to know how the code is implemented, just what to call and what is the declaration of the function. Now, if we do this, then list.c can be compiled separately into object code. So, we can say gcc -c list.c, this will produce just file call list.o. List.o is not executable, but it can be used in other programs to create executables.  So, how can we do this? This is the procedure known as linking. So, we can link the list.o. So, notice the difference here. When we see gcc -c list.c, what it could produce is a .o function, .o file; and this .o file can be included to produce output. So, this says that we are compiling prog.c file, with list.o object file, and the output we will produce is called prog. So, gcc -o prog means, the output file we will produce will be called prog. So, if we omit -o prog, and the simply say gcc prog.c list.o, then the file that we will get is, a.out. If you specify an output file we will get that output file. Now, inside prog.c, let say that we need to use list functions. So, prog.c will include “list.h”; this is the important thing. It will not say include “list.c”, it will just say include “list.h”. This is similar to what we have seen with stdio; we did not bother about whether there was an stdio.c file. We said we will include <stdio.h>. Also, notice the difference that we are using double quotes instead of angular brackets. So, when we wrote <stdio.h>, what we had was angular brackets, open angular bracket and close angular bracket, here we have quotes; why use that? We will see this.   So, what is the advantage of separating list.c from prog.c, why break it up into multiple files? One advantage is that it saves a repeated compilation of list.c functions while compiling prog.c. So, the “list.h” specifies to the c pre-processor; we will see this is in a subsequent lecture, that the current working directly will be searched for list.h file.  So, since we are saying that include “list.h” within double quotes, what it means is that, where is list.h found? It will be found in the current directory. If it is not found in the current directory it will search for some standard library parts, some standard header file parts. So, in the case of <stdio.h> we put <stdio.h>; that means, that <stdio.h> will be found not in the current directory, but in some standard header directories.   So, what is the division of work? What is the separation between the .c and the .h files? .h file is the public interface; that, if anybody else, any other program wants to use the list functions what you would do is, include the list.h functions, include the list.h file. Now, list.c implements, defines all the functions that list.h has declared. In addition, it can also define other functions, but these functions will not be available to other programs that are using the list.h file.  So, files using list.h will not be able to use these extra functions or even know about these functions. These are thought of as private functions. So, this can be used to implement certain details of your code that other uses of this program need not know about.  So, the general principle is what is known as information hiding or localization. So, break your programs into modules. We have already seen one way to break a program into modules, which is by writing functions. Now, this is another way to, this is another level of module array station where you say that take a collection of functions and put them in a file and have multiple files.  Now, each module implementing some aspect; for example, data structures like a link list. Now, if a module B does not need to know the details of how another module A works, then we do not need to tell B about how it is done. But, module B should use module A’s .h file, not the .c file.   Why do we separate definitions into .h and .c? There are some reasons. Programs that use the list functions, for example, are typically consumers, and they do not need to know the exact details behind how these functions work. And we have already done this in other, we do not know about how scanf or printf worked. We just know that scanf needs these two arguments, for example, it needs a format string and it needs the variable to be printed; the printf needs the format string and the variable to be printed. Similarly, scanf needs the format string and the variables to be assigned.  So, we just knew that, we do not know anything about how scanf or printf is actually defined or implemented; we just know that it needs these arguments, and therefore we can call them. So, this is the kind of separation of detail that we are hoping to achieve. Now, so if some program wants to use the list functions, such programs can use the prototypes using the include command, #include “list.h”. So, again to remind the double quotes specify that it is the current working directory that list.h is present in; you can also give full paths.  List.c program will contain all the actual function definitions. Now, usually header files are much smaller than the c files. If list.h and list.c are separated, then list.c can be compiled ahead of time, and you can generate the object file. Now, notice that list.o in this case will be not executable; it is just an object file that can be used to build executables.  Now, list.c programs is complete, except for a main function. So, it has a lot of functions; it defines all the functions there list.h has declared, plus optionally some more functions. And it can be compiled to produce an object code, but it cannot be done, it cannot be compiled into an executable code because it does not have a main function. Now, suppose we have written function called prog.c that uses many of the list functions, that uses list.h. We can compile prog.c to generate an object code: gcc -c prog.o prog.c. So, now, we have 2 object files, list.o and prog.o; and then we can use these two object files to create the executable file.   Let us look at a diagram which will hopefully be helpful. So, list.h includes a prototype declarations, but not the function definitions; list.c defines these functions. So, in order to define these functions, first it says, include “list.h”, therefore, it will get all the declarations, and then it has this code which implements the list function definitions. prog.c is a consumer which needs these functions. So, how does it do it? It does not say list.c, it says include “list.h”. So, the declarations of all the functions are available to prog.c. Now, I separately compile list.c into list.o using gcc -c, and prog.c into prog.o using gcc -c. So, now, I have 2 object files, list.o and prog.o. And these will be combined using gcc -o. So, this says that the output file will be called, a.out; the compilation units that I need are prog.o and list.o. So, use these two files, in order to create the output file, a.out.  And what is the big advantage here? Let us consider a scene where the prog.c file changes. I need some changes to be made into prog.c; maybe I add some more functions, modify some functions and all. So, now I need to recompile and produce the output file. I have changed prog.c, but not list.c.   So, let us say prog.c has changed. What should I do now? I should compile only the prog.c. I can say gcc -c prog.c; now, I will produce a new prog.o file. Notice, list.c has not changed. So, we do not need to recompile list.c. So, we can just say, gcc -c prog.c; list.o is same as before. And then I can use the new prog.o, the old list.o, in order to produce the new a .o. So, notice the, a.out depends on prog.o and prog.c has changed.  So, only this path gets recompiled which is saving a lot of effort. And in large programs, when one particular file changes and you recompile the project, only the necessary files get recompiled. It does not recompile the whole project which will take a lot of time, instead it will compile only those files which are necessary. So, this is the huge advantage.  So, this just repeats what was said in the last slide.  Now, couple of thoughts about a writing data structure libraries. There is no one design which is best for a data structure library. Choose your structure functions to be as complete as possible for your programs. Now, programs can be based only on the function prototypes. Suppose I write a program which needs a list function, I can just look at the function prototypes in the .h file and then write by program. Consumers do not need to know how the program is implemented; just what the functions are, what are its arguments, not the details about how it is implemented.  Now, implementation of libraries should be very sound. All boundary cases should be completely defined and the implementation should thoroughly match the specifications.  Also one more thing, allocation and release of storage. If the library is allocating storage, it is only sensible to provide routines in the library itself which can free those storage. So, it cannot be that libraries allocating a storage and the freeing of storage has to be done outside the library, that is not a sensible design. So, if the library itself is allocating storage, you give library functions to free the storing as well. For example, in list.h, memory allocation is done only in two places, make empty list and make node. So, to deallocate that you should provide a free functions for these functions, corresponding to these functions.  Thanks.      In this lecture, let us look at one particular part of the C compiler which is very important, namely the preprocessor. Technically speaking, the preprocessor is the step before compilation. So, let us understand this in detail. (Refer Slide Time: 00:18)    So, let us look at header files. A header file is a file containing C declarations, macro definitions etcetera to be shared between several source files. Header files are included in your program using C preprocessor directives “hash include”. For example, we have seen <stdio.h> and within quotes list.h. So, header files serves two purposes that we have seen. First is that it could be a system header files. This declares interfaces to part of the operating system including system calls, C libraries and so on. Or you could have your own header files, which you have written to contain declarations of your code of the functions in your code.  Now, what happens exactly when you include a header file in a C file? Including a header file produces the same results as copying the header file into each source files. So, when you say include<stdio.h>, it is essentially taking the contents of the <stdio.h> file and copy, pasting in to your source code. So, this happens at exactly the place where the corresponding hash include command was written. The advantages of having these header file and hash include is that related declarations appear only in one place. And if you want to change a particular function or declaration of a function, you just have to change it in a single file. And all files which include that header file will automatically see the change.  So, here is something that we have mentioned in the previous video. If the difference between angular bracket in the double quotes; so the angular bracket is usually used in system header files and it searches for the file named let say <stdio.h> in a standard list of system directories. If you say within double quotes, on the other hand like list.h, it searches for this list.h first in the current directory. If it is not found in the current directory, then it goes again in to the standard list of that. Now, the argument for hash include; whether you include it in a angular bracket or in a double quotes, it behaves like a string constant and it is literally put there. So, if you have like comments, the comments are not recognized as just comments. If you have a * symbol, for example, it will be just put exactly like a * symbol. So, it is just treated as a string constant and no interpretation is done.  Now, let us look at a very special case that could happen in the header file. Typically, you would not do this. So, suppose you have; within the “header.h” you have a text char *error=“Overflow”. Typically, you do not initialize variables in a header file. But, let us say that in a particular “header.h”, we have this char *error=“Overflow”.  Now, in p.c I write this very peculiar thing. I write int x and then in the middle of the code I say #include “header.h”. Till now we have always used hash include headers in the beginning of the file. But, suppose what happens if I do it in the middle? Now, after the C preprocessor processes the file, what happens is that whatever text is there in “header.h” is copy, pasted at that position. So, for example, this code will be transformed by the C preprocessor to look like this. It will say int x and the “header.h” contain the single line; char *error=“Overflow”. So, that text will come here. Now, this transformed text is what the C compiler sees and it will compiled in and produce the object code or the executive.  So, included files are not limited to declarations and macro definitions, these are merely the typical uses. You can put any text there. And when you include that header file, the text will be copy, pasted into the position. Typically though you would want to avoid this, you would want only declarations in a header file.   Now, let as look at some other features that the C preprocessor gives. We have seen in some code, this use of #define. So, #define is used for what are known as object-like macros. An object-like macro is basically an identifier and it will be a replaced by some code text. It is called object-like because it looks like an object. So, its most common use is to give symbolic names to numeric constants. Suppose, you want to write a program in which the maximum array size is let us say 1024, instead of putting 1024 in several places, the typical usage in a program would be to say #define BUF_SZ; so buffer size to be 1024. So, you have used #define to define this identifier BUF_SZ and BUF_SZ will be assigned the text 1024. So, this says that I am defining a macro named BUF_SZ. And it is an abbreviation, the short form for the token 1024.   Now, if somewhere in your code if you say #define BUF_SZ 1024, in all places after that, suppose you say like char *str= malloc or calloc(BUF_SZ, sizeof(char)), what the preprocessor will do is that it will look at this string constant. It is the name of a macro. And it will replace it with 1024 which is value of the macro. So, the transformed text will look like this; char *str= malloc or calloc (1024, sizeof(char)).  Now, by convention macro names are return in upper case, so that somebody who reach the code will be aware that code this could be a macro; because if I write it in lower case, there are chances that somebody would think, that it is a variable name and look for the variable. So, writing it in capital letters is a way of indicating to the user that this is actually a macro. So, please look at in a header file for example.  So, the C preprocessor scans through a program sequentially. This is an important thing to understand. And macro definitions take effect at the place you write them. So, let us look at a very specific example to illustrate this point. So, suppose you write foo = X, after that you have a line say #define X 4 and then bar = X. What will the C preprocessor do? It will look through the file and say foo = X. fine. It does not know what X is. It will not transform that line. Then it sees the #define X 4. Now, it knows that X is a macro and it has the value four. And then it sees bar = X, but now X is a macro. The preprocessor knows about this. So, it will replace X with four. So, that transformed text will be foo = X; bar = 4. It is natural to imagine that I would have four = four. But, that is not what happens; because the way the source code was written, the #define happened after four = X. So, anything that happens before the macros was defined is not changed.       Now, let us conclude this discussion of preprocessor with a very typical project management problem. And we will see a third macro, that is, third operation that is done by the C preprocessor. This is something called # ifndef. This is used typically when you have multiple files in your project and you need to include multiple header files into a single a source file.  So, let us discuss what is the problem with the particular example? Suppose, we have a list.h and the list.c So, I have this header file list.h. Now, I have a program p1.c; that needs the list functions and also creates a bunch of new functions. So, its declarations will be included in p1.h. Now in p1.h, I would say include list.h. So, this is okay. I will have a corresponding p1.c, which will we just say include p1.h. Now, suppose that I have another file p2.c; the p2.c needs some functions in list.h and some functions n should p1.h. So now, there, when I write p2.h, I will say include p1.h and include list.h. Now, what happens is that when we compile p2.c, list.h gets included twice. First, because it indirectly includes list.h, and second because it includes p1.h which itself includes list.h. So, list.h code will be a copy, pasted twice in p2.h.  So, for example, this is the problem, because if list.h contains a structure definition, it will be included twice and the compiler will produce an error. So, this is the standard problem in large projects; where you want to include a file, but you do not want to include it multiple times. So, in this particular example I want to improve list.h, but I want to avoid the possibility that list.h is included multiple times leading to compiler errors.  So, how do we solve this? So, this is a facility provided by the C preprocessor. You can say you can use this #ifndef. So, it is saying that if this macro is not defined, then do something. So in list.h, I will write the following: #ifndef. This is a macro that I will define. So, usually if a file is list.h the macro will be named in capital letters; LIST_H. If this macro is not defined, then #define list.h. So, this says define list.h from me and then all the remaining statements in list.h. And then it will be enclosed in an end if.   So, now, what happens is that suppose list.h is included for the first time in p1.h, then list.h is not defined. So, it will define list.h and then include list.h in p1.h. Now, p2.h includes p1.h and list.h. So, now when list.h is included for the second time, the C preprocessor will look at this statement; ifndef LIST_H. That has been defined because p 2 p1.h has already defined. It calls it to be defined. So, it says that LIST_H is defined, so I will skip the entire thing until ifndef. So, this is one way to say that. So, if LIST_H macro is not defined as yet, then define it and process all statements until the matching ifndef. If it is already defined, this happens when you are trying to include it for the second time, then all statements until the ifndef are skipped. So, you do not copy, paste it for the second time. So, this is the standard way to avoid including one file multiple types.  So, the high level picture of the stages in compilation. You have; we take up. So, the high level picture of the stages in compilation. You have source files and then it run through this preprocessor, it produces the transformed files. And then after compilation using gcc -c, it produces object files. And after the object files are done, they are linked to produce the executable files. So when you press gcc, some source file, internally it first runs the C preprocessor, then it runs the compiler and then it is runs the linker. And gcc provides facilities to stop the compilation at any stage. And so for example, we have seen in the previous video that you can stop the compilation just after the compilation itself by using gcc -c. So, it will produce .o files. And several .o files can be later linked to produce the a.out file. In this video will talk about how pre increment, post increment and operators like that work in c. So, will first introduce the notion of side effects. Now, we have earlier seen that any expression in c yields a certain values. So, let us look at a particular example, if you have integer variables i and j, i is assigned to 1 and then, you say that j is assigned to i plus 1. What happens is that, you take the value of i add 1 to it and then result of the expression i plus 1. So, the result of the expression will be 2, which is assigned to j. The value of i itself is un change due to an expression like i plus 1 is just that you read the value of a use it and then, return the value of i plus 1. Now, some expressions in c also change the variables involved in them. For example, if you have a code like int i. Let us say i is initialized to 1 int j and then, you say j equal to plus plus i. In this case what happens is that, you take the value of i increment it. So, you will get i equal to 2 and then, that incremented value is then assign to j. So, evaluating the expression plus plus i has the side effect, that i becomes 2. So, it not only takes the value of i increments it by 1 and gives it to j, it also has the additional effect that i's value is incremented. So, contrast the first example and the second example, in the first example when you said i plus 1, the value of i was unchanged and in the second when you said plus plus i, the value of i is changed. So, this is known as a side effect, because in addition to returning the value it also changes the variable involved in plus plus i.  So, now, let us look at the operation in slightly more detail. So, when you say int i equal to 1 in j and then j equal to plus plus i. The effect of this plus plus i can be understood in terms of an equivalent code. So, what you do is, consider a code where you have i equal to i plus 1 and then assign j equal to i. So, in this case i will become 2 after i equal to i plus 1 and then j will be assigned the value 2. So, this is the effect of the pre increment operations.  Now, there is also the post increment operator. So, plus plus i is an example of an expression with the pre increment operation. And you can also use i plus plus, which is known as the post increment operation and confusing thing is how do we interrupt fairly complicated expressions like the following. So, suppose you have int i equal to 1 in j and then j equal to i plus plus plus plus plus i. So, what should we expect in this case is this allowed behavior what does it mean? What will be the result? Which is stored in j? So, let us look at these things in slightly greater detail.  So, first let us look at some simple examples and try to understand the behavior. So, suppose you have i equal to 1 and then two variables j and k and first you say int j equal to i plus plus. So, this is the post increment operator. So, what happens here is that, you take the value of i assign into j. So, that is i equal to 1, the current value of i will be assign to j and after the expression is over i will be incremented. So, then i will become 2. The old value of i is assigned to j and then the value of i will be incremented. So, it is the post increment operator. So, when you printf i and j here, i will be 2 and j will be 1. Because, old value of i was what was stored in j. Now, let us look at plus plus i. So, if you say k equal to plus plus i, i is now 2 when it is starts and you pre increment i. So, you increment i, i becomes 3 and that value is stored in k. So, it is the pre increment operator,. So, the value will be incremented before the assignment will take place. So, when you print i and k, i will be 3 and k will also be 3. So, notice the difference between the first case and the second case, the pre increment versus the post increment. Now, let us look at slightly more complicated examples. So, at this point what do we have? We have i equal to 3 and j equal to 1 at this point and then you say k equal to plus plus i plus j plus plus. So, take a minute and think about what will happen here, you pre increment i. So, the value of this expression, that is used to add will be 4. Because, the value of i will be incremented before it is used in the plus expression, where as this is the post increment expression. So, the old value of j will be used and then j will be incremented. So, here the value that will be used will be 4 and here the value that will be used will be the old value of j which is 1. So, k will be 4 plus 1 which is 5, i will be incremented. So, i becomes 4 and after this expression is over j will be incremented,. So, j becomes 2. So, when you print this you will say that i is 4, j is 2 and k is 5. So, understand why k is 5? Because, it is 4 plus 1 rather than 4 plus 2. So, this is fairly simple can be understood in terms of the pre increment and the post increment operator.  So, let us look at some code that is equivalent to the post increment operation. So, suppose you have j equal to i plus plus, you can think of it like the following, you can say that j is assign to i. So, the old value of i is assign to j and then, the value of i is increment i equal to i plus 1. If you want to use the compound assignment operation, then what you can do is j equal to i and i equal to i plus 1. So, this is equivalent to i plus equal to 1 is equivalent to i equal to i plus 1. So, contrast with the pre increment operation, there i equal to i plus 1 will be done before j equal to i, here j equal to i will be done before i equal to i plus 1. So, can we see that this is exactly how post increment works? And the answer is yes, in this particular case this is exactly how it works. But, if you want to understand the general case, we have to understand a slightly more advanced concept in c. And note that, this is not something that strictly false in to an introductory course. But, in case you want to understand exactly how it works, then we will look at the general case.  So, to understand the general case instead of writing a few examples and compiling it and saying, one way to do it would be to go to the c standard and say what is the standard say and here it is slightly surprising. So, the result of the postfixes operator is the value of the operands. So, this is the old value of the operand will be return, after the result is obtain, the value of the operand is incremented, this is what we saw in the last let. Now, when is the operand increment, we loosely said last time that after the expression is over then the value of i will be incremented. But, what is the precise point at which the value of i will be incremented, this is slightly surprising. So, the side effect of updating the stored value of the operand shall occur between the previous and the next sequence point. So, when you have an i plus plus operation, it will not be immediately updated, it will be updated only after a place known as the sequence point. So, let us just understand briefly what is mean by a sequence point. So, before we get into it let me emphasis, we are trying to understand. So, the post increment operation will say that, the old value of i will be used and the value of i will be incremented after the expression, we are time to precisely understand after what point can we say that i's value would have been incremented.  So, a sequence point has defined in the standard is a point in the code by which all pending side effects are ensured to be over. So, this is very technical definition and it is to be understood by compiler writers. But, we will briefly understand what does it mean? So, some prominent sequence points include end of full decelerators. So, for example, if I have a declaration int i equal to 0 comma j equal to 0, then a full decelerated gets over after i equal to 0. So, after i equal to 0 there is sequence point here. So, if there are any pending side effects, then it will be incremented at this point, this is another full decelerator. So, it will after that again any pending side effects will be ensured to be done. Then, the surprising think is suppose you have full expressions. So, suppose you have like i plus plus plus 3. So, the major think to understand will be when is this i plus plus suppose to happen, will it happen immediately after i plus plus and the think is then the c standard does not say that, that has to happen. The c standard says that, the next sequence point is the semicolon. So, when you see the semicolon operation, you will know that, this hole think is what is known as a full expression j equal to i plus plus plus 3. So, that is known as a full expression. So, after you encounter a full expression any pending side effects. So, this is the pending side effect, that will be updated. So, only at that point c standard says that, by now you should have updated the i plus plus operation. Before that the compiler is free to do what it works, it may or may not updated. So, this is actually slightly confusing and contrary to the popular understanding of when should i plus plus have to again the general cases slightly confusing, it is not what would expect, it just says that by the next sequence point in the code, all pending side effects should be take in place. Now, it does in say that exactly at the end of the sequence point, you will update all side effects, compilers of free to do what it wants, all it says is that by the time you need the next sequence point pending side effect should take place in whatever all. So, this is slightly technical. Now, for a full stand list of course,, you have to refer to the c set standard, which is not really recommended I mean,, but it is just that if you want to understand that, then you can look at the standard.  So, let us try to understand the post increment operation. So, int's again slightly greater detail. So, if you say that k equal to i plus plus plus j plus plus. Now, there are to ways to do it. Of course, k equal to i plus j, the old values of i and j are used and then, you calculate k assign in to k. And then, you can do i equal to i plus 1, j equal to j plus 1, because the standard says that by the time you see the full expression pending updates must be happen it. So, you can say that by the time you see the semicolon operation I will do i equal to i plus 1 and j equal to j plus 1. Now, if you think a minute you could also do update j first and then i. So, I know that by the time is see the semicolon pending update should happen,, but in what order should it happen is it i equal to i plus 1 first and j equal to j plus 1 next or is it the other way round. And the answer is that, the c standard does in say.  So, here is the second certlity in this whole business. So, if you say, what is the order of the side effects? There are certain operations, where the sequence is specified. For example, the function call the logical AND operator, the logical OR operator, the conditional operator and the comma operator. So, for very specific operators the sequence is specified. But, in all other operations the order of evaluation of sub expressions is unspecified. And similarly, the order of side effects is also unspecified. So, in the previous slide doing i equal to i plus 1 before j equal to j plus 1 is valid, as also j equal to j plus 1 and i equal to i plus 1. So, both these orders are valid and the c standard does not say that, what should really happen? So, what in practice you will notice is that, in one compiler a certain order may happen, in another compilers certain other order may happen. So, it is left to the compiler and you cannot assume anything about, what really happens? Which order it happens?  Further and here is the most important think as for as the sequence points are conserved. The c standard says that, an object or a variable can have it is stored value modified at most once by the evaluation of an expression between two sequence points, this is very important. So, between two sequence points, if a variable is to be updated by a side effect, then it should be updated at most once. Beyond that, if it is updated multiple times, the c standard says that the result is actually unspecified. So, let us look at a few specific examples to see, what is actually happening here? So, let us take the first expression j equal to i plus plus plus i plus plus. So, we know that, here is a sequence point and we know that, here is a sequence point. These are full expressions between these two sequence points, the value of i is updated more than once. Here is i plus plus plus i plus plus and the c standard says that, the behavior is unspecified, this is somewhat surprising. Because, you may try it out multiple times and you will see that consistently some behavior is happening. But, what the c standard says is that, if you take the code and compile it with a different compiler, the result may be different. So, the result of this expression is actually unspecified. Similarly, let us look at the next example. So, here the sequence point is a full expression, let us look at the next expression. So, i plus plus plus plus plus i. So, post increment and then pre increment. Again even in this case, the result is unspecified, because these two are the sequence points here between this full expression and between these full expressions. So, you have two sequence points and between these two sequence points, the value of i is updated more than once. So, the result is unspecified according to the c standard. Let us look at this interesting example, j equal to j plus plus. Again result is unspecified, because you can have these two sequence points and between these, the value of j is updated twice. First, by the post increment operator and then by the assignment operator. So, the value of j is updated more than once, the result is unspecified. The last expression, it is interesting. So, if you look at the two sequence points here, you have one full expression here, another full expression here. Between these, the value of i is updated only once, here and the value of j is updated only once, here. So, it is not that the value of i is updated more than once,. So, the value of j is updated more than once. But here, it say which of these sub expressions happened first? Is it i plus plus that happens first or i plus 1 that happens first. So, according to the c standard that is actually unspecified. So, the order of evaluation of the sub expressions is unspecified, according to the c standard. So, let us just go back to that and this is, what it says, the order of evaluation of sub expressions is also unspecified. So, if you look at this expression j equal to i plus plus plus i plus 1, it is not clear which happens first, i plus plus or it is i plus 1, that is also unspecified. So, here are the sequence points which end at full expression and the specific case of the last example, it is not that values of variables are updated more than once. It is just that the sub expressions may be evaluated in whatever order, it may occur.  So, all this is slightly confusing. So, let us just summarize something that you can take away for, as per as programming is concerned. So, let us list out a few operators with side effects. So, let us say pre increment, post increment, pre decrement, post decrement all of these have side effects. In addition to returning the value, it also updates the variable. The assignment operator clearly has side effects. So, if you say j equal to i;; obviously, the value of i will be assigned to j and we have earlier seen that, as an operation it returns the value that was assigned. So, that has the side effect, because it updates j and also return the value, which is the value of j. We have also seen this compound assignments. So, you can say i plus equal to 1, which is the same as i equal to i plus 1 and j minus equal to 2, which is as same as j equal to j minus 2. So, all these operators have side effects. And the general advice is that, use operators with side effects with extreme caution. In general, if you use them make sure that a single full expression does not contain more than one sub expression with side effects. So, make sure that even if you want to use these expressions with side effects, make sure that one full expression contains at most one side effect. So, avoid expressions like i equal to i plus plus, as we have seen before, this has two updates on i. So, the result is unspecified i equal to j equal to 1. Well, here is a full expression that has two side effects, technically the result is you can predict what the result is,, but as a programming practice, please avoid these kind of expressions. Because, this is an expression that involves multiple updates and it is not really that the result is unspecified. Because, the updates are on different variables. But still, as a good coding practice avoid such expressions. So, let us look at the third example, you have x equal to y equal to 12 divided by y equal to 4. Again, it is not clear, which of the sub expressions y equal to 12 or y equal to 4, which will happen first? So, the result of this expression is very difficult to interpret. So, in general do not use full expressions that have more than one side effects, even if they are on the single variable. If it is multiple updates on a single variable, then the c standard clearly says that, the result is unspecified. But, even if they are on multiple variables, try to avoid writing such expressions. You can always write slightly longer code, where the meaning of the code will be perfectly clear and the result will be completely specified. Thank you.


Good morning, welcome to the course of Problem solving through programming in C.

This is a course of programming no doubt about it the first course on programming for
many of you, but also the focus of the course is to show you how we can carry out
problem solving; that means, solving different problems using programming. We
encounter a different types of problems all the times in our life and some of them can be
solved using programming, why I am saying that some of them can be solved not all can
be solved there is a reason for that we will come to that later, also there is another thing
in the bracket you can see that we will be discussing programming in C.
Now, C why I have put it in the bracket the reason is the C is just one of the means one
of the languages using which we can do programming, there are different other
languages like as many of you know Java, C plus plus and others using which we can
also do programming. Now our objective is to not to just think about the c programming
language, but also some programming principles, some programming logic, some
programming methods that are adopted while solving problems all right.

Now, let us think of some of the problems that we often encountered in our regular life,
let us start with a very simple problem of there is there is a large volume of data large
volume of data maybe integer or may be numbers different types of numbers.

And we have to find the mean of that and mean of that many of you know mean is
nothing, but the same as average. Now how do you find out the average of a large
volume of numbers now all of you know how that is done, that is a relatively simpler
problem. We can also have, this is this has got some standard formula if you have got 4
numbers say x y z p you add them and divide them by 4 that is how we find out the
average right.
Now, also for n numbers if thereby n numbers then we can write it as sigma x i by n what
does this mean, this means I am taking what is xi, xi is each numbers, x1 is one number,
x2 is another number, x3 is another number in that we are up to xn. Now each of these
numbers any of these numbers I can represent with xi and by replacing different values
of i, I can get any of these numbers. So, sum of all these numbers sum of all these
numbers can be designated as x sigma of xi this sigma means summation and, I do the
summation of this and divide by n when it was 4 number I divide it with 4 here since
there are n numbers I divide it with n.
This is a very well known mathematical formula mathematical approach that all of us the
school children will, Now, therefore, we can very easily translate this problem and solve

this problem into programming, we will see how we can translate it to programming also
we will also discuss why we should translate it to programming all right. Let us take a let
it I mean a little different problem suppose there is a text all right there is a text of 20
sentences all right.

We will have a text of 20 sentences all sentences are here and I say that find out how
many times the word human occurs in this text, this is my text and I want to see how
many times the word human occurs in this text also the problem can be much more
complicated.
This is another type of problem where I have to look every word and see is it a human no
is it a human yes. So, accordingly I will have to go on counting all right now I can also
say that how many times does, the word pair human being appear in this text, so that is
can also be, I get human, but I do not get being after that, I do not count it all right. If it
be human followed by being then I count it once in that way I can formulate different
steps by which I can solve this problem. If you just spread your imagination you can
think of making the problem even complicated for example, human being and man,
woman, child, boy, girl, parent, teacher etcetera all of them are human beings.
Now, if the problem is posed in a way that find out how many times earlier what the
problem was earlier the problem was how many times the word pair human being
appeared as it is. Now if I modify the problem statement and say that find out how many

times human being has been referred to in this text; that means, if it be a man then also it
is a human being, if it be a woman then also it is a human being, if it be a child then also
it is a human being, if it be a grand grandparent it is also human being, In that case the
problem becomes a little more difficult little more difficult than the previous version of it
where we wanted to just find out the word pair human being this is an example of a
second problem and third problem.
The third problem is a little more complicated as you can see, we can go on adding
examples of problems let us take another one suppose you have got a fixed amount of
money.

All right whatever that amount is suppose you have got 1000 rupees and you have got
you have been asked to buy some items may be rice, wheat, sugar, vegetables etcetera
and each of them have got a price rice may be rupees 50, wheat may be rupees 30, sugar
may be rupees 70 and vegetables depending on the variety there are different prices all
right.
Now, suppose you have been told that you have been given this amount of money and
you have to buy the maximum amount of rice possible the maximum amount of rice
possible. So, with 50 rupees you can have 20 kgs of rice, but there is a constraint, there is
a maximum amount of rice you have to buy, but you have to buy at least 5 kg of wheat,
at least 2 kg of sugar, at least some amount of vegetables. Now given this you can buy 5

kg of wheat, you can buy 6 kg of wheat, 7 kg of wheat, you can buy 2 kg of sugar or 3 kg
of sugar etcetera you can do many things, but you have to see that how you will
distribute this so, that even after satisfying these requirements you can find you can buy
the maximum amount of rice.
There is another problem when you go to the market I mean in such a thing is always
told or we have got in mind that we have to cover these items and there is a fixed there is
a cost for that and we have to satisfy the cost. This is another type of problem we can see
this is an maximization problem or in problem solving terminology we also sometimes
call similar problems as optimization problems; that means, I want to maximize the
amount of rice that I want to buy, but these are the constraints that I have to satisfy right.
So, I have to satisfy these constraints after satisfying these constraints, how can I
maximize this, this is another type of problem relatively much simpler maximization or
optimization problem.
Let us now move to another type of problem say I have got a number of places let us
name the places A B C D E.

Now, suppose these are, suppose some cities and we have got direct paths among some
cities and there is no direct path among some cities all right suppose this is the scenario.
So, I can directly reach from A to C, but I cannot directly reach from A to D I can
directly reach from B to E, but I cannot directly reach from B to C like that moreover

along with each of these paths we have got some cost associated the amount of money
the amount of expense that we will have to bear in order to make this travel possible,
suppose this traveling B to E I have got a different options say for taxi first I put the taxi
thing first, then I put the cost by bus and then I put the cost by train now suppose from B
to E I can go by bus taxi and train both.
So, suppose by bus it is 10 rupees and train it is 20 rupees and also of course, there can
be I mean according to the mode of transport that I take the time taken will also be
different, say from D to E I can go by taxi and that will cost me 30 rupees and by bus it
will cost me 5 rupees and there is no train between these 2 all right, there is no train no I
put it null here. So, A to B suppose I have got taxi of course, 30 rupees bus may be here
in this route it is a little expensive 7 and there is no train here, A to C I have got 20
rupees by train, 4 rupees by bus and there is no train, here C to D there is 50 rupees,
again 8 and by train it is say 10 rupees.
This is the picture now I am here and I have to reach this point from A to E now I can go
via A to C, C to D, D to E or I can travel A to B, B to E right, if I come by from A to E
by taxi then it will be 30 plus 50, 80 rupees required, if I come via this path it will be 20
plus 50, 70 plus 30, 100 rupees required, but if I come here by train there is no train. So,
so I cannot come between these 2 by train if I come by bus 4 rupees and now by train 10
rupees 14 and here there is no train I cannot do that right, I cannot take train from here.
I will have to take again bus from here, in that way I have to solve the problem of how to
reach from one city to another with some constraints now these constraints are coming
every time and this constraints actually generate the fun in this what are the constraints
that we can have in this problem the constraints it will be satisfying the time how fast I
can move I have not shown the time information here that time information should also
be kept here for example, from B to E by a taxi it takes 50 rupees and say takes 20
minutes and by bus 10 rupees, but it takes 40 minutes and by train is 20 rupees, but it
takes 10 minutes like that.
So, if the time information is also there I may be asked to minimize the time and also
what is shown here this is cost, I have got the cost and the time, I may like to minimize
the cost also. I may be asked that I am not much bothered about time I am relaxed it is a
weekend I can devote time, let me try to minimize the cost then the problem will have

one color right one form. If I just say that well now I am little pressed with time, I will be
selecting a vehicle or selecting a mode of transport I do not mind the cost, but I have to
minimize the time then the problem is something different also it may be that I am with
the total time spent between a less than one hour less than one hour even this constraint
minimize the cost, in that way different forms of this same problem can be put forward
and often we have to solve such problems in our real life.
Let me, that is the best way to reach a place right this is how we can find a best way to
reach a place.
Now, I come to another interesting problem, this problem that was there it is a again an
optimization problem again you could see now say let us take another example.

Although I am showing it as a game it can act as a model for many real life scenarios.
This is a maze and I am here and I have to reach say here, this is my source, this is my
destination and from here I can either from any place each of them are places from any
of these places I have got 3 moves, either I can have an up move, I can have a down
move, I can have a diagonal move all right.
So, for example, from here I can with a diagonal move I can come here with an up move
I can come here I cannot apply a down move now this up and down moves are allowed
only if there is no bar or there are other moves also I can move left or I can move right. I

cannot move diagonally down suppose these are the moves that I have and any of these
moves can be applied only if the corresponding destination place is not bared or if the
destination place is free for example, if this place is bared and say this place is bared then
from this point source I cannot apply the diagonal move why because this place is not
free.
Suppose I apply the up move, I can I will go from here to here now I am here at this
point I have what are the moves that are applicable left move cannot be applied this
cannot be applied this is out of question, up move cannot be done down move I can do
you see down move I can do I can come back alright and diagonal move is possible
suppose I come to I find if I apply the down move I come here then; obviously, if I again
apply this move then I will be just doing these 2 repeatedly and I will not progress any
further may be once I come back here because of some thought I can apply this move all
right.
Let us see once again let us start suppose I was here now apply a up move, then I can
apply a diagonal move and then I can move a horizontal move, another horizontal move
1 2 3 4 assuming that all these moves are having the same cost, same effort all right then
with 1 2 3 4 moves I can reach my destination. Let us see if I had instead of going up if I
had taken this move 1 because I could not go diagonally then I move diagonally 2 then
with 3 moves I can reach the destination assuming that the costs are same then this is a
better move.
If the costs that is scenario becomes a little more complex when each of these moves I
have got different costs it is I have to pay more or I have to put in more effort for moving
from this point to this point, from this point to this point in a diagonal manner is much
more easier to move in a horizontal manner all right. This is another type then the
problem would have been little more complex right in that case suppose the diagonal
move will costs you 5 and all other moves cost you 2, then what would be the cost in this
2 5 7 8 9 10 11.
In this path let us do it again 2 because up is 2, 5 because diagonal is 5, 7 8 9 10 11 units
if I have done in this way 2 5 7 and 5 12. So, in that case this is becoming costlier, but;
obviously, if the diagonal move was 4 and not 5 then what would have happen let us see

2 4 6 7 8 9 10 and if I do it in this way what it would be 2 4 and 2 6 and 4 10 in that case
both of them would be equal.
This is another problem where again you can see that we are trying to look at the cost
and solve a problem, this you can think of a path finding problem or a search problem
what are we searching here I am calling it we are search problem. So, what are we
searching here, we are searching for the path through which we can move we can reach
the objective, now this is a very simple example of the type of problems that we solve in
artificial intelligence, say a robot has been asked to move from this point to this point
how the robot will find it is way given some obstacles.
So, this is another type of problem that we can solve using programming now having
said that is it that all the problems that are there in the world can we solve them by
programming when you say problem solving we are not actually meaning to address all
possible problem solve the problems that are in the world we are not saying that all of
them can be solved by programming for example, the problem of hunger cannot be
directly solved by programming some person is feeling depressed he is feeling sad that is
a problem we are not addressing that sort of problem here.
So, when we say problem solving through programming then we are talking of not all
kinds of problems, but certain categories of problems, that is that will be discussing in
the next module what are the problems that can be solved by programming and we will
progress further.
Thank you for this module.

So we move to the next module of this course.

In the earlier module we have seen some example problems, and the problems which can
be some example problems which can be solved through programming using computers.
And also we said that all problems cannot be solved by computers. So, what are the
problems that can be solved using computers? That is a natural question that can be
asked. The answer to that is that, if it is known what are the steps that we must execute or
perform in order to arrive at the desired result then we can solve it by programming.
Now, those steps may be directly known for example, in the case of finding the average
marks in the class for n students, we know the steps right. So, let us see if we write down
the steps following which we can solve this problem, how would it look like?

I want to read one number, suppose I am reading phone numbers, I want to find out the
average of phone numbers, I want to find out the average of phone numbers read. Read
means I just know get I can also say get first number, 2 get second number suppose you
want to find for 3 numbers; get third number add the numbers; that means, first number
plus second number plus third number and let that be the sum and then I say divide sum
is this sum by the number of numbers and what is the number of numbers? Number of
numbers here is 3, because there are 3 numbers and then say announce result.
So, this one divide the sum by numbers. So, that is something like say something like
this that result is equal to sum divided by 3 in this case right and announce result. So,
these 3 these steps are very well known, very clear and since these are very clear. So, I
can solve them by programming. Why because programming what is programming?
Programming is informing a computer as how to solve a particular problem. So, I can say
let me just do it a fresh.

Programming is nothing but, letting the computer know how to solve a problem.
Now, there are some important aspects to this sentence this phrase. Letting the computer
know is one important thing, but what do you let the computer know? How to solve a
problem? So, how to means I have to tell the computer, that what are the steps to be
followed to solve a problem. I have to be very clear about it and I have to let the
computer know. So, there is a big problem here how I let the computer know I will come
to that later.
The steps to be followed are what we have to tell the computer. So, in the earlier
example we just saw that the steps for finding the mean of 3 numbers are very clearly
stated, and I can inform the computer often this is informing the computer is also known
as instructing the machine. The machine is nothing but the computer itself and these are
the computer instructions. A programme therefore, consists of a number of instructions
to be executed. Now the example that we saw was for adding there numbers now we will
soon see that the thing becomes a little more complex if I wrote get first number, get
second number, get third number suppose there are 20 numbers, then I will have to write
them 20 times get first number, get second number, get third number like that upto get
twentieth number that is boring is not it.

So, instead I can possibly write that for 20 numbers let me do it in a let me do a number
here for 20 numbers repeatedly get number, aright that is possible.
So, for 20 numbers I will be getting the numbers. So, I do not need to write down one get
first number 2 get second number 3 get third number not like that, I can straight away
with one instruction I can express myself, but whether this will be understood by the
computer or not is a different question. So, I am keeping that question open. Understood
by machine and whenever I talk about machine, I mean a computer. So, for 20 numbers
get number, in that way I can say that or say I could have written that in a little more
smatter form let us let me try to do that.
Now, if I do that then what would be the next one? I have not I have to add those 20
numbers. So, one thing is that again I can write here add number 1 number 2 number 3
upto number 20, then divide sum by 20 this is one way of saying that, but this is again
boring right this is very boring, I mean it is not interesting to look at this why should I
write this in this dot dot dot dot form instead say I can write it in a smatter form say I
write it in this way and you.
Just see whether you can understand what I am writing for 20 numbers, I am using my
own language, it is not a computers language, it is an English and it is a version my
version of English. I just need to express it to you and then whether that will be
understood by the computer or not is a different question and we will address it
separately ok.
For 20 numbers get number sorry I say repeat get number or let me add the number with
the current sum; that means, presently whatever is the value of sum, I add that number
that I read with that. Now initially therefore, what should be the current sum? Initially
when I am starting the current the sum is 0. So, I can say let us sum be 0 initially. Now I
get a number at the number to the current sum and this repeat I am just using my.
So, just showing as if it is a bracket, that this part I am repeating I am repeating this part
how many times I am repeating this part? This part I am repeating, how many times I am
repeating? 20 times because for 20 numbers I am getting the number adding the number
getting the number, adding the number and I am going on doing this and adding the
number and I am keeping that number in sum. So, ultimately I do it 20 times and then
this part is finished then what I have to do. So, this was step 1, this was step 2 this was
step 3. So, this step 3 was repeated 20 times I am sorry let us make it sorry actually this
is the second step, which I did 20 times and after that I have got the all those numbers
added.

So, next I come and I say result is sum divided by 20. So, that will be my result and then
I can announce the result frame the result whatever. So, here you see in the earlier
example what I did is, read first number, read second number, read third number read
forth number like that here I just expect do it in a smatter way that for 20 numbers do this
activity repeatedly 20 times. So, that is another way I can express it. And that shows that
I can specify very clear steps by which the problem can be solved and since I can specify
the steps clear steps through which the problem can be solved, this problem can be
solved by programming. I can programme a machine to solve this problem.
So, similarly say how many times the second problem that we had looked at, how many
times a particular word human occurs in a particular text. So, I have to do something like
this, I have to open the texts I have to see look at the text and read a word and see is it
human? No, is it human; no is it human yes. So, I will have to have some sort of counter
or a count, which I will increase every time I am sorry every time, I encounter the word
human.

And this will go on as many times for every word in the text. So, I can write that down as
for every word in the text if the word is human increment count. So, this will go on only
if the word is human I will increment the count otherwise I will go on reading the words.
So, this is the very clear step which I can express to the computer in its own way. So,
that it can find out how many times the word human has occurred.

Now, there are other different variants of this that I have told you that, whether its a
human being or whether it is an equivalent man, a woman boy girl whether it refers to a
human being or not then; obviously, the instruction will be a little more complicated than
this in these way. So, I once again come back to my state when that, what are the
problems that I can solve using a computer? I can solve the problems where I can
enunciate, I can express the clear steps set of steps one after another by which I can solve
the problem correctly.
So, that is now for example, now if we take the example of that searching in a maze,
where I was trying to use the diagonal up down whichever, there also I can express some
intelligent ways by which I can instruct the computer to approach the problem. But
everything as I said do not render themselves, to such enunciation of very clear steps I do
not really know. I really do not know exactly that may be either the problem is not well
understood, I mean a student of friend of yours is feeling depressed is not feeling well
now there may be you really do not know exactly what is the reason for that. If you know
the reason then you can try to solve it help him out.
Now, when the problem is not well understood then of course, we cannot solve it in such
clear through such clear steps. If the information that you have you are getting all are not
very reliable then also there are ways and means by which we can think of how we can
get a good enough solution. Another thing is that there are some things which we do not
know. So, we cannot solve that using programming or may be some cases where. So, the
problem is so complicated for example, solving the problem of hunger all. Right now
obviously, if you say buy food give food by that hunger will be solved, now that is too
simplistic solution and that is not a realistic solution there are many angles many
interacting variables, which are working towards that. So, that is not directly amenable to
solving using programming.
So; however, we are been able to give an idea of the category of problems, which can be
attempted to be solved by programming. And I have also said what is programming once
again programming is the set of instructions.

I am rewriting it in different way, set of instructions to be provided to a computer to
solve a problem. Now a computer is an electronic machine, till now what I was doing I
was writing the set of the statements in the form of somehow like English. So, you could
understand that, but the computer being an electronic machine will not be able to
understand that. An electronic machine is made of switches. So, since it is made of
switches it will understand only it understands only zeros and ones.
So, whatever I say get number, now each of these get a number is one simple instruction
or you can always understand this you can all of you can understand this, but for a
computer I will have to somehow write it in the form of some zeros and ones. So, may be
something like this 000 111 00 suppose this is representing get. A number can be this
anyway be are that number can be say 111 000 101 something of that. So, that is the
completely different type of expressions alphabets. So, the way we are writing it here
cannot be directly understood by the computer. I think in the last lecture I had mentioned
that how to let the computer know the steps.
Now, if I want to let somebody know of I want to express myself to somebody, I must do
it in the form of a language that he or she understands for example, whenever I am
talking to French person, I will have to talk in French otherwise he will not understand if
he does not know other languages right. Similarly if I encounter an alien for example, I
will have to talk in his language or I will not understand his language. Therefore, but

how do you do that if I meet a person who does not understand my language, some the
natural solution is that will have somebody who will be acting as an interpreter, who
understands both my language and the other parties language. So, we can understand my
language and convert it to the other language.
So, what is the other parties language. So, what are the parties here let us see.

On one side it is we who want to do something, on the other side we have got this
machine called computer, alright this machine which is lying in front of you.
Student: 
Now, I have to communicate with this machine and this machine will have to
communicate to me. And this communication, but this understands its word consists of
zeros and ones and my word consists of a b c d’s, and with that I can say apple, but this
apple to this machine is 0 1 0 1 0 0 0 1 something like that. So, I will not understand this
to be apple and he will not understand this to be apple. So, there we need some sort of
mechanism that is this is that translator some sort of translation is required to. So, we
will be talking about this translation process in the next class, but before that let us
summarize what we you have learnt till now. We have seen that there are problems
which can be solved by computers and there are problems which cannot be solved by
computers.

The problems which can be solved by computers have we have to in order to solve them;
we have to express the specific steps to be followed for solving that particular problem.
We have to express that to the machine we have to express that to the machine in its own
language somehow we have to express it in its own language and this specific steps.

The steps that to be followed to solve a problem, this is also known as algorithm:
algorithm consists of the specific steps or the methods that have to be followed in order
to solve a problem. In the next lecture will see how we can express these algorithms.
Student: 
How can we express the algorithms, that is what will do in the next mo next module next
lecture; how can we express algorithms there are different ways, even I mean when I say
how can we express algorithms not to the computer, but maybe I want to communicate
an algorithm to you or you want to communicate an algorithm to me, I was showing
some examples in which I was writing in English. So, there are different ways of doing
that we will discuss that in the next class.
Thank you.
In the last lecture we had concluded with a term called Algorithm.

And we said that an algorithm means a sequence of steps that are followed to solve a
problem; to be followed to solve a problem. Now the question is that how do we express
an algorithm, how do we express the sequence of steps how do we express, that there can
be different ways of expressing it right. So, usually ultimately we will have to write a
program for this.
So obviously, program is the final form of expression of the sequence of steps, that we
want to reach to, but even before that I mean a program is for communicating the
sequence of steps to a computer, but even for our human exchange, we may like to
express; what are the steps to be followed. There are 2 distinct ways by which an
algorithm can be expressed one is flowchart another is pseudocode.
Now, a flowchart as the name implies is a diagrammatic representation of the sequence
of steps it is a diagram. And pseudocode on the other hand is an English like English or

whatever in human language English like not exactly English, we can take a lot of liberty
we will see how to when I express the sequence of steps, English like language to
express the sequence of steps. Now we will show both the flowchart and pseudocode
with respect to some of the problems that we had discussed earlier.

So, let us start with this finding the average of 3 numbers. This is the simplest possible
way simple simplest possible problem that we can solve. So, we will start with the first
we will start with the start node, we are trying to draw flowchart. So, once we draw this
start. Then next will be sum assign 0. Now what all of us know that in order to find the
average of any number set of numbers, we have to first add those numbers. So, the
addition result is stated as sum. So, here we are when there is no number that has been
we have already taken into account, we initialize the sum to be 0. So, right now sum is 0
right next what we do is we read the first number read number one.
Now, what does this read mean? Read means who is reading whom do you want to read;
who ever who ever will be finding the average he or she will have to read the number. If
I ask a human being to do that the human being will have to know the number. So, if I
show that number on a piece of paper writing 5, he will read that number 5 and will say.
So, 5 is the first number then I show the second number 7, 7 is a second number in that
way that is the significance that is the meaning of this read.

Now, in our case ultimately the computer will read it, and earlier we had talked about um
the input often we had discussed about this, this is also known as an input mechanism.
So, it is reading the number, now here I would like to state a few things that is.

Say a flowchart has got some basic fundamental elements, this one you have already
seen that is a start symbol.
Student:
Now this figure is known as oblong.
Student:
This figure is a rectangle. Now this oblong is actually used for input and output power I
mean specification wherever I need to do some input or the system provides me some
output let me explain. So, input I have already explained that when I am writing some
number for you to read or for the; anybody will do the computation to read that is the
input. And you know all of you that we have got some input devices the most standard
input device is the keyboard using which we can put in the data. the output is after the
computation is done the system will or system will give me the output or if it be a human
being who is doing the computation, he or she will be telling me the output that is the
result. So, that is known as output.

So, while drawing a flowchart sometimes we will write read for this input, and maybe
print or write for output. Now this diagram is essentially the computation box. So,
whenever we do some computation, that we show in this sort of a box for example, we
can say x is p multiplied by q something like this. Or the other very important block is
the decision blocks block which looks like this a diamond now here what we do we just
take decisions depending on some conditions. Depending on some conditions I will
either take the left path or the right path. So, for example, I can say whether the age of a
boy is greater than 14.
Student:
If the age of the boy is not greater than 14 he is not allowed to go to a film. So, if it be
no, then he cannot go to see a particular film, and if it be 14 or greater; that means, it is
greater than 14, if it is yes then he can go to a film. So, we come to this particular point
and make a decision looking at this out of scenario. So, this is known as the decision
box.
Student:
Now, these are the basic 4 elements of any flowchart. Now, we will again come back to
our flow chart. So, you can see here that sum is 0 and the number that has been read is
the first number right. Now suppose that number that was read is 5; so some number. So,
next what I do is, I add that particular number with the sum. So, now, if the sum was
initially 0; so I add 5 with sum. So, if becomes the total sum becomes 5. So, next what
should I do after I computed the sum, then I read the second number because I have to
read 3 numbers and find the average. I read the second number and then I add the second
number with the sum the first number was 5.
So, the value of sum is now 5 I have read the second number suppose that was 8, then the
sum becomes 8 plus 5 that is 13. Now I come and read the third number suppose it is 3.
So, I read the third number and then I compute the sum. So, I have computed 3 the sum
to be 13 plus 3 16, next what do I do? I have to compute the average. So, what I do I find
the AVG is by AVG? I am depicting the average, average is sum divided by 3. So, it was
what was it 13 plus 3 16 divided by 3. So, it will be 5 point something. So, that result
whatever I get that I will be printing. So, that is a flowchart these are the steps that I have
to do.

Now the same thing I can express in the form of a pseudocode or English like language
let us see how it looks like. Here you just see what I have done, I have initialize I what I
wrote in the first step is this one is equivalent to this initialize the sum to 0 and then I
read the first number, sum is added sum equals sum plus number one exactly what I did
here read the second number then I sum equals sum plus number 2, and then I read the
third number and then sum is sum plus number 3.
So, these are the steps you see exactly if you just do not look at the left part of the whole
thing, if you just look at this right part you can also understand what are the steps
through which I must go and. So, ultimately I compute the average which is I just write.
So, it is English like compute AVG equal. So, it is not exactly English, it is English like
anybody who knows English will be able to understand this. So, this is known as the
pseudocode.
So, this is for the very simple problem that we are doing. Now suppose let us think off
for a second that suppose instead of 3 numbers I ask you to find the average of 10
numbers how would the flow chart look like? Obviously, this same thing that I have
done here read number 3 read number 4 read number 5 read number 6 in that way it will
go on and on and on, had it been 100 numbers there will be even larger.
Now, can we do something better in order to I do not have so much paper to waste. So,
can I write it can I express it in a much better way?

So, let us go to the next problem where we want to find the average of N numbers
average of N numbers I want to find out. So, the first thing will be again start that is from
where I am starting next is read the value of N. So, what is this value of N? Now if I say
this value of N when I read what is this N? This N is telling me how many numbers I
will be considering for finding the average is it 100 is it 1000 is it 10 whatever. So, I am
that is n.
So, I am reading the value of n, now I am initializing the sum to 0 again just as before I
initialize the sum to 0 and then I read now you see here I have written read number I
have not written read number one earlier since I had to only do number one 2 and 3 here,
there I wrote down number 1, number 2, number 3, here I am just writing read number,
because I do not know how many numbers I will be reading the reason will be very clear
soon.
So, next what do? I do I read the number the sum is sum plus number. So, I take the sum
was 0, I take the sum and at that number which number? The number that I just now read
say- I have just now read number 5. I have read just now I am sorry I just read number 5.
So, I read number 5 and I have added that number with sum. So, sum is now 5, next I
decrement this is a new thing that is coming up here. Since I know here at this point the
user or the whoever supplied the data told me that you have to look for 100 numbers say
N is 100 I have learnt that. Now, here I have read one number and I have taken care of
that number because I have added that with sum and. So, therefore, I now decrement that
value of N what does this signify? This signifies that I now since initially it was 100, I
have to read 99 more numbers 99 are yet to go.
Now, I have to check have I read all the numbers, what is the value of n? The value of a
N is 99; that means, N is not 0; that means, I have not been able to read all the numbers.
If I have since in a decision box as I have told you just a couple of minutes earlier that I
can have 2 options, I can either have yes or no answer if N is equal to 0 what does that
signify? If N is equal to 0 that signifies that I have read all the numbers I have already
read all the numbers, then I can compute the average as sum whatever sum I got divided
by N.
Otherwise if N is not equal to 0 then let us look at here if N is not equal to 0 no then I
will go back here again look at this part I will go back here again and read number. I read

that second number read and add it to sum I will go over here decrement. So, I have read
to number. Now, how many are yet go 98 N is 0 no, N is not 0 N is not 0. So, I go up
again I read another number add that particular number to the sum decrement N how
many to go 97 is it 0? No not yet 0.
So, I go on in this way I will go on in this way ultimately after I have read the hundredth
number this N will become 0. So, at that point I will come to this average and compute
the average as sum divided by [noise], and then I will print the average and stop. So, see
is just by this thing I am sorry just by this thing which is nothing but this is called the
loop this is called a loop and using this looping repetition I could reduce the length of the
flowchart the repetition of the flowchart in a very elegant way, I hope it is clear. So, the
same thing can be also reflected in the flowchart.
Now compared to the with the earlier flowchart, earlier statement here when I read it
only for 3 numbers, I read initialize sum to 0 read number one read number 2 and at
every point I was adding it to sum, here what I do is I write it in a little bit flexible way,
because when I write in a pseudocode I am not very constrained I can take the flexibility
as long as I can express myself its good enough I just wrote get the value of N earlier
probably I wrote read the value of N means the same thing.
So, get the value of N initialize sum to 0, and till now here I am talking of this looping
till N is as long as till means as long as N is greater than 0, it will better to say as long as
N is greater than 0, read a number at the number read the number that you have read to
sum you read a number add the number read to sum. And one thing I missed out here and
you decrement N you decrement N here you have to make N equal to N minus 1 in your
note you please take it down that here it will be N n minus 1. And so this till N as long as
N is greater than 0, I will be going on doing this after that I will compute average as
average divided by sum average is sum divided by N I am sorry and then I will print the
average. So, I can express it either in the form of a flowchart or in the form of a
pseudocode.
Now, let us take a; I mean it is not very visible here, finding the maximum of 3 numbers
that was another problem that we had discussed last time. What I am trying to do is I am
trying to find the maximum of 3 numbers. So, how can I go about doing the flow chart?

So, I start just 3 numbers not a large set of numbers, I first read the number one. Now tell
me one thing when you are first read one number; what is the maximum number.
Obviously, since you have read only one number that itself is a maximum only one. So,
it is a single ton. So, it is the maximum. Therefore, I say that max is nothing but the first
number, the number that I have read max is number 1.
Now, I read the second number I read the second number; now which one is the
maximum if the second number is greater than the first number, then the second number
will be the max. Now when I read the first number when I read the first number here, I
said that to be the max. Now, after reading the second number I can compare the second
number with respect to the max. If the second number is greater than the max, then what
will happen then number 2 will be the max. If it is yes the number to become the max
and if no; that means, what number 2 is not greater than the max then I skip this part. I
skip this part and go out by this way skipping this part; that means, at this point who is
the max; obviously, at this point I had number one, and number 1 is still the max I hope
its clear.
Next I read the third number, again I do the same thing after reading the third number is
the third number greater than what number 2 should I compare no. I should compare
with the max because till now between number 1 and number 2 whatever is the
maximum I have already remember that in max. So, I read the number 3 and then again

compare is number 3 greater than max, I can have yes or no. So, if it be yes then number
3 becomes the max because number 3 is greater than the maximum number till now.
And then I will proceed and if not if number 3 is not greater than max then I will. Then
obviously, whatever was the max till now, that is the number one that will remain the
max think of number 1 to be 5, number 2 to be 3 and number 3 to be 1 what will happen?
3. So, max is 3 sorry this was 5. So, I read 5 next I read 3 is 5 greater than 3 no. So, I
kept 5 as the maximum alright, I read number 3 that was 1, I compared is it greater than
the maximum which was 5 no then I print that 5 which is the maximum, but if suppose
number 3 was 7. So, it is greater than 5.
So, then I can go here and update this max to be number 3 or the 7, and then I come to
the print max part. So, this is a flowchart of finding the maximum of 3 numbers and
consequently you can see the pseudocode of this.

Start read first number, then I assign max to be the first number, then I read the second
number assigned. Now if number read is greater than max, then I will make the max to
be number 2. If the number read if the if its badly written read number it is wrong it if
number 2 is greater than max then make max number 2. Then read number 3 if number 3
is greater than max, then min make max number 3 otherwise you are continuing.

So, if number 2 is not greater than max then I am reading number 3 I am not doing this
part. This is another way of explaining the pseudocode. So, the same thing now we come
to another variety of this finding the maximum for N positive int N positive integers,
here I have taken a little liberty the finding the maximum of N positive integers, earlier I
was doing it for all numbers, but just as a change. So, let us see.

I read N again, N means the number of numbers that I want to read. Now I set max to 0
why do I set max to 0? Because I am trying to find the max of N positive integers, any
positive integers will be greater than or equal to greater than 0. So, I am putting that max
to the minimum value possible and then I am reading a number I read a number and if
that number is greater than max, which is by default 0 I have kept it as the bottom was
possibility. In all unless that number is 0 it will always be greater.
So, I will set that number to be the max, next again you remember what I did for finding
the average? I reduce the value of N. Suppose I had to do find the max of ten numbers.
So, N becomes now 9 and then I check. I have the max sorry this is a mistake here. This
arrow, this arrow should come from this point this arrow should come from this point.
So, I am just drawing it here I am drawing it here.

It should come like this. So, I have read a particular number and then if that particular
number is greater than max, I am sorry I read a number and if that number is greater than
max then I will if it is true, then I will make that number to be the max right max will be
that particular number, and then I check N I have already read N. So, is N 0 then I have
read one number and then I reduce N, just as I did in the earlier case and then I check any
N greater than 0. If yes then I have to go back and again read a number right read
number and this will go on as long as N is greater than 0. If N is greater than is not
greater than 0 no then I will come and print the max.
So, there was a little error in that diagram which you will be able. So, you can see that
this line should have come from here is N 0 yes then print max, otherwise this should
have come from this point this is wrong. So, in this way we can again find the max for N
numbers it is a flowchart. So, again I can have the pseudocode for this. So, a pseudocode
for this is shown here, read the value of N here initialize max to 0, till and till N is 0 read
the number if number is greater than max, max is equal to number decrement N, N is N
minus one and then it will be not one here it will be again print the max.
So, in that way you have seen examples of some intermediate representation of the
sequence of steps or the algorithms. We will encounter a number of algorithms in the
course of these lectures. And the Next step we will see what is to be done in order that
this sequence of steps can be transferred to a computer language so that; and can be

transferred to a computer so that computer can solve the problem, that we will see in the
next part.

So, in the last lecture we had seen how we can represent algorithms, and we had
mentioned particularly two different ways. One is flowchart which is a diagrammatic
way of representing the different steps, and also we saw English like form, which is
known as a pseudocode. It is not exactly why is it called a pseudocode, it is called a
pseudocode because it is not exactly the code that can run on the computer, but it is a
way close to that and by which you can express ourselves, and from which we can also
convert to the computer language.
Now, we had given a few examples of such flowcharts for a few problems. And I
strongly encourage you to take up more problems from text books or some mathematical
problems that you may encounter, and try to solve them; try to draw the flowchart of
those.

Now coming to the context of the books here are some of the suggested books, but I will
start from the end that is any book on C will serve your purpose. You can take any good
book on C language and try on that. And the number 1 that is C programming by

Kernighan and Ritchie is the most authentic book for C programming C language for that
matter and, but I suspect that for some of you may find it to be a little difficult therefore,
a middle path be a this second book programming with C by B.S Gottfried which is
Schaum’s outline series. So, and this second book has got a number of examples solved
examples and examples given as exercises. So, I think that would a good very good
starting point.
Now, having said that, what we have right now is we have some algorithm.

And from that algorithm, we want to come to a program. Now algorithm is a sequence
of steps that might be in our mind also. So, I know how exactly I want to do that, I and I
express it in some way and that is understandable. Now you know about 2 ways one is
the flowchart another is a pseudo code which expresses how what are the steps that a to
be taken. Now from this algorithm to a programmer program is a task of a programmer.
Programmer is a person who knows how to write programs.
So, from the algorithm to the program whatever language the program might be that has
to be translated. Now the key point to understand is that this algorithm I can express in
any particular way; however, that program must be written in a language that is
understood by a computer; alright language understood by a computer. So, a programmer
is essentially a person sitting here who is translating the algorithm or the steps as
expressed in some informal way in to a form, that is understood by the computer and this

language just like any other language we will have it is own vocabulary, we will have it
is own grammar.
Now, here comes the question what is the language that is understood by a computer.

Now in order to understand that, we have to look at what is there inside a computer; now
all of you many of you may be knowing it from your school days, but just it is a quick
revision of it is machine computer is nothing but a machine which can accept data
process them and output the results. Now there is an input device which can be a
keyboard. Nowadays it can be speech, microphone, it can be a joystick it can be many
things right mouse is also another one. And ultimately we have got the computer here
which consists of the CPU and the main memory and storage peripherals.
So, this is the actual part of the computer. Now the data comes over here, it is processed
here and the output is sent to the user. So, the user is on this side the user is also on this
side. So, this side is also the user and this side is also the user. Now there are couple of
important things to understand here, typically we tell the computer how a problem is to
be solved and that is the sequence of steps that we do, and whatever in sequence of steps
that is specify. Now whatever sequence we specify that is remembered by the computer
in it is memory. Now the memory can be actually it is stored in the secondary memory I
will come to that later. But the key point to think about is that this entire box is nothing
but an electronic machine and consequently it only understands 1’s and 0’s.

So, whatever we have to express; we have to express that using 1’s and 0’s.

So, this is the first thing a computer being an electrical machine understands only 1’s and
0’s, because it is an electric machine, it only understands whether a particular switch is
on or off right that is what it can at this understand. Therefore, whatever we have to
express we have to express it in the form of 1’s and 0’s. So, consequently say A B all
these alphabets small a everything will have to be represented in the form of 1’s and 0’s.
So, maybe A just hypothetically it is not to be taken to be accurate, I am just saying that
suppose 0 0 0 1, 0 0 1 0 is a pattern that represents A. So, similarly maybe 0 0 1 0, 0 0 1
0 this pattern represents b and may be 1 0 0 1 0 0 1 0 represents small a. In that way
everything will be represented into a pattern of 1’s and 0’s and might be knowing some
of you that each of these one and 0’s these are known as bits, bit stands for binary digit
binary digit.
So, bi for binary and bit that last t for this, binary digit from spades. So, it is a sequence
of bits. So, anything, anything is represented in a computer as a sequence of bits or we
often say bit pattern. Now just 1’s and 0’s gives rise to a new number system that is
known as the binary number system.

So, that leads to the binary number system might be some of you might be aware of this.
Binary number system where I have got only 2 elements, 0 and 1 I have to do. Now in
decimal visa we if I just consider that regularly we use decimal number system where we
have got from 0 to like that up to 9, and I whatever I express as a combination of this.
Now in binary number system everything is represented just by 0 and 1.
So, quickly let us look at; what are binary number system is, that suppose I have got a 4
bit number. So, there are four positions 1, 2, 3, 4 and suppose. So, con parallely let us
think of a four digit number. Remember that in decimal we call it digit and in binary we
call it bit right. So, if I have 7, 8, 3, 2; now all of you know what is the value of this
number each of this place have got a weight, which are known as play I mean weights of
the different places. So, this is 10 to the power 0, this is 10 to the power 1, this is 10 to
the power 2, this is 10 to the power 3. 0 weight, 1 weight, 2 weights, 3 weight. So, this
number is actually meaning 7 times 10 to the power 3 that is 7000, 8 times 10 to the
power 2 that is 800. 3 times 10 to the power 1 that means, 30, and 2 times 10 to the
power 0 that is 2 so that is giving us 7 8, 3, 2. It will be easier to understand this with this
analogy for example, here I have got something like 1 0 1 1.
Now unlike; so here also the weights are 0, 1, 2, 3 but the base here was 10. So, here it is
2 to the power 0 is binary here. So, is 2 to the power one 2 to the power 2, 2 to the power
3, here the base is 2 here the base was 10, that is why this is a binary system this is a

decimal system. So, if I have this pattern 1 0 1 1 then I can straightway convert it to an
equivalent decimal like what does this mean. So, I can take it there is a 1 here, 1 times 2
to the power 3 that is what 8, then 0 times 2 to the power 2 that is 0, 1 times 2 to the
power 1 that means, 2, 1 times 2 to the power 0 that is 1. So, the value of this will be 11.
So, this is the binary number system.
So, there are ways and means by which I can convert from a binary number system to a
decimal system, from a decimal system to a binary system that is possible right. So, if
you want to see that I do not want to go into that because many of you have done it in
school. So, let us leave it for the time being. But what is more important is to know that a
computer in a computer everything is represented in the binary system as a bit pattern of
1’s and 0’s. Since everything is expressed as binary number system. So, if I remember
the say we had something like this.

Let us not take max, let us take a sum equals sum number one.
Student:
This is something we saw in our earlier lecture something like that. Now this is a
statement how do I represent it to a computer. In order to represent this to a computer say
I want to say this is and you have to do some addition and some assign; some you have
to copy it somewhere and write it somewhere. Since or I just take this simple part add

sum with number, sum plus number how do I express that? Everything has to be
expressed say this number have will be some patterns say 0’s 1 0 1, 1 0 0 something of
that sort sum will be something 0 1 1 0 0 1 1 0 0 whatever and class will also have some
code 0 1 1 0 1 1 0 1 1 might be. Suppose this is add and suppose 0 1 1 1 0 0 1 1 1 is
subtract similarly there will be a similarly there will be some code of for multiplication
etcetera.
Now, since I am here, I am the user and I am also the programmer and here is my
computer and I have to translate my thoughts my algorithm in a way so that a computer
understands. I have to translate that algorithm or the flowchart into this pattern of 0’s and
1’s, because that is the only thing that it understands. The language that the computer
understands is known as the machine language. So, let me once again draw another
picture here.

So, here I have got my machine I have got a machine here nice looking machine and here
is the programmer. The programmer understands flowchart or the programmer
understands English like pseudocode, but this one only understands patterns of 0’s and
1’s. A pattern of 0’s and 1’s, and this is a language it understands and this programmer
understands the language of flowchart for example. Now, this patterns of 0’s and 1’s that
the machine understands, this is my machine M C is the machine. Now this machine

understands that language is known as the machine language, and that machine language
is not understood.
If some genius can understand remember all those patterns of 0’s and 1’s for every
possible combination, that is a different thing, but for normal people it is not it is very
tedious, it is not possible it is not advisable also. Therefore, earlier people had to for
small computers it was possible at the very beginning, people used to program the
computer by setting up different switches. And thereby, it was being programmed. But at
that time the operations and the capability of the computers say much more limited, but
once it became larger we are doing much more flexible programming and everything, it
is not no longer possible to remember the machine language.
So, what is the other alternative? The other alternative is the best alternative would be
that on this side I have got my normal language English and if I could directly translate
into machine language, but there are some problems with that because in English or any
natural language that we use, many things are often ambiguous. It is not very clear it can
have multiple meanings just I am giving an example go to the bank it is in English
statement.
Now, what does this word bank mean? It can be many things right it can be in the bank
where you deposit the money, it can mean the river bank etcetera. Therefore, English
language or any natural language is not the yet suitable to be translated to the machine
language. So, instead people thought if we could have some intermediate language. So,
once again I come here, I again draw the machine here, the machine is here and the
person is here.

So, on this side is my natural language like English, but which I am not being able to use.
So, people developed some intermediate language which is close to English, but the
grammar is much more stricter and we cannot allow any ambiguity no ambiguity. But it
is high level language because it is easier for us to remember, it is easier for us to
explain. For example, if I write this say X equal to P plus Q or I write read P now this is
meaningful, this is looks like English and I can understand this.
Now, given a high level language and on this side this machine can only understands
machine language. So, we need to have some translator which will convert this high
level language to the machine language, and this translator is known as the compiler.
Now think of the situation that here is a person say just forget about the computer high
level language, think of a person who knows French, and here is a person who knows
maybe English.
So, a compiler or an interpreter is something which is somebody, who will translate from
French to English right. So, here also depending on what language I am using as the high
level language, there will be different compilers. Examples of high level languages are C
which we will be discussing or taking as an example in our course; it can be Java, it can
be FORTRAN, it can be Python, alright. We can have many other languages that are
coming up nowadays other languages also coming up.

So, depending on the language high level language, in which we want to express our
algorithm we will have to select a suitable compiler. So, for C we will need a C
compiler, for Java will have to need a Java interpreter. The same thing the more or less
same thing that it will translate the basic function of this is translation. So, it will
translate from a high level language to the machine language. And as you had seen that
here all those things I will be binary, I mean in binary system in the pattern of 0’s and
1’s, I have to convert if this machine has to operate with my program this have to process
this my program I have to convert it into 0’s and 1’s.
So, now here is something more that we have to say. Now whenever we write a program
what we do here is we write some high level program.

And that high level program is taken up by a compiler, and is converted into a machine
language.
Now, here you have to be a little careful that depending on the different machines, you
can have pentium machine, you can have apple machine and other things. So, depending
on what machine you are using, you will you may need different compilers for that
particular machine. So, for the time being let us ignored that thing, let us assume that one
high level program can be translated by a compiler to a machine language. So, there is a
program right. So, remember what we did in our earlier cases, we had we said find the

maximum of 10 numbers, and the numbers were 3 10 7 12 5 6 so and so forth right 1 2 3
47 2 1 5. So, out of these I have to find out the maximum.
Now, through the flowchart or through the pseudocode what did we specify? We
specified the sequence of steps. So, those sequence of steps that have to be adopted in
order to find out the maximum of this is our program. And this program will be
converted to the machine language. Now this program will run on some data this
program is a program that can run on this set of data or another set of data say 5, 15, 16,
7 say for 4 data if I just run it for n number of things and here the N was 10. Remember
what we did earlier and here N is 4. The same programme should work on both of these
therefore, the program remains the same, but here is some data set and here is another
data set. So, we have got 2 different data sets.
So, in order to execute we need both the program and the data. Now when we start say
our program and the program when we start with the high level program.

I am writing H L L is the high level language, now this by the in the context of passing I
am saying this is also known as the source language. So, in my lecture often I will be
using this term source language. Source language means or I will say the I will not I will
not say source language, I will say source program. By source program I mean the
program that is written in the high level language that will be translated by a compiler to
a machine level language. Now when we now this is one side. So, the machine language

has been generated by the compiler. If my source language is C then I need a C compiler
here, and I will get the machine language. And this machine language is independent of
what the source language is, it is only dependent on the particular machine on which it is
running. So, the compiler we translate into that machines machine language.
Now, in my computer diagram we had the CPU here and we had memory. Now the
memory can be divided into 2 parts, one is the RAM and ROM some let me put it 3 parts
RAM and ROM are 2 types of memories, which all of relatively smaller capacity I think
this is not very clearly coming. So, let me write it clearly, RAM stands for random access
memory and ROM stands for read only memory.
Besides that we have got the secondary memory, which is the disc. Now the machine
language after compilation, when it is saved I save it and it is saved and stored in the
secondary memory in the disc. Now when that program will be RAM, I have done the
compilation and after compilation my program is ready to be executed is ready to run.
Now when I run it, can I select some plain color; sorry. So, when I run it from the
secondary memory it will go to the RAM and the CPU the program will move to the
RAM only when I execute it, and the CPU you will read that program from the RAM
and will execute it. So, this is a sequence you should remember I repeat once again. I
write the program and type in the program in the machine, after that I do the compilation
after compilation it is converted to the machine language and I save it. When I save it, it
is saved in the secondary memory.
Secondary memory is typically the disc; I save it in the secondary memory. But on
execution when I execute it, when I run the program then only it goes from the secondary
memory to the RAM and the CPU reads from the RAM and executes it. So, we will be
bothering about mostly this RAM and secondary memory, and how that is stored many
variables and all those things are stored well in the next lecture we will see how we can
gradually move towards encoding our pseudocode to the machine language to the high
level language. So, summarizing what we discussed in this lecture, it is that we have got
the pseudocode, but on the other side we have got a machine which does not understand
this pseudocode, the machine only understands the patterns of 0’s and 1’s.
So, we have to have something which will convert the pseudocode cannot be directly
converted because of lot of ambiguity. So, will have a high level language designed

which can be which is unambiguous, and which can be converted to the machine code by
another system that is a compiler. And that compiler is nothing but another more
sophisticated program, using which you can convert this and keep it over there take it in
the machine language. And the machine can then read that machine language program
and can execute it.
Now we have also seen that a program I mean if we have to run a program we need the
program as well as the data both this are stored in this memory part and from which the
CPU will be taking that. Sometimes the data can be fed directly from the input device at
runtime. So, whenever we say read n then from the input device somebody will type in
the value and that will come from to the CPU into the RAM. So, this part will see later
gradually.
Thank you very much.

In the earlier lecture we had seen that we start with an algorithm and convert that
algorithm into some sort of high level program.

We convert it to some high level program and that high level program is fed to a
compiler and the compiler prepares the machine level program. This machine level
program is fed is stored in the memory of the computer and from this memory stored in
the memory of the computer.
Now, from the memory the CPU execute set and we get the desired result that is the
overall flow of the whole thing. Now we will now come back to some of the statements
that we used in the earlier example programs will come back to that.

Say we had statements like SUM is equal to SUM plus number 1 right yesterday we
accounted we encountered such statements SUM equal to SUM plus number 1 now also
say for example, MAX assigned number 2 then the question is what are these things max
number all right or for example, if I write AREA is assigned 5.2, what is this area and
what is this 5.2 now this is some very fundamental concept that will be discussing today
these are known as the variables and these are known as the values.
Now, we must be very clear before we start translating or writing a program in any high
level language it is imperative to know very clearly what is a variable and what is a
value. So, today’s lecture will be devoted to explaining the difference between variables
and values and what is the significance of these variables.

Now, let us look at this diagram the memory can be considered to be a cvr number of
racks in a book rack sort of thing or you can think of a number of a drawers in the chest
of a drawers essentially is these are specific places as is being shown here, now each of
this place is known as a memory location all right.
Student: (Refer Time: 05:40).
Now, here you can see that each of these locations have been marked with a particular
address, these are the addresses and each address of every memory location. So, think of
a scenario that in a locality there are a number of houses each of this house is a location,
this is a location right, now I want to reach a particular house; that means, a particular
location, how can I identify where I should go for that we need some address. So,
similarly in the case of memory for every location there is an address, here we can we
are showing 1, 2, 3, 4, 5, 6, 7, 8, 9, actually there are more locations which have not been
shown.
We are showing N locations, N number of locations are being shown and each of these
have got some address there is a peculiarity here the reason of that will be clear later let
us for the time being accept that we are starting our journey with the number 0. The first
address is address 0 and, the Nth address will be address N minus 1 because the second
address will be address 1, the Nth address will be N minus 1.

Now recall that we had the scenario that we had the high level program.

High level program or if you remember we call it also the source code and from the
source code, the compiler converts them into a machine code machine language. Now in
my high level source code I have a statement like SUM equals 25 say now when I say
that SUM is equal to 25 the compiler will look at this and will assign these variable now
this SUM is a variable means what it is a variable because it can be loaded with different
values.
A variable can have different values for example, here I am making SUM equal to 25
after a while I can make SUM equal to 37 therefore, SUM is a variable and it can have
different values right.
So, say in a program in a program I have got here SUM equals to 25.

X equal to 56 and SUM equals to SUM plus X something of that sort, here how many
variables do you see and how many values do you see we find that sum is a variable and
X is a variable and these variables have been repeated here and what are the how many
values do you see 25 is a value, 56 is another value. Now when the compiler takes the
high level program and it looks at the compiler looks at all the variables and assigns or
allocates distinct locations to each variable for the sake of simplicity let us say that it
assigns distinct locations to each variables all right.
Sometimes advanced compilers also share variable share location, but that is not our
concern right, therefore, let us come back to the slide once again you can see.

If I have a number of variables when every variable is mapped to a particular memory
address for example, here if I write SUM equals 56, X equal to 27 and Y is equal to 3.5
the compiler will look at this piece of program and you will allocate and we will allocate
some location to each of these variables maybe SUM can be located allocated here, X is
allocated here, Y is allocated here say therefore, SUM can be identified now by the
computer or the CPU when it will run the program it can look at whenever a sum appears
in the program the compiler will convert it to the corresponding address of SUM. SUM
has got the address 3, X has got the address 6 and Y has got the address 7, therefore, this
thing is converted to a scenario where I am actually writing 56 into address 3.
So, as if 56 is being written here I will explain it later, X is being written here, 27 is
being written here and 3.5 is being written here all right because while the computer
executes the program it will take the data from the memory location only and the
memory locations it no longer understands whatever name you gave to this particular
variable, whether it is sum or any other name, but it is identified uniquely by the address
that the compiler has given it.
The compiler can depending on the availability of the memory locations allocated
different addresses to different variables once that is done there is a table for example,
there is a table like this a record that is kept that you can think of that we have got the

variables here the variable and the address. So, some table of that sort is prepared SUM
is address 3, X is address 5 and Y is address 7.
Now, the CPU whenever it, the program in the machine language is converted in terms
of these addresses this variables will no longer appear in the machine language, let us
look at this in a little more detail.

Now, suppose look at this instruction this is a program now one thing to mention here is
typically a program consists of a sequence of instructions that we know that one
instruction after another will be executed. So, this is usually done in a sequence where is
an exception from that sequence? We had seen in the flowcharts that whenever there is a
loop I am repeating an instruction time and again, we have seen when we are trying to
find the maximum of n numbers or average of n numbers we are repeating some
instructions time and again, in that case we will go back to the earlier instruction
otherwise one instruction is executed after another right.
As time passes we have got some instruction here not doing any meaningful computation
say just to illustrate X equals 10, now here is another point what does this equal mean all
right.

This is something that we should understand in our school we often do say X equal to Y
that means X, the value of X is equal to the value of Y. If X is 5, then Y is 5, but here
this symbol whenever we are using now is this symbol actually means assignment now
this is something which you should understand and this is fundamental to any
programming language that we will use. When I write X here I am writing X this symbol
Y I will read it as X is assigned Y what does it mean X is getting the value of Y.
Now often is therefore, in order to avoid this confusion we write it in this way that the
value of Y is assigned to X now here is something to really understand what is X, X is it
a value no, X is a variable therefore, X is a memory location the compiler has allocated
some memory location with a specific address, this X is nothing, but a memory location
with some distinct address is it readable, memory location with some distinct address
that is X and Y is also a memory location with distinct address, but this assignment
means it is getting the value that is in Y.
Let us think of like this that here is a memory location that has that is X. So, X when I
am writing X that is means that it is actually the address of X, that has been address of
this memory location and Y is also memory location and when I am writing Y this
variable name Y just for ease of our understanding otherwise I would have to write the
address here and the address in a computer system in machine language will be a string
of binary bits I mean a bits bit string, that will be really complicated. So, for the sake of

understanding we are just writing X and Y, but you must understand that this X or this Y
means the address of X and who has allocated the address of X or the address of Y the
compiler. Now when I am doing assignment this X is assigned the value of Y suppose Y
had 5 all right the value was 5 now this 5 is then written over here and this also becomes
5 this is the meaning of assignment it is not exactly meaning equal to Y essentially after
this what happened is the value of X is actual equal to the value of Y, but this sign
typically means assignment in order to show this equality we have got other symbols will
come across that later.
Let us move to this, here we are executing an instruction one instruction after another.
So, here in the first instruction we find that X has been assigned the value 10 is not say
once again let me come here.

This is this means X is assigned the value of Y if I write this X assigned 10 that means,
X is assigned the value 10 because here I had some value in Y whatever it is and that was
being transferred to X, but here it is not this side the right hand side is no longer a
variable, but a value right the right hand side is a value therefore, X is a memory
location.
For this example X is a memory location which is having the value 10 after execution of
this instruction this will be the situation in the memory after the execution of this
instruction right. Here let us now you will understand as I assign 10 to X and this is a

same memory location this is a memory location for X the same memory location see
how the picture is changing, here that memory location X is getting the value 10 on this
side I am showing the memory location allocated to the variable X. So, 10 next step I
assign 20, this location gets 20.
This 10 that was there same location 10 was there 10 is being over written by 20 here.
So, when this is being executed then this 10 is being over written and 20 is being written,
I am getting here 20. Now X has got 20 what is X now X is 20 now I do another
arithmetic operation here what how do you explain this X assigned X plus 1.

Let us go back one moment to this X was this is X it was 20 and I have come across an
instruction, which says X equal to X plus 1 what does it mean? It means assign to X
what? X plus 1; that means, whatever value you get after computation of the expression
will be assigned to X. So, how will it be done? Right now what is the value of X 20, the
CPU will have doing some addition operation, will it read this value 20 here and some
incrementation by 1.
So, that these 2 will be added the value from the location X will be taken it will be added
with 1 or incremented with 1. So, here I will be getting after addition I will be getting 21,
now this assignment means whatever value you get after computation will be assigned to
this. Why this because on the left hand side I have got the same location X, this will be
changed to 21.

Now suppose if instead I had the situation like this.

X at 20 and I write Y assigned X plus 1 what does it mean? It means that this Y is
another memory location and what is been told over here, you take X take the content of
X and, you will take 20, and have 1 added add them you will get 21 and assign it to Y in
that case you see the picture, the main content of the memory location the value of the
memory location X remains unchanged and another location gets the value 21 right
unlike the earlier case. When we had written X assigned X plus 1 when I do that then in
this case this value will be overwritten this 20 will be over written, but in this case it is
not being over written it is remaining all right.
Now, let us go back to the slide here, when I therefore, you understand X was 20 assign
20, then next step X is assigned X plus 1, it becomes 21 the same location X is becoming
21, now I am doing X assigned X multiplied by 5.

So, again what I am doing? I am the same thing X assigned X times 5, I had X and X
was 21 here I took that value, and this time instead of adding the CPU is doing some
multiplication and with this constant value 5 and is getting the value 105. Now this 105
is again written back to X, it is going over there and it will over write this 21 and we will
write 105.
Therefore here we will have the result as 105

I hope you have been able to understand the difference between the variables and values
here, and the variables the fact that the variables are nothing, but memory locations. I

will continue with this in the next class, quickly let us have a look at this. Let us revise
here another situation another program segment the part of the program. X is assigned
20, Y is assigned 15, next step Y is assigned 15, X is assigned Y plus 3, Y is assigned X
divided by 6 now; obviously, since there are 2 variables in this program, there will be 2
memory locations assigned.
Now, here in the first instruction X is being assigned 20 therefore, this location has got
20 written in it what is there in Y I do not know; anything that was earlier from the
beginning was remaining that is there I do not care. Next step I am assigning 15 to Y
therefore, now X remains as it is 20 and Y becomes 15. Now what am I doing in the third
step? I am doing X assigned Y plus 3 just as I had explained in the last slide just now
that I will be actually taking the content of Y.

Whatever Y was it was 15 or something I take it and add something to this and store it
back to X all right that is what I am doing right.
X assigned Y plus 3, Y was 15, that is taken 3 is added to that the result is 18 and where
is that loaded, that it loaded into X and, it becomes 18 and what happens to Y? Y is not
disturbed because here at this point Y has just been read it is not been written into Y has
been just read, I read from this location I did not disturb it I disturbed x. So, I added 3
and made it 18 here what I am doing? I am now disturbing Y how? I am reading the
value of X dividing it by 6, 18 divided by 6 will be 3 I am writing that to Y therefore,

now I am disturbing Y and Y has got a new value, now, my result if I had written here
print X and Y then my result would be 18 and 3 right.
So, that is how the variables are handled by a programme and I tried to explain to you the
difference between variables and values, you please look at the pseudo code of the
examples that we did in the last lecture and see what are the variables and what are the
values and try to draw a diagram as I have done today just to have clearer conception for
that.

In the last class, last lecture, we were discussed about variables and values

And we explained that variables or mapped by the compiler to different memory
locations. So, whenever we mention about any variable X Y or Z, each of them
corresponds to a memory location, each of them corresponds to a memory location and
each of them corresponds to a memory location

And whenever we assign some value likes 20 to X; that means, in a particular memory
location that value is written. So, we had done this example once again, we quickly go
through it that X is being assigned 20. So, the memory location corresponding to X is
getting the value 20 whereas, the memory location corresponding to Y can be anything,
when we assign in this statement the value 15 to Y.
Then 15 is written in the location, corresponding to Y, when we do Y plus 3 and assign it
to X; that means, actually we are reading this value of Y, here reading the value of Y
which is 15 and we are adding 3 with that and we are getting 18 and that 18 is written
into this location, all right. This may appear to be very simple, but this way of thinking
or way of looking at the things will come in very handy as we will see at a later, during
the later phases of programming.
Now, here again when we are, what is been meant by this statement? That the value how
will I read? I will read it like this that the value of X value stored in X that is 18 will be
divided by 6 and that result will be stored in Y all right. So, X was 18, 18 has been
divided by 6 and we get 3 and that 3 is written in Y. Now, here there are couple of
things, that what is this 18? What is this 20? These are values and whereas, these are
variables, these are also known as constants. Constants are the values which do not
change during the execution of the program, next we can now, we can think of the
software.

Now, you know any computer system; consist of hardware as well as software right. So,
we will have some hardware as well as software. Now, the hardware is consisting of the
C P U, the memory, the I O devices, all those things are hardware and the software is the
instructions, that this hardware that is executed by this hardware, the instructions that are
executed by this hardware constitute the software. Now, software can be of two types for
example, first one is the application software; application software is the software that
we write.

So, we can just have an idea of this, through this onion type of diagram at the core, we
have got the hardware. The hardware is here and I am putting two layers around this and
the user is standing somewhere here and the user is not directly interacting with the
hardware, because the hardware nearly understands ones and zeros and it is very difficult
for the user to write in ones and zeros. So, the user will write in some high level
language H L L, in which the user writes and the system automatically converts it into a
way that is understood by the hardware.
And what is that automatic way of converting it, we have seen that is compiler, is a
software compiler is again a software right, a complier is software which converts before
coming to application software. Let me talk about system software. So, we know that
when the user has written something in high level language, that is converted by a
program called compiler into the machine level language or high machine level language
right, which the hardware understands.
So, the compiler is let us mark it like this. These are part of this layer, which is the
system software similarly; operating system is another very important software, that is
lying in this layer, internal layer which enables the user to use the computer in a much
more user friendly way and in a much more efficient way. So, operating system compiler
etcetera are the core, very important elements of the entire computer system, without
which we cannot, we would not be able to use the computer in, as efficient way as we do
it now a days.
Now, given this hardware and this layer of operating system, and compiler, and other
system software, now, we are in a position to write some programs for our day to day
use, for example, a company wants to find out the salary information of the people, they
can use some pay roll software, here or for example, you want to design some data
analysis software that will take some data and using a particular software will analyze
the data statistically and give you some good insights.
So, all those things, the user is writing and they are forming the application software. So,
most of the time the programmers, who are not systems programmers, not the system
designers, but just users they mostly use the application software given this, we come to
a very important software.

We just now mentioned, that is an operating system. Now, you know that you are
averred of typical operating systems like windows, Linux or Unix, now a day’s Apple is
becoming popular Mac OS, all these things are operating systems.
Now, what is the operating system? The operating system is a layer around the hardware
which enables a user to use the software, use this computer system. I am sorry, use the
system in a much more friendly way. Now, there are different varieties of operating
system; single user operating system, multi user operating system, etcetera. Now, this
operating system also activates another system software that we have talked about, that is
a compiler right. The operating system will call or will activate the software system,
software call the compiler, when you want to run a high level program, given this
background. Let us now move to discussion on programming.

We know by now that programming means we have to express our intention of solving a
problem by executing a number of steps and those number of steps, once again you know
that by now, we start with the algorithm and that algorithm can be expressed in different
ways like pseudo code or flow chart and then the programmer actually writes them in a
high level language, some high level language.
Now, what we are going to discuss now, is a particular high level language, which is
called C. We are taking C just as an example of an high level language, because we have
to express the logic in the form of some high level language. We are taking C as an
example and as I have mentioned earlier that the logic, the style and the philosophy,
remains more or less the same across different programming languages like Java, C plus
plus and others of course, C is the simplest to start with.
Let us see now, we are using the term language, think of a human language; any
language is constituted of some vocabulary right. The vocabulary say for example, in
English, the vocabulary consists of some words right. Different words like a bird is a
valid word in a, in the English vocabulary now, but if I had written r b i d that is possibly
not a valid word in the English language vocabulary all right.
Now, we have got some valid words. Similarly, C will also have some valid words,
which will see through, which we can express the basic elements of a C program, just as
English sentence is built using English, valid English words, otherwise the meaning will

not be understood in the case of C programming language. Say C will have, it is own
vocabulary right. The words valid in C now, if I had written some word in English, that
is now some string, some patter in English like r b i d that unless this has got some
special meaning, this will not be an, if this is a part of a sentence, this will not be very
clearly understood by anybody.
Now, when I have written a C program, who is going to understand this, for whom I am,
I writing this C program, I am writing this C program, for the compiler C, compiler all
right. I am writing it for the C compiler and the C compiler is responsible to understand
this and just as we understand an English sentence open the door. So, we understand the
meaning of that sentence, we go and execute that we open the door.
Similarly, in C if we write something, unless the compiler understands this, it will not be
able to convert it to the machine language, which will be executed by the hardware or the
computer right. So, the C program must constitute of valid C words and we will see what
are the valid words and what are the rules for that. Now, the next thing, if I write a
particular sentence

I saw a bird that is a valid English sentence, why is it valid? Because it is grammatically
correct and also it is carrying a very clear meaning. It is a meaningful sentence right, this
is both correct, grammatically by grammar and also it is meaningful. Now suppose, I
wrote it, wrote something like I sees a bird. Now, this is grammatically wrong; however,

it conveys some meaning, I understand that the person who wrote this is weak in
grammar, he is not very much conversant with subject, verb, agreement, but still I can
make a meaning out of it.
On the other hand for a compiler, if I write a C sentence, let me call it not sentence, let
me call it C statement. Now, a C statement; that means, a statement in the language C
will consist of some valid words in C and also it will have to follow some grammatical
rules of C. Unfortunately, here although it is grammatically wrong, I could understand
the meaning of this, but a C statement, if it is grammatically wrong, grammatically
according to the grammar of C, if it is not in tune with the grammar of C.
Then is grammatically wrong and since this C sentence will be interpreted not by a
human being, but by a machine, computer hardware smart, it may look like is basically,
not as intelligent as human beings. So, that as of now, whatever we can make out the
meaning of it a compiler a C program will not the compiler, will not be able to make out
correspondingly the correct machine language cannot be generated therefore, if there is
something that is grammatically wrong according to C grammar that will be indicated
marked by the compiler as a syntax error all right. So, unless we write something in the
correct syntax, there is always a chance of it will it not there is always a chance it will;
obviously, lead to a syntax error and the compiler will not produce the corresponding
machine code, all right.
So, we are now supposed to learn what is therefore, we need to know what are the valid
words in C and what are the correct grammatical structures in C. Now, if we learn both
these, we learn the C language similarly, if you want to learn any other language
computer language you have to exactly know this things what are the valid words, in that
language and what is the correct grammatical structure in that language. So, given this
we will start looking at C programs, even before that we once again recapitulate.

Whatever we are expressing them using some variables constants, right and the variables
I have got, we have shown X Y Z, etcetera, at variables. So, each of this variables which
are nothing, but memory locations are been given some names right. So, we have to give
some names of the variables all right. There are some rules for naming them just as in
English, we start a proper noun with a capital letter Ravana, all right Sita, we write them
with the capital letter this is the rule of English; however, if you write in any Indian
language, say you write anything, Amar you write that there is no question of any capital
letter here, but it is a, it is a property of English, it is a rule of English that the capital first
letter of a proper noun must start with the capital letter.
Similarly, for naming the variables in C there are some rules. So, here we have seen X Y
Z, etcetera. These are the variables. So, there are some rules for naming the variables, we
will come back to this again, but first of all any string of alphabets say, let me introduce
one word; alphanumeric.

Alphanumeric means what alphabets and what are the English alphabets A B C up to Z
small letter a b c up to z that is alphabet and numerals, we know 0 to 9 all right 0 1 2 3 up
to 9. Now, an alphanumeric means A union of both these either alphabet or numeral. So,
a variable name in C can consist of any alphanumeric character now.
So, it can be say, Apple is a valid variable name in C, again if I start with small a this is
also valid variable name in c, but although these two are same, since I have put in
different characters, one capital, one small, these two will be treated as two separate
variable names all right. Similarly, I can write, say Apple 1 2 that is also valid variable
name. Now, there are some special characters like underscore, that is allowed like I could
have written something like this, Apple underscore 1 2 that is also valid variable name.
However I cannot start a variable name with a digit or number for example, 1 2 Apple is
not a variable, valid variable name other special characters like say, Apple percentage is
not a valid variable name. So, these are some of the rules. So, the what are rules of
naming a C variable, it can consist of any alphanumeric character, any length, but it must
start with an alphabet and only some specific special characters like the underscore is
allowed, others are not.
So, this is not allowed, but say Apple bob 3 4 is a valid name. So, here I can use as again
a p p l e b small o, small b, there is also a valid name. So, in general what is the rule; I
can have a string of alphanumeric character, starting with an alphabet and having no

special characters except for this underscore all right. So, with that, that is how we will
name the variables and each variable I will again repeat, you know that a variable
essentially consists of memory locations, a variable is nothing, but a memory location
and we are putting the name to that particular memory location.

So, if Apple be this memory location, may be a p p l e is another memory location. Now,
which variable will go to which memory location is decided by the compiler. So, might
be Bob is another one, all right. So, these are separate memory locations.
So, variables and naming of variables is a fundamental step in writing a C program,
because whatever we write, we have to write them through variables, now quickly once
again we look at this that whenever we are writing suppose, again I am writing.

Now, a suppose there are three numbers A B C or. So, I want to find the average of that.
So, I can write it in the form of say and say average, you can see that average is the valid
name in the case of a variable. So, I can say A V G is A plus B plus C, whole thing
divided by 3. Now, this one I can call to be A C sentence or I am saying sentence.
So, that you can have an analogy without English, but we will call it C statement all right
and this C statement consists of several things, will come to the other things, but you can
see that we are, it is consisting of 1 2 3 4 variables and one constant that is 3 all right and
there are some special parenthesis and all these are also valid symbols in C and these are
operators. So, we will see how was C statement is constituted, but whenever we write A
C statement, it will consist of a number of variables.

Now, coming to A C program, A C program consists of a set of in, let me call it a
number of may be one, but at least one number of functions. What are functions? There
is a significance of this term functions, but for the time being let us simply try to
visualize it in this way that I am trying to build a machine.

Which will do something, what will it do.
Say for example, it is a machine that will take, say 2 or 3 numbers, A B C and will
produce the average. Now, this is the machine all right. It does something; takes some

input and give some output. Now, this entire machine can be built of with smaller sub
machines all right and one machine, each of this sub machines can do some specific task
for example, if I take a complicated, say paper rolling machine, then there are so many
things to be done in order to roll out or prepare papers.
So, similarly, there can be different sub machines, which are doing different functions.
So, each of them, each of these sub machines are carrying out different functions are
carrying out different functions, all right. This is doing one, this is doing another and all
these three together is doing something.

Now, as I said in the worst, in the, in a special case just like for a simple case of average,
I may not need many sub modules, because I can very well take A B and C here, A B
and C and simply in this machine I can write a program like A V G is equal to A plus B
plus C divided by 3 and that will be the output right.
So, here I do not need any sub machines, because it is simple problem, but never the less,
I need at least one function, that is what is this task is being done. So, any C program
will require at least one function and in many cases we will see, it will require more
number of functions. We will come to this in the next lecture.

So, we have started our discussion on a specific programming language; that is C and
once again I repeat, that a C program will be constituted of some valid words of the C
language, just as the an English sentence must be constituted with valid English words,
similarly for C and must be every language has got a grammar. So, C has got a very strict
grammar and any statement that is written in C that is not adhering to that grammar will
not be accepted by the compiler. The compiler will reject it, saying that it is a syntax
error or grammatical error. So, before going further into discussions on C briefly, let us
look at the history of C, it was originally developed in 1970 by Dennis Ritchie all right
and his book.

I have also referred to you at AT and T, Bell labs and become very popular by the mid
1980's, because it was the compilers. Now, a language, a computer language cannot be
popular, cannot be used unless there is a compiler for it. So, it took some time, although
it was developed in seventies, but many compilers in, for different platforms, for

workstations, for PC’s, for different platforms were made available by mid 1980's and
this became very popular and there were some standardizations that also took place.
Now, even that we, let us look at the structure of a C program. Let us look at the
structure of a C program, here every C program will consist of One or more functions one or more functions. One of the functions will be given the named main, which is the function. Now, I in the last lecture, I said that there should be at least one function, if nothing else is there, if the even, if the program is. So, simple that I do not need any sub machines, in that case I can do it with only one simple function and that function has to be named main and if there be a number of say for example, sub func, number of functions or sub machines, in that case also there has to be one program, which has to be called the main and the rest can be given some other names, the program will always begin by executing the main function. So, once again let us go to the diagram that we had used in the last lecture.

Say I have got a program, which has got only one function, very simple then this
function will be called main and no other sub functions are there it will take some inputs,
whatever the inputs are, it will process that and the output will be made available. Now,
suppose I have got two sub machines, required for this one here and after that another
one.

So, this sub machine will do something, then this sub machine will do and then will
come out and this is the output and there is some input coming in. Here these are the inputs and they are some sub machines, but I have got one machine, which is the main.
This is again the main. So, although I am taking help of the sub machines, I have to first
enter the main function and then from the main function I can enter here and go
somewhere else and ultimately, I will have to come out through the main function. So,
we cannot escape the function.
So, the main will be there and typically we write the main any C body, within two curly
braces, here whatever I am drawing as a diagram that is equivalent to these two curly
braces. Inside this, whatever is written is a C program, whatever I write here, whatever C
program I want to write, I have to write within these two curly braces, I will come back
to this in a moment. So, so there has to be one function called the main and the program will always begin by executing the main function, each function must contain a heading, which consists of the function, name followed by something application, say; followed by an optional list of arguments,
I will explain that later.

Let us again come back to this, that I have got a function, I have got a program which has
got one function, whose name is main and I have got another function, whose name is
say add and there is another function whose name is find. Is it readable? Find average or
let me, this is a little confusing, let me rename this, I name it as divide sum, take the
example of our simple finding average all right. I want to find average.
So, what are the sub tasks, one is I have to read the numbers, say read say ABC that
reading suppose, I am doing here this read ABC is here, one after that I am doing, add
ABC, say adding ABC is being done by this sub machine say, and therefore, I have to
give a name to this, sub machine that this sub machine is inside the body of this sub
machine, I will actually do the addition, but the name of the sub machine should be
expressive of what.
This sub machine of the function is supposed to do similarly, after I do that then I divide
sum right I will divide sum by 3 by whatever 3 here in this case. So, that is being done by
this sub machine this is too simple these are two simple sub machines, but this is being
done by this submachine. So, they each of them has to be given some name each of the
functions including main has to be given some name. Now, along with that there is
another point that has been mentioned here, there is the argument each of these functions
must have a place, where I can write the arguments right. Now, I am not writing anything

on main, but say when I say what are these arguments, if I just consider this separately
all right, any function separately any function

If I consider separately, now this function will have some inputs and some outputs. What
are the inputs and what are the outputs? Suppose, the name of this function is my
function, then this function will have some arguments, which are given in within this
parenthesis and suppose, these are A and B are two variables, which are read by this and
C is a variable that is output by this.
So, the name of this function should be associated with the names of the variables, which
are taken as input or is supplied as output by this function these are called arguments, we
will come to this when we discuss some other very important properties of functions, but
for the time being just remember that a function must have a name and there should be
some place for writing the arguments, often you will find that a function like main.
Suppose, I am writing a function which will simply print a particular line, then inside the
body of the function I just want to print, I will say print my name, is something
whatever. So, my name just say my name. Now, this function whenever it is entered, it
will just print my name it is not requiring any values to be passed, but still then I will
have to put this parenthesis with the name although, I may keep the inside of this
parenthesis gland. So, a function in order to be a valid function in C, these are a C rule
that in order to have a valid function. A function must have a name and a place for the

arguments. So, a function heading is the function name all right, followed by an optional
list of arguments enclosed in parenthesis like this is optional, because it can be blank and
there are these are the things that there will be some argument declarations, etcetera, will
come to this particular part later, but before that we have to understand a compound
statement. What is a compound sentence? Say, simply in English if we consider, you
know that a simple sentence has got only one principal, verb principal finite verb;
however, I can have a compound sentence like a boy went to school and his father was
happy say.

So, here there are two sentences his father was happy and a boy went to school. These
are two simple sentences and we are connecting them with an end here, all right. So,
these are compound sentence. Similarly, we can have complex sentence and all those.
Here the idea is similar, but not exactly the same, I am saying that.

A function is a machine, which has got a name like say, add and sum parameters A B C A
B and the third parameter is sum; that means, it will take A as input B as input and will
produce sum, but here I write a number of C statements, a number of C statements are
written over here. Each of this C statement is a statement and all these together are
together forms are compound statement. Whenever, we find more than one C statement
working together that will be a compound statement. So, here the entire function add will
be if it consists of a number of statements, then it is a compound statement, in the default
case, in the very trivial case, when the program consists of only one statement then also
we can call it a compound statement, but with only one statement.

So, next, each compound statement is enclosed within a sorry, is enclosed within a pair
of braces like this, this is called braces, this is called parentheses and this is called braces
right.
The braces may contain combinations of elementary statements, a single one or other
compound statements. Now, once again let us see till now, I was drawing the machine as
this

I was drawing it as a rectangle. Now, I will move towards, more towards C. So, I will say
that this boundary will be specified in C as this sort of boundary, whatever is here is
within this parenthesis. Now, each of them, each of this braces, I mean inside these
braces, we will have some statements. It can be an elementary statement like say, A
assign 20 or maybe more number of statements. Now each of the C statements are
delimited by a semicolon.
This is very important, this you must remember, each of these are delimited by
semicolon, if I do not write the semicolon, the sentence is not completed, just like in
English we have to write a sentence and we have to complete it by a full stop right. It
rains very simple sentence, it rains and then there is a full stop here.
Similarly, in C, the end of one single elementary statement or a set of statements is
pointed out by semicolon all right. Otherwise, it will be ambiguous, there can be a
problem like for example, if I write A 20 B 15 and I forget the semicolon. If I can, I am
writing one after another, because that is nice to write one after another, but if I write
them side by side that is also equivalent, but if I put semicolons here, the compiler will
understand that this is a one statement.
This is another statement, but if I do not give the semicolon here, for example, I write A
20 B 15, then the compiler will be in a problem, because it does not know what it is
supposed to assign 20 or 20 B or whatever is it possible to assign 20 B many things will
come. So, we must be very careful about completing the statements with semicolon.
So, the braces may contain combinations of elementary statements and other compound
statements. Now, there is another very important thing called comments, whenever you
write programs, you must be generous of writing comments. Now, what are these
comments? Comments are statements, which are not, which are not converted by the
compiler to machine language, but then why do we write it? The reason is that whenever
we write a complicated or a large enough programs, the presence of the comments
enables us or enables suppose, I have written a program, it will enable somebody else to
understand the program. So, if I write something like say

I am again, I am not going to a complicated example as yet I am remaining with that
finding the average of the numbers, but suppose, I am doing it in two steps all right. Say,
I do, I am writing, I am just doing something like A assigned 20, B assigned 15, sum
assigned A plus B and then C assigned 25, sum assigned sum plus C. Now, when I write
this, somebody may this rather too simple, but somebody may say what are; what am I
doing here at both the places? I am doing sum. So, that somebody else does not get
confused, I can write something like this. Let me just check the syntax here, yes I was
right. So, what is happening?

So, I can write say, A assign 20, B assign 15, note the semicolon that I am putting after
every statement, sum is equal to A plus B. A plus B and here I can put in a comment, say
adding first two numbers I am ending this with this symbol, this is again I am doing a
bad job here. Say, I write numbers and then I put this sort of symbol.
So, here you see I put here this and here reverse this, whatever I write in between that is
assumed by the compiler to be a comment statement. So, the compiler need not convert
this into machine code. So, here again I can write later say CS sorry, C assigned 25 and
sum equals some plus C. Now, I can explain that adding whatever I want I can write in
any form, adding third number to sum and put this I am sorry, here always I am making,
I am not being able to manage the space, it should be, there should be a space in
between. So, I will have to rank the third number to sum and I put this end of comment.
Now, this part will not be compiled.
So, for any program, when we write as the program, becomes more and more
complicated. We should be generous about writing the comments that will also help us.
Say, you have written a program today and he want to look at it after, say one month and
see what you did? Such comments will be helping you to understand what you did or
somebody else of course, to understand what you did right. So, for examples let us see
here,

I have got a simple thing A assign B plus C. So, here you see, add two numbers between
this to this and the end of comment is this, all right.

Now, let us look at a simple C program there for now, this part I will be explaining
separately, but before that let us look at this part of the code is a very simple program,
simplest possible program. What it does? It simply prints our first look at C program, this
line as is will be printed as is will be printed, where will it be printed this? Will be
printed on the screen or on the printer or on some other file, where will it be printed here,
we are writing another statement hash include stdio dot h.
This stdio dot h means standard input output std for standard. So, it is stdio is standard
input output. Now, if nothing is specified, then the standard input is our keyboard, by
default. It is the keyboard and the output by default, is the screen. So, when I write this
then, when I write print f; that means, this line will be printed on the screen that is the
meaning of a stdio dot h.
Now, this single piece of simple program has got many things to illustrate. This term
hash include is an instruction to the compiler that you need not convert it to the machine
language, but before you convert the program to the machine language, please do this.
What is doing this?

Please, include stdio the standard i o dot h. Now, what is this stdio dot h? In order to
understand this, you have to know what a library is now? Any programming
environment, any programming environment provides you with a library of functions C,
provides you a library of functions.

Now, this library of functions and library of other packages, which are library functions
or codes, let us see that is already there now. So, I am going to write a program here and
here there is a library and in that library there are many things here, all right and one

such thing is stdio and all these libraries files have got an extension dot h. Why that is?
That we will see later. Now, when I am writing this part of the program, if I say hash
include within this corner brackets stdio dot h; that means, whenever I am writing this
program, whatever program I have written, that will be converted to the machine code
that will be ultimately converted to the machine code.
While doing that, this before, doing that this stdio part must be included or must be
included some of the information, must be included, that will tell me that well you see
whenever you are doing this print f that print f will be, will have to be done on standard
output and what is that standard output? The printer, it is a printer, so, that is the purpose
of hash include. There is a preprocessing statement, compiler a preprocessing statement.
Now, I had said that every language has got, some of it is own vocabulary. Now, in
English when you understand, whenever I write print or write this words, carry meaning
to you in English in C, we write it as print f.

This is a special word of C, why they say if there is a meaning for that. That is in C,
wherever we write, whatever we write, we consider that as if we are writing in a file, say
in your office or in your work desk, whenever you write something, you write it on a
piece of paper and put it in a file in C. We consider every input or every output device to
be a file and this f stands for file as if I am printing on the file, which file? The printer

file, then the next class, we will start with this and will describe some of the other he
brew like statements, here which will from, which we will go ahead.
Thank you.

So, we are looking at a sample C program.

And as we had discussed in the last lecture, we have a structure as is shown here. You
can see that there is a main function here a main function is there, and that main function
is covered by two parentheses. Now, we can see that we start with the header file that
includes stdio dot h. An stdio dot h stands for standard IO.
That means, whenever we will get some instructions to carry out input or output that will
be in reference to or with respect to the standard input that is a keyboard; that means, the
data will be taken from the keyboard. And if anything is to be printed it will be printed
on the screen. So, that is a default thing for any C program we have to put in stdio dot h
include hash include, this is known as this is read as hash include stdio dot h. Unless you
want to take the file do not want to take it from the keyboard or do not want to print on
the screen.

Next thing is that the main function which as I said in the last class that there must be a
ma main function. And the main function will have a place for the parameters, you can
see here for the parameters here which may or may not be empty. The third point is the
structure the overall boundary of the main function of for that matter for any function
there should be a boundary specified, and that boundary specified with by this to curly
brackets.
Next we come to the statement. As I had said that just like any other language c also has
got some words which are understood by any by the compiler; print if is one such word
which is the statement for printing the sentence that is given within these double quotes.
You can see that double quotes here and so, what will it print? It will print our first look
at the C program here as his shown here that will be printed.
Print f within quote here there is a quote n quote and here is a start quote our first look at
the C program. In addition there is I am sorry let me go up, we can see to special
symbols which are these backslash ns right let me just clear it out, here you can see this
backslash n something of the sort. This means go to a new line or end of line now
suppose.

Let us see suppose I am I had something like this I had printed something all right I had
printed something this is a screen, I had printed a brown fox. Now after I printed; that
means, a computer printer you can see where my pen is my pen is lying here right my

pen is here. Now if I say backslash n this is no radar backslash, backslash n; that means,
my pen will come to the beginning of the new line and here I will write our first C
program, and by default my pen is here, but since I have given another backslash n the
pen will come here.
So, next time if I again start with the backslash n it will come to the new line, and if I do
not give a backslash n it will continue from here. You will understand this more when we
look at more number of programs, it will be much more clear to you. So, this the
structure of a very simple C program we will see more of this.

Now, here is a another program. Again now it is easier to understand you have got an
includes t d i o dot h which has to be there for any C program, there will be a main
function as is being shown here, and there are parenthesis between these two the program
should be written, there is a boundary of the main function. Now here there are some
more new things which are being shown to you in the form of example.
So, you see the first line is int a, b, c what is meant by that is that I am I will be using in
this program 3 variables a b and c and each of them is of type integer. Now you are
already acquainted with the term variables, but you are probably not acquainted with the
term type of a variable.

So, quickly let us go to that, we have got variables and the variables can be of different
type, also constants can be of different type for example, the variables can be of type
integer for example, 7,17 all these things 256, 1999 all these are integers. Another type
of variable can be real numbers which are say 10.5, 6.325 fractional numbers right these
are real.
This is also known as in c as floating point numbers. Now integers are these reals of flow
floating point numbers of these. Similarly I can have characters like say x y p whatever
these are different characters or maybe and is a character. So, each of any of these
alphanumeric and all those can be characters now. So, we know what is an integer, what
is a real what is a floating point, what is a floating point what is a character.

Now, a variable is of type integer, what does it mean? As you know a variable is nothing,
but a memory location right it means and suppose this variable I say variable a is of type
integer. So, there is a memory location corresponding to a and this memory location can
only hold values which are integers. So, 57 I can store here, but if I try to store 57.5 here,
it will not store 57.5, because it has been told to be an integer.
Similarly if I say variable b is of type floating point, I am in short I am writing float; that
means, this variable b can store a floating point number. So, 57.5 can be stored here.
Even if I try to store in b 57 in b if I store 57 just 57 then that will be stored as 57.0 all.
Similarly there can be types of characters. Now depending on the type of the variable the
compiler assigns different sizes of memory for the different variables.

For example in standard c compilers and it is a convention that for an integer two
memory locations are allocated.
Now, how big this will be say sometimes it is my each of these memory locations can be
16 bits, in that case I am using 2 16 bits; that means, 32 bits to store an integer whereas,
for a real number. Now this is a convention, 4 locations are used for storing a real
number. So, 64 bits 16, 16, 16, 16. So, that will be for real numbers now. So, depending
on what I write, what how I define the type of the variable when I say a b c I also say
what type of variability; is it an integer, is it a real or what it is.
Now, if you come here we will see that here I have written float and I did not write
floating point number. Now in c in order to specify variable to be real we declare that to
be float say p q; that means, semi colon; that means, p and q are two variables which are
of type floating point number right and if I write int a b c; that means, a b and c are 3
variables, which all of type floating integer type int. So, we do not write integer we just
write in c int. Now obviously, then for p how many bytes how many depending on how
many bits will be given how many memory locations will be given for p may be 4, q it
will be 4, but for a b c it will be only 2 all right.
Now, let us therefore, go back to the program here, here we find int a b c now this
statement this is called a type declaration all right this is known as a type declaration this
is the first statement. So, I have declared the variables now in C program before the

variable is used it should be declared about its type. The other thing is you can see this.
So, here you can see a has been assigned 10, b has been assigned 20; that means, what.
That means in the memory location a corresponding to a memory location corresponding
to a 10 has been written, and to the memory location corresponding to b 20 has been
written all right and this statement c assigned a plus b, I had explained in another lecture
that; that means, this data this value 10, and these value 20 will be taken out on the from
the left hand side from the corresponding memory locations they will be added and the
result will be 30 all right; the result will be 30 and the 30 will be written into the location
c. So, this will be 30 this much is clear.
Now what about this line? I know that a print if statement just tells me that I have to print
whatever is there in the quote. So, how will the print look like? Please note the sum of
percentage d and percentage d is percentage d this is equivalent to writing this.

The sum of dash and dash is dash there are 3 gaps, one here, one here and one here now
how will these gaps we filled? They will be filled by the values of a, b and c respectively
each of these dashes will be filled up by the respective values of a b c. Now this
percentage d is a format statement is saying that this gap can be filled by a digit or by an
integer.

This gap can be filled only with an integer. Now here I a is an integer therefore, this gap
will be filled with the integer value 10 and percentage d, and it is being printed as it is
because it is within this double quote and dash. this dash will be filled with another digit,
and what is the digit? The second space b and b is 20. So, it will be 20 is what is a plus b
is c and what is the value of c c the value of c is 30.
So, this is what will be printed all right. So, this is how we print a sentence, where I want
I have got some places for different variables and these places will be filled up by the
values of the variables, whose names are being specified here. I repeat this gaps will be
filled by the values of the variables whose names or whose identifier are been specified
here and the type of this variable, and the specification of this dash should match. Now,
it will be printed sum of 10 and 20 is 30; now coming to the third sample program.

Now, this is a little more complicated, and this is trying to find out the largest of 3
numbers; that means, what we had done in a flowchart exercise finding the max of 3
numbers. Now that was discussed using flowcharts and pseudo code and here we are
discussing that using a program a C program how is that idea translated into C program.
Again let us start with even before that I would like to point out something, again let us
revise the structure of the program, we start with header stdio dot h, now we start we put
in a comment what is this? We saw in the last class it is a comment this comment is just

telling us the compiler has got nothing to do with, it is just telling us that this program
finds the largest of 3 numbers.
Then as usual we have got a main function which must be there and there should be a
parenthesis which is delineating the boundary of this program. Now for and also we have
seen this, I am using 3 variables a b and c and I have put in the type of that. The next
new thing that is coming up is here scan f, this is an input statement for reading 3
variables from the keyboard. Now recall that I said that for every language there are
there is a vocabulary, there is the set of words that the language understands.
So in c, in an earlier one we have seen in an earlier program we have seen the statement
print f right we had seen a program print f. So, print f is a particular word, now we now
encounter another word int is also another word; int is another word which specific to c
and the meaning of this every word will have a meaning. So, this means that whatever
follows are variable names of type integer. Whatever follows this word int are variable
names of type integer.
Next, new word that we are getting is scan f. Just like we had seen print f earlier all right
print f is a word, that tells us that something is being printed here scan f is an int is a
word that tells that whatever is inside this parenthesis is a input statement. Now let us
study this a little bit here. Here again you will see that there is a percentage d percentage,
d percentage 3 percentage ds within quote and that percentage d means it is a specified
for an integer, some integer is being will be that scan f means say assume it is really.

So, therefore, it something like this, I am going I am creating as if 3 places, because
corresponding to each percentage d, percentage d, percentage d, percentage d within the
quote, I am creating 3 spaces and followed by that let us go back to this, I am sorry here
there should be no comma all right; I am just giving 3 percentage ds.

So, let me go back here. So, it should be within the court here is scan f, within quote
percentage d blank percentage d blank, percentage d and the quote is closed comma; that
means, as if just to understand I am creating 3 spaces each of which I have ready to

accept an integer and where will those be stored? Here I am writing and a, and b, and c.
Now here I will request you to just forget about this ampersand sign forget about this for
the time being this will explain a little later.
Just assume that a, b and c, but before that for any read statement will have to put an
amperesand before the variable names there is a reason for that. What is the meaning of
this sentence? The meaning of this sentence is that there are 3 places which are ready to
hold 3 variables, which will come to the locations a b c; when I am reading as if I am
reading from the user 3 variables a b c ok.
Now, why I put that amperesand will explain a little later. So, 3 space have been created
and what are the spaces? These spaces are nothing, but these 3 memory locations which
3 memory locations whose names are being specified here all right. So, this is something
that you have to be a little careful and practice a little bit it will be very easy later on. So,
within the quote I specify the format specify that is integer in this case percentage d and
this other variable names.
Now, let us go back to that anything that is new here. Now a new word we are
encountering here, if is a conditional statement you did not bother about it, if you recall
we had in the flowchart we had a thing called diamond right where we are taking some
decisions based on some conditions yes and no right. We are doing that here we are
looking at some condition here if a is greater than b and a is also greater then c, if that is
yes then I am printing that a is the largest number. Try to apply simple logic here, if is a
conditional word condition is a conditional word and this entire statement starting from if
to this semi colon is one statement, and where I check the condition whether a is greater
than b and a is greater than c.
If that is so, that is if the diamond comes out with that yes, then I am printing that the
largest number is a. Otherwise, that means if the answer to this is no otherwise I am
again checking again if again I am checking another condition, I am checking another
condition here what to do I what my checking? Is b garter than c yes if yes then I am
printing the largest number is b otherwise is yes, otherwise if it is no then I am painting
the largest number is c.
So, we are encountered in some new words if and else. If means if in the diameter result
of this diamond box is yes then this statement will be executed otherwise; that means, if

the answer to this diamond box is no, then this part will be executed. Now here again the
second block I am checking if b is greater than c, again if this is true for this condition
this will be executed when this condition is true or yes if it is false then this statement
will be executed. So, it is a little more complicated program, but a very useful example.

So, we see the comments we have already mentioned, now you are coming to another
program.

This is using what we earlier had said that a big machine can we divide into sub
machines. So, big program this one is not a big program, but any programs can you
broken down into different functions. Here is the main function this one is main let me
draw it a little nicely. Here we have got a main function and inside there is another
function whose name is my function I am sorry.
Now, let us look at this, now first here there is another new thing we are introducing and
that you should understand that is define PI to be 3.1415926; that means, this verified in
this program this PI will appear, there will replace it with this value 3.1415926, but
inside the program I will not right PI, I am just defining it once for all and this means I
am replacing pi by this value before the compilation is done. So, this is again a p
processor statement.
We will continue with this example in the next lecture.

So, we were discussing a little more complicated a little more different program that is
using a function.

Here, what we had discussed in the last lecture is, that we are using a new type of
statement that is hash define this is a preprocessor statement; this is called a preprocessor
statement which is replacing PI with the value that is specified.
Now, anywhere I can do I can define other things like this also for example, I can write
see hash define resistance is 10 ohm; 10.2 ohm whatever. That means, in my program
wherever I get this variable name resistance, that will be replaced by this constant value
10.2 even before the program is compiled; that is the first new thing that we saw.

The second thing is look at this, let us study this program. First time putting an a
comment and the comment tells me what this program is going to do. The comment is
compute the area of a circle, and as usual I start with a main sorry as usual I start with a
main an inside main let us see what we have done, we have done something different.
Now all of you will be able to say what is this. This is a type declaration for two
variables radius and area. At what sort of type declaration is that it is float; that means,
radius and area are two variables which will hold real numbers or floating point numbers
right. Now I also declare myfunc this is another function, and the style in which I wrote
tells a compiler that this is a function and this function is also of type float.
What is the type of a function when we will be studying function in detail, we will be
understanding there. Now what have we done here? Scan f you know that by now scan f
is reading the value of some variable. How many here I look at this point? I find that it is
1 percentage f. So, only one variable is being read and what is that variable that is that is
radius alright. So, I will read the value of the radius and radius is of type float right. So, it
will be say 15.25 that is being read now computing the area the main function is not
doing itself. So, let us quickly go back to our old diagram.

So, this is the main machine of the main function. So, here what have you done? We
have read I am writing in a pseudo code I have read the value of radius and there is a
function called myfunc; my function. Now after I read the radius I do not want to take
the botheration of computing the area, this machine submachine knows how to compute
the area it knows that area will be computed as pi times r times r; that means, pi r square
right area of a circle.
But this is a function that can compute area of any circle it has been design, because by
pi r square you are not finding the area of only this circle, you can find the area of the
circle or might be this circle only thing that is differing is the radius right; here it is one
radius, here there is another radius, here is another radius. So, this machine or this
function can compute any any area of any circle provided it gets the
radius told to him told to this.
So, this machine is expecting some value to be passed on to this. Please note the terms I
am using. This function once some value required some value to be passed on to this.
Now you can ask that well be such a simple program, I could have written it here itself
yes certainly you could have written it here itself, but this is just an example. Actually in
a very complicated scenario, there are many complicated tasks and if we want to solve
the entire task by yourself by through single program, there is a chance of error that is
problem number one.

So, we want to divide the problem into sub problems; that is a general programming
philosophy that we want to divide the problem into sub problems and solve each of the
sub problems separately because they are more manageable, I can find out what are the
errors whether they are working properly or not and then I combine them together and
solve the overall problem that is advantage number 1.
Advantage number 2 is that suppose let us just for the sake of argument, assume that my
function this finding the area is really a complicated program very complicated program.
So, somebody has really taken the effort to develop this complicated program. Now
whenever me or you or anybody any programmer wants to use this facility, then they do
not need to reinvent the wheel and write that complicated program once again it is
available and I can reuse it, and only thing that I need to do while using it is just to pass
the parameter. Therefore, the second big advantage is reuse of functions that is why the
concept of function is so important in programming alright. You will encounter this
irrespective of programming languages. So, let us go back to this.

So, here you see I have I am not computing the area, I means the main is not computing
the area what the main is doing? It is just here it is calling my function.
So, immediately this one is being called, and what will my function do? My function is
ready my function is here and it is just expecting something which is r to come in
because it will compute pi r square. This expecting r and this one has got the variable

that radius in the variable radius. So, this is being passed on to this. So, over here from
the main function here is the main, from the main this radius is being connected to this r
alright and this function my function is reading is getting the value of r, and inside that it
is computing the area.
Now, there are some details which I will mention later, it is computing the area and it is
finding the value in its own variable a. A is a variable now for any program, if this
function is used then instead of radius you may have my radius or any other value any
other sorry any other variable name can be there. Now any this will work for all of them
let me clarify it once again.

See here there is a function and this this function accepts r and produces a.
Now from, as I said that it can be reused from my program, I am using it with the
variable radius it is been connected here. Maybe from your program you have not used
the variable name radius, you have used the variable name say rad so that will that when
your program is using this function, this rad will be connected to r. Now suppose here in
my program I have used the variable name area for noting the area. So, this output a will
connect to area for example, for your program you said area.
Now, recall that in c small and capital makes difference to this is another variable name
is a different variable. So, for you this a will connect over here, now this person this my

function is only concerned with r and a and the job of connecting them is up to the
function that is using it. So, here what happened I called the main function my function
computed a how here I wrote PI r r know how do I know PI; because pi has already been
defined here. So, this pi will be replaced by this value. So, 3.1415926 times r times r and
what is this r? Since it has been call when it has been called with radius the value of
radius will come here and return a. Now this return term means where will it return, this
is another new word that you are coming across. This return means it is returning to the
point from where you are called. The programmers going on like this from here it called
my function.
So, after my function is executed, it will return back to the same point.

So, we have come across a new word return and return is well returning the value a, and
that is being assigned to my variable area all right and then print f you can now
understand it will what will be printed? Area is dash and this one will take some floating
point number maybe 255.72 whatever it is and this value of area will be filling up this
place.
So, this is another example of a C program. So, through these examples, what we tried to
do is to introduce you to some of the very common names, common words and common
features of the C programming language.

Next we move to this that main is also a function I have already said that that main is
also a function this is clear to you now, but just quickly have a look at this. Here I have
identified some variables, have identified some variables a b c which are integers and the
same old program and is also a function fine.
Now, here are some words of advice, when we are writing a program it has got a couple
of things we have to keep in mind, first it must be correct so that it can be executed by a
compiler. It should not it should adhere to the rules of the game the syntax in the
grammar of the C language. The other thing is also this program has to be understood by
others, because if they you have written program and someone else wants to extend this
program. You are working in a big company and there are number of programmers and
each of them are writing a small segment of the program and everybody must be able to
understand everybody’s program.
Therefore the programs should be written in such a way so that it is understandable more
better understandable. Just like if we write in very bad hand writing write something
here, something there, something there I not understand it, but if you write it nicely in a
sequence it is much with proper paragraphs etcetera it is much better readable and better
understandable. So, here we will see some of the requirements for desirable
programming style one is of course, clarity.

It must be very clear; the program should be clearly written it should be easy to follow
the program logic. Now here is something that is very important I insist on that there
should be meaningful variable names. For example, I want to add two numbers and when
I say sum assigned a plus b or sum assigned num 1 plus num 2 it is good semi colon
please do not forget the semi colon and listen.
Now, the sum is a meaningful variable name, it immediately tells me what this variable
is meant for it is holding the sum. But suppose if I had written something like t t is equal
to t t t multiplied by t multi minus x, then from there its not very clear what is this t t why
are you using this t t. If say for example, average I am computing average as avg and that
is x plus y plus z divided by 3 is very understanding semi colon it is understandable, I
could have written the full thing average equals to this or I could have written avg all
these things are fine.
But if I had written p q r is equal to x plus y plus z divided by 3, then its not very clear
although I can look at this side and understand that therefore, it is p q r is the average, but
this not a very good practice. Now so, make variable and constant names meaningful for
example, pi should be written as p i is not good that 3, 4 3.1415 all those that value I chi because that is not very clear what this value standing for.

So, here are some examples use area instead of a, radius instead of r and program
documentation. We had said that we should be very generous about writing comments,
but if that too many comments then that is also not very desirable.

Now you are coming to a very important point that is program indentation what is that?
The structure of the program should be immediately feasible. We will give you some
examples.

Here is a good example, here this is simple I am writing in straight line, here there is a
function that is fine let us come to another example which will be better illustrating this
this is a bad style you see here compare these 2.

Here there is a declaration then I leave some blank, and then I put the actual code here
these are the declaration. So, I understand this a declaration. Compared to this which is
easy to understand this is something this is something else. Compared to that here why I
where I do not put a gap it is difficult to understand, where the declaration ends and

where the code starts. So, here is another good example of finding the largest of three
numbers look at this.

As I said that if I have read this, but one bad thing is here, there should be a gap here
there should have been a gap here. Now here if a and b. So, that is the first diamond a
decision box if a is greater than b and a is greater than c then I am doing something
alright then I am doing this this part of the program, otherwise I am doing this. So, here
you can quickly looking at this indentation, that this print f is a under this and this part is
under this, that is very clear from this indentation I have shifted it a little bit.
And so immediately you can understand that this print f is if this condition is true. That
means, this part is for this diamond box to be true like that; is a good indentation good
style now the same thing.

Same thing would be bad style if I write it in this way.

From here it is not at all clear which one is a corresponding to which one, not very clear
if I study it closely I will be able to understand sorry, I will be able to understand that
this print f this print f corresponds to this condition.
But immediately when I look at it is not very visible. So, this is a bad style alright. So,
indentation is something that is very much prescribed in good programming, this
becomes very important when we actually go for more complicated programs.

Now coming to the C character set. In an earlier lecture I had briefly talked about this
just as in English we have got a character set a to z capital A to Z. Similarly C language
has got a character set with which we make the words we have already seen them.
So, the first thing is of course, the upper case letters, the lower case letters a to z digit 0
to 9 and some special characters like you can see this hash we have already encountered
this when we said hash include that is a part of the c symbol set percentage we have seen
that when we say percentage d, percentage f you are seen that and this sort of symbols
this have already encounter all these are some certain special characters, that are allowed
in C.

Now the identifiers and keywords we have also talked about that. The names are given to
very different programming elements for example, variables we already know, constants
we already know, functions we have already seen each of them are given some names.

For example when we wrote myfunc that was the name given to a particular function.
When I wrote avg that was the name given to a particular variable that was the name
given to a particular variable. When I wrote pi that was the name given to a particular
constant right. So, in that we have encountered this. So, now, the how there is some

restriction on the names that I have also mention, may consist of letters digits 0 to 9 and
this underscore character with no space in between. Whenever I want to put space, I will
put in this underscore character is very useful is very useful to put this underscore
character hear what is happening here.
The first character must be a letter, this character must be a letter an identifier can be
orbital is long, but that depends on some c compilers some c compilers recognize only
the first few characters 16 or 31. And another very important thing that you had talked
about that it is case sensitive. A small area written in small letters and area written in
capital letters or an area with a mix of small and capital are all different these are not the
same this we had mentioned in the last class.

There is some keywords some words which are reserved for and have got some
predefined meanings in C for example, auto, brake, constant, float you know float has
got a specific meaning int got a specific meaning return your seniors got a specific
meaning etcetera. If it has got a specific meaning, l c f seen it has got a specific meaning,
but within comments you are free because it never being so, close the looked at by the
compiler the compiler simply text it and print it out.
So, this is another thing that you have to remember, whatever keywords you face during
programming you will gradually remember that these are the keywords and that should
not be used as a variable name.

So, here we will conclude this lecture with some examples, you can see some valid
identifier x is a valid identifier, a b c of now simple interest I put in an underscore here, a
123 is fine because it starting with a, and alphabet list stud name (Refer Time: 26:55)
student name very clear understood employee 1, employee 2 average employee salary
see I wanted to write a big thing. And I could take to that buy instead of blank I just put
underscore alright invalid identifier studies and why because I cannot start with sorry.
Because, I cannot start with blank sorry I cannot start with the numeral, for this is wrong
this is wrong because there is a special character that is been put in here, I am in hide
could have written my underscore name. My thing is also is also this not looking nice I
could have done this my name, but is not allowed hello is not allowed because here I put in some special characters, simple interest is not allowed because hes a blank I cannot put in a blank, but I could have rewritten simple underscore interest that is quite for light. Area is not valid because it has got a parenthesis, and percentage is using special characters here. So, these are invalid identifier examples of invalid identifier. So, you should keep that in mind. We will continuity with R programming lectures.
So, till now what we have done is we have looked at some of the rules for writing the
program and how the variables and the constant should be named; we will continue with
this.

So, till now we have looked at how in C language.

We can write the identifier, this is becoming a little too thick, which identifiers are used
for used for writing the variable names and the constant name. So, for example, PI or
some variable name suggest sum all those things. Now we have seen what are the rules
that the language c imposes on writing the names of variables or constants, that is how
we can write the identifier alright.

Also we have seen that there are different data types like int with stands for integer, and
float which represents floating point numbers or real numbers, and char is used to specify
some data which is of type character. Will see some more examples of this in the course
of these lectures, now we also know that int means integer and whenever a particular
variable a is declared to be an integer, then typically it also varies from machine to
machine and compiler to compiler, 2 bits or 16 bits are located for storing one integer
alright.
Each of these boxes are that I am showing here are 8 bits wide. So, there are 2 such. So,
16 bits, for float we will have 2 more real numbers are stored using 32 bits whereas,
characters are typical is stored in 8 bits. Now this is not so sacrosanct as in some
machine which is much more powerful and much more accurate having high resolution
we can have 32 bits for storing integers 64 bits for storing floating point numbers and
characters can be a bit 16 bits.
However depending on what is the type declaration, the amount of storage the amount of
memory that is allocated to a particular variable varies ok.

We just like int float char we also have got some more like short int alright, long int or
unsigned int. These are also different data types, will come across his in the course of
this lecture. Short int means just if in an integer takes 2 bits or short int will take one bit
if a long int if a int take 16 by 16 bits; that means, 2 bytes or long int can be made to
consume 4 such bytes or 32 bits, but still that will be an integer. So, in this 4 bytes an
integer that that will be stored; that means, a integer accuracy will be much larger.
So, depending on the number of bits I allocate to a particular variable, depending on the
number of bits suppose I allocate n bits the range of values that I can represent varies for
example, if there be n bits then I can go from I can have 2 to the power n distinct values
stored for example, if there be 8 bits, then the maximum value that I can store is when all
these 8 bits are once and that is your knowledge of binary arithmetic will tell you that
this will be 2 to the power 8 right that is 256 it will be actually 255 alright. So, 255 and if
I make everything 0 if each of them are made 0 all zeros will be 0 right, I can have the
range from 0 to 255; that means, total 0 to 255; that means, I can store any of distinct 256
values 2 out of 256 values distinct values I can store any one of them. Now if this 8
would have become 16, then my maximum range would be 2 the power 16 minus one
right that is the maximum value that I can store it.

Now signed and unsigned mean sometimes in our presentation we keep one bit for the
sign part in that case of course, the range decreases, but if I go for unsigned, then we
remaining within say 16 bits to bytes.
I can have a larger representation we will go will encounter these details as and when we
need them.

Now, let us come to some examples of the data types. You can see integers 0, 25 minus
156 all these are examples of integers. Now here I am for the first time showing some
characters. Now the character values are you see the character values have got something
special say I am declaring some variable char as type char my variable, I name that my
var my var is of type character and I assign I want to assign to my var I want to assign
that my variable will hold the character a.
Now, when I am assigning a character, then I have to put a single quote around this. For
example, I had another variable int yourvar. Yourvar is another variable which is of type
int. So, if I assign into that in yourvar then I can stay to say an integer value 10, but when
I right onto a character a character constant has to be always in cap, I mean encapsulated
with into single quotes right as here.
Now, this single quote within the single quote is a character slash, what about this this is
just single quote single quote; that means, we win that there is a blank so; that means, I

am see if I say myvar is assigned this; that means, myvar will be assigned a blank
character. Now you should remember that each of these characters, that we type in have
got an ASCII value each of these characters have got an ASCII value.

What is ASCII? ASCII stands for American standard code for information interchange.
Now according to this table for every English character a b c d and capital A B C D and
1 2 two everything up to 9 or all of them have got some particular code American
standard code and that is accepted in all the computers. So, whenever I type an a, when I
strike the key on the keyboard when I strike the key a right whenever a strike a then
actually when I as I press a what goes inside the computer is an ASCII code of a alright.
Now, this ASCII code of a will be store therefore, and the code for b the quote for capital
A are all distinct. So, whenever I type in a character from the keyboard a particular
ASCII code goes in whenever I assign some value to a variable for example, as I did
right now myvar signed a this means that myvar will now, have done the ASCII code of
a alright it will have the ASCII code of a.

Now the third variety that is these three are very common float for example, 23.54 or
minus 0.00345 25.0 or I can also write it in this way. 2.5 E12 what does this mean?
This means, it is 2.5 times 10 to the power 12, what does this mean? This means 1.234
times 10 to the power minus 5, because it is E minus 5 here it is E 12 I can use capital E
or small e that really does not matter these are the examples of floating point constant ok.

So, if I have a variable like float x and I assign I can assign x to be say x is 1, y is 1, z is
another one. So, I can assign x to be 23.54 semi colon or I can assign y to be 2.5 E 12
and z to be 1.234 E minus 5 alright.
That means now z will have the value 1.234 times 10 to the power minus 5 that is how
we represent the floating point numbers given this. So, this part is clear that is how we
write the variables now and the these are the examples of data types.

Now, coming to constants the constants can give integer constants on floating point
constants just the once that we I was showing right now. But there is another type of
constant character constant so on. We have already seen example of character constants
of single character like we had say a sorry what is happening here; can have a single
character like A or say x all these within a single quote a single characters, and there is
another type of character constant which is a string.
For example I can have a string which is another type of character constant which is not
a single character, but a string of characters. For example, I want to write down my name
the name of a person. So, string type variable name to name and I can assign some value
to the string like say g o p a l alright. So, this is a number of characters taken together is
forming a string of characters, it could also be named to be x 1 2 y double quote. Now
note that in this case I am using double quote where is for single character I was using

single quote. Now these are some of the rules of defining character constants on numeric
constants in C.

Next we move to you have seen the integer constant. Now couple of things to be just
mentioned that the maximum and minimum number of values, that can be stored as an
integer constant is dependent on how many bits are allocated for the presentation. For
example, as I said that for 32 bit representation, I can have 2 to the power 32 different
combination alright. So, if you compute this you will find that on one side here is 0 when
everything.
If I take one bit to designate positive or negative, then I will be left with that 31 bits. So,
the maximum I can have on the positive side is 2 to the power of 31 minus the 1 middle
one is 0 alright and I can go up to this and on the other side I can go up to 2 to the power
minus 2 to the power 31 right. So, this is the range, there is a maximum integers and the
minimum integer that I can represent.
But; obviously, we need not be so concerned about it, because that varies with the
number of bit representation in the machine. So, for a 64 bit representation; obviously,
this size will be doubled; will be much larger I am sorry it will it will be much larger.

So, we have also seen floating point numbers just now. So, I do not need to repeat this,
and where it why are we going for this this type of why are you going for exponential
type of representation, because that enables us to represent much larger numbers and
very small numbers also using less number of bits because I can always write 0.123 into
10 to the power minus whatever.
So, here minus 12 I could have written minus 15. So, it has got 2 num 2 parts one is the
mantis apart that is this part I just put the decimal part 1 2 3 be present in binary
somewhere and on this side I put some bits for the exponents. So, it can be minus 15 plus
15. So, using less number of bits I can increase the range and can go for a much larger
range of a presentation.

This one we have already explained that single character constants, now here of course,
you can see that this operator plus also has gotten ASCII quote every character has
gotten ASCII representation whatever we have we find on the keyboard has gotten
ASCII representation. Therefore, I can also have capital z or plus as a character now here
is something that is a little new to you we have already encounter one of these as a friend
earlier, here you can see that we are using a special character like backslash.
This backslash means that whatever is following a backsplash is not the normal nature of
that for example, if I write n, it really does not mean an a character n, but backslash n has
got a different meaning alright. For example, suppose I was writing something printf say
I write you have seen that example earlier printf suppose I am just writing a b c and then
I put backslash n; that means, I am I will be painting a b c, but after that I will not print n,
but since its backslash n, its a some other information it is telling us that go to the new
line. So, immediately we go to the new line. Similarly we can see that backslash t this
one is the horizontal tab.

So, if I have backslash t my cursor will move from here to some fixed tabular distances
right.
Backslash now you know single quote or double quote; single quote if I put a charac if I
just want to print the characters single quote how do I do it? I will do it because any
character have to do it in this quote. Now if I put single quote here then it will be
confused it will take these 2 and will take a blank character in between, because a blank
character is represented as n is blank with into single quotes, but I really want that here
not blank, but I want to print the single quote.

So, in that case what should I do? For this should take the signal quote and then
backslash single quote back I mean single quote; that means, this single quote is different
from these 2 single quotes. So, these are the boundaries of the character representation
and what is the character? That is single quote similarly for double quote you can now
very easily reason that I must enclose it with in single quote, and then backslash double
quote followed by single quote .
Similarly, if I want to print backslash what should I do? Single quote then backslash; that
means, it is something different, backslash single quote similarly backslash null is
backslash 0 alright.

So, these are some special character constants that we may encounter during our
programming practice. The other new things that we have learnt is string constant; now
string constants are us are sequence of characters its a sequence of characters enclosed
within double quotes.
Just like we wrote that the characters may be the characters within the double quote may
be letters, numbers, special characters bank blank spaces like that for example, nice good
morning this is a blank here, now what will happen with this. When I put this as a string
do not think that it will be computed and printed as 9. It is just a string that will be
printed. So, if I write in this way within double quote if I write three plus six then just 3
plus 6 that string will be printed. The difference between the with character constants is
that, backslash I mean the single quote c this is a character this is a string and they are
not equivalent.
Because their representations we will see we will be internally there will be represented
in a different way this one has got an equivalent integer value that is ASCII code
whereas, this does not have an ASCII code this is something different where they will be
c and something more which will see later. So, string constants thing only thing to
remember is, string constants are a sequence of characters which can be letters numbers
expressions whatever this sort of operator special characters enclosed within double
quotes alright that is a string character .

Now, we already know what variables are. So, we do not need to repeat that.

And we have we have seen the variables.

We know that the variables are to be declared and the general syntax is a particular data
type.
Sorry is it will be a particular data type followed by variable list right. So, like examples
we have already seen, int velocity distance int a b c d, a b c d velocity distance all integer
variables temperature is a float temp is a floating point variable, flag option these are
character type of variables we have already seen them right.

Now, we come to something that we evaded till now. Pointers have got big role in C
programming, but we will just have a very simple look at the pointers. Here pointer
means basically address alright. So, you please forget about the title for the time being, a
variable is assigned a specific memory location that we know and that memory location
is assigned by the compiler. So, if we have some variable say when we find out int a b c.

Then as we have discussed earlier a b c are three memory location, which are the sign by
the compiler which of these memory locations actually have got an address right. So, the
address can be say this is 1350 is an address just like our houses have an address just like
your rooms have got some numbers, just as your drawers may have some levels. So,
similarly might be this is 1400, this is say 1450 or 1420 suppose a b c has got this 3
addresses are right.
Now, when I read when I try to read something, we know that I need to scanf. Now in
scanf what I did is percentage d and a; that means, I am trying to read the variable a, but
I did not explain to you earlier why I put this. And this and means that and you know
what is this percentage d. So, I have got some space some space to hold an integer and
that space is the in the a variable, but when the you from the keyboard type in say the
value 25.
When will that value go? The value will go to the address of the variable a, what is the
address of the variable a? 1350. So, it will go to 1350, 25 will come here similarly when

we write say scanf percentage d, percentage d comma and a and b then I am going to
read 2 values and 2 integers, and the address of the first once upon suppose type in 25
and 27. So, for the add 25 will go to the address of a that is a 1350 and 27 will go to the
address of b that is 1400.
Given this lets now read this a variable is a sign the specific memory location we know
that. For example, of variable speed is assigned memory location 1350 and assume that
the memory location contains the data value 100. So, when we use the name speed in an
expression it refers to the value 100. So, for example, when we write distance is speed
into time, then it will take this speed from this location 1350. Every variable has an
address and its contents. So, we have seen a has got an address a is a variable a has got
an address 1350.
And when I write the 25 into that 25 is a content. So, address and content we had earlier
discussed also.

But you see here integers speed I think you can read it and. So, speed is this particular
location that is in 1350 and when I right when I write speed equals speed assigned 100,
then 100 is written over here alright when I assign it. So, speed is getting the value 100
whenever, but when I say what is and speed when I am asking the question what is the
address of the variable speed, what is the address of the variable speed and the answer
would be 1350.

So, this and sorry this and operation this and operation is nothing, but asking for the
pointer to speed or the address to the variable speed. So, this should be the answer. So,
and of suppose here time is given here, if I just say and time what will that be returned
what is and time? And time will be 1351 something of this sort alright. So, that is another
thing that we needed to understand what is the purpose of this and.

So, here in C terminology speed refers to the contents of the memory location, and speed
refers to the address of the memory location corresponding to the variable speed. So, let
us come to this example printf percentage f percentage f percentage f; that means, I am
going to print three floating point numbers and what are the variables c floating point
values speed time and distance; that means, what am I going to print look here I am
going to print the contents of the memory location speed, the content of the memory
location time, the content of the memory location distance.
And when I am reading percentage f percentage f and speed and time; that means, what
that I am reading where I am reading in the address of the variable speed, I am reading in
the address of the variable time. So, this is required to be understood. So, basically when
I have say speed I once again repeat, suppose speed is 25 and I print speed; that means, I
am printing the content of this location speed, but whenever I am reading into speed
where am I reading the value? I am reading into the address of speed that is this location.

That is the main difference between these 2 alright. Let us stop here in the next lecture,
we will straight way move head to write some c expressions, because till now whatever
we have learnt are the bits and pieces the tools of c that is how the how just like in the
language how the word are written what are the some of the simple rules, but then we
will have to learn writing the real sentences in a language. So, that it we will start from
the next lecture
Thank you

In the last lecture, we encountered a special notation as if like this where we can put in
ampersand and a variable name to denote the address of the particular variable right.

So, that is what we encountered in the earlier class. Next we will be now we will be
moving ahead towards some statements which are absolutely essential for writing any C
program.

Just as in English, we write different types of sentences, similarly in the language C just
is as it is a language there are again different types of statements that we can write, and
through which we can express what we want to do. The simplest type of statement that
we have already encountered about is assignment statement. Assignment statement
means I have got some contents in some resistor; some resistor say X some memory
location say variable x and has got some value 50, now how does this value come over
here? Initially it was not there. So, suppose I have got memory location variable say
speed, and I want to put in some value into this location alright say 500. So, what we do
we write speed assigned 500 semicolon.
So, the general syntax for dot is a variable name followed by the expression; as you have
written here speed is a variable name and the expression here is nothing, but the constant
alright it could be something else.

For example, I could have written speed assigned 2 times 500 or may be v times q
whatever speed is assigned v times q. I and here are some examples of such assignments.
As you can see here velocity is a variable right on the left hand side the variable name is
there, on this side is an expression now what type of expression is this? 20 is nothing, but
a constant value. Please note that all the statements must be ended with a semicolon you
get the second. B assigned 15 again a constant. Look at third one temp assigned 12.5. So,
what type of variable is temp? You will immediately answer temp must be a floating
point variable of real number.
Here you see a different type of expression a variable A is being assigned the variable A
plus 10 what does it mean. So, A assigned A plus 10. So, A being a variable, A is a
memory location and suppose it has got some value 25.7, if A is a floating point variable.

Now if I do A assigned A plus 10; that means, whatever is there in the as the value of the
variable A is taken out. So, we take out we read 25.7 add 10 with that and we get 35.7
and then this 35.7 comes in here and I get a new look of A the same location, will now
hold 35.7. So, you see the left hand side if the destination, where the new value occurred
computation of the expression will go. And the left side sorry the right side can have the
same variable of the source or might be the sum of a variable could be sum of the
variable also like here this expression you see, I am using 3 variables here.

V is one variable, u is one variable I am sorry I am using 4 variables here, f is another
variable and t is another variable.
Now, suppose you have got some value 20 f have got some value 0.5, and t has got some
value 2. Then v is being computed as u is been taken 20 plus the product of these 2 2 and
5. So, 2 and 0.5 will be 1 and 1 is being added to 20. So, these 2 being added is
becoming 21, and this 21 is filling up this variable v alright. So, here you see I can use
more number of variables, I am sorry this is must be a little nice. So, it should be 21.0.
Similarly here you see if they mix up variables how many are here s if a variable u is a
variable t is a variable f t t, f t. So, 1 2 3 are there again u f t and s alright and there is a
constant 0.5. So, this side entirely this side is the expression.
Similarly, this is again an expression, this is an expression this is also an expression will
see more of these expressions in a moment alright.

So, a value can be assigned to a variable when the variable is declared for example, when
I am declaring a variable, just starting I want to declare a particular variable and. So, I
want to declare a variable may be acceleration. Acceleration alright now when and I say
that acceleration is a real number. So, when I declare it I will write float acceleration, and
then at some point later on I can say acceleration assigned say 2.5, this is one way. The
other way is that I could have written it when I declared it a float acceleration assigned or
initialised to 2.5 this is also allowed in c. So, a value can be assigned when it is declared.

(Refer Slide Time: 09:13)

For example here speed is an integer, which is being declared as an integer and along
with that it is being assigned the value 30. Here you see the char is a type of another
variable flag and when I am saying that it is a flag is a character, I am along with that I
am also assigning it to value y.
Now, you understand you remember that within the single quote means it is a did the
character string. So, I could have done it also like this char flag, and then alter on flag
assigned y that is equivalent to what i did here. Several values can be assigned the same
value using multiple assignments operative what does it mean? As soon as we see the
example it will be clear for example, a b c all these are being assigned the value 5 flag ne
and flag 2 both are being assigned the value y, speed and flow both are being assigned
the value 0.0. So, here say for example, the correct thing would be to say float, speed
flow are assigned 0.0. So, that is the simplest opposable way we go about it.

Now, when we write an expression, first thing we have seen now is the assignment
statement. Now in the assignment statement if you have seen the earlier slide we were
using some operative. For example, u assigned say v minus f times t right. So, these are
an; this is an assignment statement here is an assignment, but on this side I have written
an expression.
So, how can we write an expression in c. We have seen quite a few examples of that
expressions in the earlier slides right, we have seen different types of expressions like s
assigned u times t plus 0.5 times f times t times t. So, this is you will immediately recall
that this is our standard school formula f is equal to u t plus half f t square right. Now this
expression has got 2 components, this well-known expression in school has got 2
components. One side is the expression here which has to be computed and then that has
to be assigned to another result of other variable. So, that is being written here. Now this
is the way an expression is written in c you cannot just write it in this way as we are
doing in our school, this is not possible we have to write it in this way ok.
Now, here when we write this expression you please observe a couple of things, look at
these this, this, this. These are known as the operators you have this is meaning
multiplication this is meaning addition these are again multiplication symbols. Now
these they are sets of allowed operators in c. Just as every language allow some contrast
to form sentence and some of them are not some other contrasts are not valid in a

sentence formation, similar to that in the programming language c or for that matter for
any programming language there are some allowed operators by which we can form
expressions. So, we have got 3 types of operators the type of operators; that we have
encountered till now we have seen till now are arithmetic operators, but besides
arithmetic operators there are 2 other types of operators called relational operators and
logical operators ok.
(Refer Slide Time: 14:30)

So, let us see a little more of this arithmetic operators, these are the some of the very
familiar arithmetic operators you know that this is, this means addition normal
subtraction, this is division, remember unlike this sort of division we use in schools we
use here this symbol for division. Unlike this symbol that we use for multiplication, here
we use this symbol and new symbol that we are introducing here is this symbol, like the
percentage sign. Now this does not mean percent computing percentage, it means
modulus what does modulus mean? Say the modulus means finding the remainder for
example, if I compute 15 modulus 3; that means, I am dividing 15 by 3 and whatever is
the remainder is my result. So, what is my remainder here? Remainder is 0. So, modulus
is basically the remainder operator. So, another example let us look at.

Say I have got 27 modulus 2 what would be the result be? 27 divided by 2 the quotient is
13 right quotient is 13 and the remainder is 1. So, this modulus would be 1 whereas, if I
has done 20 6 modulus 2 that would be 0.
Now, again I have got if I instead of modulus operator if I had done 26 divided by 2 the
result would be 13. So, this gives you the quotient whereas, this gives you the remainder
alright. So, this is a new operator that we are coming across and you should keep that in
mind next let us proceed.

And here some examples distance is rate or velocity or speed multiplied by time. Please
note again as I have told earlier also that any expression must end with a semicolon as is
being done here what does it this mean? Can you read this variable, can you read this
variable it is meaningful net income is income minus tax. So, operator is minus this is the
arithmetic expression and this is the arithmetic operator. Speed is distance divided by
time again ended with a semicolon speed is distance divided by time how do we find the
area of a circle? Pi you remember pi we can define pi we had seen this example earlier
has defined pi 3.1415 etcetera, etcetera, we could have done that. So, pi is a constant
times radius times radius. Here basically what I am computing is area is being assigned
is the assignment operator and the expression is pi r square. Now this expression I am
writing in this way pi times r radius times radius.

Here is another expression y assigned a x square what does it, how does it how do we
write it typically in school. This is expression which is a x square plus b x plus c alright
this is a very familiar expression of a quadratic expression. Now when we write it again
here you see how many operators I have got 2 multiplication operations 3 multiplication
operations and 2 addition operations right and one assignment operation. So, here again
quotient is divided by divisor. Now this is exactly what I was telling a couple of
moments back, that this operator is actually turning you the quotient alright of a division
operation and this is actually giving you the remainder of a division operation. So, here
are some examples of arithmetic expression.

Suppose x and y are 2 integer variables, and the values are we know 13 and 15. When
added to y x plus y arithmetic operator plus will give me 18 x minus y 13 minus 5 will
give me 8. Now the point to note here is that here again always try to think in terms of
our memory location diagram x and y are 2 variables, x is 13 and y is 5. So, x plus y
means the content of the location x plus the content of the location y; x minus y is the
content of the location x minus the content of the location y.
Similarly, when we multiply it is 65, now if I add an assignment with this operation with
this operation I just add a assignment for example, I write I am giving 2 variations z
assigned x times y; that means, what? There is another location with where the content of
x and the content of y are taken and multiplied and 13 times 5 is 65 that is stored there
and that is possible because I have assigned it here. Again I could have assigned
alternative could have done x assigned x times y what would have happened in this case?
The content of x would have been taken 13 multiplied with a content of y that is 5 13 and
5 would be 65, and this product 65 where would that be written? It would be written in x
why because it is being assigned to x. So, then this would be over written with 65.
Similarly, we will recall now x divided by 2 is a division from expecting the quotient 13
divided by 5 what will be the quotient 2, but x modulus y would be the remainder of
when I divided 13 by 5. So, that modulus is 3.

Now, in an expression we can have different operators. If more than one different
operator occurs in a particular expression how will that expression be evaluated. So,
now, we are concerned about how we will evaluate or find the result of computing an
expression k. Now here is a list in decreasing order of priority. So, if I have something
like this say x assigned p plus q times z minus x divided by l plus m. Now here you can
see that I have got different operators what are those? Our well known operators are plus
multiplication minus division plus again here is another operator that is parentheses.
Now as we learnt in school algebra that the parentheses has got the highest priority
alright. So, I will first compute the elements which are within the parentheses. So, first p
plus q will be computed then l plus and l plus m will be computed now out of this p plus
q and l plus m which one will be computed first? Whenever these 2 that are these are of
the same priority this parentheses, now if there will be more than one operator of the
same priority they will computed left to right.
So, first we will have p plus q computed alright suppose that is something, say let us call
it a some value A times Z minus X suppose this is computed to be some constant B. So,
in that way it will be computed. So, the parentheses has got the highest priority next after
parentheses is unary minus.

Unary minus means usually when we write something like x minus y, then I have got 2
variables on which I am carrying out this subtraction. This is binary operator in the sense
that I am leaving 2 variables of 2 constants 2 elements and which I am carrying out this
computation. Unary minus means that particular variable is being operated on for
example, if I had something like this minus x plus 7.5 semicolon and suppose x was 2.5
n. So, what will be the value? X is 2.5. So, for this will be done. So, it will be minus 2.5
plus 7.5. So, the result will be 10 5; it is not that I will first compute this 2.5 plus 7.5 and
then do negation alright.
So, the unary minus. So, here I have shown a variable, it could be something constant
also minus 2 plus 6 that means, you all know that 6 subtracted by 2 although it is plus
because this has got the higher precedence.

The next one is multiplication division and modulus. These 3 will have the same priority
multiplication division and modulus these 3 operators will have same priority therefore,
if I have an expression like say x division y multiplied by z modulus q how will that be
which one will be done first? This, this and this have got the same priority therefore, we
will carrying it out left to right alright, but if the expression was something like this
minus.

X divided by y multiplied by z modulus q then which would be done first? First is unary
minus should be done first followed by these 3 candidates which will be done left to
right left to right.

Next comes addition and subtraction. So, if I have got an expression again like say x
times y even before that if we put it, p plus x times y divided by z minus q then in which
order would it be computed? First plus will not be computed multiplication has got an
higher priority this also has got an higher priority. So, out of these 2 which one will be
done first left to right? So, first I will do this suppose this is yielding a result A. So, it
will be p plus A then divided by Z minus q and then this one will be done because left to
right of the same precedence suppose it is B then it turns out to be p, it turns out to be p
plus b minus q alright. Now out of this plus and minus have got the same priority then
which one will be done first this part will be done first, suppose that is c, c minus q this
is how this entire operation will be done.

For operators of the same priority the evaluation is from left to right. In the next class we
will see some more examples of this and we will proceed further.

In the last lecture, we were introduced to the precedence among the operators, and we
had seen that parentheses has got the highest precedence followed by unary minus then
multiplication division module, and modulus have got the same priority addition and
subtraction are having the next priority. And for operators of the same priority if an
expression there are more than one operators which are of the priority then evaluation is
done from left to right.
Only one thing we did not mention and that is if we want to change the precedence of the
evaluation, then we can always do it using parentheses because we know parentheses is
the highest priority one or so, over riding scenario. So, let us look at some examples for
this which will make the idea clear.

Here are some examples arithmetic expressions; here you can see a plus b times c minus
d divided by e. Now according to my precedence rule, this is equivalent a plus as if I
have if I have done it hand computation. If I had done by hand computation how would I
have done there is a chance of confusion, somebody could have done a plus b and the
whole thing multiplied by c etcetera the you know even in school level in order to avoid
such confusions we use parentheses. And this is equivalent to this scenario that a; this b c
are parenthesized and d divided by e are parenthesized. So, first this will be done then
this will be done why b into b times c first, because it is left and this is right, right.
So, first this then this then addition and sub. So, let us see how you will break it down.
Again we will have first b times c will be done followed by b times e then we have
suppose this result is x and this result is y. Then my expression is a plus x minus y now
out of these again these 2 they are the same precedence. So, first this will be done
suppose this is z minus y that is how the computation will go on.
Here what is the significance of this? The critical point to note here this part here there is
an unary operator. Therefore, during computation what is it means the computer will
automatically assume that this parentheses are there alright. If you had not wanted that
then you better write in some other way put it some other way. So, that the confusion is
not there. The computer will not allow the compiler will generate the code in a way that
it will be treated as this a times first minus b will be done, then this one is the highest

precedence next highest precedence. So, this will be done, then multiplication between
these 2 will be done now I am sorry I am sorry here normally if I had done this what
would have happened.

First of all I will be doing minus b and by capital letter I am writing some constant value
alright. So, b is right now is 5. So, first after computing this it would be a times minus 5
because b was 5 plus suppose d was 100 and e was 9. So, what is my modulus 1 right.
So, then I am I will be now at this point, I have got b modulus e minus f.
Now, at this point which one has got the higher priority? This and this, now since now I
have put a parentheses here therefore, if I put a parentheses here then this will be done
first otherwise this would be would have been done first; because this multiplication has
got the same priority as this and put it in a place to write now. So, similarly here a minus
b plus c plus d.
Now, here these are having the same priority left to right, now I want it would to be done
in a particular order therefore, I have put the parentheses in such a way that a minus b
should be done first, then a minus b plus c will be done first then d will be added to that.
That would have been done anyway why because since these are of the same priority that
would be done left to right. So, first this would be done, then this would have been done
then this would have been done either way.

Here also the same I can write in this way, but that is the precedence is being shown in
the form of bracket.

But here this is an example, where I use parentheses to over write the precedence. The
precedence between this multiplication and this modulus was the same, but just by
putting this parentheses there, I have forced this to be computed first. Similarly here now
normally given this, this would be done first, then this would have been done, then this
would have then then additions would have been done.
But I have over written that by saying that wait first you do it a plus b, then you multiply
c and d multiplied e that is there anyway, and then you do the addition, but this is
actually over writing the normal precedence. So, you should I mean with a little bit of
practice we will initially we will make some mistakes, but then gradually with practice
that will go away n and all of you will be able to write it fine.

Now, we are coming to a very important concept of this arithmetic expression evaluation
integer arithmetic.
What does it mean? It means that when the operands in an arithmetic expression are
integers, then the expression is called an integer expression and the operation is called
the integer arithmetic. Integer arithmetic always deals integer values, it will always
yields I am sorry it will always yield integer values. So, it will be clearer when we take
some examples.

On the other hand real arithmetic is arithmetic operation involving only real or floating
point values.
For example here you can see this expression 1.0 divided by 3.0 multiplied by 3.0. Now
all these are operands now here is I would like to introduce a term, when I say a plus b
then this plus I call it as an operator, and these I call as operand on which the operation is
being done. Now in real arithmetic all the operands are floating point numbers.
Now, sometimes the floating point values are rounded to the number of significant digits
because it may be 7.5976 like that you can go on, its often rounded to the number of
significant digits permissible in the particular machine, we get an approximation of the
results. Now one thing that we have to remember is that the modulus operation is not
defined over real operands.

So, I am not allowed to do 3.5 modulus 2.1 that is not allowed. The modulus operation is
allowed only for integer arithmetic.

Now, we can also have mixed mode arithmetic, where some of the operands are integers
and some are float or real in the case we call it a mixed mode arithmetic expression. If
any of the operand is of real type then only real arithmetic is performed and the result is
a real number this is this example will make it clear.
Now, you see here look at the first one 25 divided by 10, both the operands this operand
and this operand both these operands are integer therefore, when I divide by divide them
I get an integer quotient or integer result whereas, if one of the operands was integer and
one was real if at least if even one is real, then the result will be real. So, what is
happening here? This is becoming like 25.0 divided by 10.0 so that will become 2.5
alright.
Now, here on the other hand since both are integers the result will be integer. So, let me
just put in one twist on this. Suppose now here 25 divided by 10 is actually what? Is a if I
divide it, it is also 2.5 right 2.5, but since this operator is nothing, but an integer division.
So, it will in out the quotient and the quotient is an integer the quotient is 2, if I had done
25 modulus 10 what would my result be? The result would be 5 as a integer right. So, we
could understand what is meant by mixed mode real mode, and integer mode of
arithmetic we will see some more things later.

Now, there are some problems of value assignment for example, in assignment operation
we actually take the expression value and assigned it to a variable or we assign a
particular variable to another variable. For example, we could have as we have done say
something v is u plus f times t, this is an expression value is going first it will be
computed and the value will go to v. So, the value is going there right on the other hand I
could have done v assigned u; that means, the value of u is going to the this variable here
also, this value is going here the value of an expression here just a value of a variable.
But the most important point is that the data type of the right hand side should be
compatible with that of the left hand side ok.

Now, if for example, I say v assigned u and u is a float and v is an int, then may I may
have problem what type of problem can I have? Suppose u is 25.7, I assigned this to v.
So, v can only take an integer value. So, in most of the cases we will get an error why?
Because you know that depending on the computers, depending on the different
architectures integers are often 2 bytes and floats are given 4 bytes.
So, you are trying to track in a large number I mean a 4 byte into a 2 byte space the space
is not there. So, the errors can come, in some cases may be they will cut it out and
represent it as ignore this part and you will not understand it will just assign 25 to v, that
is also an error that is skipping in now this is this error will go unnoticed. If the compiler
catches it which is mostly the case, in that case you will you will the compilation error
will occur and we will understand that it is not working alright.

For example as I said the 4 bytes floating point number is not allowed to be assigned to a
2 byte integer variable.

So, sometimes what we do this is an new concept called type casting, look at this
example. Here we have defined x to be integer. So, x have got 2 bytes, suppose that I
show 2 bytes for x and r is floating number which has been represented through 4 bytes.
Now sometimes what we do we type cast this thing 2 times r will be what 2 times r will
be float? Because the r is real and. So, if one of the operators are real, then it this part

will be a real arithmetic, but then that result and casting back to int. So, this operation is
called the type casting operation; that means, whatever I have I have casting that o fit it
in a way. So, that it can fit in as an integer ok.
Here is the another example say perimeter has been defined as double; that means, it can
have twice the floating point space. Pi is a float three point one 4 now you see this is pi
we have encountered that pi earlier, but here this pi is not the constant which has defined
as the pi, but pi is a variable, which has been initialised at the time of declaration and r is
an integer.
Therefore when I am computing perimeter is twice pi r. So, what am I actually giving?

I am trying to compute 2 pi r right the circumference of a circle. So, twice 2 is real now
pi dot r perimeter is doubled. So, I want to have perimeter with a larger accuracy
therefore, I first make r to be doubled, I type cast this integer to a double retype, I type
cast this float to a double type then I multiply and get the perimeter. So, this is another
very powerful operation, which we often need for scientific computation.

So, type casting of a floating point expression to an integer as is shown here, and the type
casting to double has been shown here we have already explained that.

Now, we have till now looked at arithmetic expressions, how to form arithmetic
expressions, and arithmetic expressions are formed using arithmetic operators. Besides
arithmetic operators there is another very important type of operator called the relational
operator. A relational operator is used to compare 2 quantities let us see for example, this
symbol say very familiar denotes is less than, this symbol which is also familiar shows is

greater than, this symbol is less than or equal to this, sometimes in our normal course we
write it in this way, but in a computer we cannot write it in this way we have to write it
less than equal to alright.
Similarly, greater than equal to unlike the greater than equal to that we used to write in
this way, we have to write here greater than or equal to now this means greater than or
equal to that is well known to us.

Next here is another operator this requires some discussion is equal to. Now earlier this
is very important to know than this is a very source of a very common error and common
mistake. Typically when we say in our normal arithmetic x equals y we meant that the
value of x and the value of y are the same right, but we have seen that in c language this
actually means the variable x is being assigned the value of y right.
So, how do I compare whether these 2 variables are equal or not, for that c provides this
technique of using 2 consecutive equal it is find to show x whether x is equal to y alright
we will come to this in a moment, there is another operator that is not equal to again.

Let us compare to what we had in school, we used to write something like this in c we
used to write it with this exclamation mark followed by equality, this is means it is not
equal to alright.
Now, a very important thing comes into the play whenever I am using this relational
operators what do I get? If I write x less than y in an now we know that what are these x
and y? These are 2 operands and what is this? This is on one operator. So, when I carry
out some operation I will be getting some result. So, if I had done x plus y and suppose x
was 5 and y was 7, then x plus y would have given me what 12 would have resulted into
12, 5 plus 7.
Now, if I do this x less than y; that means, 5 less than 7 what will this give me? It will
any relational operator gives me only true or false 1 or 0. So, when I say x less than y
and x is 5 y is 7 it is true therefore, x less than y in this case will return 1.

If I write y less than x, it will return me false because y is 7 and x is 5, then this will be
false this will return 0 ok.
Similarly, for greater than y greater than x will return me in this case is for this particular
value set, y greater than x will give me true one or it conceptually we can say true that
this true cannot be represented as t r u e in a computer it is this in c it is represented as 1.
Less than equal to in this case what would we have what would have happened? Y less
than equal to x is it true or false less than or equal to in this case is y less than x? No is y
equal to x? No therefore, it will be false.
Y greater than or equal to x what would have happened? Y is not greater than is greater x
not equal to x therefore, it immediately becomes true y is y equal to x in this case no. So,
it will return false y is not equal to x is it true or false it is true therefore, it will be one.
So, what we could have observed is we can form expressions using relational operators,
but these expressions only return the values true and false ok.
We will see that these relational operators if you recall in our flowchart discussions, we
often had some decision box is shown as rhombus and in that decision box we used to
say x greater than 10 or say.

We used to write something like N equal to 3 right yes or no right we have taken one
path for yes one path for no and that can be captured very easily using such relational
operators as we will see.

Now, here are some other examples or I have already given you enough examples 10
greater than 20 true or false, it is false 25 less than 35.5 yes it is true, 12 greater than 7
plus 5 now here if one of the operands is an expression that will search the evaluated. So,

the arithmetic operators and expressions have higher priority over relational operators
alright.
So, here what will happen 7 plus 5 will be first computed. So, that is 12 if 12 greater than
12 no. So, it is false. So, when arithmetic expressions are used, on either side of a
relational operator the arithmetic expressions will be evaluated first and the arithmetic
expressions will be evaluated in accordance with a precedence that we have already
defined. So, if there will be something like this a plus b greater than c minus d that is
equivalent to, first I will compute a plus then I will compute c plus d and then suppose a
plus b is 10 and c plus d is 17, then this will lead to false first these will be computed
then the relational operator will be computed.

So, here is a quick look at an application of this, suppose I want to implement the
flowchart something like this, I have read x and y and I want to do x greater than y if so,
yes I will be say I will print x is larger otherwise I will print y is small otherwise I will
print y is larger yes. So, that sort of situation how will that translate into c language here
you see this part we have not discussed, but is very intuitive you can understand. If x is
greater than y, I print what is larger dash is larger then what will come here the value of
x. So, I will print say x is 10 and y is 15 n this is x and this is y then what will be printed
here? 10 is not greater than 15. So, this part will not be executed will come to here

because x is not greater than y. So, we are taking no path, and we will print dash is larger
and in dash what will come the value of y that is 15.
So, what will be printed is 15 is larger. So, that is how we can implement this sort of
decision box and when I have that the choice between path based of the decision, that is
being a condition is being computed using relational operators which this conditions are
telling me which path I will take if the is the situation true if. So, I will take this path
otherwise I will take this path this is known as these are (Refer Time: 30:06) of the
relational operators.

So, next class we will start with logical operators, today we have discussed about
arithmetic expression how arithmetic expressions are formed using arithmetic operators
and what are the very important thing that we discussed today is, you know in the earlier
lecture also lecture that what is the precedence till now, why what I have discussed is
that what is the precedence of the operators in an arithmetic expression and what is the
relational operators. And we have seen that relational operators have the lower priority
than arithmetic expressions. So, if I am either side of the relational operators the
arithmetic expressions those will be evaluated first, in accordance to the arithmetic
operation priority. Next we will come to another very important concept that is logical
operators.
Thanks.

In the last lecture we had talked about two different types of operators, relational
operator and arithmetic operators. Today we will be discussing about the third type of
operator which is known as a logical operator.
Logical operators are also known as logical connectives. So, there are two essentially
there are two logical operators in C, one is logical AND and the other one is a logical
OR. Now, what do they do? They act upon the operands themselves which are logical
expressions. For example, let us say I am writing a logical expression temperature is
greater than 50, now this will this statement suppose the temperature now is 40 degree
centigrade then temperature greater than 40 greater than 50 will result in false value,
because the relational operator will always generate either true or false. And suppose
there is another logical expression a times b plus c is greater than equal to 25, now this is
another logical expression sorry this is another relational expression. On the left hand
side of this expression I have got an arithmetic expression and on the right hand side I
have got a constant and I am connecting them with a relational operator greater than

equal to. Now, if a times b plus c is greater than 25 or equal to 25 then this will result in
true.
Now, I can connect these two this one and this two together and write another expression
like temperature greater than 50 and a times b plus c is greater than equal to 25. Now,
this expression is a combination of two relational expressions and a logical operator a
logical connective. This logical AND means that this entire thing expression will be true
or will result in a 1 if both of them are true. So, if the temperature is 40 then this will
become false or 0 and if this is 25 then this is true, but 0 and 1 both are not true therefore,
this 0 and 1 will result in 0. But suppose if the temperature was 50 and a times b plus c is
equal to 25 or greater than 25 then this is true and also this is true in that case these two
together and because they are ANDed then this will be true.
So, the logical AND operator what it does is it turns a true value or 1 if all the
components of the expression logical expression connected by the AND operator, logical
AND operator is true.

Now, one thing you can note here that since this ampersand is a character and we have
already use this ampersand in expressions like AND scanf and we have discussed that
this AND actually means we are trying to get the address of a particular I am sorry I am
sorry absolutely sorry.

I actually what I write is scanf etcetera percentage d and velocity say where velocity is a
variable alright. So, this AND in that case you is used to mean the address of this
variable velocity.
So, in order to differentiate between this usage of AND and the logical operator logical
AND is denoted as two ampersands, two ANDs.

Similarly logical OR means that some expressions say, I have I write it in an abstract
way say expression 1 or expression 2 or expression 3. Now, this composite expression

will be true if any one of them either expression 1 or expression 2 or expression 3 is true.
If any one of them is true then this entire thing will be true, if two of them are true then
also it will return true, if all the three are true then also it will be true, but if none of them
are true if none of them are true then it will not be true, then none of them will be true.
So, what is the difference between this logical OR and logical AND therefore? In logical
AND if instead of this it was written like if, instead of this it was written like expression
1 and expression 2 and expression 3 this composite and expression would be true only if
all these three expressions are true alright. So, that is logical OR.
Now, what do they do? They act up on the operands that are themselves logical
expressions why logical expressions where from did I get logical expressions I got the
logical expressions from relational operators.

For example, now I am writing some time is greater than 20 is a logical expression. What
is this? This is a relational operator, but this expression is a logical expression. Why it is
a logical expression? Because this will return only true or false nothing in between, so t
greater than 20 if t is time or whatever value t might be if that is greater than 20 then it
will return 1 or it will return 0. So, the logical connectives or the logical operators they
are acting upon the operands themselves and connecting them. The individual logical
expressions get combined into a more complex condition that are either true or false. We
will see some examples.

So, logical AND the result is true if both the operands are true had or for two operands.
If a three operands if all the operands are true, it should be connected as if all operands
are true and logical OR the result is true if at least one of the operands are true, if at least
one this is most important.
So, let us look at the truth table here X and Y any of them can have the value false or
true. Accordingly we can have four combinations X false, Y false, X false, Y true, X true
Y false and both X and Y are true. Now, if I carry out the logical AND then for all these
cases say false false the result will be false, so 0. False and one true still it will be false
because here I want all operands should be true. One is X is true Y is false the result will
be false if both of them are true the result will be true. While in the case of OR X or Y
will result in false if X is false and Y is false, but if X is false and Y is true will get a true
because I am interested in getting at least one to be true if this is true and this is false
then also true if both of them are true then also it is true.
So, I think it is clear to you what is meant by the logical operators and how we can
combine logical expressions based on that.

Now, we have seen three types of operations.

So, actually operators, one is the arithmetic operators, the next is relational operators and
the third one is logical operators. Now, arithmetic operations use of arithmetic operations
lead to arithmetic expressions. The use of relational operators lead to logical expressions
why logical expressions, they lead to true or false value right logical expressions and use
of logical operators will combine and get more complex logical expressions complex or
let me not write complex, let me write composite that communicates the meaning better

composite logical expressions, composite logical expressions. So, will see the use of this
pretty soon when we will be looking at the control operators right.
Next, just to wrap up the things let us come to the input output statements.

By the way besides this besides the arithmetic expressions, logical expressions we had
seen another type of expression those are assignment expressions or assignment
operators. By that means, the left hand side is an expression and right hand side is a
variable we assigned the result of the computation of the right hand sorry I just said the
opposite the right hand side is an expression on this side is an expression. Here on the
left side is a variable and we compute the expression and assign the value of that
computation to this variable and this is the assignment operator.

Now, besides that we have seen two other statements one is a printf statement we have
seen that performs the output to the standard output device typically when we declare s t
d i o dot h then by default it is taken as a screen. The other one and it requires a format
string in which we can specify the text we printed out and the specifications on how to
print the values like printf number is dash and that dash can be filled up by percentage d
for; that means, the specification is that an integer can come here. And then you
remember what this means this means, I am going to the new line alright and then
followed by the number. The format specification causes the value listed to be embedded
here I have discussed that that you can consider this format to be a place holder alright,
the number is dash and how can this dash be filled out the dash since its percentage d
some integer value can come and fill it up right we have seen that.
The other statement that we saw is scanf that is for reading the values.

So, it performs input from standard in input device, normally by default it is a keyboard
and then it also requires a format string and list of variables like it is required to put an
ampersand before the names of the variables, we have also explained why that is so. The
reason is that this ampersand essentially means the address of that variable where the
value that is being read will be put.
So, here are some examples, scanf percentage d and size; that means, what that I am
reading in a variable size, size is a name of a variable and in which I am putting in some
integer value alright. Similarly next char say is a say this one is a character variable. So, I
am specifying that only a character can come in here and that is why I have put in the
specification percentage C. Percentage f means some floating point number will come
here, but in all these cases this ampersand means the address of the corresponding
variables alright. Here percentage d, percentage d means sequentially I am going to read
two integer variables a and b. So, all these we have seen and you will be best learning
this by practicing it time and again and we will see a number of examples and in this
course there will be quite a few assignments which you will have to do.
Next, we will move to, next we will move to a new topic which is a control structures
and control statements. We have seen if we recall in a flowchart, let us go back to the
flowchart where we have got some computation statements where we are doing some
computations.

And we usually carry out one statement after another right that is how we do and in that
way we will go on till the end of the program. For example, read number one, read
number two etcetera divide add the numbers and divide the numbers to get the average.
So, when we computed the average it was something like this and at the end we did some
printf and in the meanwhile they were some reading the numbers these were some of
them were input some were computations right. But it was a complete sequential thing.

But if you recall the other type of, the other type of flowcharts that we had seen there we
had started we did some computation and then we took some decisions and based on the
decisions I have sometimes gone back to the earlier operation that earlier thing I had
done and otherwise I would have followed this path. Typically in the examples that I we
had sees we just see the pseudo code if I write say for computing the average of three
numbers I will be read num 1, read num 2, read num 3 and then sum equals to num 1
plus num 2 like that I add them and then I compute the average to be sum divided by 3
right. So, and then we print the sum print the average.
So, this entire thing is going in a sequence alright. Just one after another one after
another no change in the path.

But in this case for example when we try to if you recall when we are not writing the this
program in this form of pseudo code instead I initialise a count to be 3, then read number
1, sum and initially count here and say sum was 0, assign 0 and then sum is let me just
make it make it just num I am reading one number and sum plus num and then count I
decrement. So, I may count to be count minus 1 because I have, one I have already read.
Now, I check if count is greater than 0 then what I do in my flowchart, I go back to
reading the number again. Otherwise, else I come to the computation of the average
right. Otherwise, if as long as count is greater than 0 I am continuously doing this thing
right this steps.

So, here at this point you check that I am looking at the value of count and depending on
the value of count I am deciding whether I will be going in this direction or I will go
back and change the direction of the flow. So that means, as if the at this point the
execution is undergoing a decision making to decide which part it will go through this
path or this path.
As if you are therefore, you are controlling the flow of the program either in this way or
you change the path, we will see that we can change the path in two different ways. One
is that sequentially I am coming and I may go ahead I can skip some of the operations
and I can go jump forward that is also a change of the path. This dotted line is showing
the normal sequential execution or could be that some here I can go back to another path.
So, these are two types of change of flow, change of flow that is that can be resulted in
and that can be resulted in using the control structure.
So, we will soon go into the details of the control structure and see how such control
structures or change of the sequential flow can be achieved in any programming will
exemplify as we are doing for all others examples using the constructs of C, but that does
not mean that it is restricted only to C. It can be, there are similar control constructs for
other languages as well. We will come to that in the next lecture.

In the last lecture, we had an idea of what control structures are. Control structures are
some language structures which by which we can change the flow of control which
normally is sequential that means, one executed after another.
Now, in the language we just as we have statements arithmetic expressions logical
expressions all those are statements, in our language c language we also have some
control statements for achieving the control structures.

What they do? As I have said allow different sets of instructions to be executed
depending on the outcome of a logical test. So, if we go back to the flowchart, we are
coming in a sequential flow, at this point we encounter decision point and at this decision
point we carry out some logical tests for example, is x greater than 0 yes or no. If it be
yes there will be some flow and if it be no there will be some other flow all right some of
not necessarily backward it can go somewhere else etcetera all right. So, based on the
logical test; that means this test which will result in a logical value and what are the
logical values? Logical values are either 0 and 1 either true or false.

So, whether true or false that is a; this is called branching. So, again whenever I am
coming to a decision box and from there I am branching out, either in this direction or in
some other direction all right. So, this is a branching branch point. So, that is change of
the control flow.

Some applications they also require that a set of instructions be executed repeatedly, they
will be going they will be executing as in the case reading the numbers c numbers. I will
be repeating reading a number adding that with some I mean decrementing count

checking whether count is equal to 0, and then again go back and read the number and
this slope will continue based on some condition. How long in the earlier example how
long I will where we doing that based on what condition? The condition was whether
count is 0 or not. As long as the count is not zero we are going on doing this. So, this is
also known as looping doing the same repeatedly, this is also known as looping. So,
branching or if we go back to the earlier one then it is called a loop.

Now, do we specify the conditions? By now I am sure you have get how we do that. We
specify the conditions using relational operators or there are four relational operators you
have seen; less than, less than equal to, greater than, greater than equal to. I have said not
equal to also, but not equal to can also be seen as the negation of the equality operator.
The equality operator is this double equal to sign and not equal to is exclamation mark
for the equal to now. So, using this relational operators, we will get using one single any
of these one single relational operator, we will get one logical expression and using
logical operators and connectives, we will be able to connect a number of logical
operations logical expressions and logical another logical expression. In that way we can
carry out we can generate the condition using this.

Now, two logical operators we have seen and or. Another unary negation operator we did
not discuss earlier, but we are doing it now that is this means not all right. For example,
suppose x is 5 and at some point I compute x greater than 5, the result of this logical
expression will be false right this is false, but if I take the negative of this then this false
will be negated and the negation of that will be taken. So, that will be one two; that
means, what is the meaning of this, is it the case I can read it in this way, is it the case
that x is greater than 5 is false is not true yes that statement is true. I can state it in
another way is it the case that x is not greater than 5? Yes that is the case again I tell the
first one that is more complicated is it the case that the statement is greater than 5 is not
true that statement is true? That it is not true is true. So, that is not means whatever
logical expression I have after this that will be negated. So, it is equivalent to not of the
logical expression.
So, if this logical expression if this logical expression leads to this logical expression is
only 1, then not of that will invert it and make it 0 or if this logical expression was 0 then
this not of this will make it 1. So, this is the unary negation operation all right.

Let us see some examples count less than equal to 0 this is the logical expression it will
be either true or false maths plus physics; that means, here maths is the marks obtained
by a student in maths plus physics, plus chemistry divided by 3 is greater than or equal to
60 that means, the average of these 3 marks is greater than or equal to 60.
Either the person the sex of that person is male sorry and let us look at this if I am using
a logical connective the person this will be true if the person is a male and he age is
greater than or equal to 21. So, for a female of age 22 this will be false, for a male age 20
it will be false. A male age 25 it will true. Here again another one with this connective
marks is greater than 80 and marks is less than 90 sorry marks is greater than equal to 80
and marks is less than 90; that means, what anything starting from 80 to 89, if the marks
is between this then this will be true..

Another one with an or operator balance is greater than 5000 or the number of
transaction is greater than 25 say in a bank see situation for example, you are making a
lot of transactions what is the transaction when you deposit a money that is a transaction,
when you withdraw the money that is also a transaction. So, there are different
transactions. So, what we are saying here either I have got 5000 rupees greater than sorry
greater than 5000 rupees in my balance or I have done more than 25 transactions. If any
one of them true suppose you have got 6000 rupees in your balance and number of
transactions is 26, then also this is true. If the balance is 6000 and number of transactions
you have done is only 20 then also it is true, we have already explained the role of or
operator earlier ok.
Now, this if the grade of the student is a if a student has got grade a what will be the
value of this logical expression true or false if the student has actually got the a grade all
right. So, this one this part will be true, but my actual logical expression is this one
which is a negation of that. So, it will be false because the person has grade a what does
it means? It means that is it the case that the student has not got grade a.

Here is another little more complicated x greater than 20 and y less than 16, but the way
we should evaluate this is, I will evaluate each of them separately suppose x is greater
than 20 suppose 21. So, this is true and y is 15. So, this is true. So, both these together is
true then I take this one with this and so, the result will become false let me clear it again
suppose x is 21. So, this part is true then I compute this y is 17, this part is false
therefore, these two are connected by this ampersand; that means, logics are not I a m
sorry very sorry it should it is not ampersand double and; that means, and operator by
logical and. So, these two will result in though the logical and it will result in 0, but my
actual expression is the negation of that. So, the result will be 1 clear.

So, that is how we carry these are the examples of evaluation of logical expressions and
logical expressions. So, each of them each of these logical expressions can serve as a
condition in our control structure in our this loop in our this diamond box, decision box
where we test or let us call it the test box in that any of these sort of logical expressions
can reside and the result of that can be either 0 or non-zero false or true ok.
Accordingly we will branch out in either this direction or in some other direction.

So, 0 indicates false and non 0 indicates true typically the true is reprinted by the value
one in most of the machines.

This is something that we have already seen, the decision symbol in the flowchart
indicates the decision to be made it contains an expression that can be true or false, test
the condition and follow the appropriate path that is how we will do is a single entry
single exit structure; that means in this diamond box we will enter through any one point
and we will exit from only one point either this or this, simultaneously we cannot come
out of this because the thing cannot be true or false at the same time therefore, any one
exit will take.

The general syntax, syntax means what? Syntax means the grammar; the exact
grammatical structure that we should write is if condition then I carry out some
operations. You have seen in an earlier lecture when we were comparing two numbers x
and y and would be printing x is large is x is greater than y then what did we write we
wrote something like this, we wrote if x is greater than equal to y, print f what we printed
y x is greater than equal to y, x is large or not in this form we wrote down that x is large
here all right. So, if this condition is true then I will be doing this print operation, x is
large then black slash end I am not being able to write very clearly here.

So, I try again if x is greater than y or greater than equal to y. So, this is the condition
you see this is this is the reserved word in c end the condition. If the condition is true
then this is followed by a statement. Now if it be a single statement I do not need to give
this curly bracket, but just I am giving it just to keep the parity, here I write print f x is
large then black slash end right and we end this statement ok.
So, if this condition is true, then this statement will be executed that is my syntax
otherwise some other statement will be executed. Now this is something which takes
some times to settle down. So, we will explain it repeatedly to some extent.

If there is a single statement in the block this braces can be omitted I am sorry this braces
can be omitted.

Now, let us come to this structure. If statement first of all we are looking at the first and
very important control statement in c that is the if statement, if some condition. So, we
come here the structure is we carry out some tests on some condition grade is greater
than equal to 60 if it is true, then we do something I print past otherwise I would write
something else. So, this is a selection structure what is it selecting? It is selecting which
path should I go all right.
Now, you see here we have come we are coming to this path, if this here I carried out a
test if this test is true I do this do this execute this statement, and come back and continue
not come back and then continue to this part. If this statement is not true; that means, if
this test fails then I will not take this I will not select this path, I will continue in the path
which in which I was going right. So, that is why this is often known as a selection
structure.

So, a decision can be made on any expression. Here you see only thing that we are trying
to do is test whether some condition is true or false. Now we if the result of an
expression is 0 then we take it to be false and if it be non 0 then we will take it to be true.
If I evaluate something to be true like say for example, if x was 5 and I carry out x is x
equal to 5, this logical expression we will evaluate to true; that means 1 that means, it is
non zero.
If I had written x less than 5 then it would have resulted in false it would be 0. Now
suppose I simply do something different I write in this decision box I am coming like
this.

And inside the decision box I write and x was 6 say I do not write a logical expression
here I write an arithmetic expression x or let me x was 5, I carry out some expression x
plus 5.

What will be the result of this expression be? It will be ten that is it is non 0 then also it
will be taken as true although we will we do not need it all the time you need not bother
about it, but in general a decision can be made on any expression. Typically and most
conveniently we will be using logical expressions, but if I carry out an arithmetic

expression something a times b plus c minus d, then also this will give me a value and
this value gives 0 means it is false and not 0 then it will be taken as true however, this is
just a matter of detail you need not get too much bothered about it right now, we will try
to keep as much as possible relational expressions or logical expressions inside this text
blocks.

So, here if grade is greater than or equal to 60 being passed 10; that means, this is the
equivalent of this structure that we have shown here. This flowchart can be simply
written as this statement I think probably you will be able to read it now, if has been
given in a different colour because this is what we have introduced here this if is a use of
if the selection structure followed by a condition if the condition is true then this
statement will be executed.
If the condition is false, then this statement will not be executed we will bypass this
statement. Now please remember this, when I write if some conditions some statements
this statements will be executed only if this condition is true, I write it in a different way
now.

Say for example, I have a got a number of statements, some statements are there and then
here there is an if statement. If condition then some statements here may be more than
one statements are in a brace. Now if the condition and after that there are other
statements.
Now, if the condition is true, then only these statements will be executed lets name this
statements to be a then this block a will be executed this block will be executed. If this
condition is false then this block A will be bypassed and on false I will come here and
come to so, this block b. So, if the condition is false then the block B will be executed, if
the condition is true then this block A will be executed all right.
Now, suppose let me explain it in a little different way I am drawing another diagram.

Now, here is some block of statements, let us call the block of statements to be a and
then I have one statement, if condition n whatever the condition is, then within
parentheses there is a block of statements B. And then there is a block of statements C.
So, the 6 flow of I mean the flow will be that first A will be executed then if the
condition is true, then if the condition is true then B will be executed after that what will
happen? After that again we will come here and C will be executed.
Now, if the condition were false condition were false, I just computed a after that what
would have computed condition will be checked B will not be evaluated not be executed
because condition is false after that C will be executed. So, please note that in this
structure I am computing I am executing C either way, now the choice of whether b is
being done or not is dependent on the condition. So, this gives you an idea of procedure
if the condition is false then also this part will be executed. So, here we will conclude
today with this example, small example program lets try to understand each line of them.

We start with include s t d i o dot h I hope you have not forgotten that any c program
must have a main program main function and here is the main function. Inside the body
of the main function what is being done I have declared what is being done here, I have
declared 3 variables a b and c. Then what am I doing here observe this line scan f
percentage d percentage d percentage d and a and b and c. So, I am needing 3 variables a
b c ok.
Now, what am I doing here, I am evaluating an if condition if a is greater than equal to b
and a is greater than c. So, you understand that if a is a number b is a number c is a
number a is greater than b and a is also greater than c; that means, a is the largest
number. So, then I change this, I change this only if this condition is true otherwise I will
do something else. Now suppose a is greater than b suppose a is 20, b is 10 and c is 5.
So, this one will be true then the largest number is a that we printed, next statement will
come to is another if statement.
What is being done here? If b is greater than equal to a and b is greater than or equal to c
b is not greater than equal or to a therefore, this does not evaluate it to be true therefore,
this statement it does not execute. Next I come to this statement I am showing this I am
following this flow, but only branch that I took is if this condition was true, then I printed
this in this particular case of data in this case of data for some other case should be very

different now if c is greater than a not true. So, this is false this will not be executed. So,
the only thing that we printed is a largest number is a.

Now, if for example, a was 10, b was 20 and c was 5 then what would have happened let
us see here a is greater than or equal to b I try to test this fail. So, this will not be
executed. So, I come here right and then I test this b is greater than a right and b is
greater than c that is also right. So, this condition passes.
So, then I execute this I print larger number is b. I print that and then I come to the next
statement what happens in this statement? C is greater than or equal to a false. So, the
only thing that is printed is the largest number is b all right. So, we stop here we will
continue our explanations in the next lecture further, we will have we will need to
discuss it and also try it a little bit more, because from this point onwards our logic and
logical constructs are becoming started becoming just a little more complicated, but is
very interesting and it is very easy to understand, if you just try to think about it
logically.
Thank you very much.

We are looking at the IF selection structure where the structure was something like if
some condition and then there were some statements, and here is an example of what we
are looking at.

So, here you can see that if a is greater than b and also greater than c here is a logical
connective. So, then this statement will be executed. So, in English we can just call it
like if the condition is true then if the condition is true, then execute a set of statements.
So, in this case the set of statements is just only this printf. Otherwise if this condition is
true then this statement will be printed. So, this is what we discussed in the last class.
Now, one thing for those who will be writing programs in C you should remember that
this condition is always within a parentheses and within that parentheses there can be a
composite expression which is here you can see there is a logical expression, here is
another logical expression and here is a composite logical expression joining them by
AND or it could be by OR etcetera. So, in that way we can form the condition statement

and if the condition statement is true then these things will be executed. We will see
more examples as we go ahead.
So, let us look at a little more different, a little more extensions of the structure.

Here we are going to see the if-else structure what we actually want to mean is if a
condition is true then will be doing these things and if the condition is false then I will do
these things. Let me clarify it a little bit more.

Suppose I write if x is greater than 5 increment x by 1 and printf “new value of x is
percentage d back slash n x” alright. That means, if x is greater than 5 suppose x is an
integer I am assuming that x is an integer here. So, somehow somewhere up here I have
written int x equal to for int x just int x and later on I have assigned x to be 7 alright.
Now, when I encounter this condition this condition always true then I come to this set of
statements because this condition is true. So, what will be the value of x now? x was 7 it
is greater than 5 therefore, x will be 8 and what will be printed new value of x is 8 that is
what will be printed. Now, suppose I write printf x not greater than 5. What I intent to do
is if this condition is true then this will be printed otherwise this will be printed that is
what my intention is, that is what I want to do. But the way I have written it will actually
do something different. You see when the execution will be done you know the
execution is normally done in a sequential manner. So, here we will come x is greater
than 5, x is 7, so x is greater than 5 this thing will you printed and will come out and
come to this next statement. Let me number these statements say this statement was 1,
this was 2, this was 3. Now, see I am calling this entire if statement to be a single
statement; so 3 and then 4.
So, normally 1 will be executed, then 2 then 3 now 3 will be executed because x is
greater than 5. So, this condition is true and then what will be executed 4. So, what will
be the output what will be written? Here new value of x is 8 will be printed and here
when it 4 is executed again you printed x is not, x not greater than 5, but that was not my
intention. So, in order to avoid that I can write a new statement here there was an if, if I
write here else this. That means what? If this condition is true then print this otherwise;
that means, if this condition is false then do this and then number 5 can be something
else and that will be executed. So, what will be the execution? Suppose x is equal to 4,
let us try to write down what is execution sequence then 1, then 2.
Now, x is equal to 4 therefore, this condition will be false this condition will be false
therefore, this statement 3 will not be executed, this part of 3 will not be executed then
we will come to this else statement; that means, if the condition is false then I am coming
over here. And so 4 will be executed 4 will be executed, 3 will not be executed
completely and then 5 will be executed.

But if I had not put this else then what would have happened in this case if x is 4, in that
case this will not be this will not be true only this statement will be printed fine there will
not be much problem, but suppose x is equal to 7. And if this else is not there then what
will you print it x is 8 x not greater than 5. But if I put the else here if I put the else here I
am fairly repeating a little bit more because you lot of students face difficulty in this
structure. So, if I put else here in that case this will be x is 7. So, this will be printed and
at this else this condition was true. So, this is this part will not be executed, this part will
be executed only if the condition was false. So, this contradictory situation would not
occur alright.

So, let us look at some examples of this if statement if-else. It is also a single entry single
exit structure it allows us to specify to alternate blocks of statement one of which, one of
the which is executed any one of them depending on the outcome of the condition.

Essentially what we are trying to say is that I will have a single entry point to a decision
box and I will check for some condition I will test that particular condition if that
condition is true then true then I will do some state set of statements let us call that S 1,
otherwise if it is false then I will carry out some S 2 alright and then I will be meeting
may be at some other point which is S 3.
So, this structure I can write as if condition then I do I have name I am not writing the
statements I am just writing S 1 else S 2 and then S 3. So, my flow will be either this way
and S 3 or this way and S 3. If I had not put this else how would this diagram look like?
You have seen this diagram, now if I had not put this else how would the diagram look
like. The diagram would look like if here I have got the condition block decision box true
then I do S 1 and then I do S 2 and S 3. So, will come at this point if it false then I will
also come at this point if it is true then also I will join at this point if this else was not
there. But since this else is there then I just separate the out their point of joining alright
will see more examples of this.

So, the general syntax of this is if condition then block on1,e block 1 is what I was
calling S 1 the set of statements else block 2 the other statements alright. If a block
contains a single statement then the braces can be deleted I am sorry if the block contains
a single statement then this a start essential that I put them, but just for the sake of
generality in most of the cases I will have more than one statement therefore, I am
putting that in place alright.

So, the diagram that I was looking at I was explaining that sort of diagram. Suppose the
grade is 60, if the grade is greater than equal to 60 suppose somebody’s grade is or marks
is 50 then at this point the condition is false this part will be executed, if the grade is 70
that is this condition is true this part will be executed. Then I will come to this common
point, this is a common point which will come.
So, this I can write as if grade is 60 see here there is only one statement. So, I did not
need not put the I have not put the braces here print sorry printf passed else printf failed
and then whatever I had to do I will do it here and then whatever was following that will
follow here. So, let us come to. So, I hope this is clear.

So, the syntax of if-else let us look at little bit more here I have said block 1, block 1
means or S 1 whatever you name it. This is block 1 or I had name it as S 1 the same set
of statements where their number of statements each separated by a semicolon. Please
note suppose there n statements here separated by a semicolon.

Now, next I come to this if I want to do else also if expression statements 1 to n, else
state these statements 1 to m. So, this is my block 2 and this is block 1. So, here we can
see that based on this expression which is a condition evaluation if this condition is true I
will carry out these statements else I carry out these statements. Note that this individual
statements have got semicolon and this is a whole body of the else statement this is the
whole body of the if statement. So, composite if this entire thing we call an if-else
structure.

So, if grade is 60 printf passed else print failed.
Now, this next we are coming to a little more complication of the same thing it is the
next thing of if-else structure.

Now, why this if-else what are we trying to achieve we are achieving branching. That
means, we are carrying out a sequential flow we are carrying out a sequential flow and
from there we make a decision box and then we branched either in this direction or in
this direction.
Now, suppose here in this direction it is true and this is false again I come and make a
decision. It can be, if x is greater than 5 then I come here and y is greater than 7 then I do
something here it can be x is greater than 5 I follow this path, but y is not greater than 7.
So, I follow this is true this is false I follow this false path. If x is not greater than 5 I
come here and suppose I check z less than 2 true or false there can be 2 outcomes. So,
suppose x is 4, not greater than 5 I will come through this path, now z is 3, z is not
greater than 2, less than 2 therefore, I will follow this path. So, you see the path that we
follow that is a branching that we do can have the path that we follow can have more
than one decision box say x is greater than x is 7. So, here I was coming in this path then
I follow this path because x is 7 this condition is true and I find that y is 8 so I follow this
path alright, if y was 6 then I would have followed this path.

So, in the path that the program follows there can be more than 1 decision box. So, that is
what we mean by nesting of if-else structures.

That means nest one if-else statement within another. Now, all statements may not have
the else part. Now, rule to be remembered is an else clause is associated with the closest
preceding unmatched if really confusing what do I mean by this.
Let us look at this how will this be executed.

Here e1 means some expression, if e1 is true then s1 else if e2 then s2. Now, with whom
does this else go? This else certainly goes with this preceding if. If I just quickly draw
this that flowchart corresponding to this how does it look like? I come here and x
evaluation, evaluate the expression e1 on true I do s1, on true I do s1, on false here is
false alright I come here and there is another if here. So, I again check e2, if e2 is true
then I do s2. This statement actually means this graph. If e1 is true then I will carry out
s1 otherwise else is there. So, this else is linked to this if then I do this one.
What about this? Let us erase this for a while and how would we interpret this one. Here
you can see the two elses. With whom is this else paired? This else is paired with I have
written it in a bad way, this else is paired with this if.

So, this means again I check e1, e1 is true so I carry out s1 else false; that means, this
else is for this decision box I check here e2, e2 is true so I carry out s2 and else I carry
out s3 this is what I am trying to do.
Now, here I would have preferred to write it in a better way. That is why if you recall in
a earlier lecture we had talked about a good program writing practice that is indentation.

I would have like to write it in this way if e1 then s1 else if e2 then s2else s3 which
makes a very clear that this else is corresponding to this if and this if this else is
corresponding to this if right.
Let us look at the third scenario what does it mean. If e1 if e2 s1 how would I draw that?

I draw that like that I take e1 if e1; that means, if e1 is true I immediately come here and
the statement starts with another if. A nested if, this is known as the nested if one if

within another there is one if statement there is another if statement within this, this is
knows as nesting alright.
So, here sorry over here if e2 s1. So, immediately I am there is no else here by the way.
So, if e1 then I come here then if statement is again there therefore, there is another
decision box where I am checking the condition e2 and if e2 is true then I will follow
then I will carry out s1 else s2, which else should it be here or there. Now, this is
something this else is pairing with a preceding if, so it should be false will be s2. Now
this else is therefore, covered this path is covered. So, this else can only mean this one
and s3 will be because this is already covered right. So, this is the nearest one to this
clear. So, if we go to the earlier slide. Let me go back to the presentation.

So, here this one how would this one actually look like? How will this one look like?
There is something still there. So, how will this one look like; coming straight here if e1
if the condition is met then I again test here if e2 this is true this is true then I come and
do it here s1 and else this else is again with this if. So, it will be here s2 and I have not
specified this one here alright.
So, if you put a little bit of mind here. So, you can see many different other scenarios that
can come and we can proceed accordingly.

Let us see here. This one as I was saying it will be nicer to write it in this way because
here you may feel there two elses two if who goes with whom. Now, here if I write it in
this way if e1 s1 else; that means, this if-else else if e2 s2. Here if e1 s1 else if e2 s2 else
s3. So, this else is therefore, with I am sorry I think I will have to go back to a couple of
slides you see and else clause I would like to be corrected a little bit and else clause is
associated with the closest preceding unmatched if, any if that is not there that should be
it should match with that. So, that is what I explained in these examples.
So, it is a much better for example, just look at this how would I like to like write this. If
e1 I would not prefer this also, I would prefer that I write it in this way. If e1 then if e2
s1 else s2 that becomes very clear this if-else and else are very clear. Say for example,
here also this is better, but still I would prefer to write this one as this one, this is one
way I can write if e1 if then I mean this is the part of if, if e2 s1 else s2 and under this if
that is what is been done here else s3.

So, what we have learnt today is a nesting of another structure. What we are discussing
now is how we can have a better or more versatile flow.

Normally it is the sequential flow, but based on the decision points I may have to take
different paths which is known as branching right and for branching or selecting the
proper path the structure is if. Along with that we have learnt today if-else structure and
we have seen how if-else structure can be nested to give rise to some better more
versatile scenarios. We will continue with this in the next lecture.

Thank you.

Welcome. In the last lecture we had looked at the nested if-else structure. Today we will
continue with that discussion.

So, here is an example that uses the nested if-else structure. Here you can see again let us
come to the programming fundamentals in C, we have got just for revision we start with
an include stdio dot h and then we have got the main function. Inside the main function
we declare 3 variables a, b and c and probably you might have guessed now that we are
again trying to find out our, I mean the maximum of the 3 integers a b and c.
So, what are we doing next? We are first reading the 3 numbers from the keyboard right,
scanf, percentage d, percentage d, percentage d, then a, b and c preceded with an
ampersand and you know why this ampersand is used that is the address of the location a
b and c.
Now, comes the main logic here if a is greater than or equal to b, a is 25 b is 20. So, if a
is greater than equal to b then I check whether a is greater than c. So, this is passed then I
check this. So, if a is greater than b then I proceed to do if a is greater than equal to c if
that is also true, then we print the largest number is a; otherwise what we do not know as
yet.

So, if a is greater than b, a is 25, b is 20, c is 15 in that case a is greater. Let us suppose c
is thirty then what happens a is greater than b true then I come and compare a is greater
than c this part, no false. Therefore this else is with respect to this nearest if that we
learnt in the earlier lecture. So, if this fails then we print the largest number is c because
a was greater than b, but a is not greater than c therefore, c must be the largest.

Now, if a is not greater than b. Suppose a is 20 and b is 25, then a greater than b this
fails, this fails then I am not entering this block at all I am straightway going to this else
then I am checking a is not greater than b, but therefore, b is must be greater than or
equal to a or not even equal to b must be greater, greater than a then I check if b is
greater than c suppose b is greater than c then the largest number is b otherwise if that is
not. So, b is not greater than c suppose c was thirty then this else will come because this
if we will fail therefore, I will print gain the largest number is c.

So, I would suggest you to work it out yourself and I can also write the same thing. If
you consider that this if a is greater than b then if a is greater than equal to c, tell me if I
write it in this way if a is greater than equal to c and and; that means, and a is sorry here I
right a is greater than equal to b and a is greater than equal to c printf this line largest is a
else printf largest is c. So, do you think that these two are equivalent? These two nested
ifs and this logical operator.
Now, here I should have put a parenthesis here. Please note I need a parenthesis here it is
better that if I put it it becomes much clearer. Are these two equivalent? If you just think
a while you will find yes they are equivalent because I am computing this and then I am
computing this if this any one of this is false I will not be executing this statement right.
So, this is an example of nested if.
We can have many such examples. Let me give you one example. Let us workout right
now.

Suppose I am trying to see if a figure is a triangle or a square or a rectangle or rectal I
mean 4 sided figure whether it is a triangular figure or a quadric quadrilateral figure. And
if it is a triangular figure then I want to see whether it is isosceles; that means, two sides
are equal or it is not isosceles. Suppose that is what I want to do. So, how can I proceed
to do that; how would I write the logic? Let me just only write the relevant part. I have
done some the declarations are here and then I have done scanf percentage d, number of

sides all right number of sides. So, number of sides are variable. And then I also then;
what I can do? I check if number of sides is equal to 3 then I will be doing something all
right because in that case it will be a triangle.
Then what do I do I? Then read that is scanf the 3 sides of the triangle percentage d, first
and suppose all the sides are integer has got all the sides have integer values all right 5,
6, 5 something of that sort. That is why I am putting percentage d then I am reading the 3
sides and a and b and c semicolon.
If a is same as b or you remember this is the logical OR, or a is the same equal to c or b
is equal to c then what can I say, printf “it is isosceles backslash n”, as our common
practices. If any of these conditions are true either this is equal to this or this is equal to
this or this is equal to this then is isosceles. Else I will printf say I am writing in brief
“not isosceles”. You can write in a much better way. Remember this double quotes we
complete this. Now, that is the, I complete this. Now, this is the if part. If the number of
sides is 3 if the number of sides is not 3 then I do not do anything I will come at this
point because this if you will fail I will come at this point. I can say here can I write here
printf not a triangle, can I do this, just think because here I have checked that the number
of sites is 3. If it is number of sites is 3 I will do this and print and otherwise I write it
here is it all right. If you look at it you will see that there is a problem here, that if the
number of sites is 3 and then it checks whether it is isosceles or not and then it comes out
and again prints is not a triangle I do not want that. So, what should I do, how can I avoid
this problem?
Here you must have guessed now, here I have to put an else that goes with this if all right
and then if this is not true then only this will be executed otherwise some point down the
line here will be executed. Another thing that I would like to mention in this case look at
the use of this parenthesis why was this parenthesis required because I had more than one
statements for this if condition if this condition is true then there are more than one
statements.
Now, here is a puzzle. How many statements are there inside this block? How many
statements are there? 1, 2, 3, 4, let us see. Here is one statement scanf so one and then
this if statement you see goes up to this. So, that is one statement, but here I am using I
said that if felt is a structure. So, this entire thing is a statement. So, actually I have got

two statements. Since I have got more than one statement I had to put these braces. Now,
suppose of course, then the program will not work here, suppose I had not written this
statement this statement was not there all right this statement was not there in that case I
could have done away with these braces because then it is within this if statement there is
one statement only this brace was not essential. So, you could see this and you can
practice and in the assignment we will also give few programs that you have to do using
this sort of if-else type of structure.

So now, here is the example that we did.

Now, there is a problem here there is a danger I would rather say. You have seen earlier
when I was writing I was writing if a is equal to b, then I was doing something right.
Now, this is very important that is a common point of source of, common source of error
that often because we have learnt to say equal to like this it will we can write in this way.
Now, the problem is if I write it in this way when a compiler looks at this what will it
assume it will see that is an if often you will not find that it will cause an error because
what the compiler will think is well, what is the meaning of this; a this means a is
assigned the value of b. So, it will try to successfully, it will try to transfer copy the value
of b to a all right and this operation will be executed successfully.
Now, if x in any expression is computed successfully; what does it return? If you recall it
returns a one and one means true; that means, this condition will evaluate to true. I once
again repeat. Now, we can use any expression that produces a value in the control
structure. Now, if it be a nonzero value then is true and 0 value is false.

So, if I write if a plus b plus c printf “A” else printf “B” what will happen? a plus b plus
c is if they will be just be added, but there will be no assignment suppose I make it more
meaningful. Suppose I make it z sorry z assigned (Refer Time: 17:53) I write z assigned
a plus b plus c all right then this there is a problem here because there is no semicolon
here right. So, this will become suppose I do this.
Now, this will be computed and this assignment will be done and this assignment will be
done successfully. So, anything that is done successfully will return this will be
equivalent to if 1, if 1 means it is true and so what will be printed, printf A will be
executed, this will be printed.

Now, similarly I can say let us see I just write if this and something. What does this
mean? Semicolon nothing before this we call it a null statement; that means, I have not
state anything meaningful, but it is still a statement. Remaining silent is sometimes a set
statement. Now, this means that this is always true this will always be true. So, this is
equivalent to if 1 this; that means, always you do this statement this, whatever is here
you read do it always all right. So, this is a interesting thing in C.

However sometimes you know it varies all with the compilers also some compilers take
care of such situations and may give you a warning some very few compilers can also
give any error. Now, let us look at this example sorry this example.
If pay code is equal to 4, what does this mean? This means if the pay code is 4 this is a
logical equality if this is true then will print you will get a bonus. Now, instead of, I want
to do like this, this means that I am coming here I am checking pay code in non C
language you speak out 4 yes I do something no I do something else. But if I had written
it in this way what would it mean?
If pay code assigned 4. Now, pay code being out suppose pay code is an integer type of
variable then this can be assigned the value 4 successfully and anything that is done
successfully this will result in if done successfully one do this. That means, it will be
successfully executed it is not doing what you are intending. So, sometimes we are saved
by the compiler when it points out that note here, here is something some syntax error
that you are committing all right, but there are situations when we unintentionally can do
such mistakes which will go unnoticed by the compiler and the result that will be getting
may not be what we desired.
So, this is a very critical point you should keep it in mind for all programming languages
we will find there such nuances some specialties which you will have to keep in mind.
We are just mentioning here the ones for C. But if I had done it in this way it would be
ok.

So, generalization of expression evaluation in C is assignment operated is also a part of
expression that we know.

Now, let us see here i is assigned 3. So, typically some compilers what they do till now, I
was saying that if an instruction is executed correctly it will return 1, but generally
speaking it will return the value that has been assigned.
So, typically here i assign 3 will return the value 3 after assigning it to it, but for us when
we do what we are bothered about if the condition this part is open sorry I would rather.

Now, say is part is 0 or nonzero. If it is nonzero then this true I was saying if 1 it is true,
if 3 that is also true the only falsity will come if it is 0. So, this returns the value 3 after
assigning it to i.

And then, so let us look at this code. I give you 1 minute to look at this code and think
what this code will do, what will be the result of this. Look at this code carefully then we
will analyze it.
You can see that here we have initialized a variable i to 4 and j has just been declared,
but not initialized. So, here the picture is something like this, i has been initialized to 4
and j can have something, but I have not initialized at. Now, here if this statement, what
will this statement do? First the condition part; that means, within the bracket this part
will be evaluated and what will happen, what is this i is being assigned 3 so this will be 3
and the value that will be returned by this execution of this statement will be 3, then j
will be 0 then j will be 0. Else j equal to 1 that will never come because this will be done
successfully, this will never come. So, the output will be, output I have not given any
printf here, but this j, value of j will be 0.

So, what will be the value of j? Whatever be the value of i, j will be 0 right. Now, instead
if I had written it correctly, correctly means if my intention was that if i is equal to 3, j
should be 0 otherwise j should be 1 then I should have written it in this way. So, that if I
is equal to 3 then j will be 0 otherwise j will be 1. So, this is a very important point that
you have to keep in mind and gradually with practice they will be ok with this.

So, here, more about expression. Now, here we introduce two new expressions typically
when we write suppose there is a variable i and the variable i has got a value 5. Now, if I

want to implement the value 5, if I want to implement the value of i I will write i
assigned i plus 1 or if I want to decrement the value of i then I can write i assign i minus
1, but C allows us or gives us one special implemented another special decrement
operation.
So, this thing I could have written also as instead of this, this part I could have simply
written i plus plus, i plus plus means i is assigned i plus 1 and this 1 will be i minus
minus all right. So, this is known as the decrement operator, this is known as the
increment operator. Sometimes it becomes handy to write it in this way, but if you are
new in programming i personally would discourage you because you should not get
ground in the special features of a language initially better you go by the standard
features because these features have got some more complications which will come to
later. But you may know that this is an increment operator which is equivalent to this and
this is a decrement operator which is equivalent to this all right.

So, this is I can write it in two ways sorry i plus plus or plus plus i. The reason why I
were I discourage you to get into the usage of this initially will be evident soon. If I write
i plus plus it means this is called post operation this means pre operation of prefix
operation. We will soon see what that means. So, I can have plus plus i or minus minus i
that is a prefix operation and postfix operation is i plus plus and i minus minus.

Now, plus plus i means first increment or decrement depending on whether it is plus or
minus and then use it in the evaluation. For example, suppose I have got the value i here
as 5 and I write x as signed plus plus i plus z or let me make it a constant, let us say z is
5. Then what will happen, this is what, this is pre increment i first increment i and then
do the operation.
Now, this has got precedence of course, over this. So, first i will be, i will be
incremented, so i will be 6 and z was 5. So, the result will be x will be 11, but if I had
done written it x assigned i plus plus plus z here also I will first increment this 6 and then
z will be added to that. But there are situations where we will do it after computation of
the whole thing. I think I will need a separate session for you to explain this clearly. We
will do that in a more careful manner.

Let us look at this here int t is an integer and the value of m is 1. t assigned plus plus m;
that means, what m was 1 and m is first incremented and assigned to t therefore, t will be
2 all right. Again if we do it like this here then yes, here it makes the difference very
clear I am sorry t sorry here you see m was 1 and what I have done I have put the
assignment of I have done a post operation, post fix operation; that means, first I will be
doing the assignment, first I will be doing the assignment and then I will increment. So,
what will happen? m was 1 here, so first this 1 will go over here. So, t will become 1
right and then before I complete this operation I increment m so m becomes 2 all right.
So, we will see more examples of such things in the subsequent lectures.
Thank you.

In the last lecture we had discussed about 2 new operations, that is post increment and
pre increment. Here you can see that we are calling them as prefix operations because the
operator is before the operand here you can see also the operator is before operand and
what is the operator? Operator is incrementation, but that is being denoted as plus plus
twice the addition operation or twice the subtraction operation. And in this here we are
talking off we are calling it to be postfix operation, here you can see that the operand is
coming first and the operators are following right. So, the operators are following them.
So, that is why this is known as postfix here also you can see the operated operand to be
I followed by the operator minus minus right. So, that is why these are called postfix or
prefix. The significance of these as we discussed in the last class is that a particular
variable.
Will be first incremented here in this case it will be first incremented and then used in
operation, here it will be first decremented then will be used in the operation. While here
it will be first the operation will be done and then the decrementation will be done here

first the operation will be done then the incrementation will be done. So, we can, that is
what we have written here first increment or decrement and then use it in the evaluation
and here increment or decrement is done after being used in evaluation. So, it will be
clearer when we come with some examples, see about the example that we have shown
in the last class t and m are 2 variables, m is initialized to 1 and when I am saying plus
plus m; that means, first I increment m.
So, m will be here you can see as soon as I do that m will become 2 and then that is
being assigned to t. So, t becomes 2 whereas, here you can see that m is 1 and we have
done post increment. So, first the assignment operation will be done; that means, m was
1. So, sorry m was to here after this I am doing this. So, m will be. So, t will be one. So,
what will happen is m is 1. So, that m will be assigned to t. So, t becomes 1and after that
it will be incremented. So, ultimately m will be to, but t will be 1. So, if you look at these
2 you will find the difference between these.

Let us have a few more examples, suppose we have got 2 variables a and b whose initial
values are 10 and 20. They are initialized to 10 and 20 next we carry out look at this
operation very carefully, it looks a little clumsy here there are 2 operators one is this one
another one is this one. So, this is pre increment.
So, this is equivalent to x is assigned 50 plus as if I have put a parenthesis, but that is not
required that first a will be incremented and then that will be added to 50. So, what result

do we expect a was 10. So, first that will be incremented. So, that will be 11 and that will
be added to 50 and. So, x will be x we get the value 61 all right that is what will happen
in this case. So, a is 11 and x is 61 as we have shown.

Now, let us take this again this is the; this is post increment. So, what do we expect here
let us see what will happen in this case, first here after the operation is done then a will
be incremented. So, what will happen? X was 50 sorry sorry I am sorry a was 10 and I
am adding 50 and 10 and a; that means, 50 plus 10. So, that becomes 60 and that 60 is
being assigned to x.
Because, the assignment operation, is taking precedence over this post increment. So, we
get x to be 60, but I have my job is not it clear because after is participation in this
operation, it will be incremented by 1. So, a was 10 then we will be made incremented
by 1. So, it will become 11. So, consequently this is the result what we will get.

Now, let us see again here; what do you expect to happen. A is 10 as usual, a is 10 and b
is 20 what is being said here? A is post increment, but b is pre increment pre decrement.
So, first b will be decremented. So, b will become 19 decrement means by 1. So, it will
be decremented it will be nineteen it will be added to a; what was a? 10.
So, these 2 will be added and what is that 29 and that 29 will go to x. So, x will be 29
and then my job is not it clear not it over. So, this will be incremented and a will be 11
all right. So, this is how the thing will happen.

So, the results that we get in this case will be b will be 19, because b has been
decremented x will be 29 and a will be 11. I hope you have understood the flow. So, now
this is another one, here we really do not know what to do because here I am
incrementing pre incrementing a post incrementing a here now I will take this value of a
now what will happen. Suppose the problem here is suppose a is let us take the case here
a to be 10 now first.
I will decrementing I will incrementing. So, a will be 11, but a was this a is not
incremented. So, a minus 11. So, 11 minus 11, will it be 0 and then this will be a will be
12 or which one will be done first this is a particular scenario, for the same variable in
the post increment the post decrement is given often that is implementation dependent
and the compiler does not take it well. So, it often results in undefined value. So, you
should try to avoid this as much as possible actually you should not use this you should
use you can use the pre increment post increment, but as I said in the last class I had
strongly suggest that at the initial phase of programming you avoid using this pre
increment post increment operations, instead although it will be a little laborious you
write x assigned x plus 1 or x assigned x minus 1 for pre increment and pre decrement,
but it is good to know that c allows us with this facilities.

Now, here is another one which at the initial phase you should not try to use unless you
are very confident. We know if conditions then we do something else something. So,

there are three things, if some condition then although we do not write them, then we do
some operations else we do some other operation. Then the same thing can be written, it
call it a ternary conditional operation here we write it in a different way.

Just to save space on I mean the size of the program what we do here say grade greater
than equal to 60 printf passed otherwise printf failed. So, this means here this is the this
part is the condition part and this part is the part that will be computed if the condition is
true, and this part will be computed if the condition is false all right. So, this is
equivalent to writing if grade greater than equal to 60 printf, past else printf failed all
right this is equivalent to that. So, what is happening here in this example? So, the
general syntax is if there is an expression there is a condition expression then we carry
out if that is true.

Then we carry out expression true otherwise if it is false, then we carry out if it is true
then we carry out this part this part, that is fall following interrogation mark, and we
carry out the expression three that is the expression that is following the colon mark for
the else case or if the condition is false. So, this is again writing that if then else in a
cryptic shorter way this is known as ternary conditional operation, but again I would say
that this is a specialty of c it is good to know that, but initial phase at the initial phase of
programming I discourage you to use this .

So, here is an example what will this v can anyone tell me? We are computing the
interest on the amount of money you have got in bank, this means here let us look at this
part this is a ternary operator. If the balance is greater than 5000 then you compute
balance times 0.2 that means, 20 percent of the balance or compute 10 percent of the
balance. If somebody has got a balance 6000 then have 20 percent of that computed and
assign it to the interest part. So, you see a bigger statement if balance is greater than 500
then interested equals balance multiplied by 0.02 else interest equal to balance multiplied
by 0.01 all these things can be done in one single sentence or one single statement using
c all right. So, that is why some people prefer to use such ternary operators and you will
also certainly use it, but when you are very confident about your programming. So, this.

Now, we come to a new construct you know that is the switch construct. Now in order to
understand this. So, let us quickly go to the flow chart for a while see I draw flow chart
like this.

I am evaluating some values here all right or maybe I get some value from the user here,
I read some value let me make it clearer.
I read some value from the user all right something read colour now here depending on
the colour that the users applies earlier in this decision box whatever you doing? We
were either going for true or for false. Now here what we are seeing if the colour is red
then we do something, if the colour is blue we do something if the colour is magenta, we
do something if the colour is orange then we do something if the colour is violet we do
something ok.
So, the same diagram I can draw in a different way that is.

I am reading colour and then as if I am coming to a switch box, think of this to be a
switch box where number of switches are there all right and number of switches are there
now depending on what value of the colour is coming. So, this may be the red switch,
this will be the blue switch, this one with orange switch, depending on which switch
which value is coming. So, let the value be v. If v is r then this switch gets closed and we
follow this path. If the v is blue then this switch gets closed and we follow this path. If v
is orange then then this switch gets closed and we follow this path all right that is why
because of this analogy which switch this statement is also known as switch statement,
this is also very much use for branching.
Branching we have seen with this else type of thing and here, also we will see another
variety of a c construct called switch using which we will do that. So, let us see here now
let us look at the construct of this. The syntax of the switch statement is this switch
expression then case expression 1 expression 2 let me give an example first and it will be
better I will come back to this.

So, here is the total switch structure, it is a multiple selection structure. So, I come to this
point switch if the case is a, if it is the case that the colour is red like that if the case is a
then I take the case a actions and then come out M otherwise I take the case reactions in
the case be b then only I will take the case b action and then come out.

Similarly if there may be different cases. So, what we are getting here is an advant is an
example, that we are showing here what we are getting here is using this case construct
multiple branching we are accommodating in one shot. L et us look at this I was giving

an example with colour here it is an example with a letter. So, I have read some letter
from the user some letter has been now that letter can be anything A to Z say A to Z. So,
if it be if the case is that the letter is A. Look at how it has been written case A before
that switch what is my variable on which way I am switching? Switch on variable letter.

In the earlier example it was switch on the variable colour. So, here we start with switch
on the variable letter.
And what are the possible switches I encapsulate that in 2 braces just as we do. Now
within this I am taking multiple decisions multiple possibilities are there for example, if
the letter is a; that means, if it is the case that the letter is A then we put a semicolon then
I write down print the first later. So, what will be printed first later and then there is a
break statement what this break statement does? That you execute this and then you
come out of this entire switch box come out here; that means join the next statement. If
the letter was B then here it is not written I am writing case B printf second letter
backslash n and then break; that means, if the case is B then.
I will print this and after that with the break I will come out of this now after that I have
not written anything else, but I have written case z only this is case z all right printf last
letter as is shown here and then break. Now if somebody this letter was p if this letter
was q or some other alphabet sorry I mean anything small alphabet or capital alphabet x
whatever in that case what do I do? This one only tells me what I can do if the letter is A

or if the letter is Z or in my case if the letter is B, but if it B something else otherwise
then we use this statement called the default statement if anything is other than what has
been specified here then we will say that it is some other letter and.
Then break it you see here if the letter is a then only I entered here and then went out if
the letter is b then I only entered here if the letter is c then I will come to default if the
letter is c it is not specified here I will come here and I will escape I will go right it is an
intermediate letter and then come out. So, with this understanding if we can go back to
the earlier slide, the flowchart then we can see that the flow chart will be something like
this.

We start then we evaluate expression, we evaluate expression come here its equivalent to
case a yes do something do something and then break otherwise it will come here is
looking at I am just doing this case z, if true then do something oh and then break right
otherwise.
So, this is true this is false, this is true this is false otherwise default I will come here do
something and then break now all these breaks all these breaks brings me to the next
statement after the case statement. So, anything that is here whenever I encounter a break
this comes brings me here this also brings me here, this also brings me here and I
continue following the sequential nature of program from here all right.

So, we have a seen. So, here is another nice example we can look at it say here switch, I
am switching on an expression what is that? Choice to upper now if this has got some
multiple parameters into this, let me take it up in the next lecture so that I can devote
some time on this.
Thank you.

So we are looking at a new construct that is switch and case.

So, here is another example, but this example has got many more things embedded in it.
For example, in order to understand this you have to understand two things that are being
introduced here, one is getchar. This is a construct we have seen scanf, we have seen
printf as input output statements right, but getchar is also another statement another
function actually, this is given by you can since we have not considered function in detail
there is a built in library function or an operation you can consider that to be an operation
also that getchar and then they there is a parenthesis as if we want to have some value
here.
It means get the character from the user. So, where from does the user provide you the
character whatever the user types, that will be captured by this function and this will get
that particular character that is why it is called getchar, all right.

That other thing that we have here is another function to upper to upper and then you can
see that there is another parenthesis to upper what it does is it converts any character
variable to its upper for example, if I type a as a character say I have got a variable
mychar. Now suppose I have declared mychar to be a character type of variable and
somewhere here I assigned mychar to be a.
Then what does mychar get? Mychar gets a ascii value of small a, now if I say toupper
mychar then what it will do? It will take the ascii value of small a and will return me the
ascii value of capital A all right to the upper a. So, this one will be returned.

So, here you see to upper what not mychar, but what? We have written to upper then
getchar character. So, what it means is that, you will get the character from the keyboard
suppose it is small a, and then that will be converted to capital A. So, it becomes capital
A and then that is being fed assigned to choice ok.
Let us look at it because it gives us the opportunity to look at nesting of functions also
here two built in functions which are being used here to get the character and assign it to
choice all right. So, you can also have another example similarly we have got to lower
getchar something, where if I had given capital A it will be converted to small a ok.

And then I assign it to something else other things also I could do by suppose I getchar,
mychar and mychar is assigned a sorry mychar has been assigned a, then I can say again
I can assign not mychar.
So, some others mychar and suppose the there was another variable mychar 1 to upper
mychar that was also possible of course, mychar one has to be also declared that is not
declared here ok.
So, this now that was the first part of the thing.

Now, let us look at this. So, we take a choice. So, what is the choice? We are taking a
choice and what is the choice; choice is a character that has been given if the user gives a
lowercase character then suppose I want a choice between a multiple choice answer
scenario, type in the answer a b c. So, somebody can type caps cap a shift a or just a all
right whatever you type internally I will convert it to capital.
So, through my; to upper functions. So, now, I take your choice now based on the choice
I go on checking is it r if so, print red and then break its not R then let us go and check
whether its green G. If it is G then print green and then print green and for break you will
come and meet here it is not green also not R not green, I will come to this point is it
blue yes then I will print blue, but suppose somebody has printed as typed in give the
choice as y all right Y then neither it is R nor it is G nor it is B then we will come to
default and we will print invalid choice.
Here since that is a last statement I am closing the bracket immediately after that I may
not give the break statement here, I am free not to give the break statement here.
Otherwise now suppose let us look at this break statement suppose I do not give the
break statement suppose this is not there and my choice is r my choice is small r.

So, at this point the small r will be converted to capital R by this statement right by
this. So, my choice will be capital R now I go here and I will my system will find that it
is r. So, it will printf red I am sorry why should I the printf red will be worked on let me

do it again, my choice was r that was converted to capital R and by this and then I come
to this point and I find that it is r.

So, my system prints red, red has been painted now this break statement is not there. If
the big break statement is not there, then it will not go to check this condition it will
simply print all these things. Since it has follow this path unless I force it to break it will
go on following this path. So, I will have green printed again which is not what I desired
right. So, let us see. So, now, let us see here let us look at this flowchart.

The switch statement if the case is red let us take to the example that we are doing, red
then I print red then break. If the sorry if the break was not there then I would be
following this path again I mean this path would be followed that is why this break is
essential will show that requirement of break in a moment.

Now, let us look what the break statement is used for. The break statement is used to exit
from a switch or terminate from a loop; we have just illustrated it for the switch
statement it can be also used for some other purpose.
So, the break statement causes a break statement causes a transfer of control out of the
entire switch statement to the first statement following the switch statement.

So, I hope you have understood what is meant by the switch statement how it can be
used we will see that, through a number of examples later we will see with the number of
examples. So, we will see that the break statement can be used for exiting from loop also
we will see that, but what is a loop.
Next we come to see repetition, till now what we have seen is branching, but now we are
going to look at another important construct which is repetition. Now just for a moment
let us go back to our old friend example that is finding the sum of n numbers for
example.

Now, how did you do that what was the flow chart? The flow chart was something like
this read N there is a number of numbers all right then we make sum equal 0, I am
adding 10 num adding n numbers then read number I am giving a different variable name
num, then I am adding that with sum, sum is assigned sum plus num, then I am
decrementing N.
Now, I look at is N 0. if yes then I go and print sum all right. So, if there be three then I
first read one add it. So, n actually shows how many numbers are yet to be added. So,
print sum then stop, but if N is not 0 then what I will do? I will go and continue this path
this is another form of structure that we see that we have based on some decision we
have got sum statements somewhere, and we are going back to that and repeatedly doing
this this is we are repeatedly doing this this is known as loop this is known as repetition
or loop all right.
Unlike the earlier case of if then where we look at the condition and then we follow
either this path or this path both in the forward direction, here we are also taking up the
backward direction. So, this is a very important concept we will need it at every step in
our programming exercise. Now there can be different types of loops we will discuss that
later, but first let us take.

Let us look at a counter now there are three types of loops briefly let me tell you one is
loop is something that is repeatedly executed. There can be counter control repetition
where we know that that we know before and how many times I must repeat ok.
Suppose I know that find the sum of N numbers whatever that be n I know that this will
have to be repeated N times all right N times, but there is another case where we actually
go on repeating a particular set of sentences we go on repeating that until a particular
condition occurs; that means, some value has become negative or something that say for
example, I am taking the sum I am adding that and the sum goes beyond 9999 and if it
goes beyond that I will stop, that sort of situation is known as sentinel control or even
controlled repetition this will come later.
But most importantly we will look at this counter controlled repetition where we know
how many times we should look and for that we need a control variable we will see what
that is.

So, counter control repetition requires name of a control variable or a loop counter. If
you recall in when we added n numbers what was my counter variable? What was my
control variable or what was the loop counter, how many times will it do n the number of
numbers right.
So, similarly I can have another some other variables say I say I can just draw arbitrary
flowchart for you say is and integer initialized to 0, then I come here do something and
then i increment i let me use what we learnt I increment i plus plus; then I check, i
greater than 10 if it is yes I will again, if it is no sorry if it is no I will again do that if it is
yes i will come out all right. So, I am doing it as long as i is not greater than 10.
So, this here what is my control variable? My control variable is i or this is a loop
counter based on which how many times I will be carrying it out is determined. Now we
also had an initial value of the control variable what was the initial value that I did in this
case.

The initial value of i was 0 it was initialized to 0 if you have seen the condition that tests
for the final value of the control variable whether the loop should continue or not, what
was my condition test in the earlier case? It was i greater than 10 if i is greater than 10
then I will come out otherwise I will go on continuing with the looping and another
increment or decrement operation here i was 0. So, I implemented it until it comes to 10
or crosses 10.
If you recall in the earlier example there was n. So, I have to read n numbers after
reading one number I decremented n. So, depending on what I want to do I will have to
increment or decrement the control variable and based on this condition I will come out.
So, here is an example an initialization is done, you can see here a counter has been set
to one it is an integer counter that has been set to one while counter is less than equal to
10, while it is a statement that you are getting. As long as counter is less than equal to 10.
So, this is one new term you are learning.
While counter is less than equal to 10 do this printf the counter value and then increment
the counter and then go on doing it; now this is this really does not make any difference
if I had written counter plus plus that we equivalent because these are singleton here
there is no assignment or nothing addition with this value. So, its standing alone it really
does not mean me and does not matter whether it make it counter plus plus or counter

minus minus. So, this one is. So, here is the condition check counter is my control
variable and increment and decrement operation.
Now, you are getting this while statement and now let us try to find the simple English
meaning of while. We often write something like this while it is raining stay home; that
means, as long as it is raining stay home. So, this is the conditions condition as long as
the condition is true do this, here you see while the counter is less than 10 as long as this
condition is true do this. If this condition is false then come here do not do this that is the
meaning of the semantics of while.
So, while is used for one of the methods by which we can achieve counter control
repetition now counter control this we have seen.

So, the while statement actually looks like this, while some condition the statements to
repeat it can be one statement or it can be multiple statements as is shown here within
this block all right, this entire statement should be this entire thing should be repeated;
example here suppose here is a weight loss program I mean as if you have being told to
lose weight by following this while weight is greater than equal to 65. While weight is
greater than equal to 65; that means, as long as your weight is greater than 65, then printf
go exercise ok.

Then come back again enter your weight and then read the weight, now here there is a
nice thing often we had encountered the scanf and printf independently. Now look at this
statement printf enter your weight scanf weight what does this two together mean.

I have got my screen here and a program is running and it just says scanf percentage d
and w say weight, you do not see anything on the screen, but suppose somebody who is a
little more helpful to the user writes printf enter your weight all right. Then here on the
screen it is printed enter your weight and then since backslash n is there you are here.
Now, scanf percentage d and w. Now here then when you type your weight say 65 then
that is shown here you know what data you are supposed to give. So, this sort of thing
makes it more interactive all right. So, here you see these two I have made the program
more interactive, but what is the program do? It checks at every point first it checks
weight. If the weight is not greater than 65, it will simply come out here because this
condition is false otherwise it will carry out all these statements and then it will read the
weight again you see again, the weight has been read and after the weight has been read
it is coming back here and checking it again whether the weight is greater than 65. If by
one days exercise you have reduced your weight then; obviously, you need not exercise
more you can come out otherwise you will have to again go and do this. So, while is a
very important statement you should understand the meaning of this, and we will try to
do a couple of more exercise on examples on this.

Thank you.

We were looking at C constructs by which we can achieve repetitions or loops; that
means, a set of statements will be executed repeatedly for a fixed number of times ok.

So, one of such constructs that we came across was the while statement as is being
shown here while. And you can see the structure of this that while a particular condition
is true, we will carry out a set of statements. It can be one statement or it can be a
number of statements as is shown here a number of statements will be repeated as long
as this condition is true. An example that we had seen in the last lecture was this that is
as long as I can read this while as long as all right. As long as the weight is greater than
65 we will have to do exercise all right, and here you again check the weight and if it is
greater than 65 you will carried out that is the structure of the while statement.
Now, how can you use it fruitfully? Let us take an example of using the while loop for
some meaningful computation. For example, I want to add 10 numbers the example that
we are doing earlier we had shown the 0 count for that. So, I have got a value N.

Let us see let us do it for a small n number N equals to 5. So, I will carry out the sum of
5 numbers. So, I will have a count another variable count which may be initialized to 0
ok.
Now, we can write something like. So, initially count is 0, count is an integer, count is 0
while count is less than N and also I do another thing I am going to add 5 numbers. So, I
create another variable sum. So, sum is 0 and count is 0. So, while count is less than N, I
can I write a complete program; now printf. Please enter a number and then. So, on the
screen I will have please enter the number printed here, then I am doing scanf percentage
d and num, num is the variable which I am reading, and then I am adding updating sum
initially sum was 0. So, sum plus num all right I do this and then I how many numbers I
have read I have read one numbers. So, I will do count plus plus; that means, count is
now 1.
So, one number has been read. So, I will be completing here, now let us see what will
happen. Suppose M was 5. So, sum is 0. So, the first number has been read. So, count
was 0 please enter a number and some number has been entered and suppose that number
was 5, then sum is sum plus number. So, this one becomes 5 then I increment count. So,
count becomes 1. I come back here, I find count is still less than 5, because I am going to
n is 5 right.

So, count is still less than 5 I again do that suppose I did the second number 6. So, then
this becomes here I add this becomes 11 and count becomes 2. Please note that count in
this case is therefore, keeping a count of how many numbers I have already read because
I am reading the number here and then incrementing count. So, count now I have read 2
numbers and I have added the sum ok.
So, now after doing this count is becoming 2 average, 2 numbers I again go here now 2
is less than 5 I take another number say 11. So, I add sum. So, it becomes 22 and I
increment count 3. I have read 3 numbers I go up again here and read the forth number
15 add that with sum. So, 22 plus 15 will be 37 and then count will be upgraded it will
become. So, I have read 4 numbers 5 6 11 15.
Now, I again go up go up here and check count, count is 15 yeah sorry count is 4 which
is less than 5. So, I read another number suppose that is 7 I come here add it, it becomes
44 and I increment count I first add that number. So, it becomes 44 and then I increment
count. So, count becomes 5 meaning that I have already read 5 numbers.
Now, when I go back here, I check is count less than N? No therefore, I will come out of
that and maybe here I will write something like printf the sum is assuming integers is
percentage d back slash n and here I print sum and whatever I do here are the other
components of the complete program declarations integers and all those things are there
all right.
Now, point to be careful about, I must be very careful about expressing the condition.
Look here if instead of this I had if instead of this I had made it less than equal to n then
what would have happened? If instead of countless than n, if I had written count less than
equal to n what would have happened? After count is five; that means, I have read 5
numbers have added 5 numbers and 44 is my result I would again go back here, and find
that count is less than equal to 5 count is 5 therefore, this condition would be true, I
would again come and would have read another number sorry I should cut it out. I would
have read another number and then count would be incremented 6, I would have 45
which would be along result because here actually I have read 6 numbers. So, you must
be very careful to specify this particular statement.

So, that the number of times you want the loop to work should be accurate should be
correct. So, I think you have understand this example, a very simple program, but some
theory is needed about this. So, that was an example of while statement.

So, here is another example suppose the digit is 0 what would this one do can you find
out what this will do? This is a while statement. All of you try to look at it and find out
what this loop does this while loop does. If you look at it carefully you will see that I am
starting the digit I have initialized digit to be 0.
Now, while digit is less than equal to 9, first time I come here it is less than equal to 9.
So, what will it do careful it will come to this printf statement and we will print digit now
it is a post increment or pre increment it is a post increment; that means, first digit will be
printed. So, 0 will be printed then digit will be incremented. So, this digit will now
become 1 I again go back here and find that digit is less than equal to 9 right. So, I will
come here, print the digit 1 and then again increment digit, digit will become 2 I go back
here check whether it is less than equal to 9, it is still less than equal to 9, I will come
inside the loop will print the digit 2 in that way it will go on ultimately 8 will be printed
and 8 has been printed, and I go back after printing 8; this has been incremented to 9, I
go back here.
Now, you see here less than equal to 9 therefore, I will still executed; that means, I will
print 9 and then increment it, it will be 10 and then when I go up here this condition is no

longer true therefore, I will come out of this loop. So, what will be printed 0 to 9 the 10
numbers will be printed. So, that is how the while loop works.

So, this flowchart is very important to remember what while does you have actually
understood it by now, but the key point to note the most important point to note is this,
that when I am executing the program in this direction, I first compute the condition.
First I compute the condition and if the condition is true I execute the body of the loop
then I again go up check the condition and this will be going on.
So, first the condition is checked if it is false I will go out of the loop. So, if initially say
for example, I write something like this say digit, is equal to 20,and I start something like
while digit is less than equal to 15, some things I will be doing. Now in this case when it
comes to this condition at the very beginning in will fail, because this condition is not
true. So, it will come out to this false path and this loop will not be executed, will be just
coming to the next statement after the loop.
So, in while the condition is first evaluated and depending on the success of the test of
the condition, will either enter the loop or will bypass the loop. So, this flowchart is very
important.

Now, we will be contrasting while statement with another statement which is the do
while statement what is the difference looks like very similar. So, there is a scope of
confusion while and do while. So, as the name implies here do comes first do something
and then check the condition. What it means is say do some statements here while
condition will do all these statements and then check the condition.
So, let us see what will happen here, the weight loss program again really with while is
do go exercise. So, we start with a do you do, go exercise printf comeback whatever
whatever, then read the weight and while weight is 65. So, at least the condition is being
checked here the condition is being checked here. So, it will at least carry out the
computation once.

So, the digit thing if we do suppose I write something like this. So, digit is 20, and I write
while digit is less than equal to 15 say I do digit plus plus, printf digit. Now in this case
since the digit is 20 what will be printed here nothing all right or say let me make it even
simpler.

Let me make it a little different digit is 20, while 15 digit plus plus printf percentage d
back slash n digit. If I do this since digit is 20 what will be printed here 20 will be printed
because this plus plus will not be executed right because here it will feel.

But if I do it now if I do it as digit equals 20, do I need to give the bracket, I may or may
not, but let me gives give it it really does not matter digit plus plus; while digit is less
than 15 less than equal to 15 and here I write printf percentage d back slash n digit all
right what will happen let contrast this here also digit is 20 here also digit was 20.
Now, here it was tested at this point. So, this digit plus plus will not be executed, it will
straight way come here and will print digit it will be 20 whereas, in this case I first
encountered this do, and as I do I check this digit I make this digit plus plus; that means,
it becomes 21, and then I check while digit is less than equal to 15. Now I find digit is
not less than equal to 15 of course, I will not do it again, but once I have already done it.
So, when I take the printf digit will be printed to be 21.
So, here is the difference between while and do while. So, these are 2 constructs by
which just 2 examples constructs by which we can carry out the loop. So, at least one
round is carried out. So, if I take if I look at the flowchart, it will be looking like this it
will have a set of statements which will be executed at least once whatever the condition
b condition s. So, this will be executed first it will be first executed here.

And then we check the condition if it is false I will not do it again, I will come out
otherwise I will repeat. So, here again that old example digit was 0, do printf digit plus
plus while digit is less than 9. So, you remember in the earlier case we had printed 0 1 2
3 4 5 6 7 8 9; now what will be printed in this case let us see digit is 0 initially.

Now, we come here first we print digits. So, 0 is printed, 0 is printed then digit plus plus
is done. So, digit is 1right. So, digit now becomes 1 digit was 0. So, it becomes 1 and
then I check is digit less than 9 yes it is less than 9. So, I again print digit one is printed
let us make this 9 let us say that is 5 all right let us say it 5. So, we have done make made
it one and after printing one digit has been made 2 plus plus has been done, I check again
it is less than 5. So, I will do. Go to the loop again I will do it again. So, I will be printing
2 and then make digit to be 3 it is still less than 5, I will go again I will print 3 and then I
make digit to be 4 still less than 5, I print 4 I make it 5 all right less than equal to 5 right.
So, I print 5 print 5 I first print 5, then increment it to 6 as I do it I increment to 6 and
then I check whether it is a less than equal to 5.
So, if it is since it is less than not less than equal to 5, I will come out of the loop. So,
what I will be printing is 0 1 2 3 4 5. So, this is an example of while do while next.

So, this is one type of statement that we have encountered here, that is while and do
while. Here we are not be specifying any number of times that it will be doing; as long as
a condition is not met I will be doing it.
Now, how is it that the condition is being affected it is through the computation insides.
So, for example, the computation here this is plus plus, that is being done by that this
condition variable is changing all right there are cases where I know a priory beforehand

I know beforehand that I will have to carry it out 10 times I will have to carry it out 20
times so and so forth ok.
So, for that another construct is very important and is used in C language that is the; for
construct. Welcome to the; for construct this a little complicated, you should be attention
there 3 components of this for one is an initial a value, now this initial value can be
assigned to a control variable. So, there is a loop program and how many times it will
loop. How many times it will loop that is being determined by some control variable. In
the case of while what was our control variable? Say for example, in the earlier is a case
of earlier example the value of digit was the control variable. Here we put some control
variable and initialize the control variable with some value; here some control variable is
initialized and then we have a condition. If that condition is true, then I will enter the
loop and do that and after doing this loop I have got some iteration parameter by which
we update the control variable and check the condition in that way it will go on.
So, let us have a look at the structure in a little more detail.

See here we have got some initial value expression some condition and iteration and we
have got some statements which will be looping. Here is an example say I am calculating
the factorial of 10. So, I am trying to compute the factorial of 10, some people write it in
this way some people write it in this way all right.

Now, here what is being done I will explain it in a little bit more detail, fact is a variable
which is standing for factorial it is initialized to 1. Now you know factorial of 5 is what?
1 times 2 times 3 times 4 times 5 right. So, I am started with some variable and
multiplying it with it is successor, and then the product I take and multiply with the
successor of the last integer and in that way it goes on. So, here is a look of how it will
look like we have got a for statement here, and I am saying for I assigned one now this is
what I was talking about I is a control variable here that is being initialized to 1.
So, that is less than 10 of course, because here I am trying to compute factorial 10 and
then what I do fact was 1. So, fact will be fact multiplied by i what was i? I was 1. So, it
is one times 1, then after this operation is done I go and do this iteration operation
iteration operation what it is doing it is incrementing i and i is becoming 2, and then
before I enter I just check whether it is still less than 10 yes it is less than 10, I will again
do that. So, fact will be it was 1, 1 times what is i now 2, 1 times 2 after I compute 1
times 2 I will increment i. So, that will become now 3 it is still less than 10 please follow
my pen it is still less than 10, I go in compute what was I three. So, I whatever was fact
was the product of 1 and 2. So, I multiplied that with 3, and then I increment the iteration
variable it becomes 4 again I come and check is it less than 10 yes it is I go on here and I
multiply it in that way it goes on and on.
Now, ultimately it will be ultimately it will be like that 5 6 7 8 now suppose i is 9 sorry
suppose i is 9. So, I come here I multiplying fact with 9 i plus plus. So, i becomes 10, i
come here, i is still less than equal to 10 is it is equal to 10, I come here multiply 10 i
plus plus it becomes 11, I come here this condition is not satisfied I come out all right,
this is the for statement will look at it in the little more details in the next class.

We were looking at new construct for building up loops in C language and that construct
is for construct.

So, let me first write a simple program again the same program that we are writing for
reading for finding the sum of 10 numbers. So, just I am writing and you try to follow
what the meaning of this program is, then we will go and further explain it. My intention
is to read n numbers and find their sum the simple thing, how can I write that.
So, I put a variable again sum is 0 and I have read some value n whatever that value is.

Suppose say n equals 5 user has provided me or I can initialize it to 5. So, 5 numbers I
will read and add. Now, I write for i. What is this i? i is an control variable or we also
call it as very common name of this is an index variable, index variable. It need not be i
it can be anything, but an integer variable. So, that has to be declared at the beginning.
Si, I can declare let me start with normal declarations int, some program has start at main
int sum i and the number that I will read, I will see if I need any other variables later and
also n sorry and also n.

And here I do sum 0 n equals to 5. Now, this thing I could have read from the user, could
have taken from the user the value. How could I take it from the user? By doing a scanf,
scanf printf please enter the number of numbers you want to add then scanf percentage d
ampersand n in that way I could read this But here for the sake of saving time I am just
initializing it N is 5.
Now, what I do for i, this i equals 1 semicolon. So, this one complete statement i less
than equal to N semicolon i plus plus. What does it mean? We will see what it means
then what would I do I will printf. Please enter number let us say integer I call it please
enter an integer scanf percentage d num ampersand num. Then sum assigned sum plus
num that is all.
Here I do not have to increment this control variable why, after I add the number that has
been read here after I add that with sum I am going back to this for loop and where am I
going to, I am now doing this operation that is incrementing i. So, i will become it was i
was 1, so i will become 2 and then again I add the number. After I make i equal i
increment i, initially i was 1 here, so what is happening. Let us look at what is happening
to the control variable of the index i was 1, I do it once. So, the sum becomes number
suppose the number was 5 suppose the number was 5 that was entered. So, the sum
becomes 5, I increment i so i becomes 2, I check it is less than 5 less than this n. I again
read another number suppose I read 7 as the second number.
So, sum becomes 5 plus 7 12 and then I go back here increment it, it becomes 3 all right.
I check again after doing this I come here check it is still less than 5, so less than n I
again do this I need another number suppose it is 12. So, 12 plus 12 it will be 24. Here
increment this, it becomes 4, i still go over there still it is less than 5. I read the next
number which was 6 say, so sum becomes 30 here. Then i is incremented to be 5, i again
come here and check that is less than equal to n true. So, I come here I read another
number say 10 sum becomes 40, come back here i become 6, i come at this point this
condition is not true therefore, i will come to this point where maybe I will be writing
something like printf percentage d backslash n sum. So, the sum will be printed at this
point 40.
Now, you see I have read how many numbers 5 7 12 6 10, 5 numbers and that is what I
wanted to do. Now, I can look at this. Now, I could have done several this thing in a

different way also. For example, if I had just instead of this i equal to 1, I make it I
initialize this to be 0 all right, I initialize i to 0 and keep everything the same. What will
be changing? N is 5, so here i will start not from 1, but from 0. So, first will be 0 then it
will be 1, then it will be 2, then it will be 3, then it will be 4, then it will be 5. So,
ultimately how many numbers would I read? 6 numbers. But I was actually trying to read
5 numbers. I am sure you are confused. So, let me show it through another example.

Suppose I read, I want to read 3 numbers. If I write it in this way for i, now by the way it
need not be i, I could have written declared it properly and I could have taken any
variable to be my index, I could have saved that it is my index But the only constraint is
that this must be an integer variable. My index is 0, note the semicolon here because this
is one statement then I write my index less than equal to 5 say less than equal to I am
trying to read 3. So, my index is less than equal to 3 semicolon again and then my index
plus plus and I just read the numbers. So, I am dropping off the printf just writing scanf
percentage d and num.
Now, I since its only one statement I can simply remove this parenthesis. Now, let us see
I wanted to read 3 numbers. Now, what will happen? Here I write my value the value of
my index and the value of num. My index has been initialized to 0 and I check with my
index my I check with this statement, it is less than equal to 3. So, I read the number

suppose the number is 15, I increment my index. So, my index now becomes 1, my index
becomes one still less than equal to 3, I read another number 5.
Next I come here. So, I do this and come here and my index becomes 2, still less than
equal to 3, I read the number say 14. I again come here my index becomes 3 less than
equal to 3, I read another number 5. I come here my index becomes 4 I compare this
condition is not satisfied. So, I come out of this loop.
But in the process how many numbers have I read? I have read 4 numbers 1 2 3 4. But
what was my intention? My intention was to read 3 numbers. So, where did I go wrong
where did my logic go wrong. This is what as a programmer you must be very careful
and cautious about. Where did I go wrong? You can say that I have gone wrong in either
of the 2 places, one is I could have simply initialized my index not with 0, but I could
have initialize it to 1. In that case what would have happened, first this part we forget we
will start with my index one, read one number less than 3. So, then become 2 less than 3
I read the other number increment it, it becomes 3 still less than equal to 3 I read this
number, whenever I come to 4 then my index becomes 4 this condition is violated. So, I
will not be read in this number it will be all right.
Otherwise, another thing I could have done what could I have done? You must have
discovered it by. Now, that suppose I had kept my index to be 0, I decide no I like this
circular figure 0 very much, so I keep it like that. Then what should I do in order that I
can still be logically correct? I would have changed this condition from less than equal to
to less than, then let us see what would have happened. Then also my index starts with 0
I read one number incremented. So, it becomes 1, I check for the condition my index is
still less than 3. So, I read the other number 5 my index is incremented 2 still less than 3.
I read the other number 14 fine as soon as I after I read I make it 3 incremented and I
check the condition. Now, it is no longer true it is not less than, but equal to, but less than
equal to is not my condition my condition is less than therefore, I will not read the forth
number.
So, this is a point where often people make mistakes while writing for loops. So, I
encourage all of you to very carefully study this we look into the for loop a little bit
more. So, we have seen the initial. So, I have given you some example one point that is
very important you must have noticed while I was writing this that there is no semicolon

at the end of this statement why, because the entire for statement has not ended here it is
going on for this period to this, that is the end of the statement. So, no semicolon is given
for this for conditional part all right. And here all these are expressions you can see that
this I am sorry what happened. You can see that this is an expression sorry this is an
expression, this is another expression, this is another expression.
Now, since these are expressions it can be very general for example, I could have written
initialization is fine, but here I could have done something i plus p times 2 is less than 25
that is very much valid and here also I could have done i assigned I could have written i
assign i plus 5 or I could have written i assigned i times 5 anything. This is a modified
modulator I am changing the condition and changing the index variable and then testing
that index variable with respect to a condition. Only point that you should remember is
that that this must been integer variable.

So, how it works? The expression one that is say typically i assigned 1, the expression 1
is used to initialize some variable call index that controls the looping action. Expression
2 i less than equal to 5 represents a condition that must be true so that the loop continues.
An expression 3 say i assigned i plus 2 all right that is the bracket, i assigned i plus 2 or i
plus plus as you are seeing till now, they are used to alter the value of the index initially
assigned by expression 1. We have seen this, so not much to worry about it.

So, expression one is used to initialize, so here.

So, what is the way it is done is first expression 1 is executed. So, for j equals 0, j less
than equal to k plus 5 can be anything it can be an expression j plus plus. So, first this
expression is executed then after we execute this, I check by initialization have I violated
the condition in that case of course, there is no point getting into the loop I will go out.
Otherwise if it is not done then I go inside the loop carry out the loop and then instead of
going into the loop straight back I will first come to this alteration or modulator

statement. So, it is I am sorry what did I write here. I wanted to write j assign j plus 1
here or j plus plus whatever. I do that and after I do that what do I do, I immediately
come back to this expression and test it again is it true, if so I will get into otherwise I
will exit. So, this is the structure of the for statement.
Now, there are a couple of critical issues, but before that let us write a simple program
with for. Suppose I want to find the sum of first 10 natural numbers.

What are the first 10 natural numbers? 1 2 3 4 5 up to n. So, in school mathematics you
know that the sum for 10 numbers it is the formula is n times n plus 1 by 2 right. So, one
simple program is if I want to find the sum of n numbers you can simply do in your main
int sum assign 0 and then in one short you can write sum assign 10 because I want to
write 10 natural numbers, 10 times 11 divided by 2 and then printf sum, that could be
one way. But that is not what I am going to do. I want to illustrate the for loop.

So, the way I can do it is main main function and here I put in int sum equals 0. Now, I
know that it is not I am not going to find the sum of n natural numbers I am going to find
the sum of 10 natural numbers. So, I can write it in this way for. So, in sum equal to 0
another variable I have to initialized that is my index I write it int my index not
necessarily i or j all right, but it must be an integer. So, for, but I am not initializing it
here, for my index assigned 0 my index less than 10, please verify whether I am right or
wrong my index plus plus. Sum assigned sum plus my index plus 1 what will happen?
Sum was 0, my index was 0, so my index plus 1, the sum will be 1. What am I
expecting? 10 times 11 by 2 right. So, that will be 55 right, sum of first n natural
numbers.
Now, my index becomes 1. So, my index is 1 now, less than 10 I again add that. So, sum
was what was my sum? My sum was 1. So, here is first iteration sum was 1, then sum
was 1, I have written it here. So, sum plus my index my index was 1. So, 1 plus 1 am I
right. So, here it was right. Now, sum was 1 and my index is 1 plus, 2, 1 plus 1. So, it
will be 1 plus 2, this will be added so the sum will be 3.
Next my index will be implemented to 2. So, now, sum is 3 my index is 2 plus 1, so 3
plus 2 5 and 1 so sum will be 6. In that way it will go on and ultimately I will come to
this point where it will exceed 10 and then I can stop.

So, here is now, you can also do that, some of natural numbers you can do that all in a
loop using the very the index itself being updated and creating the different natural
numbers every time.

So, if I had written it in this way for i equals 1, there is the first one less than 10 less than
10 would that be i plus plus sum equals sum plus i. What would have happened? i is 1,
sum is 1 right.
Now, next i is incremented i is 2 and then sum was 1 so that will be added sum is 3.
Again this will be added 3 sum is 4 sum is 3. So, then be 6 again 4 then be 10 in that way
it will go on ultimately. So, suppose I was trying to do it for 5 numbers. So, i just i less
than 5 first 5 natural numbers. So, sum is 5. So, now 4, I have already taken. Now, i plus
plus it becomes 5, but I will get stuck here.
So, if I start it with 1 what should I do? I just did it in a couple of moments earlier in the
earlier lecture. So, what should I do here? I should make it i less than equal to 5, in that
case I will take this 10 plus 5 15. So, 5 natural numbers sum of 5 times 6 by 2 is 15 right.
So, I can compute that using this loop all right. So, that is a very interesting application.
So, for is a very powerful will see, in future application that for is a very powerful
construct using which we can do many things.

Now, we are discussing about formation of loops, creation of loops in a program using
for statement. Before that we have seen the while statement and do while statement and
then we have seen the for statement as well.

Now, the for statement as we had shown we had discussed in the last class it is basically
starting to take an expression, arithmetic expression and then it starts with in sorry
initialization expression and then we check a particular condition. So, something like this
for some variable integer variable j assigned some value 5 maybe and then some
expression here this one is j less than equal to 25 and then here there will be some
statements which will be executed and after that there is a third expression which is
altering it and that can be j assigned j plus 5 all right and the body of the x loop. These
are structure that we had seen.

Now, there are some critical issues that are to be noted for the for structure.

So, if you look at this you can see that we are using arithmetic expressions. For example,
x assigned 2 and y assigned 10 that is an arithmetic expression. So, similarly this is a
valid arithmetic expression for j assigned x, j less than equal to 4 times x times y that is
the condition. That means, after some computation will have to find out whether j is
satisfying this condition and here j here probably this is something this construct we have
not shown you, this is I do not like it very much and initially you need not bother about

this j plus equal to y by x this is a C structure, say C syntax expressing j equals j plus y
by x. So, the whole thing can be written in this way.
So, this, but that is not important for the purpose of understanding for expressions. So,
here is just an expression.

And this is equivalent to like this for say x was 2 and y was 10, then this is equivalent to
j assigned 2 because j assigned x and j assigned 2 are essentially same; j as less than
equal to 4 times x times y that means, 4 times 2 times 10 that means, 80 and j equals
assigned j plus y by x is 5. So, this is equivalent all right. So, this is initialization, this is
loop continuation condition and this is the increment or I as I was saying that this is a
modulator or the alteration.
Now, increment can be negative. So, this increment all the way we are calling it
increment that is why we should not call it increment let us call it a modulator because
say the same thing I can write as for j assigned 2 maybe something j less than equal to 80
and might be j minus minus. It can be the case when can it be. Say for example, if I add
if I want that I will be printing the numbers in the reverse order starting from 10. So,
what should I do? So, can I do this what I want to do is, that I want to print something
like 10 9 8 7 5 all right in this order.

So, simply I can do this repeatedly in a loop for example, for j assigned 10 and j sorry, j
greater than equal to 5 j minus minus and here I just do printf percentage d backslash n j.
So, what will happen? Initially j is 10 less greater than equal to 5, so 10 will be printed.
Then I go back I decrement j. So, j will become 9 still greater than equal to 5 I come in
here print j 9, I again decrement j decrement j becomes 8 I compare with this still it is
greater than equal to 5 I get in and printed. In that way I can do it I can repeatedly do the
same thing, but here as you can see I am being able to achieve this reverse order by
instead of incrementing and decrementing this index. That is why I can increment to
decrement, I can multiply it, I change it, I modulate it, that is why this to an alteration
expression or modulation expression is a better term than increment or decrement.

So, if the loop continuation, if the loop continuation condition is initially false is initially
false then the body struck the for structure will not be executed. It will proceed with the
statement for the next statement.

So, for example, if I write something like this as you have seen earlier j equal to 20 and
for i equals i assigned 1, i greater than j i plus plus say and then I want to do some things
here all right.

Now, j is 20 I will first initialize i to 1 and immediately I find the first thing that I do is
its false I check this and its false i is not greater than j therefore, this stay these
statements will not be executed even once and the statements following the for loop will
be executed.

Now, here are some examples of for loops. This is again computing the factorial fact.
Factorial is a the variable, fact is touring the factorial factorial all of you know as
factorial n is n multiplied by n minus 1 multiplied by n minus 2 so on so forth up to 1.
So, it is 1 and I have got a variable i. Now, you can see simply I can do it like this i
assigned 1, i less than 10 i plus plus fact assign fact times i. Now, what is happening
here? So, I have got fact to be 1. So, i equals 1 then with that what I do is 1 times 1 is
fine and I then make i to be 2 and then i, i becomes then 2. So, 1 times 2 then i becomes
3 then 1 times 2 times 3 then i becomes 4 then 1 times 2 times 4 times 3 times 4 and so
on and so forth it will go on in this loop. So, that is a nice way of writing factorial.

And here is another example you can see what it does quickly. You can explain it
yourself what it does. Sum is 0 and N is a variable and count is another integer variable
all right. Sum is 0, N is a 1 variable and count is another integer variable. Now, we are
reading N and for i equals 1, i less than equal to N I am adding some. So, what is being
done here what will happen if I press this program what is going to happen? Let us do
that.
Suppose I have read N to be here, I have read N to be 5. Now, what am I doing here? I
here there is one problem here i should have been declared there is a mistake here int N
and here i also add i should have been declared here. Now, i assigned 1. So, i is 1, N was
5, i less than 5 less than equal to 5. So, sum is sum was 0. So, sum is 0 plus i times i, i
was 1. So, 0 plus 1 square and then I check i increment i. So, i becomes 2, i becomes 2
and I check that i is less than it not less than a is still less than equal to 5 so I got this sum
and with that I add now, i square i times i, so 2 square. Similarly, it will go on it will do 3
square. So, i will become then 4 and then still it is less than equal to, so 4 square then i
will become 5 and still it is true. So, it will be 5 squared then i become 6 this condition
will be violated and i will come to this printf.
So, what will sum be sum is 1 square plus 2 square plus 3 square and if I make it N then
up to N square. So, this is the very well known series the sum of the square of natural

numbers we can compute by this small program using for loop right. So, it is a nice
example.

Now, we introduce the comma operator. As we say that here for when we write for then i
assigned 1 instead of that I can put in more than one statements here using a comma
operator. For example, for fact 1 i equals 1, i less than equal to 10. Now, this part is
what? This part is the initialization. Now, remember that this will not be continuously
initialized, this is just an just a statement that I put here an assignment statement, but my
index variable for the control variable for the loop is i. So, I could have written this
earlier example of factorial maybe, earlier example of factorial this could be initialized
here also all right. So, that is just saving space saving the number of lines of code.
But personally I would suggest as I did earlier also that is for of those of you who are
beginners in programming you should not try this tricks or should not try this thriftiness
reducing the number of lines, that is not so important to how much you can reduce. The
most important thing is to be logically can syntactically correct while you write a
program ok.
So, we can give several things in comma like some here again. So, the program becomes
even smaller look smarter, but sometimes at the beginning if you try to do that you try to
be smart and in the process you may result in some long program long long logic better
avoid that.

Now, infinite loop in general what is an infinite loop. When a program continues,
program continues in a loop repeatedly it goes on and it is never completing its going on
because the condition that is supposed to turn out to be false at a particular point of time.
So, that it comes up the out of the loop never happens all right. That can always happen
that say if I write something like for i equals 1, i less than n and whatever i plus plus.
Now, every time inside the loop when you get in you read you do something and then
increment i and when you come inside the loop you do i minus minus, then whatever has
been done here will be canceled out here. So, this loop will never reach this condition I
less than i therefore, that this loop will continue forever such situations are known as the
condition of infinite loop.
Now, sometimes usually we do not like that, but sometimes it may be necessary to
specify that something will happen forever all right. Say some particular work has to be
done continuously.

Now, in order to specify that for loop provides us some facility like say for and while
everything say this one we had discussed earlier while 1, that means, always it is true it is
a nonzero this while loop this expression part condition expression part should return
nonzero and so it will go on. Now, here for and I put null; that means, the for has had 3
parts, for the initialization part, some condition part and some incrementation
decrementation part whatever.
Now, I just keep everything blank. So, I turn it to be for nothing and nothing all these
things are blank. In that case what will happen? In that case what will happen? If I keep
some statements here that will go on forever. Similarly if I in the case of do while if I
just put while 1 that is again in finite loop. So, by this I can express my desire that some
things will have should continue forever all right. So, this is another trick that you can
utilize in some cases for the for and the while constraints.

Now, we come to another statement which we have encountered a little few lectures
earlier in the context of switch statements. While we are considering the switch
statements if you recall you have seen that after every case statement switch on a
particular variable then their case red case, green case, blue if you recall then we did
something and then give a break, did something give a break like that we proceeded
right.
So, the break statement of course, we know can help us we can use it with several things
one is while, do while, for and switch. Now, this switch, switch part we have seen, but
we can also use it for while do while and for, for breaking out of the loop, we want to
break out of the loop. Sometimes that is required it works with while, do while, for, but
does not work with if and else statement. It causes immediately exit from a while for a
do while or case we have seen that switch statements earlier.
So, the program continues after with the next statement let us see. Why do we want to
use it? It helps us to escape early from a loop. Sometimes we want to escape early I do
not want to go till the end of the loop, when a particular condition is met I want to come
out. I am doing it in a loop, but waiting for some condition to take place as soon as that
condition takes place I come out of the loop. Maybe, as we have seen in the case
statement switch some expression all right color, then case R we do something and then

give break right, case G we do something and then give break right we do like that. So,
we skip the remaining part of the switch block right. We come out of that.

So, similarly we will see a couple of examples of this. Say here there is a complete
example let us look at that. Here is a complete example complete program, once again
include stdio dot h you are running some programs main, then fact and i are integers fact
we are computing factorial. So, fact is 1, i is 1, while i is less than 10; that means, I want
to break out while i is less than 10 fact times i, if fact is greater than 100, then factorial is
above 100 factorial of a number is above 100. So, for example, I am going on up to 10
numbers. So, what will happen with the factorials? Let us see. So, factorial 1 will be 1,
factorial 2 will be 2, factorial 3 will be 3 times 2 that is 6, factorial 4 will be 4 times 3 for
4 times 6, it will be 4 times 3 times 2, so 4 times 6; that means 24, then 24 times 5, so
that will be how much it will be, more than how much will it be if I have got this 4 3 2
and multiply that with 5, so 26.
So, here just with 5 numbers I am exceeding the value 120, but I do not know when I am
going to reach the value 100. So, I have written the program in this way, fact while i is
less than 10 I will test it up to 10 numbers every time, I compute fact if fact is greater
than 100 print. So, here as soon as fact becomes 100 will say factorial of 5 is above 100,
factorial of 5 is above 100 and then I break out. Otherwise if I had not put this break then
this would have continued till this loop all for all the 10 numbers up to factorial 10, but I

just want to stop whenever my result becomes more than 100. So, this is one way we can
utilize a break right.
Similarly there is another statement although we do not use it often it is better to know
that sometimes it can come handy, that is a continued statement; that means, the
remaining part of the body of a loop we will skip if I put a continue all right.

So, let us see and it proceeds to the next iteration of the loop. So, what happens is let us
look at one example here.

So, while one that means what; that means, it is always true. It will continually go on
doing it. So, fact is fact times i, i plus plus. So, I start with i 1, then 2, then 3. If i is less
than 10 I will go into the loop otherwise I will break. So, this continue is basically
remain forcing me to go back to this point, by forsaking this part. I am not coming to the
remaining of the loop, but if this condition is not holding then I will not execute continue
I straight away come here and do break. I think it will need a couple of moment for you
to just realize what is happening here all right.
So, just look at this. So, in this way it will I think you can understand it. So, I have got i
to be 1. So, fact will be 1 times 1, then i becomes 2 and then I go back. So, it will be fact
will be 1 times 1 times 2, i will be 3 and in that will go on, but as it will go on as long as
i is 10, less than 10. Then i will not come to break I will go back here. But if i is less than
10 i will come to break and i will come out of the loop. So, it is a combination of
continue and break this is. But what I want is that you should understand how the for
loop is used for repetition that is very important to understand and will carry out with
some examples in the next lecture.

Till now, we have learnt about some constructs of programming. To implement some
very generalized structures, programming structures, right. What are they? First, we have
seen, how we can do Branching, right.

And Branching means that whenever there is a sequential flow, we take a decision pop or
we come to a decision box and depending on whether the result is true or false; we take
different paths right. That is what we have seen and that is implemented by if else
statement right.
We have seen that and the other thing that we have learnt is repetition or looping all
right. That means, we have come to a particular point, we take a decision and based on
the decision, we decide whether we will go back to an earlier point or we will continue
forward. So this is, this repetition we have we could achieve by While statement, do
While statement or While do statement or for statement. So, if else and do while, while
do, for all these are constructs in the C language.

Whereas, the concept of Branching and Repetition or Looping is general for most of the
programming languages. So, these are general concept, while this is a specific construct
corresponding to the C language. Now to start our journey into the world of real
examples, let us first start with the school level equation solving.

When we try to solve a quadratic equation of the form ax square plus bx plus c equals 0.
We tried to solve it, means we wanted to find the roots of the equation. Roots of the
equation of this form and what are the roots? The roots are the values of x that will saw,
that will satisfy this equation.
For example I can have 3x square plus five 5x plus 1 equals 0 all right. What are the
values of x that will solve that will solve this right. So, we knew.

We know that, we can solve this general equation by the well-known Sreedhar Acharya’s
Method; that is x is minus b plus minus root over b square minus 4ac divided by 2a. By
this, we can find the roots of this equation and since it is a quadratic equation how many
roots will be there? There will be 2 roots. We also know that if b square minus 4ac is
equal to 0 then, this part will be 0. What will be the roots? Roots will be minus b by 2a
only.
So, there will be 2 roots which are equal. The same roots. For example, if I have x minus
a whole square that is equal to x square minus 2ax plus, what will that be? Plus a square
right. Now if I saw and if I say that this is equal to 0, from here I say that this is equal to
o, if I solve it I will make this as x minus a whole square and; that means, x assigned a
will be the root right. That means, x minus a is 0. So, x both the roots will be equal. So, if
I have root over b square minus 4ac equal to 0, in that case I will have both the roots
equal.

If root over b square minus 4ac is negative, we know then, our roots which are minus b
plus minus root over b square minus 4ac by 2a; if this part is negative, then, the roots
will be imaginary right. If b square minus 4ac is greater than 0, then, we will have Real
roots right and the Real roots will be minus b plus this and minus b minus this by 2a. So,
that will be that is a school level knowledge that we have.
Now, if I want to apply this knowledge, to write a program, that can take as input any
equation of that form ax square plus bx plus c and find its root. How will the program
look like? Suppose, I want to write such a program and now, henceforth in my discussion
about this problem I will called, I will call this b square minus 4ac to be the
Discriminate, I write it for short, Disc, as the Discriminate. Because that is, what is
telling me discriminating between the roots Disc. So, whenever I refer to Discriminate;
that means, I am talking of b square minus 4ac.

Now, I want to write a generalized program, for finding the roots of ax square plus bx
plus c; so, equal to zero. So, I want to write a program that will be equally applicable to
solve this root, this equation, solve this equation or 25x square plus sorry here I should
not write c, let me put it something like 5. 25x square plus 17 equals 0 or any such
equation. So, you see here what is the coefficient of x? Coefficient of x square is 25.
What is the coefficient of x. In this equation it is 0, that is why this term has vanished
and what is the value of c here? It is 17.
Whereas, in this equation the coefficient of x is 3, x square is 3, the coefficient of x is 4
and the constant term is 5. So, since I am going to solve any general equation of this
form, how can I define the specific equation? An equation of this form can be specified
by specifying the coefficients. So, I have to accept the values of a, b and c from the user
and you can see that the root is dependent on the value of these coefficients, because we
know the root x is minus b plus root over b square minus 4ac by 2a and minus b minus
root over b square minus 4ac by 2a.
So, the roots are determined only by the value of these coefficients. Therefore, the 1st
step that I will have to do here we can start with a flow chart.

So, I will 1st, I write Read a, b, c. Read them from the user. Then, I compute, Find
Discriminate equal to b square minus 4ac. I just compute this part, b square minus 4ac.
Because depending on this, we will have the different values of the root or I would say
all right. So now, so earlier probably I said that the Discriminate is root over b square
minus 4ac. I would like to correct myself. I would say Discriminate is this part b square
minus 4ac.
Because depending on the value of this, if this is negative, then, the roots will be
imaginary. Because the square root of this will be imaginary. So, this is the Discriminate
part. If this is 0 then, the roots are equal. If this is greater than 0 then, the roots are
positive and real and if it is negative then, the roots are imaginary. So, at this point, I will
make a decision. Discriminate greater than 0, yes. Then, what should I do? I will Print
Roots are real and then, I will print the roots. If the Discriminate is not greater than 0
then, I come here and I check whether Discriminate is 0, if Yes then, my decision is
Roots are equal and then I go and Print the roots.
If this is No, then, obviously, I will print Imaginary roots. I can see this part and then, I
will go and Print the roots. That is the flow chart of the whole thing. So, I am computing
this value and based on that, I am finding the roots. Now if the flow chart is clear to you,
let us proceed to write the program for this. Now here, obviously, I should have said that

the Discriminate is actually this part b square minus 4ac and then, I take the square root
of that.

So, now if we start writing the program, if I am a nice programmer, I will always start
with so, first of course, hash include stdio dot h. Then, I am including another thing
which is a library called math dot lib. Dot lib stands for library. Why I am including that?
I will come to that later. Now we start our program, main and we start. I can give a
comment, program to find roots of a Quadratic Equation all right. So, that is a comment.
So, anybody can understand, what I am writing here.
Now, I will have to declare a number of variables. I will declare the, lets say the
coefficients are all integers. So, int a, b, c. Now b square minus 4ac can be anything. So,
I put float Discriminate; also float root 1, root 2; 2 roots. Next, what should I do? Let me
proceed, to the next page, with this declaration, I hope you have been able to take down
this declarations.

Now, lets proceed and go to the next page. I am continuing with that. I start with printf
Enter coefficients a then, b then, c all right.
So, the user is told that, he is supposed to enter the coefficients now. Next thing will be
scanf, since I know, I can also say that please Enter integer coefficients; I am just
restricting into here like that, though its not necessary. So, scanf percentage d percentage
d percentage d, and a, and b, and c. So, what I will do? My system will read the 3
integers a, b and c. Now starts the main program and as if you have studied the flowchart
that I had shown, here you can see that, I have got only 1 decision box and I can proceed
through that decision box. There are 2 decision boxes actually, one in this direction;
another one in this direction.
So, accordingly I do not have any loop here. So, what is the construct that I will be
needing here. The construct that I will be needing here is if. So, what should I do? First,
let me compute the Discriminate all right. I have got this b, a and c. So, I do Discriminate
assigned b square minus 4ac. So, b times b minus 4 times a times c. So, this is an
arithmetic expression. I get Discriminate. Now I will have to take the path depending on
the Discriminate. So, what I will write here is if then, a parenthesis for the condition if
Discriminate is greater than 0, printf Roots are real and I can put a backslash in here else
I have not computed the roots as yet ok.

So, let me write the else as close to the if as possible, as we have learnt about
indentation. So, else if, I should have written this if also and small just for the sake of
uniformity and at not only for the sake of uniformity, C is very much case sensitive. So,
capital if is not if. So, if Discriminate is equal to 0, printf Roots are equal backslash n;
else now this, else comes under this if, you remember that else and ifs are tied up, based
on the closest the else is connected to the closest if. So, these 2 else, else the only option
is Discriminate is neither greater than 0 nor equal to 0.
So, Discriminate is less than 0. Then printf Roots are imaginary and backslash n again.
Now so, I have just said what type of roots they are. But I have not printed the roots as
yet, we have not I have not found out the roots. So, what I can do? I can modify this a
little bit or how do I find out the roots? Let me go to the next page. I do this and then, I
come back to a particular stage or I can do it here itself. How would I find out the roots?
Say, let me go back and do it here. Here, I have I have not written down, what the roots
are?
How could I? Suppose I modify this part a little bit; I modify this part a little bit. So, let
me modify this part, I will rewrite this part in the next page.

So, I rewrite it as, if Disc is greater than 0, printf Roots are real I find. Now I compute
say I compute, lets call it, I should have declared this also Discriminate 1, another part
that is, I had the Discriminate part. So, I can certainly make another variable. So, I add 1

more variable here, int a, b, c and here I entered another variable say d. Why, I will show
later.
So, I have entered another variable d there. So, printf Roots are equal and d is square root
of Disc. So, I called Disc to be b square minus 4ac. Now I am finding the root of that.
Now here I have committed 1 mistake. Can you tell me what the mistake is? So, this
Discriminate can be integer, but when I take the square root of that, it can be a float right
and also here I have already declared, if you look at I Disc, I somehow declared Disk as
float, but since a, b, c are integers, then, this will also be an integer.
So, I should correct it a little bit. What should I do? I or it really does not matter if I keep
it as float. So, only thing is that I cannot keep the d here. I will have to remove this d all
right and I will also remove this.

And will make this small d as a float. So, then I come here; d is square root of the
discriminate. Now what is this square root? Who will compute this square root? The
square root computation is done by an inbuilt function in C library. C compiler provides
us with a library of some inbuilt function, mathematical functions which we can call and
invoke whenever we need them.
So, you can see here, that is why I have included this math dot lib; that means, I will be
using some library function here, dot lib means library. So, you will find in the course of

this core lectures and more examples, where you will see more number of library
functions. But just for this, we need the square root function. So, I compute the square
root of Disc d assign the square root of Disc and then, root 1 is what root one is minus b
plus d by 2a. Is it clear? The 2 roots, one is I have my formula is b plus minus root over
of b square minus 4ac by 2 a.
So, this b square minus 4ac is d here all right. So, b plus d whole divided by 2a, I should
also put a parentheses here, is root 1 and root 2 is minus b sorry minus b minus d divided
by 2a. Then, I have got the 2 roots and I can print here. So, I have computed the roots.
So, I can either print it here. I can printf that The Roots can be float. I can say the roots
are percentage f, roots are floats percentage f, percentage f backslash n and root 1 comma
root 2. So, this is the whole part compound statement if Disc is greater than 0.
So, if we go up. So, I will modify this part in this way. We will also have to modify this
part. What should you do? Simply, what can I do to write this? If Disc is 0 then, I will
print roots are equal right, as I have written roots are real and then, I will find out; now I
do not need to find out this part. So, let me just show you this part and I leave the other
part for you.

That second part, if Disc, oh my god what did I do here; this all right. It is greater than
equal to, if disc is 0. Then, printf that the more than once sentences. So, this is coming
else that else part, else if disc is 0; printf the roots are equal and here I donot need to

bother much I can put a backslash n, that you know by now printf The Roots are equal.
Root is what?
Now, if in this, b plus minus root over b square minus 4ac by 2a, if this part is 0. Then,
my root is only minus b divided by 2a 2 multiplied by a and printf The Root is
percentage f backslash n root or I can say root 1, because I did not declare anything as
root. So, root 1 anyone root that is same. This is this part if the Discriminate is 0. See
yeah. So, I have just mentioned root 1. Why? Sorry, you see here I declared only root 1
and root 2, I did not declare any root. So, I can make root 1 root 2. Now, so this is
replacing this part.
Now what will you do here? The roots are imaginary, but the same thing the values will
be the same; only thing is roots are imaginary. I leave it to you as an assignment; you
think off, what will you do for that part? For the imaginary part. You can understand that
only thing that you need to do is to print some roots as say the real part. Real part is this
and imaginary part is this. So, you think about it; we can discuss about it in the next
lecture.

So, we were looking at solving a quadratic equation and we have seen that there are three
cases. One is if the discriminant is 0 we print the roots that their roots are real, sorry if
the discriminant is greater than 0 then the roots are real, otherwise if it is equal to 0 then
the roots are equal and if the discriminant is neither greater than 0 nor equal to 0; that
means, it is less than 0 then the roots are imaginary.

So, next what we did is we started with a program like this where we declared the
coefficients here and then the discriminant and the intermediate variable d and 2 roots
right root 1 and root 2.

Next we proceeded with this and we modified this part.

If disc is greater than 0 printf roots are real and then I modified this, this part and
replaced this part with this, if discriminant is 0 prints the roots are real and also compute
the root.

Now, if the discriminant is equal to 0 then prints the roots are equal compute the root and
print it. Now, I asked you to see how you will deal with the third case if the discriminant
is not equal to 0.

So, this if, when this if comes then we was already failed the condition the discriminant
is greater than 0 and if the discriminant is not equal to 0 then we will come to just an else
here right, and let me go to the next page to write the else part of this.

So, it will be else simply I am sorry here did I give the parenthesis, yes I did. So, I am
ok. This is please note these are the points where we often make the mistakes. Else printf
“the roots are imaginary backslash n” fine, and what are the roots? So, if we if the roots
are imaginary then the real part say one, one root is minus b by 2a is the real part and
plus i that is what we, i d by 2a is it clear another this is one root another root is b by 2a
minus i d by 2 a.
What does, so this d, basically you see what we are doing is x is minus b plus minus root
over b squared minus 4 ac by 2a. So, this is my discriminant and I take the square root of
that. So, plus minus root over d by 2a right. In my program what did I write d or
discriminant square root of disc sorry disc. So, I should not use different name. So, it
should be disc by 2a and that square root of disc can be either imaginary, so negative if
this is negative then I will find it is its absolute value and, this can be written as minus b
by 2a plus square root of disc by 2a is one root another root is b by 2a minus root over
disc by 2a and since its imaginary it should be i, the imaginary part.
So, I can print it as a real part to be b minus 2a and imaginary part is square root of disc
by 2a and the square root of disc is nothing but d. So, minus b by 2a plus i d by 2a that is
what I am writing here all right. So, this is the real part this is the imaginary part. So, I
can print it in different ways.

I can just say else printf roots are imaginary or rather I should have said this is wrong to
say. What should I have said, you should have I mean I am doing a mistake here all
through, starting from this point, you must have observed it.
Here the roots are complex roots then in that case, not the imaginary roots because it has
got a real part and the imaginary part. So, the roots are complex. I should have written
roots are I should have written complex roots and then I could print real part percentage f
backslash n, I can put an expression here minus b divided by 2a. We can make it a little
cleaner, looks very nasty here, b divided by 2a that is the imaginary part that is a real part
all right.
And printf imaginary part is plus i percentage f comma minus i percentage f backslash n
followed by. What is my imaginary part? Imaginary part is d by 2a. So, you see I have
put this i part plus i and i here comma b divided by again d divided by twice a all right.
So, this and then of course, everything is done so I come to the end of my program.
Before that here there should be a parenthesis. So, this is the complex part.
Now, as we will become little more conversant with programming you can see that I
have repeated many things right. So, instead of doing it there are some common you can
think of how can write it in a much more elegant and shorter way. But this is an example
which gives you an exposure to the use of if then else statements, if else statements in C.

Next, well another example we can take up. Say for example, we are going to compute
the income tax of a person.

Suppose the if the income tax is less than 100,000 rupees then income tax is nil, if it is
between 100,000 to 200,000 rupees then you pay 10 percent of the amount above 1 lakh,
100,000. For income above this 200,000 if the income is above 200,000 then you pay 20
percent of the amount whole amount not how much is exceeding 10,000 suppose this is
our income tax policy. How can we do this?
So, what is the input that I need from the user? I need this income from the user right;
and what is the other variable that I want to compute? The tax. So, here earlier I needed
math dot leave in this case probably I will not need that, but, I will not need that if
needed I will can always add it later main and then you can say put a comment
computation of income tax, tax computation all right.
Now, I start my program all right I can put the parenthesis above, does not matter . Then
printf its always better to do this, “Please enter your income” because if you do that then
you make your program interactive; that means, the user can see what you are doing
right, please enter your income. Well I have not yet declared the variables at all. So, here
I should write float income and tax. Then here scanf, percentage f and income, so I read
the income here fine. Then what should I do? Next let me come to the next page then or

because there will be number of if conditions. So, this part is ok, I have read then come
here.

Now, if income is less than or equal to 100,000 printf no tax, else what is my principle; 1
lakh to 2 lakhs, 10 percent of the income, 10 percent of the income above 100,000, so
else if income is less than equal to 200,000. So, it is not when it is coming here it is
already greater than 100,000, if it is less than 200,000 then tax will be 10 percent; that
means, 0.1 times the amount that the amount exceeding 100,000, so income minus
100,000. Printf tax equals percentage f backslash n tax, is this part clear.
This part is so when am I coming here this if condition as failed. So, I am coming here;
that means, it is not less than 100,000 so it is more than 100,000, but if it is less than 200
less than equal to 200,000 then I am the second bracket and I will be paying 10 percent
of the amount that is exceeding 100,000 that is why I computed this and then I am
printing this. So, here it is more than one statement I put a bracket. Here you see under if
I had only one statement. So, putting a bracket is not mandatory, but here it is mandatory
otherwise it will mean something else.
So, else this, now if this is also not true, that is if this if does not satisfy then I am in the
third bracket that is here what should I do else tax is 20 percent of the income and printf
tax assigned percentage f backslash n tax. Now, here then I will come to the end. So, I
come to this beginning this, this beginning point and I end the program here.

Now, you can see that I can reduce this program a little bit. How? I have written this
printing the text this thing the same thing twice, I am sorry here they should be another
bracket for completing this. This should be completed and then the next bracket. Now,
this I could have done later after these 2 use all right, but under this else under this else.
So, you can also try to reduce it and as an assignment you should run this program and
get yourself satisfied all right. So, this is another classical example of if then else usage
all right.
Given this we will. Now, move to some more examples, some more examples of the
other construct that is while and do while type of constructs. So, here is an example to
show if a number is prime or not.

Now, how do I go about it let us first think of the algorithm for finding out whether a
number is prime or not.

Say for example, I take a number 13. I want to find out whether 13 is prime or not. So,
when is a number called prime? When the number is not divisible by any other number
other than the number itself and 1. So, in order to find out whether 13 is prime or not,
what should I do? I will start with 2 and I will try to see whether the 2 is dividing 13.
How do I know where the 2 is dividing 13? By the modulus operator, if there will be 2
integers say 14 modulus 2 the modulus leads gives me the remind, sorry remainder. So,
if 14 is divisible by 2 the remainder will be 0. 26 divided by 2 the remainder will be 0,
but 13 divided by 2 the remainder will be 1.
So, similarly, suppose I want to see where there are number 15 is divisible by 3 I will do
the modulus operation of 15 with 3 and the remainder will be 0. So, 15 is divisible by
three right.

So, now if I want to find out whether 13 is a prime or not; I will first try to divide see
where that is divisible by 2. If it is divisible yes, will tell me not prime right it will tell
me not prime, but no then I will try to divide it by 3, if this is divisible by 3 then again
not prime. No, I will divide by 4 then; obviously, not divisible then I will divide it by 5
so on so forth I will go till I divide it by 12. Since of course, by 13 it will be divisible, if
the answer continuously up to 12 is no then we say it is not a prime right, not a prime.
So, here you see there are 2 things happening. One is I am taking a check branching here
I am dividing it by 2, if it is divisible is it is not a prime, if no then I am taking another
path. What is that path? That path is again trying with the next successor of this 2, yes; if
the result is yes I take this path otherwise I will follow this path with a successor of this.
So, the same thing trying with the successor I am doing continuously repeatedly if the
divisibility result is false; that means, if it is not divisible I will continuously go on till I
reach if this number is N, till I reach N minus 1 right, up to that I will try up to N minus 1
I will try. So, this is an example where there is a branching as well as a looping, another
real life mathematically important application. So, let us look at the program now.
Let us try to understand the program here. This include stdio dot h is known to you
mean. I am declaring 2 variables one is n another is i; n is an integer, i is also an integer,
initialize to 2. I am reading the number here say 13 while i is less than n; that means, i

was 2 if we look at this page we started with 2 we started with 2 and then went on right,
this is the value of i and this is the value of n.
Now, while i is less than n, I had 13 and i is 2 this is n, I will go on up to 13 up to while i
is less than n that means up to 12, I will go on trying this thing what; if n is divisible by i.
Is n divisible by i, yes then print that the number n is not a prime and then exit we come
out of this loop. Just like break we come out of this loop, but break is not applicable in if
statement exit we can write. So, I come out of the loop.
Otherwise what I am doing still in the while loop, the while loop is starting from this
point and going up to this point. I am incrementing i, so i becomes 3 and again I go and
try to see if it is divisible with 3 know then I come make it 4, make it 4, I will again try
this one fails, it is not divisible so I do not do this part, I do not do this part. I come here
make it 5 and go on in this way while i is 12, up to 12 I check and then it becomes 13.
So, I come here and ultimately I come out of the loop and till 13 I could see that no, I
could find no number no integer that is dividing it. So, we say that this is a prime
number.
Say for example, what would have happened if I had given the instead of n 13 if I had
given it 14. What would be the change in this flow? I would start with the 2 and again I
divide it by 2, try dividing it by 2 it is divisible I print that it is not a prime and I exit and
come out of this entire while loop. So, in the while loop here this I am exiting from the
while loop all together, not from the if loop I am exiting from the while loop if is not a
loop by the way. I am exiting from the while loop completely. So, this example also
illustrates the use of if here and the while loop here all right.
We will see a few more examples in the future lectures.

So in the last lecture we have seen how we can write a program to find out whether it is
prime or not.

Now, this program that you see that we have we have discussed in the last class, we will
certainly give us correct result. Now our job is not only to write a correct program it is
also very stimulating intellectually to think of how we can make it a more efficient,
program often the program can be correct, but it is not very efficient. What do I mean by
this efficiency? Say if we look at this program and again I take the earlier example that
suppose I have my n is 13.
Now, and I start with the value of i to be 2 and n is 13 and since it is prime I am checking
this condition time and again and since this is third I mean prime number how many
times it will never come here, it will never succeed. So, I will have to carry on this loop
and ultimately when I exhaust all the possibilities then only I will come to this point.

So, how many times do I have to do this let us see, I am starting with 2 checking ones
then start incrementing and making it 3, then 4 then testing with 5, then testing with 6,
testing with 7, testing with 8, testing with 9 10 11 12. So, how many times did I check it
1 2 3 4 5 6 7 8 9 10 11 times, I had checked it with 11 times
Now, do I really need to check it with 11 times? If you think a little bit if this number is
n then, I did not check it and I am starting with 2. So, n minus 2 times I am checking
right do I really need to check n minus 2 times. If I do not find it divisible by squared
within square root of n times. So, square root of 13 as an integer what would it be? 13
would be 3 point something right. So, 4 times within 4 if it is not divisible, it will not be
divisible late by the future numbers also right.
So, if I just apply this knowledge that if it is not divisible within square root of n, then it
will not be divisible later I can make this program much more efficient how let us see, let
us look at the and a more efficient version of the program.

So, here you see I am starting with 3 and I am reading the value of n fine. So, far no
problem I am starting with n.
Now, here I am checking not up to n I am checking I mean in the earlier case what we
did is sorry earlier case what we did is we tested with up to n, but here what we are doing
is I am testing with up to square root of n and if n is divisible by i; that means, say 13, I

first try with 3 it is not divisible is try with 4 and. So, square i is for that is less than the
greater than the square root of n right. So, with that I will come out and every time what I
am doing is I am implementing i by 2. So, I am testing with 3, I am testing with 5, I am
testing with 7 like that I am going on. If I apply this then I can always make this program
more efficient clear.

So, you see by the. So, let us take another example here say I am trying to find out
whether 21 is a prime number or not. So, I start with i to be 3. So, 3 is of course, 21 will
not work sorry let me change it 21 is not a prime. So, first time in first short it will give
me that it is not the prime fine, but if instead I had a 23 then what will happen? I start
with 3, it does not divide then I come and make it 5. If something is not divisible by 3 it
will not be divisible by I mean next square root of that I am just going by 1 more I come
to 5 it is not divisible by that, what is the square root of 23? It should be 4 point
something. So, again quickly I am coming to the point where I can see that it is not
divisible. So, by doing this using this small technique, I can make it a little faster the
number of checks will be much more reduced.
So, now, let us go to another example.

This is again finding the sum of and sum of the digits of a number. Now this 1 we did not
do sum of the digits of a number what is meant by this? Suppose I have got a number
123, sum of the digits of a number means 1 plus 2 plus 3 6. If my number is 243 then the
sum of the digits will be 2 plus 4 plus 3 6 and 3, 9 this is what I want to find out.
So, how do you go about doing that, how do I find out the digits? Say 1 2 3 from there
how do I extract out 1 2 and 3.

Just think over if I have got 123 and I divide it by 10, I will get a quotient 12 and a
remind remainder. So, the remainder is 1 digit, now I take the quotient divided by 10, I
will get a remainder sorry a quotient and the remainder, the remainder is another digit
and then I go on till it is the number is not equal to 0. So, next I take one and divide it by
10, the quotient is 0 and the remainder is 1.
So, you see I have got all the digits from the right hand side one after another right. So, I
can add them that is my basic way. So, let us keep it on the side and see what we have
done in this program. I have got a number n, now this number that has been given
initially 123, I do not need to preserve that number. So, I can play with that and I have to
make a sum of this right 1 2 and 3. So, I keep a sum to be initially 0. I keep a variable
sum which is initialized to 0 as we saw in the earlier examples and sum is also an integer
then I read the number that is say 123 has come.
Now, while the number n that is 123, 123 is not zero then I take add n modulus 10 n
modulus 10 will give me what? The remainder 3 and add it to the sum. So, my sum now
becomes 3, and then I want to find out this thing also. I make my n to be n divided by 10
now this operation gives you the quotient right this operation gives you the remainder.
So, I now I get n by 10 means now 12, and I go back to this loop I check that 12 is not
zero. So, I will again do that, sum will be sum what was that 3 plus n modulus 10. So, I
again divided by 10 and take the remainder and that remainder is added sum plus this.
So, 3 plus 2 will be 5 and then I divide n by 10. So, now, I find out 1 still I go back 1 is
not I go back actually here, 1 is not zero sure. So, I again divide it by I take the
remainder divided by 10 and take the remainder. So, the remainder is 1, I added with the
sum. So, it will be 6 and then I divide I find the quotient and that is 0, I go back again
here and find that n is not equal to 0 condition is not true. So, I come out of the loop and
I apply this printf statement what is the printf statement doing? The sum of digits of the
given number I cannot say given number n because n has already changed I will come to
that in a moment.
Now, it is sum. So, I have got the sum. So, this is another example of while loop now my
question is if you have understood it, I want the output to come as printf; the sum of
digits of the number 123 is 6 how can I do what modification should I do in this
program.

What I want to be printed is the sum of digits of 123 is 6 what should I modify? Of
course, I should modify this statement, this statement should be the sum of the digits of
the number percentage d is percentage d, and here before sum what should I do? My n
that was provided by the user has already been destroyed in this loop.
So, what because every time I am dividing it by 10 and making a new number, 123 is
becoming 12 and then it is becoming 1 then is becoming 0. So, I have to save it
somewhere this 123. So, what I can do here after this reading this, I can save it in another
variable num has n and here I will put num comma now because I am destroying n here,
but I am not touching num. So, num will remain intact only another thing that I have to
do I have to add this num here I must declare it num as an integer otherwise it will give
you syntax error all right.
So, this is another nice example of while using which we can find the number of digits
the sum of the number of digits of a number.

With that we move to another example; decimal to binary conversion some of you may
know it and some of you may not be very conversant with that. We know that we have
got the decimal binary number system where the base is 2. So, everything is expressed
using zeros and one.
So, sorry if I have a binary digit sorry decimal digit 4, it is binary equivalent is 1 0 0, if
we have 5 that is 1 0 1, if it is 1 then it is 0 0 1 or just 1, if it is 2 it is 0 1 0 like that the
question is that given our decimal digit how can I convert it to binary what is the
algorithm? The algorithm is something like this say I take 4 and divide it by 2.

So, the remainder is 2 a sorry the quotient is 2 and the remainder is 0 right and then I
divide it by 2 again, the quotient is 0 and this is 0 now when I divide it by 2 further what
will happen [FL] [FL] [FL][FL]
[FL]
[FL]

[FL] [FL] yeah [FL].

Let us take the number 4 and I want to find out what is the binary equivalent of this, the
algorithm goes like this I first divide it by 2, because 2 is the base of any binary system I
divide it by 2. So, I get the quotient as 2 and remainder as 0.
Next I divide it again by 2. So, my quotient is 1 and remainder is 0. Next I divide it again
by 2 my quotient is 0 and remainder is one. So, I go on dividing till I get a quotient to be
0 and I have remembered all the remainders that I got now I can get the binary if I did it
in this direction. So, it is 1 0 0 all right.

Let us take another example suppose I want to have the number 15, now what is the
binary of 15 to understand that you let us look at the weights of the different positions in
binary, this one is with 2 to the power 0, 2 to the power 1, 2 to the power 2, 2 to the
power 3; that means, this is 8 4 2 1 now 15 if I have to have I must have a 1 here and 7
more. So, 1 here 8 and 4 12 and 1 here 12, 13, 14 and 15 all this should be 1.
So, can we find out find this out let us see 15 I divide by 2 my quotient is 7 and
remainder is 1. I again divide it by 2 my quotient is 3 and remainder is 1. I divide it by 2
again my quotient is 1, remainder is 1, I divide it by 2 again my quotient is 0 and the
remainder is 1, I did it in this direction and we get 1 1 1 1 all right.

Let us take another example again the weights of the system are 1 2 4 8. 2 to the power 0
2 to the power 1, 2 to the power 3, 2 to the power sorry 2 to the power 2, 2 to the power 3
now let us take a number and next one will be 16 is 2 to the power 4.
Now, let us take a number 23, what will be the binary representation of that let us see
here 16 will be there of course, I have greater than 16. So, 23 16 and 6 and 7 more. So,
this should be 0 I cannot put a 1 here, because there to be 16 and 8 will be 24. So, 1 here
20 this this. So, my binary is 1 0 1 1 1 let us try in our algorithm divide it by 2, my
quotient is 11, I have got a remainder 1 I divide it by 2 my quotient is 5 remainder is 1, I
divide it by 2 quotient is 2 remainder is 1 divided by 2 is 1 and 0 and divided by 2 is 0
and 1. So, I reach a 0 I stop and this is the pattern 1 0 1 1 1, 1 0 1 1 1 all right.

Now, let us see how this algorithm that we are talking of can be encoded in C program.
You see here I have declared 1 variable as dec; that means, the decimal number that I
will be reading. So, I am reading that number here. Now in the earlier example we did it
while do now here we are doing do while we are doing something and then I am putting
the while condition later. Do what am I doing printf this means percentage 2 d means I
am printing in binary, I mean this I am taking this dec and I mean 1 beta I am printing I
am defining out the remainder I find out the remainder and then divide it.
And I go on doing this I divide it and I go on doing this while this is the number the
remainder is not equal to 0. I am dividing it by 2 and finding out the new number, that
this is this point what am I doing? I am finding out the quotient, here I am finding out the
quotient and I am based on the quotient I am going on till I get this 0. Do not bother
about this I can simply take the this thing, first this thing and I go on printing it.
So, here what I am printing I am printing in this in this format I am printing in this
format let us forget about this for the time being all right let us put percent d then I am
dividing it like this way all right. I divide by 2 continually and I am printing in this way 1
then I change it to 11 and then divide it then dec becomes 5, I print it and go on doing it.
So, at least once I am dividing till it is 0. This is the algorithm for decimal to binary
conversion you can also try to write it not with do while, but just by while you can I
leave it as an assignment for you to write it using while some condition and not do while
not do while.

So, next let us move to another example that is also very interesting and known to us that
is finding the greatest common divisor of 2 numbers what is the algorithm? The
algorithm is shown here, suppose I have got a number 45 and 12, I am to find out the
greatest common divisor or the hcf of these 2 numbers. What I do is I divide the bigger
number is the smaller number and get a remind remainder. You see remainders are
becoming. So, important they come to the remainder
And then if the remainder is not zero, I divide now the smaller number this 1 with a
remainder and then I get again a remainder which is nonzero, then I take the divisor
current divisor and divide it by this until we get 0 that is what we used to do in school
right. So, ultimately when I get 0 whatever is the divisor currently current divisor that is
our hcf or gcb. Here you see how the code is read you just look at the code a little bit and
try to understand it.
A and B are 2 numbers, now I do not know as it which one is smaller and which one is
bigger. Here in our example we can see one is 12, one is 45, but one is 12 one is 45, but I
am going to try this here the computer does not know which one is 12 which 1 is 45 and
I am taking another variable temp I am reading the numbers A and B. Now if a is greater
than b; that means, I am taking the greater number and moving that in temp out of this 12
and 45 which 1 is the greater number 45.

So, temps becomes 45 and b becomes a B is the smaller number. So, 12 becomes c and b
becomes temp, now you see I have written these 3 in 1 shot. So, let us see here what is
happening after this first temp is 45, A is 12 and B is 45 now what I am doing here I am
keeping this temp what I am doing here I am dividing B by A. So, 45 is being divided by
A 12 and I am checking the remainder the remainder is not zero you can see that. Since it
is not zero I am taking temp to be the modulus of 12 sorry b is what? B was 45 right and
A was 12 by this point. So, then and temp was 45 I try this it is not zero.
So, then I take this remainder 9 and again make that to be b. So, now, B becomes 9 and
A becomes the temp which was this number and I go on dividing this and I go on
carrying out this loop or till this becomes 0. As soon as this becomes 0 then I have got
my GCD stored in A, because every time I am taking the A in A IWelcome to the introductory programming course on NPTEL MOOCs. The goal of this is to learn how to code basic programs in the C programming language. Basically the aim of this course is to teach you how to solve problems using a computer. And by the end of this course, we will hope that you can write medium-sized programs – maybe running to a couple of 100 lines of code comfortably in the C programming language. Programming nowadays is considered a basic skill similar to mathematics that is needed across all disciplines like engineering, in the sciences, and nowadays even in the arts. So, little bit of programming skill is an enhancement to any other skillset that you might already you have. This course we will start from the ground up; we do not assume any prior experience in programming whether in C or in any other language. So, the focus will be to start from the basics; and to use C as a medium of program. A couple of words about the process of programming; it involves two basic steps. One is to define the problem; often you get real-world problems, which are not precise enough to write a program for. So, the first step would be to define and model the problem. And this is a very important step in large scale software development; however we will not focus on this as part of this course. During this course, you will not write large software system like the Indian railways reservation system; those are extremely complex problems involving multiple programmers. In this course, we will assume that the problem is well-defined and already provided to you. So, they will be precise and they will be fairly short and simple. So, this is the first step of programming, which is definition of the problem, which you can assume will be given. Now, comes the second step, which is to obtain logical solution to your problem. And what do we mean by a logical solution? A logical solution is a finite sequence of steps; do this first, do this next; if a certain condition is true do this; otherwise, do something else. This is called an algorithm. So, an algorithm is basically a finite step-by-step procedure to solve a problem. One way to visualize an algorithm is using a flowchart. If you are new to programming, it is recommended that, you draw flowcharts to define the solution to your problem. Experienced programmers very rarely draw flowcharts, but that is not a reason for beginning programmers to avoid flowcharts. So, defining a problem is there; then the process of coming up with an algorithm. This is a very important step in the programming process. And followed by this, there is a third step, which is to implement the algorithm in a usual programming language. So, is the concept of an algorithm a new concept? I would claim that, it is not. An algorithm is a very familiar concept; the most important example that you can think of are cooking recipes. Now, cooking recipes are written in a way that, they are almost algorithms. They are not quite precise enough for a computer, but they come quite close. For example, let us take an unnamed dish – a desert and let us look at how things specified in a recipe. And we will see that, this analogy is quite deep. There is a very strong similarity in the way that recipe is written and a program is written. So, usually, they will have a list of ingredients upfront. For example, you have ice cream, crushed cereal and so on. And then once you have all the ingredients in place, then you have instructions to say how do you start and how do you end up with the dish. Now, those instructions will be fairly precise; of course, you assume that, the person preparing the dish is a fairly-experienced cook, so that certain instructions need not be given in very precise detail. For example, you can say do this, heat oil and so on. And it is assumed that, a person knows how to heat oil. Even so you will see that, certain recipes are fairly vague and other recipes are fairly detailed. And in any recipe, you can see certain things, which are vague and will cause confusion to most people. For example, here is a term, which says try to make each scoop about as large as your fist. Now, that of course, is a vague term, because my fist could be a different size than yours. And then you will see that, in a formation that makes it easy do dip in order. So, this is fairly vague and it is not very helpful to a cook, who is making this for the first time. So, think of algorithms as similar to recipes, but mentioned in a more precise manner.  Another way you can be familiar with algorithms is when you have the – when you buy a make it yourself kit for a furniture or something like that; and you will be provided with a step-by-step instructions on how to assemble the kit. Often when you buy disassembled table or something like that, it will come with a sheet telling you how to start with the components and build a table. Those are also similar to an algorithm. So, let us look at a flowchart to depict a mathematical algorithm and we will use this flowchart to explain certain conventions about how algorithms can be described. So, every flowchart will have a start and an end; and it will have a finite number of boxes. So, this is the finite number of instructions that I was talking about. There are certain conventions in drawing flowcharts; the start and the end are often described in circles. Then there are ordinary boxes and then there are diamonds. We will shortly describe what they mean. So, suppose you want to write an algorithm for adding the first n numbers; all of you know how to do it. The point is how do you describe this step-bystep to somebody who does not know it already.  So, first you have to take what is the upper limit N and then you have to sum them up. So, one way to sum them up is start with an initial sum of 0 and then add numbers one by one. So, increment a counter from 1 all the way up to n. So, you start with I equal to 1 and then add the I-th number to the sum; and then increment I; if I is already N, then you are done; if I is not N, then you go back and do the sum all over again until you hit an I. When you reach I equal to N, you come out the program; print the sum; and end the program. So, this is a very simple flowchart. So, initially, if N is less than 1, you have nothing to do; if N is greater than 1, you start a counter from I equal to 1 to n and add the numbers one by one until you hit the N-th number. If you wanted to compute a slightly different problem, which is let us say the factorial of N, which is just a product of the first N numbers, the flowchart will look fairly similar; the only difference is that instead of adding numbers, you will multiply them. So, this flowchart is similar to the previous flowchart; you will first input in N, and then increment N until you hit N equal to M. If so you will finally, print the factorial; otherwise, you go back to the loop. So, here are the conventions used. The start symbol is often as a circle or an oval; the input symbol and the output symbol are often represented as parallelograms; and the normal operation boxes are represented as rectangles; and the test box to see whether you have hit a limit to test some condition in general, they are represented as diamonds. In this session, we will write another algorithm to solve a mathematical problem. If you do not know this algorithm already, that is fine; it is more for the purpose of demonstrating, if you know a solution, how do you come up with the algorithm to tell a computer how to solve it. The algorithm is for finding the greatest common divisor or the highest common factor, this is known under two names of two positive integers: m and n. So, this is an algorithm you probably know. How do you solve this? Let us first try a naive solution. And before writing an algorithm, let us see what do I mean by the simple solution of GCD. So, you are asked to find the greatest common divisor of m and n; take the smaller number n; and now you start looking for each number k between 1 and n, remember that n is the smaller number; in descending order, do the following. What you do is if k divides m and n, then k is the greatest common divisor of m and n.  And this is obvious by the definition of greatest common divisor; if k divides m and n, then it is obviously a divisor of m and n. Also we are coming in descending order; we start from n and go down to n. So, the first divisor that you hit when you go down is going to be the greatest common divisor of m and n. So, this algorithm obviously works. It will compute the GCD correctly, but it is very slow. And think about a very large numbers: m and n; and you will see that, it may go n steps before reaching the correct GCDs. So, compute the GCD of two very large numbers, which are relatively prime to each other; that means that the GCD of m and n are 1. Now, if you pick such a pair, this algorithm will compute the GCD correctly, but it will take n steps, because you have to go down all the way from n to 1 before you will hit the GCD. Can we do better? There is a faster way and it is a very old algorithm. The algorithm is due to Euclid. We will see a slightly modified version of that algorithm. So, before we go into Euclid’s algorithm for GCD, we will describe what it does and give you a slight intuition of why it works. So, consider the GCD of 8 and 6. Now, you can consider two rods: one of length 8, and another of length 6. Now, obviously, if a number divides 6 and 8, then I should be able to make a stick of that length, so that I can measure 6 exactly with that shorter rod; and I can measure 8 exactly with that shorter rod. This is the meaning of a common divisor, and we have to find the greatest common divisor.  So, first, what we will do is we will measure the longer rod using the shorter rod. Now, it may not measure the longer rod exactly. For example, in this case, 6 does not measure 8 exactly; there will be a small piece of length 2 left over. So, take that reminder. And now, repeat the process; now, 2 has become the shorter rod and 6 has become the longer rod. Now, see if 2 measures 6 exactly; it does. So, you are done. And then you can say that, 2 is the GCD of 8 and 6. The reason why this works is – by the nature of this algorithm, it is clear that 2 divides 6, because that is why we stop the algorithm. And also, we know that, 8 is basically 6 plus 2. So, it is obviously, a multiple of 2. So, it is a common divisor. And with a slightly more elaborate argument, we can argue that, it is the greatest common divisor. So, this is an algorithm, which is essentially due to Euclid. So, it was known for at least 2000 years. Let us pick a slightly more elaborate example. Let us say we want to find the GCD of 102 and 21. The process of taking remainder is what is known as the modulo operator in mathematics. So, 102 modulo 21 is the remainder of integer division of 102 by 21. So, the remainder of when you divide 102 by 21 is 18. So, that is the shorter rod for the next stage. Now, 21 mod 18 is 3. And that becomes the rod for the next stage; the shorter rod for the next stage. And 18 mod 3 is 0; that is when you stop the algorithm. So, when the modulo operator gives you 0 result; that means that, the shorter number exactly divides the larger number; that means that, the shorter number is a divisor of the larger number and you stop the algorithm. Now, you say that, GCD of 102 and 21 is 3. So, this is a slight modification of the classical Euclid’s method for GCD. And so, it is based on the following simple fact, which we have described. And you can prove this mathematically as well. So, suppose you take two positive numbers: a and b; where, a is the larger number; then GCD of a and b is the same as GCD of b and the remainder when you divide a by b. So, it is written by the equation GCD(a, b) is GCD(b, a % b). The modulo operator is represented as the percentage sign, because this is the convention that we will use in C. And this equation can be seen by our previous slide; a was the bigger rod; b was the shorter rod. This was the first stage. The second stage was when b is the shorter rod. And the shorter rod for the next stage is modulo – is given by the modulo operator. To prove this, you can start by considering the division of a by b and writing a as bq + r. But, we will not go into the proof. From elementary properties of natural numbers, it is possible to prove that, Euclid’s method correctly computes the GCD. Right now, we will move into how do we write the GCD algorithm in the form of an input. So, here is a slightly abbreviated picture. I have skipped the start state; but the start state is there. Let us focus on what happens during the algorithm. You have two numbers: a and b. The first thing to ensure is that, a is the larger number. The reason we do that is that, if a is the larger number, then the modulo operator is properly defined. So, if a is the larger number, then we are fine; we can go into the GCD algorithm. If a is not the larger number, you merely swap a and b, so that whatever is the larger number, you called it a. So, exchange a and b; means that you say that, the value of a is stored in a temporary variable; then the value of b is stored in a; and then the value of b is stored in t with the value of t stored in b. So, here is a way to exchange the values of a and b. So, ensure at first that, a is the larger number. Once you do that, you get into the code for the proper  utility in GCD. First you test whether b is 0. If b is 0, then there is nothing to do; a is the GCD of a and b; GCD(4, 0) is 4; GCD(4, 0) is 8, and so on. So, if the smaller number is 0, then there is nothing do in the algorithm; the algorithm is over; and you say that, print a. If b is not 0, then we do the Euclidean equation. You take a % b; store it in a variable g; then assign the value of b to a and assign the value of g to b. So, this corresponds to the operation of taking b and a % b as the next step. After you do that, you again test the condition whether b has now become 0. If it is 0, then we are done and a is the GCD; otherwise, we do another round of taking a % b and setting a = b and b = g. So, a, b and g are what are known as variables. And variables are used in programming to store exactly one value at a time. So, at any particular time, it will have one value; then after the execution of another instruction, it will have a new value and so on. Now, for the purposes of describing an algorithm, imagine that, the variable is a box; and it is a name of a box; and the value is stored inside the box. For example, a, b and g are the variables that we have used in the program. And they are the names for these integer boxes. So, if we are computing, let us say the GCD of 5 and 3, then you might start with a equal to 5 and b equal to 3. The second operation that we have used in the code is the assignment operation. So, this is what an example of the assignment operator. And when we do an assignment, what we mean is that, you take the left variable, which is g in this case and assign it the value of what is the expression on the right-hand side, which is a % b . So, assignment a = b replaces whatever is stored in a by what is stored in b. So, take the right-hand side; take the value of that; and put it into the variable that the left-hand side represents. For example, if a was 5 and b is 3; after a = b, you would take the value of b and put it in a. So, a will now become 3 and b will remain 3. Another small thing that we have used in the code is sequential assignment. So, if you write a bunch of statements one after the other, let us say separated by semicolons; then this means that, the instructions are to be executed one after the other in sequence. So, first, you do g equal to a % b; then you do a = b; and after that you do b = g. So, initially, let us say that a is 10 and b is 6; g is undefined. After you run the statement g equal to a % b, you take 10 modulo 6; you will have 4.And then a = b; the value of b will be stored in a. So, a become 6. And then b = g; the value of g will be stored in b. So, b will become 4. Now, let us just dry run the program or the algorithm and see how it computes the GCD of two numbers. So, I will denote the currently executing statement with an icon and I will call this the program counter. So, this is at any point, it is the next step to be executed. Initially, it is at the beginning of the code; where, you take the input. And we will have three variables, which will represent the current state of a program. So, suppose you want to compute the GCD of 8 and 6. So, you have a equal to 8; b equal to 6. You know that a is greater than b. So, you proceed. Now, you test whether b is 0. So, since b is non zero, you go into the main body of the loop. So, you do g equal to a % b; a = b; b = g, this step once. So, you will end up with a is now 6; b is 2; and g is 2. You again comeback to the discussion and test whether b is 0 or not; b is not 0. So, you go back into the body of the loop again. So, you have g to be a % b. So, 6 modulo 2 should be 0. And then you do a = b and b = g. You will have a equal to 2; b equal to 0; and g equal to 0. At this point, b is now 0. So, you say that a is actually the GCD of three numbers – of the numbers 8 and 6. So, you can ensure that, it computes the GCD correctly.  Once we are understood what algorithms are, we will start writing a few simple programs in the C programming language. Before we begin, we will give a brief introduction to the process of programming. When you are programming, you follow typically, what is known as the programming cycle and this contains three parts. One is the process where you write the program or edit the program, and after you are done editing the program, you save it and then you compile your program. If your compilation succeeds, you are ready to run the program. If your compilation fails, then you return to the editing step and correct the errors and compile again. Once compilation process succeeds, then you can run the program and check whether the output is correct. If the output is correct, you are done; if not you go back to the edit process. So, this is why it is known us the edit, compile, run cycle. So, you edit the program first, then compile it. If there are compilation errors you go back and edit it again, otherwise you run the program. When you run the program, if the logic is correct, then you are done. If your logic is incorrect, then you go back and make changes to the program, compile it and run it again. So, this is the process, that we have to follow in the, when we program. We look at each of the steps one by one. In editing, it is typically done in what is known as in editor. Now, editor is a program that lets you create a text file, make changes to the text file and update the text file, later save it. So, in order to create a program, pick up particular editor of your choice. If you are on Linux, I would recommend a simple editor like G Edit. If you are on windows, there is free editor called Notepadd + +. Be careful that this is not the usual notepad that comes along with the system. Write your code in, in editor of your choice and save it into a file. Let us call it Sample.c. Once your code is saved, you have to compile a program. Now, why do we have to compile a program? Why is this step necessary? The computed does not understand C per say, it cannot execute a C program or the individual statements in a C, in C language correctly. For example, let us say that in C you can write g = a % b. The percentage operation stands for modulo. So, this statement says that you take a % b and assign it to the variable g. Now, the microprocessor, the processor in the computer cannot execute this statement because it does not understand this C programming language. So, it translates it into an equivalent piece of code consisting of even more basic statements. For example, a, this is just for the purpose of illustration and it is not important that you understand exactly what is going on, but in a statement like g = a % b, can be translated into bunch of statements saying load data from particular memory location into particular register, load the second piece of data from another memory location to the second register, divide the contents of these two registers, store the reminder in a third register and then finally, take the result and store it into a third memory location. So, the simple statement that we wrote, g = a % b or g = a % b, becomes a bunch of basic statements, that the microprocessor can understand and then it execute these statements.  So, why not program in the microprocessor language or in assembly language? Writing programs in machine language is very tedious. One line in a higher programming language like C translates into multiple lines of machine language. So, writing machine language code is very long and it is very tedious and is particularly prone to errors. Also, they are not portable. If you write machine code for a particular processor, let us say, you are writing the code for an Intel processor and you translate it to an AMD machine, it might not work. Whereas, if you take your C code and compile it in another machine, it will run on the machine. So, compilers work as a bridge. What they do is, take a high level C programming language and translate it into the equivalent machine code. So, think of them as a translator. So, you, the input is a C program and then you give it to a compiler. The output of the compiler will be the equivalent machine program for whichever machine you want to run it on. So, compiler is a translator, which translates from C to machine code. How do you compile? We have just seen why we bother with compilation and on UNIX system or Linux systems, you can compile the program using the gcc compiler. So, gcc stands for the gnu c compiler. So, for example, if you have edited and saved your file as a Sample.c, you can just type on the comment prompt on the terminal gcc Sample.c. If your code does not have any errors, then the system will silently say, that the compilation is done and it will show you the prompt. If there are errors, the system will list the errors and so, you can go back to the editor, edit you code to correct errors and come back and compile again. As long as there are compilation errors, there will be no executable file created. So, the executable file is the code, is the file that you can finally run. And if there are compilation errors, the compiler will not produce executable code.  So, name your file as whatever you want, let us call it, yourfilename.c and then gcc yourfilename.c. It will produce the executable file. If you are on Linux, the executable file that it creates is something called a.out. If there are no errors and look at your directory, there will be a new file called a.out in your directory and we will explain the directory structures in another session, ok. Let us look at a very simple C program. Open your editor depending on which system you are in. So, let us write a very simple program. It is, it is very short. What it has is, are three lines of code and some punctuation. This is known as the C syntax. Let us examine this code. What this code does is, it prints a particular massage, which is, welcome to C.  And it has various components, you type it into an editor as it is, make no punctuation mistakes, syntax errors. Now, if you compile the program and you have typed the program correctly, then a new file called a.out will be created. So, if you type, gcc Sample.c and if there are no errors, it will just say nothing. If there are, if it says something, then there is a compilation error. Compilation creates an executable a.out and now you can run the program by typing, and this is important, ./a.out. So, this syntax is important, what you type is, ./a.out and then when you run the program it will say, welcome dot, Welcome to C, because that is what the program is supposed to do… Let us look at the program little more carefully. What are its components? It had three lines, the first line said # include <stdio.h>. So, it has multiple components. One is the first symbol, which is, has the first symbol, which is the hash. Please do not forget to include that. And actually, there is no space between the hash and the first i, so there is no space here. So, # include <stdio.h>. This line is supposed to tell C that please include the standard input-output library. The standard input-output library is what has the print routines, which will print output messages on to the terminal. So, if you want to have any input output component of your program, then you should include <stdio.h>. Include this line routinely in your, in the first line of your C file because in the course of this class, we will often need scanf and printf statements. So, we will often need input statement and output statements. So, include this by default. Now, if you look at the second line, we will have a function called main. And again, note the parenthesis here that is also part of the syntax. So, main is supposed to be a function. All C programs start by executing the main function and it starts from first statements of the main function. Now, what dose the main function have? It has a single line, which says printf Welcome to C. So, printf is the function called to output from a C program. So, to print a particular massage you enclose it in double quotes. So, whatever is enclosed in the double codes, will be printed. So, to repeat again, please note the extra punctuation symbols, which tell you, that these are valid C statements. So, all the underline statements are, all the underline symbols are important. So, in the line printf Welcome to C, this is what is known as a statement in C and statements in C end in a semicolon. So, this semicolon is also important because it tells you, that this is where the statements ends, what typical errors do we have when we code in C. Let us systematically enumerate a few common errors that could happen in even a simple program like what we have seen. For example, you could forget to include <stdio.h>. If you do not include the standard input library, then the compiler will give you an error message. You may forget to include the main function, then also you will get some error message. You could forget to include the semicolon in the statement, you could forget to include the braces, the curly braces in main or forget to close the double quote, open or close the double quote in the printf statement. So, these are a few errors that you could make even in a simple code like what we have seen. We have only three lines, but they could also have errors. I would advise you to try deliberately making these mistakes in your code, try compiling them and study the error messages. Once you are familiar with error massages, this will help you later in your coding, because when you see the error massages you can guess what errors did you possibly make in your code. So, go back to the code and correct it.  In this session let see another simple program, and try to study what is going on in there. So, here I have slightly more complicated program, then what we just saw. This has two printf statements; once is welcome to, and the second says C programming. So, it is slightly more sophisticated then the code that we have seen. So, to recap the first line # include <stdio.h>, tells the compiler to include the standard output library.  Then we have the main function; the open and close brackets immediately after name show that main is a function, execution always begins at the first line of the main statement. Then the body of the function the logic of the function is enclosed within two curly braces; the first curly brace signals - beginning of the function, and the last curly brace says that the function is over here. This particular name function has two statements; earlier be have just one statement. The each statement as I said before is terminated with a semicolon. So, this is the first semicolon, and this is the second semicolon. The first semicolon says that the statement printf welcome to ends that point, and then followed by the second statement. And the second statement is also terminated by semicolon. Every statement in C is terminated with the semicolon. Curly braces enclose a set of statement, and each statement in a sequence is executed in the exact sequence that we wrote in the code. Now, once we edit this in an editor save the file, now compile, and run the file. So, let us call it sample.c or you may rename it any file you want. And then once the compilation is successful, you can run it using ./a.out, and then it will print welcome to C programming, which was essentially the same messages as we seen before.  Let us try’s what happens when we execute the program. By tracing we mean step by step looking at each statement, and C’s see what happens when the program executes. We have what is known as a program counter, which says here is the currently executing line of program. The program counter stars executing at the first statement of the mean, for is of reference I have given line numbers in the code. Now this is given just for clarity. Now let us just see, what happens when we run the program line by line. So first we execute the first line of the code, after we are done executing the line 4. So, after we are done executing lines 3 and 4, the message welcome to will be printed on the terminal. This will be followed by the next line, so the next lines is C programming. So, after the next line executes, it will print C programming %. I given this in two different colors to highlight that one was printed by the first line, and otherwise printed in second line, otherwise the colors have nosing, no special meaning. The program terminates when the main finishes execution, and this is what is typically known as returning from the function, we will see this terminology later in the course. Now, when you code in addition to the statements which are actually executed, you may also give a few additional remarks; these are what are known as come program comments. For example, the lines a simple C program first print and second print; these are the comments in the code. So, whatever is highlighted in red in the code is what are known as comments. Any text between forward /*, and then later followed by a */. So, any text between successive /* and */ is a comment, and it will be ignored by the compiler. So, as far as the compiler is concerned a code with comments is the same as a code without comments. It does not effect the logic of the code. So, comments are not part of the program; however, it is highly recommend that any program you write, you should comment the code. This is show that other people can understand your code also you yourself looking at the code 4 months later or five months later, it is it may be difficult to understand what you wrote? Much before and comments help you understand the logical of the program.  Now, it is a very good idea to comment your programs, and for lager program it is a must to comment the programs. This is standard industry practice, and even if you participating in large programming project like free software projects, comments are highly encouraged, because it will understand other developers, other programmers to understand your code. So, we will try to follow our own advice most of the programs that we will see in this code, we will comment it, so that it easy to follow the logic of the code. Now, a few notes just as a main is a function printf is also a function. Printf is a library function which means that it is given by the C programming language, and we wanted to tell the compiler to include this library function. The statement which set that is this # include <stdio.h>. So, # include <stdio.h> is the line telling that I want the standard input output library, because that is the library from which I will get the function printf. Now what does printf do? Printf takes two arguments, just like arguments to mathematical function. So, it takes an input argument which in our first case was welcome to. So, this was the printf first printf statement in the program that we just soft. Now, this was enclosed in double codes, right. So, it was enclosed in open double quote, and then ended with a close double quote. A sequence of characters in double quotes it is what is known as a string constant. Now we can call the functions that we define or we can call the functions that the library provide. This is how once you define a function, you can call a function. Now we will see an additional concept, the printf statements that we have seen so far, we will print a message and it will print there. And then the prompt the terminal prompt will come immediately after the print. Now typically what we want to do this will print a message, then say tell the prompt to appear on the next line. So, for this we need what is known as the new line character. All letters digits, gamma, punctuation symbol; these are called characters in the C programming language. There are the total of 256 characters in C, 256 is 2 to the 8. So, for example this small letters a to z, capital letters A to Z, 0 to 9, the at symbol, other punctuation symbols like dot, gamma, exclamation mark, and so on; are all characters in C. Now in addition to this there are certain things call special characters. So, there is a special character call new line, in the C programming language it is denoted as \n. So, there are notice that there are two kinds slashes; /, and \ on your keyboard. And the new line character is denoted as \n. So, even though it is single character, it is denoted by two letters. When used in printf it causes the current output line to end, and then printing will start from the new line. So, it is something which says the current line has enter, now whatever you have to print, print it in the next line. The new line character \n is like any other letter, and can be used multiple times in any particular line. For example, if you have something to printfollowed by \n, followed by C, followed by something to print. Now this will be treated as, so many characters and then a new line followed by C. So, let see a particular example, if you have the old program that we just wrote, but we end each message which a \n. So, we have printf welcome to \n, printf C programming \n. When we compile and execute, we will see something new. So, when we run this $./a.out, it will print welcome to, and then the next thing to print is is a \n which is a new line. So, printing will start from the next line, and then it will print the next message with C programming. So, it will print that followed by new line. So, the prompt will appear on the line after words. So, new line character is something that is use to make your output messages a little more here. So, let us just conclude by saying one more thing about new lines, the new line character \n is like any other character, and you can use it multiple times even within single message. For example, if I do the same program, but let us say I have welcome to \n \n C \n. So, I have repeated occurrences of \n in the same message, what it will do is if will print the message welcome to, then it will print a new line, and then it will print another line, and then it will print C followed by new line. So, when you run program you will have welcome to new line, then the blank line, then C, then another line. So, new lines are just like a any other characters, the difference is that, because it is a special character, it is represented by two letter. So, it is not represented by single letter it is represented by \n. So, they are together one character in C, call the new line character. In this session we will see slightly more sophisticated programs. Recall that in our discussion about flowcharts, we talked about variables, which were conceptually seen as little boxes in which you can hold values. So, let us see how to write simple C programs in which we make use of variables. So, we will illustrate with the help of a sample program. So, we have this following program, which is very simple, read a Celsius temperature and convert it into the equivalent Fahrenheit temperature. This is something that all of you must know. So, the flowchart is very simple, you have an input C, which is the current Celsius that you want to convert. Then you apply the formula F, which is 9C/5 + 32. In this session, we well see how to write simple C programs, which makes use of variables. Recall that in our discussion about flowcharts we talked about variables, which were conceptually seen as little boxes in which you can hold values. So, let us illustrate a simple C program making use of variables with the help of a program. So, we have a small problem, which is convert a Celsius temperature into the equivalent Fahrenheit temperature. This is the formula that all of you must know. So, let us write a C program for it. So, we will draw the simple flowchart for doing the program. You input the temperature in C, in Celsius, convert it into Fahrenheit according to the formula 9C/5 + 32. Once you have done that, the variable F holds the Fahrenheit value, so you output the F. So, here is the simple flowchart that we want to implement. Now, how do we write the equivalent C code. So, we, in the flowchart we have seen, that we have two variables, C and F. These are the variables that we would want to implement in the C code. So, let us see how to do it. So, we write the following C program in which now we have two more components, one is the variable declaration, float centigrade and then the second is another variable, float Fahrenheit. So, centigrade corresponds to C in the flowchart and Fahrenheit corresponds to F in the flowchart. So, I write the following code, which is supposed to implement the flowchart on the left. So, let us say, that the input is 50 degree Celsius and then the Fahrenheit, the formula is exactly the same as what we have in the flowchart. We have 9C/5 + 32. Notice here, that these are arithmetic operators. So, the * arithmetic operator stands for multiplication, / stands for division and + stands for addition. So, this is exactly as in the flowchart except, that here in the flowcharts multiplication symbol is being swallowed, but in C you have to specify it using a * operator. So, Fahrenheit equal to 9C/5 + 32 is exactly similar to the analogous line in the flowchart. And finally, for outputting we will use printf statement. So, here is something new in the printf statement. We use what are known us format specifiers, this %f symbols are new and we will describe them shortly. So, let us look at the program in little more detail. So, we have two statements, which are of interest, in the beginning of the code, which are what are known as the definition of the two variables. Recall from are discussion on flowcharts that variables are boxes and each box has a name associated with it. So, you have two concepts associated with variable as far as flowcharts were concerned, one was the box and the second was the name of the box. Now, when we come to C, we will associate a third concept with variable, which is the type of the box. So, if you look at the first statement it says, float centigrade;. Now, this defines a variable centigrades. It creates a box capable of storing a real number and names the box the centigrades. So, the box is of type float. Type float means, that box can hold real number. Similarly, fahrenheit is also a box, which can hold real number. So, you declare that the type of that variable is float. So, these are supposed to be the first two lines of the code. Now, centigrades = 50 that is the line, which assigns the value 50 to the variable centigrades. So, once you execute the code, the box associated with name centigrade will hold the value 50 followed by the line, which computes the value of fahrenheit. So, fahrenheit equal to 9C/5 + 32. It is an, it associates an arithmetic expression. So, it evaluates an arithmetic expression, takes its value and stores it in the box associated with the fahrenheit. And as we just saw before, * is the multiplication operator, / is the division operator and + is the additional operator. Now, the brackets in an arithmetic expression are just like brackets in mathematics. So, they group together a particular thing. Now, let us just trys to the program. Let us see what happens step by step when we run the program. Let us say that we save the file as sample2.c and then run it as ./a.out. So, first we will have two boxes created, one for centigrade and one for fahrenheit. These can store float numbers. Now, what are float numbers? Basically, they are real numbers, which are saved by the microprocessor. Now, the microprocessor can store variable real number only using finite precision. So, this is different from actual real numbers that we encounter in mathematics. So, we have only a limited number of digits after the decimal point, but other than that you can think of them as real numbers. We will see floating point number later in the course in greater detail, right. For now, think of them as the machine representation of a real number. So, once you finish the declaration statements what you have are two boxes one first centigrade one for Fahrenheit and because you declare the types to be float it is under stood that those boxes will hold real number. So, let us execute the first executable assignment here. centigrades = 50 and you will see that the box contains 50.000 something. Even though we specified it as an integer, it will convert it into real number, floating pointing number and store it. Then this is followed by the calculation of the Fahrenheit value, and let us say that you compute 9 times 50 divided by 5 plus 32, it comes out as 122. After that line is executed, the box associated with Fahrenheit will contain 122. Then, the next line says, print, printf the temperature, there is no new line, so the next printf will start from where this printf ended and here you see something new, which is the %f symbol. So, these are what are known as format specifiers. So, the %f symbol say, that take the corresponding variable, which is given centigrades here. Now, print it as a float, print it as a real number. So, notice the difference between first printf and the second printf. The first printf just had a string between “, the second printf has two arguments, one is a string between “ and the string is %f and then the second argument is centigrades. So, it says take value of the centigrade and print it as a floating point number. So, it does that and you see 50.000 in the output. There is no new line. So, the next printf starts from the previous line where the previous printf left off, 50 Celsius equals, it prints that. And now, you have another format specifier. It says printf %f fahrenheit. fahrenheit is 122 and it will print it as floating point number or as real number. So, it will print it as 122.000 printf fahrenheit. So, the finial massage, that well be printed will be the temperature, 50 centigrade, 50 Celsius equals 122 Fahrenheit. So, the new thing we have seen in the program include variable definitions, how they have an associated type and similarly, how do we print these variables. So, we do not want to print the names of the variables, we want to print the, we want to print the content of the variable. We want to print what is stored in the box. For that we use the format specifiers like these %f.  So, let us briefly introduce what are types in C. So, variables are the names of the boxes in which to store values, but these boxes are special. Certain boxes can hold only certain kinds of values, so all boxes are not the same. There are different kinds of boxes. Now, types are basically saying, that a particular box can hold a particular kind of data. So, variables are defined with an associated type and we will use some basic types during the course of this program language tutorial. One of the two common type, two of the common types that we see in this program are int, which stands for an integer and float, which stands for a floating point number, which stands for real number. Notice, that machine can hold only a fix number of bits. So, that does not mean, that the integer can go from minus infinite to infinite. It goes from a certain vary small negative number to a very large positive number. Similarly, floating point also is limited by a particular range. This is because machines cannot represent arbitrary values. The type of integer can store all numbers from M+1,...0,1,...,M. So, there will be some large M, for which, for which defines the upper limits and the lower limits of the particular machine. Now, that limit may depend on which particular machine that you use. On a, on a 32-bit machine it will be 232 , M will be 232. A few final words about variables. Just like in a cooking recipe, you well never mention a step, which involves ingredient without mentioning, that ingredient is needed in the first place. So, you will never say, that use salt and if you look at the list of ingredients, you were, you will see, that there is no salt in the list of ingredients. Such recipes are considered bad. So, when you write a typical recipe, you list out all the ingredients first and then write the steps for the cooking. Similarly, in a program you define whatever variables that you need before those variables are used by any statement in the program. Always define a variable before use. Now, a word about names of variables in the C programming language. The names are consisting of numbers, letters and an underline symbol, an underscore symbol. And there is a particular convention that a variable cannot start with a number. So, the initial letter has to be a letter or an _, it cannot be number, but further can be either capital letter, small letter or numbers or an _. So, there are valid names like c_sq, csq1, c_sq_1. So, all these are valid. One thing to note is, that the names are sensitive to upper and lower case. So, for example, capital C Centigrade is different from a centigrade, which starts with a small c. So, these are two distinct variables that is the common source of errors when we start programming. Another thing to note or to watch out for is, that the assignment operation, which is equal to is not the same as mathematical equal. So, when mathematically we you say a equal to b, it means, that a and b are the same quantity. So, a equal to b is the same as saying b equal to a. This is not true in C. For example, let us say, that you have the statements b = 3; and then later you have a = 2; and further you have the statement a = b; So, the statement a equal to b will set a to b's value. So, b's value is 3 and that value will be copied to a. So, it will set a to 3 and b we will be unchanged. So, watch out for this. If, if you were expecting the mathematical operator, after the operation a = b, a and b we will have the same value, but that is not the case. The meaning of the symbol equal to is, that take the value on the right hand side of the expression and copy that into the box specified by the life side. So, copy the value in the right hand side to the variable on the left. We have seen comparison operators, like less then, equal to, less than or equal. to and so, on. We will see bunch of few more operators in this session. So, let  us consider the modulo operator which we have already seen in when we discussed utility in GCD. So, a % b gives the reminder when a is divided by b. So, suppose we have the following problem, we get a number a and we want to check whether the given number is divisible by 6. If it is divisible by 6 a % 6 will be 0 the reminder will be 00. So, we will write a simple code, you have int a, a is of type int. Then, scan the number using scanf( “%d”, &a). And then, you test whether a is divisible by 6 to test whether a is divisible by 6 you check whether a mod 6 is 0. If it is divisible, you say that input is divisible by 6 %d a. Otherwise, else, printf the input is not divisible by 6 very simple operation. Now, let us make it slightly more elaborate. Suppose, you have to test whether, this a slight variant. Suppose, you have to test whether a give number is divisible by 6 and by 4 two numbers. How do you do this? So, you scanf the number and you test whether a is divisible by 6. So, a % 6 is 0. If that is true, then you also check whether a % 4 is 0. If both are true, then you print that the given number is divisible by 6 and 4. So, percentage is divisible by 6 and 4 a. So, you can argue about this program and see that, if it is divisible by 6, but not by 4 then, it will enter the first if, but not enter the second if. Therefore, it will not print that it is divisible by 6 and 4. Similarly, if it is not even divisible by 6 it will not even enter the first if condition. So, you will in any case not print that it is divisible. So, convince yourself that this particular code will print a number is divisible by 6 and 4 if and only if the given number is divisible by both 6 and 4. Now, that piece of code was slightly long is there any way to write the same code with a fewer number of lines. And for this c provides what are known as logical operators. Now, there are three logical operators in Boolean logic which are Boolean AND, Boolean OR and Boolean NOT. So, there are three logical operations AND, OR and NOT and C provides all of them. So, the same if condition that we wrote before, we could have easily said if it is divisible by 6 and if it is divisible by 4 then print the output. So, for this C provides an operator which is the Boolean AND operation. So, the Boolean AND operation in C is given by two ANDs. So, by know you should be familiar with the fact it certain operations in C have repeated characters. For example, we already have seen the equality operations which was equal, equal. Similarly, the Boolean operation and it is actually the and symbol on the keyboard. But, you have to have two of them that represents the logical AND. So, this expression says if a % 6 is 0. So, this expression is what test for a is a multiple of 6. And this is the expression which test whether a is the multiple of 4. So, if both conditions are true, then you say that the given number is divisible by 6 and by 4. So, consecutive ampersand signs, that is the and symbols without any blanks in between is the C operator corresponding to the mathematical and the logical AND function. So, it takes two values as input and returns a 0. If any of the values is 0, if both values are 1 then it returns a 1. So, this is the same as the logical AND. If either of them is 0 then the result is 0, if both of them are 1, then the result is 1. So, the truth table for the operation AND is as follows if a is a non-zero value and b is a non-zero value, then C considers that both are true. So, the output value is of a and b is 1. If a is 0 and b is any value at all the output is 0 and b is not evaluated. So, this the same as logical end. The only think to notice that, if in evaluating a and b you already know that a is 0, then you know the result is 0. So, C will not bother to evaluate b. Because, it knows that the result is already 0. Every expression has a type a and b is of type int regardless of the types of a and b. This is because a and b is a logical assertion. The type of a logical assertion is that, it is either true or false, it that it corresponds to a Boolean value. Therefore, at the type of an a and then b regardless of what a and b are the result is always 0 or 1. So, it is of type int. Now, you can print the result as an int, you can say printf %d a and then b. Now, there are three logical operations as I mention. So, there is also OR in c it is denoted by two vertical bars which are there on your keyboard. So, a or b which is a || b evaluates to non-zero if either a is non-zero or b is non-zero. If both of them are zero, then the result is zero. So, this the meaning of a logical OR operation, if both of them are false, then a or b is false. If at least one of them is true then a or b is true. So, you can write the truth table for that. If a and b are 0 then the output is 0, if a is non zero and b is any value. Then, in already know that the output of a or b is 1. So, the output is 1 and b will not be evaluated. This is similar to in the case of AND. If a was 0 and b was any other value, then you know that the output of and is 0. Therefore, b will not be evaluated. Similarly, if here if a is non-zero, then you know the value is 1. So, b will not evaluated and as before a or b is of type int. So, the third logical operation is NOT. Now, NOT in C is denoted as the exclamation mark. So, let us see an example of that. So, NOT is the logical complement and it takes only one argument, this is different from the previous two that we have seen a or b and a and b both took two arguments it is not takes only one arguments. So, it is called a unary operators. So, NOT of a is an expression of type integer and the value is the negation of a. So, if a is 0 NOT of a will be 1 and if a is non zero then NOT of a will be 0. So, for example, if I want to say that a is not divisible by 3 I will just write NOT of a mod 3 equal to 0. You know that a mod 3 equal to 0 test for a being divisible by 3. So, negation of that it will say that the given number is not divisible by 3. Let us finish this by slightly complicated example which is that of leap years. So, I am given a particular year number and I want say whether the given number is a corresponds to leap year or not. Now, what is a leap year it is that you add a few years will have February 29th in February all other years will have 28 days in February. So, what is the logic of a leap year. So, roughly an average solar year is 365.242375 rotations. So, in particular is not an integer. So, we normally say that year has 365 days that is not quite true, this it is a rounding. So, how much are we losing. So, you can calculate it as follows. The remaining number after the decimal point is a roughly 0.25. So, at a rough cut let say that every 4 years. Because of this 0.25 you will lose one day. So, every year you are losing about a quarter of a day. So, if every 4 years you will add a day. Now, when you do that you go back to... So, just a minute. So, you have 365 point let us say 25. So, every 4 years you would lose about a day approximately 1 day. So, in order to compensate for that you add 1 day every 4 years. So, in 100 years you would have added 25 days. But, that is 1 day too much. Because, remember that this number is only 365.24 something. So, in 100 days you should have added only 24 days. But, now you added a 25 days. So, to compensate for that every 100 year skip adding the extra day. So, every 4 years you have add 1 extra day,, but every 100 years every 100th year you do not add that extra day, you skip it. Because, you would have added 1 more day then you. And then again you can look at what remains, what remains is roughly .24 which means that every 400 years if you do this adjustment you are losing about a day. Because, every 100 years you are losing about quarter of a day from this 0.2375 part. So, you do the same logic again every 400 years. So, every 400 years add an extra day. So, this is the logic of the leap year that we all know. So, how do you decide whether year will be leap year. So, the logic that I have outlined just now says that, if a year is a multiple of 4 then it is a leap year. But, if a year is a multiple of 100 as well then it is not a leap year. But, if it is a multiple 400 than it is a leap year. So, here is a pretty complicated expression. So, every 4th year is a leap year. But, skip every 100th year unless it is also a 400th year. And you can write this expression in C, it is slightly complex has you can imagine. So, if the first line the first expression says that, wise year is a multiple of 4. So, if year is divisible by 4 also the following should be true, it should not be a multiple of 100 unless it is a multiple of 400. So, it should not be divisible by 100 that should be true or it should be true that, it should be a multiple of 400. For example, if you have 400 then it is a leap year. So, what will happen is that year modulo 4 400 modulo 4 is 0. Then, what happens is that you have 400 modulo 100 that is 0. So, this is equal to 0 that is 1 NOT of 1 is 0. So, this part is entirely 0, but it is divisible by 400, 400 divided by 400 is 0. Therefore, this part is true, this or 0 or 1 is true. Therefore, the whole expression becomes 1 and 1. So, it is true. So, this logical expression slightly complicated logical expression encodes the logic for saying that the given year is a leap year. So, try this out yourself this is a slightly tricky expression. And convince yourself that, this exactly encodes the logic of the leap year. In this session, we will look at loops in the C Programming language. And we will start with very basic kind of loop which is known as the while statement.  So, the general form of a while statement this similar to that of and if which is that there is an expression and you say while that expression, then do this statement. So, the flow chart corresponding to the while expression will be, you test whether the expression is true or false. If it is true you do this statement, if it is false you exit out of the loop and execute the next statement outside the loop. So, if the expression is true in C that is the expression is non-zero, then execute the statement and go to the step outside the loop. If it is false then directly go outside the next statement after the while loop. This is similar if you recall to the, if block without the else. So, loops are a new thing that explicitly there was no loop construct in a flow chart, we just had this way of going back to the expression. But, in programming languages loops are such a basic programming need that in addition to the if block, you have loop construct as well. So, slightly different variant of the while expression will be that while expression statement 1 and then statement 2. So, the flow chart here is easy to follow if the... So, if first test whether the expression is true. If the expression is true then you execute statement 1. And then after you execute statement 1, then go to go back to the expression. If the expression is false then you go to statement 2. So, while the expression is true execute statement 1 and if the expression is false, then execute statement 2. So, the difference in the, if condition will be that if this was an if block. Then, if the expression is true you do statement 1 and you exit out of the while loop. And that is not done in the case of a normal while loop. After you execute the statement you go back to the expression. So, as long as the expression is true you keep executing statement 1 and if the expression becomes false then you execute statement 2. So, let us illustrate the use of a while loop with the help of a program. So, we will introduce a very simple problem which is, read a sequence of integers from the terminal until -1 is encountered. So, -1 signals that the input is at end. Now, what I want do is that sum up all the numbers until the -1 and output the sum. It is a very simple program. What you have to do is to read a sequence of numbers, until you hit the first -1 and then add this numbers and output their sum. So, let us first introduce the very simple loop which will do only the basic thing of reading the numbers until a -1 is encounter. So, how do you write the loop you have stdio.h. And then you declare an integer variable and read the variable. So, this is supposed to be the first number. If that number is -1 then you do not have to read any more numbers. So, if the number is not -1. So, if a = -1 is false then you read one more number. After you read one more number you do not finish the loop, you go back and test whether the loop condition is still true. So, you go back and check whether the second number you read was -1 or not. And then, you keep on reading it until you hit a -1. At some point when you hit a -1 you go back to the loop and the condition that a = -1 will be true. So, NOT of that will be false and you will exit the loop. So, read the first number if it is a -1 do not enter the loop; otherwise, keep on reading numbers until you hit a -1. That is the meaning of the while loop. So, let us just trace the execution of the loop on a sample input to understand how it works. So, in a box I will represent the memory location a and its current content. So, I run the program after compiling a.out and let us say that I enter the number 4. Now, you scan the number 4. So, memory location a becomes 4. Now, 4 is not -1. So, you enter the loop. So, then n let us say the next number is 50, you read the number into a. So, memory location a is now 15, 15 is not -1. So, you again enter the loop, you enter -5, -5 is not -1. So, you enter the loop again. At this point you enter, you scan the number into a and a becomes -1. So, you go back to the loop again and now the test that so, a = -1, so, naught of that is false. So, the while condition becomes false at this point you exit the program. So, this is a very simple part of the program that we want to write, recall that we want to read a bunch of numbers and sum them. And the end of the numbers is represented by a -1. Until now we have just read those numbers. In this session, we will continue the program that we were writing. Recall that, we were writing a while loop, which will read a bunch of numbers. And it is supposed to sum them up, until you hit a -1. In the loop that we have seen, so far we just read the numbers until -1 was encountered. So, let us now complete the program and compute their sum as well. So, for computing there sum, how do we normally do it? We will add numbers two at a time. So, the first two numbers will be added. Then, that sum will be added to the third number and so on, until you hit a -1. So, let us try to do that, in the course of a while loop. What I will declare is, I will declare a new variable s. So, here is the new variable s that, I have declared. s is supposed to the hold the sum of the variables that, I have read so far. Now, it is very, very important that, when you declare a variable, you should initialize them properly. In the case of a, we did not initialize it because, we were reading the first number, as soon as was declared. But, in the case of sum, you would use s to maintain the sum, as you read numbers. So, it is important that, you start with s = 0. So, the initialization step marked by this arrow is quite important. If you do not initialize it properly, then the sum may not be correct, as we will see soon. So, we keep a variable s, which is supposed to hold the sum of n numbers, sum of these numbers and initialize the sum to 0. Then, the difference from the loop that, we have seen so far is highlighted in red. So, earlier recall that, we were reading the number. And just testing, whether the number is 1, if it was not -1, you read one more number so, that was the loop. Now, inside the loop, what we will do is, we will keep up, running sum of the numbers that we have seen so far. So, initially s sum is initialized to 0. Then, if the first number is not -1, you add the first number to s. So, s will now be the first number. Now, read the second number. If the second number is not -1, you will enter the loop again. So, you will add the second number to s. So, s is now first number plus second number. And this keeps on going until you hit -1, in the input. So, let us continue with this. Let us try to trace the execution of this program, on a sample input and try to understand, how it works. Let us say that, I compile the program successfully and run the program. So, I run a dot out and let us as before, let us the first number be 4. So, after initialization, when you declare the variable a is undefined and s is also undefined. After the initial statement, s = 0, s is now 0. And then, you scan the variable a. So, a becomes 4, because 4 was the input. And sum is still 0. You enter the loop and you say, s = s + a. So, sum becomes 0 plus 4, which is 4. And you read the next number. Let us say the next number was 15. So, a becomes 15, a is not -1. Therefore, you enter the loop again. And sum is now 4 plus 15, which is 19. So, sum at any point of time is the sum of the number that, we have read so far. So, we have read 4 and 15. So, the sum is 19. Now, you read the next number. Let us say, the next number was -5. -5 is not -1. Therefore, you enter the loop again s equal to s plus -5. So, s becomes 14. Then, you read the next number. And let us say, the next number was -1. So, since the number read is -1. You go back to the loop. And this condition becomes false. So, you exit out of the loop. And then print that, the sum is let us say 14. So, when you verify it by hand, you would see 4 plus 15 plus -5 is 14. So, you have, the program has executed correctly. The important thing to note is, the final -1 is not summed up. So, that is, it is used as the end of the input and you should not compute the sum of the numbers, including -1. -1 is excluded. Then, the program executed, correctly.  We will introduce a few terminology associated with the notion of a loop. Each execution of a loop is known as an iteration. So, in the above loop, when the input was 4, 15 -5 -1, the loop runs for three iterations, corresponding to the inputs 4, 15 and -5. So, for input -1, the loop is broken. So, you do not enter the loop. So, you do not count an iteration corresponding to -1. So, you entered four numbers including the -1 and the loop executed three times. So, you say that, the loop had three iterations. So, this is a technical term associated with the loops. And here is a concept that, I will introduce to help you argue about the correctness of a loop. So, there is a notion known as a loop invariant. Now, a loop invariant is a property relating values of the variable that holds at the beginning of each loop. So, thus bit abstract let me just illustrate with the example, that we just saw. So, loop invariants are a good way of thinking about the correctness of loops that, you have to do. So, in our program what will be the loop in invariant? Let us look at the property of that, we are interested in. There are two variables in the program, s and a. And both of those variables are involved in the loop. But, the interesting property that we have relates to s. What is the property that, s holds with respect to the loop. So, we can see that, s holds the sum of all values read so far, except the last value is that true, the first time that we enter the loop? Yes, because s was initialized to 0. And you had actually read the number.  So, it is true that, s holds the sum of all values, except the first one. So, that is true, when you first enter the loop. And that, any point when you enter the loop, you sum the last value that was the read. And read one more number. So, you will see that, s still holds the sum of all values read so far, except the last one. So, this is the loop invariant in the program. And loop invariants help you, argue about the correctness of the loops. So, if the loop invariant is correct and the program maintains loop invariant, then the value of s when the program stops, will be correct. Why is that? Because, the loop terminates, because the last value read was a -1. And the invariants says that, s holds the sum of all values, except the last value. So, this means that s holds the sum of all numbers, except the -1. Therefore, when the program ends that is, you exit out of the loop, s holds the sum of all number that you were supposed to add. So, here is how arguing about loop invariant and seeing, whether loop invariant holds in the loop that you have written, helps you argue that the program is correct. We will see a few more examples, because loops are really important. Let us go back to the first problem that we discussed, which was the problem of computing the greatest common divisor of two positive numbers. So, the problem is to read the two numbers, find their GCD and compute the output. Now, we had a flowchart of the problem based on the fact that, if a >= b, then GCD(a,0) if b is 0, then GCD(a,0) is a. Otherwise, GCD(a,b) is the same as GCD(b, a%b), with a % b is a % b is the remainder, when a / b. So, let us now try to write the program in C using a while loop. So, we have to do a few preliminary things. So, let us call up the first half of the program. In the first half I declare three variables, a, b and there is another variable t, whose need we will see right now. But, let us say that I need an extra variable for now, let us just take it on faith. So, what I will do is scan two variables a and b. Now, recall in the GCD equation that we saw right now, we assume that a >=b. Now, what if the user is unaware of his condition and enter the lesser number first. So, he just entered the numbers in such a way that, a < b. So, we need to correct that, we need to make sure that a is the greater number. So, we need to exchange the values of a and b, if it is true that a is less then b. Now, how do we do this? So, the first thing to note to try will be to say that for example, if I say that let us say a was 3 and b was 4. And suppose, I just said a = b I want to exchange the values of a and b. I just said a = b and b = a. What will be the effect of this? Note that, this is the assignment statement. So, after I execute this line, b is 4 so, a will be 4, a = b results in a equal to 4. After the execution of this line. So, what this situation that we will have is that b equal to 4 and a equal to 4. And we will have no memory of, what was the original value of a? That is lost. So, it is just simply lost. So, this idea that we can exchange two values by just writing a equal b, b = a does not work. So, what is the correct way to do it? So, we have an idea known as the cyclic exchange and this is a really neat idea. The idea is that… So, how can I motivate it? Let us say that you have two rooms and these two rooms are full of steps. And I want to change the contents of the first room to the second and the second room to the third. One way I can do it is that I will move the contents of the first room to a different room. So, have a temporary room and then copy the contents of the second room to the first and copy the contents of the third room to the second. So, this is a very nice intuition and it almost is similar to what we need to do. So, we have two variables a and b that we need to swap. So, one thing we can do is, I will keep a third variable t. First what I will do is, I will copy the value of a to t. So, now I have a backup copy. Now, then I will say a = b,. So, at this point the value of b will be copy to the a, So, now, a is 6, b is 6. But, still we have a memory of what was a before? Because, the old value of a was told in t. So, in order to complete the routine, all you need to do is to copy the value of t to b and that can be a complete by the equation by the assignment statement b equal to t. So, this idea is known as cyclic exchange. So, recall the physical intuition of swapping the contents of two rooms which are almost full. You have a third room and you move the contents of the first room to the third room, move the contents of the second to the first and move the contents to the third to the second. So, this is similar to what we did. In the case of physical contents, we cannot copy, in the case of variables, we can copy. So, now let us complete the GCD program. We have just done the first part of the program which is to ensure that a is actually the greater number. If it was not the greater number, you swap or exchange. Now, So, after exchange we have ensure that a >=b. Now, we have to write the main loop for the GCD function. So, just by translating the flowchart, what we will do is while b is not 0. What you do is, you say that store the value of a and t. Assign a to b, a = b and b becomes t % b. Recall the equation was written as follows that. So, recall that the equation was GCD(a, b) is the same as GCD(b, a % b). So, when you assign a to b, the old value of a is lost and we can no longer do a % b. So, the way to do that is, you use the idea of temporary variable, store the old value of a and t, before you do a = b. So, that finally, a % b can be done by t % b. I do not want the new value of a, I want the old value of a. So, let us just trace the execution of this program. Let us say that I scan two numbers a and b and the user was correct in entering it. So, he actually enter the greater number first. So, we have 16 and 9, a equal to 16 and b equal to 9 and t is undefined. So, after you read the numbers, you just say GCD of… After these you enter a message which is printed message which is the GCD of a and b is,. So, GCD of 16 and 9 is and then you enter the loop. So, in the initial execution of the loop you have t equal to a, which will store t equal to 16, a = b, which is a will become 9. And then, but you want to compute the modulo 16 % 9, but 16 was lost in a, because a is not 9. So, you have do t % b,. So, 16 % 9 which is 7. So, you go back to the while loop and then you see that b is not 0, b is 7. So, you enter the loop again. T is equal to a,. So, t is 9, a = b,. So, a become 7, b becomes 2. Again b is not 0, So, you enter the loop again. So, t is 7, a equal to 2 and b equal to 1. Again you enter the loop, b is not 0, t is 2, a becomes 1 and b becomes 0 at this point, you exit the loop and at this point a that we ended with is the GCD of these numbers. So, 16 and 9 are relatively prime. Therefore, their GCD is 1. Now, let us think a minute about what is the loop invariant in this program? What is it that? We have a central while loop which computes the GCD. What was the invariant in that loop? So, for this I will just introduce a slight notation which makes it easier to discuss this invariant. So, let capital A and capital B be the original numbers that I input. And little a and little b represent the numbers which are involved in the loop. So, capital A and capital B are the original input and the invariant that I have is that at every stage, the GCD of the original inputs are the same as the GCD of little a and b. We call that little a and b are the loop variables involved in the loop. So, little a and b keep changing through the loop, whereas, capital A and B are fixed, they are the input. So, the invariant that I have is that every time you enter the loop, the GCD of the input where the same as the GCD of the variable. Now, this guarantees the correctness. Because, when you exit out of the loop, you will correctly compute. You exit out of the loop, because b equal to 0, and by the original equation, you know that when b is equal to 0, a is the GCD of a and b. So, this guarantee is correctness. Now, you could also ask other questions like, how many times has the loop run? And this question is big complicated, because you have to compute it based on the input numbers. So, such questions are of interest to computer science. But, we will not going to computing the efficiency or the performance of this code. But, it is also a very crucial question. So, we will see one more example for writing loops, we see as slightly trickier example and will cover this over multiple sessions. So, the problem is the following. We have to read as sequence of numbers until a -1 is read, -1 indicates that then the sequence of sent it. And the question is we have to output the length of the longest contiguous increasing subsequence. So, that is a lot of words let us illustrate it with an example. Let us say that the input is of the following numbers - 9 2 4 0 3 4 6 9 2, and then finally a -1. And we have to output the length of the longest contiguous increasing subsequence. So, let us say what do I mean by a contiguous increasing subsequence? So, I say that 9 is an increasing subsequence, then the next number is 2; 2 is less than 9. So, 9 and 2 cannot be part of a subsequence, where the numbers keep on increasing.  So, 2 is the start of a new sequence, again the next number is 4. So, 2 and 4 form an increasing sequence. So, you can continue increasing a sequence. The next number is 0, 0 is less than 4, so break the sequence there. Then when you look at then succeeding numbers 0 3 4 6 9; they form an increasing sequence. And the last number is 2, which is lesser than 9. So, the increasing sequence stops here. So, these are the increasing contiguous subsequences; contiguous means together occurring adjacent to each other. So, the largest of the longest contiguous subsequence is obviously, 0 3 4 6 9, and the length of that sequence is 5. Let us take another example 11 9 7 8 11 12 15 15 and -1. So, just to illustrate the point 11 is greater than 9. So, that cannot be an increasing sequence, 9 is greater than 7, so that is another the increasing sequence is just 9, but then 7 8 11 12 15; these are increasing. And I decided to stop here even though the next number was 15, because I am interested in and increasing subsequence. So, 15 and 15 are equal numbers. So, we break it. So, the longest increasing subsequence is 7 8 11 12 15 and its length is 5. So, this the longest contiguous increasing subsequence. So, here is a basic property given any sequence of numbers, we can break it into a collection of increasing contiguous subsequences. For example the numbers that the sequence that we have seen. So, 9 2 4 0 3 4 6 4 6 9 2, and that the length of the increasing, the longest increasing contiguous subsequence is 5. So, we have to write a program to do this, given a sequence of numbers find the length of the longest increasing subsequence. So, how do we do it? We do it in the way that we have been writing loops so far, like adding n numbers and finding this sum and so on. The idea was that you start from the first number and keep on adding the numbers until you hit -1 at which point you have this sum. So, the idea of this algorithm was that you start from the first, and you keep reading, until certain condition happens. We will adopt that idea to solve our current problem. So, what we need to do is to keep track of the current increasing subsequence. Let us say that it is denoted by s. So, before we get into the code, let see how we will do it by hand. So, initially the increasing subsequence is s, and let say that it is empty. After you read 9, you have an increasing subsequence which consist of exactly 1 number. So, s is 9. Now, the next number is 10; 10 is greater than 9. So, you extend this. Read the next number 4; 4 is less than 10. So, 9 10 4 cannot be an increasing subsequence, therefore you say that you break the subsequence there, so 9 10 is a different subsequence.  Now you start a new subsequence which is 4. So, the current subsequence is just 4. So, 0 is less than 4, so you break it there, the current increasing subsequence become 0. Read the next number 3, 3 is greater than 0. See you extend the subsequence s is now 0 3 4, 4 is greater than 3. So, the sequence becomes 0 3 4 and so on. So, what are we doing here? We are reading the read, we are reading the numbers integer by integer, and we are keeping track of the current increasing subsequence. So, this is part of what we want to do? Now, in order to decided whether we should increase the subsequence extend it or break the subsequence, and start a new sequence what we need to do is we should remember what was the previous number we saw, and what is the current number that we have seen. So, with two variables we can say whether the subsequence should be extended or should be broken at this point. So, if the previous number is less than the current number, then we should increase the we should extend the subsequence. If the previous number is greater than or equal to the current number then we should break the subsequence and start a new sequence. So, extend the sequence means add 1 to the length of the current increasing subsequence, and add that number to the subsequence. Reset means you start a new sequence of length 1.  So, from the current from the description that we have seen so far, we need the following variables, we need C which is for the current rate c number, p which is the previous number that we have seen, and length which is the length of the current increasing sequence. So, we store the previous number into p, store the current length of the increasing subsequence into length, and read the next number into c.  So, if the previous number is less than the current number. So, we take the true branch in which case we extend the sequence. So, the new number that we have read is part of the of the currently increasing subsequence. So, increase the length of the sequence by 1 and now we move lockstep. So, what we do is? So, we are a stage where suppose we have numbers 1 2 and 3, suppose p was pointing to 1, c was pointing to 2. So, since 2 was greater than 1, we extend the sequence. After extending the sequence, we have to proceed and see what will happen with the next number. So, when you do that you can do the following, I will extend the current sequence by doing the following, I will now set p equal to 2, and c equal to 3.  So, this is the idea that we will advance both the variables by 1 number each. So, that it is always true that previous is 1 number behind current. So, I hope this idea is clear that in order to ensure that p is 1 number behind current, you have to advance both p and c. So, assign p to c, this will advance p and then read the next number. So, that will become c. Now what happens if c >= p, then the new number is not part of the current increasing subsequence. So, you start a new sequence which is of length 1 and again do the same assign p to c, which is advancing the pointer and read the next number. So, here is the method that we will follow in order to keep track of the current increasing subsequence. Now what is left is to find the longest of all the increasing subsequences that we find. In this session we will try to code up the C code for finding the length of the longest increasing contiguous sub sequence. So, let us first examine what we need to do, we will write a code, and from the previous discussion we saw that we need at least three variables; one for a storing the previous number, one for storing the current number, and the third for storing the length of the current decreasing sub sequence. So, we start by declaring all those three variables and initializing length to 0. So, here is a new construct that we are seeing for the first time, which is that when you declare a variable, you can also initialize it immediately by saying len equal to 0. So, this is a very intuitive notation. So, this will declare a variable and immediately initialized it to 0. Once we declare these three variables, let say that we scan the first variable into previous. Now, let us focus on, on the main body of the program. If the currently read number is if the currently read number is ! = -1, then you say that you start with length 1. So, the length of the current increasing sub sequences 1, and then you scan the next number into curr. So, here is current number. So, this part of the code is just to initialize. So, if the current, if the first number is -1, then there is no point in getting into the program, because the its equivalent to the empty inputs. So, there is no increasing sub sequence to be found. So, you just exit out of the program. So, initially we just check to see whether the first number is -1 or not. If the first number is ! = -1, you scan the next number, so current will be the second number. And if current is ! = -1 while the currently read number is ! = -1. What you do is exactly the logic that we were discussing before. If the previous number is less than the current number then you extend the length by 1.  So, length equal to length plus 1 says that I am continuing the current increasing sub sequence by increasing its length. Otherwise that is current is less than or equal to previous, you break the sequence and say length equal to 1. Then we have this step previous equal to current, which is the advancing both variables by 1. So, previous becomes the currently read number, and current becomes the next number to be. So, recall from the diagram that previous and current were at some position, and we will advance both of them by 1. And when the loop condition is check the next time we will check whether the currently seen number is -1. So, so far we have coded up part of the logic, which is the part of the logic dealing with when the current when the next number is read do we extend the sequence or do we break the sequence and start a new sequence. So, this is just part of the work that we need to do to solve the problem. So, lets continue with the logic. So, let us start with a few boundary cases, and let see that whether these works. If it works we can try or logic on other cases. So, let us say that by boundary cases I mean may be very long inputs or very short inputs. So, these are cases where your code normally breaks. So, when you test your code it is always a good idea to check boundary cases. And one thing that makes programming difficult is that in or when we do things by hand, we know how to handle the boundary cases elegantly, but in a program unless you say how to handle the boundary cases, the program might break. And the lot of testing and the lot of errors come from incorrectly handling the boundary cases. So, it is always good to handle the boundary cases, let us try test our code on very small inputs. So, let us say that I enter a sequence 5 - 1. So, previous becomes, so length is 0; previous becomes 5 and then since prev ! = -1, I have used an abbreviation here which is the not equal to operator, this is the same as saying not of previous equal to equal to 1. So, previous not equal to 1 is the same as saying not of previous equal to equal to 1, its an operator in C, then you say that the len equal to 1, then you say that the length is 1, because you have seen 1, 1 number and scan the next number. The next number is -1. So, you scan the next number, and the next number is -1, so you break the sequence. So, immediately exit out of the sequence, and the length of the increasing sub sequence that we saw, so 5 is the only increasing sub sequence. And when we exited the length was 1. So, we handle the boundary case of an extremely small sequence, a sequence with exactly 1 element correctly. This gives us confidence that the code could be correct, of course we have handle only the boundary case. Now, we see need to test it for other cases as well.  So far the program is not doing any anything useful, because we are just extending the sequence and breaking the sequence. What recall that the what we was suppose to do was to fine the length of the longest increasing sub sequence. So, this is the main, this the main thing that we have to do in the logic. So, to do this what we do is something simple. We keep track of the maximum length sequence that we have seen so far, keep track of the length of the longest sequence that we have seen so far. Also we have the current sequence. Now all we need to do is whether to check whether the current sequence is longer than the previously known longest one. So, for this what we do is keep track of the maximum length that we have seen so far. So, this is a standard technique in program. And how do I do that. So, let us modify the program a little bit. So, earlier we resend out that we need at least three variables. Now in order to keep track of the length the maximum length that we have seen so far, I need a new variable. So, this part we have already done before. And here is the maxlen = 0. So, that is the new variable which is the maximum length that we have seen so far. When we start the program we have not seen any increasing sub sequence, and therefore the length of the longest increasing sequence, the current increasing sequence is 0; that is len equal to 0. And the length of the maximum length that we have seen so far is also 0.  Then you scan the new number; if the new number is not -1 you continue. So, length equal to 1, now max length equal to 1, because currently the longest sequence that we have seen so far is 1 1 long. You scan the num next number. If you… So, here is the main body of the loop, and what we need to do is the following, if the currently read number is greater than the previous number, we extend the sequence. So, this logic is the same as before. Otherwise which means that current number is that less than or equal to previous. So, we are starting the new sequence. So, the situation is the following we have some maxlen sequence somewhere in the past. So, maxlen is the length of the sequence that we have seen somewhere in the past.  Now we are scanning in the sequence we have a current sequence. And we have decided to break this sequence. So, we have we are now starting a new sequence starting at current. So, we are a this part of the logic. So, we have decided to start a new sequence, that is because the current sequences last number is greater than or equal to the current number. So, here is previous, and this is current. So, we are deciding to start a new sequence what we need to see is whether this sequence is longer than the previously known maximum length. If the sequence that we just stopped is longer than the previously known maximum length sequence. So, if maxlen < len notice that length is then sequence that length of the sequence that we just stopped. Then we say that maxlen = len. So, if the current sequence is longer than the previously known maxlen, what we do is that maxlen becomes the length of this sequence. Otherwise if the current sequence was shorter than the previously known maximum length, we do not do anything, so maximum length is the same…  So, when we extent the sequence we don’t have to do anything special when we  break a sequence, and we start a new sequence, then all we have to do is you check whether the currently say the sequence that you just saw was longer than the previously known longest sequence. If that is the case then the sequence that just ended is becoming the longer sequence we have seen so far. Otherwise you maintain the max length. So, just forget about the currently stop sequence. Now there is a... So, that this loop, and at the end we have to do slight tricky logic, it could so happen that the sequence ends with a longest sequence increasing sub sequence. In that case, we will never reset the max length. So, if the last sequence is the longest, you also have to handle the case separately. So, we will see an example where, if you exit out of the loop that is you have already seen a -1, you just have to check whether the last increasing sequence that you saw was in fact the longest. So, there is a small if block at the end to do that.  In this part we will just see, small tracing of this program on a sample input. So, that the logic of the program become slightly more clear. So, I have picked a particular input 3 2 1 3 5 -1, and you will see that the longest increasing sequences are 3. So, the increasing sequences are 3, then 2, then 1 3 5. So, 1 3 5 is going to with a longest increasing sub sequence, and let us see how our program will find that out. So, initially you have a bunch of variables which should be declare. So, len = 0, maxlen = 0, and previous and current are undefined. Then you first read previous. So, previous becomes 3, it is not -1, so you enter the if condition, at which point you set length and max length to 1.   Now you scan the current number. So, current becomes 2. So, remember that previous is now 3, and current is 2. So, current is not -1, therefore you enter the while loop. Prev < curr is false, because previous is 3 and current is 2. Therefore, you enter the else part, maxlen < len is false; both are 1. Therefore, you start a new sequence with length equal to 1. Now you continue the loop with previous becoming current.   So, previous is now 2 and current you read the next number which is 1. So, previous and current have both more 1 step. So, current is not -1, prev < curr is again false, because 2 is greater than 1. So, you enter the else part. Max length and length there is no change. So, you reset the length to 1, previous is current. So, current previous becomes 1, and you scan the next number which is 3. Now at this point previous is 1, and current is 3. So, the if condition is true. So, you extend the length; length increases by 1. Again you advance previous and current. So, previous becomes 3, current becomes 5. Again 3 is less than 5, so increase the length we are extending the sequence. So, the length becomes 3. Advance, so previous becomes 5, and current becomes -1 at this point you exit the loop.  And now you encounter the situation that max length, which is the length that we have seen so far, recall that it is one, but the length of the sequence that we just stop the see the input with is 3; that is that happen, because the longest increasing contiguous sub sequence, well was at the end of the input. So, it happen right at the end. So, when we exit the loop we have to do 1 additional check, we cannot simply say that the maximum length that we have seen in the sequence is 1, because max length is the length of the longest sequence we have seen before the current 1. The current 1 was the 1 that we just stop to with it had a length of 3. So, we just check, if max length equal to length is less than the length, then we set max length to be the length. So, once you do that max length becomes 3. This is just to handle the case when the longest increasing sub sequence is the last. Now you can exit out of the exit out of the if condition, and then print that the maximum length that you have seen is 3.  So far we have been using while loops in C, now C programming language also provides you other kinds of loops.  Let’s look at some of them. The first alternative loop mechanism in C that we will look at is what is known as a do-while loop? And so it is a variant of a while loop, I am the general form is what you see here, you have do statement followed by while expression. And here is an important syntactic difference which causes some syntax errors, when you code. The do while terminates within semicolon, where is the while loop does? So, the while loop has the following a form which is while expression, and then statement; the difference is that here the statement is occurring before the while the test expression. So, the way it execute is the following. We first execute the statement, then evaluate the expression. If the expression is true, you go back to step 1; that is execute this statement. If the expression is false, then you get out.  So, you execute the x statement then test whether the expression is true or not, if it is true you go back and the execute the statement again, so you loop. If the statement is false, you get out of the loop. The difference from while loop and do while loop is the following, you have statement that will be executed without testing the expression even once. So, when you start executing the loop, you will first execute the statement without testing the expression, and after testing the expression you will go back and test the loop expression, if it is true and you start executing the loop again. So, the first execution of the statement there is no test done for that. So, let us see the comparison between a loop while loop and do while loop. So, we will look at the following problem, you have to read numbers and output in integer until a -1 is seen. Now the difference is that in this problem you have to include the -1. So, read all the numbers up to an including -1, and print all the numbers. So, we will have the following programs using while loop and do while loop. Now the important thing to notice is that the while construct and the do while construct are equally expressive. So, you cannot right any more new programs using the do while construct, then you could using the while construct, but certain kinds of programs or easier using or shorted using the do while construct. For example let us all this problem using the while construct. So, what you do initially is, you declare a variable then scan the variable; if the variable is -1, you immediately exit out of the loop, and print -1 and finish the program. If the number is not -1, you print the value and scan the next number. If the number you scan this not -1, you just print it and repeat the loop. If it is -1, you exit out of the loop and print the -1 that you show. So, here is the logic using the do while loop, in using the while loop. And notice that when we existed out of the loop we needed a printf statement, and before you yes, enter the loop you needed a scanf statement. So, this was the structure of the program. This problem can be elegantly solved using the do while loop. What you initially need to do is to declare a variable, then scan the variable and print it any way. Either the number is -1 or it is not. In any case we need to print it.  So, go ahead and print it then test whether the number was -1. If it is -1, your done and you exit out of the program. If it is not -1, you go back and scan the next number and print it. So, this is a program that we have seen where you could do this same think with the while loop. The only difference is that the do while program is shorter. And please be careful about the syntactic difference between the while loop and the do while loop, notice the semicolon at the end this causes a lot of confusion when you compile the program it is easy to miss this. If you are new to C programming, you can strict to one particular loop. As I said before you cannot write any new programs that you can do is using the do while loop, then you could previously do using the while loop. So, you can write the same logic, you can write the same number of programs using the while loop, and the do while loop it gives you no further power. So, it is recommended that you stick to one loop pick while or pick do while whatever you do, but stick to that loop in when you right the program. When you are comfortable with one of the loops programming using the other loop becomes easy. So, let us try to solve a problem that we have already seen, which is to find the length of the longest contiguous increasing subsequence ending in -1. The difference that we have is that earlier we did not include -1 in the sequence when you computed the length of the sequence, now we will include -1. So, here is the program to do that and the logic - the core logic, so here is the initialization, and here is the loop logic, and the final check.  So, if you recall from the lecture which covered the problem solving the longest increasing subsequence, then you will see that the main structures in the code. The main lines of logic in the code are pretty much the same. All I have done is to change the while logic to the do while logic. And let see what that is accomplish for us. So, what this does is that you will scan a particular number, if the particular number is bigger than the previous number, then you extend the sequence. If it is less than or equal to the previous number, then you stop this sequence and started new sequence, this was the logic.  And when you start a new sequence the length is new start with 1. Then you say current equal to the next number, and previous equal to the number that was just red. So, the logic here is that the testing for whether the currently rate number is -1 is done at the end of the loop. So, is the first number is -1, you just do all this and then say that the length of the increasing subsequence is 1, then you test if the currently read number is -1 or not. If the currently read number is -1, then you are already done and you exit out of the loop. Then you check whether max length is less then length as before. difference between this logic, and the logic that we have seen before is that we do this execution without testing whether the currently read number is -1. So, automatically what happens is that if the number is -1, all these steps will be performed before we test that the sequence has ended. So, automatically we ensure that -1 is also included when we calculate the increasing subsequence. In this session, let us look at a matrix problem and the problem is given as follows. You have a bunch of lines of input. The first line of the input consists of two numbers, m and n. This line is followed by m lines, each containing n integers. So, this is supposed to represent the matrix of size m time m cross n. We have to calculate the sum of the squares of the sum of numbers in each row, that is quite a mouthful, let us look at the formula. So, what I want to do is, . So, once you do this sum, you square that and then do the  . So, i is an index which goes over the rows. In C, we adopt the convention that the first row is starting with 0 and so, it goes from 0 to m minus 1. Similarly, the first column starts with index 0, so it goes on till n minus 1. So, the input will be given as follows. The first number m represents that there are 3 rows, the second number represents the number of columns in each row and then this is followed by a matrix of size 3 cross 4. Now, the numbering is given as follows. For example, if you have , this means second row zeroth column. Note that, second row means we start with row 0, then row 1, then row 2 and zeroth column is this, the first column. So,  is this number which is 2. Similarly,  is first row, row number 1 column number 2, which is also 2. So, the desired output that we have is  and so on. So, how do we do this by hand? Let us just look at the calculation.   So, we have 4 7 11 2 1 1 2 4 and 2 9 0 minus 1. Notice that the formula that we have to calculate is i going from 0 to 2, j going from 0 to 3 squared. So, how do we do this? First, we sum the numbers in each column so, I will name that as j going from 0 to 3  and then square. So, if you sum all this, you see 11 22 242 which is 576 and similarly, this is 64 82 and this is 102, which is 100. So, what I have tallied on the right hand side is, for each row you sum the numbers take that sum and square it. And then finally in order to compute what we want, which is . In order to calculate this, all we need to do is to sum these numbers up and this turns out to be 740. So, notice when we did by hand, we did the following, we first calculated row wise, we summed over all the numbers in that row. Take the sums, square it. Then, you repeated the same operation for the next row and then for the third row. So, we have three numbers and then we added them in sequence. So, we will see how we will code this up?  So, what we need here is something called an inner loop or a double loop, we need a loop inside a loop. Now, the inner loop is doing what we did first? It is taking a row and adding all the numbers in that row, then squaring it. So, we need one loop to do the rowsum of each row. Once a row is finished, we square the rowsum. Once that is done, remember that once we tallied numbers on the right hand side and squared them. We have to add those numbers up. So, we need another loop, an outer loop to add these squares of rows sums. So, let us do this program in stages. First, let us write the inner loop, this is the loop, so that for a given row you sum up all the numbers in that row. Now, let us assume that we are at the beginning of a row and we have not read any numbers yet. Now, what we have to do is to start reading the numbers. So, we write a while loop. We declare four variables a, column index, then we need something for the rowsum and some integer variable for rowsumsquare. Now, what you do is you go along the row and add the numbers in each column. So, while the column index is less than n, recall that the matrix size was m cross n. You scan the next number, the next number is added to the rowsum and then increment the column index. Until you hit n, recall that the last column is n minus 1, because we start the column numbers from 0. Now, once you have done you have the sum of the numbers in that row and what you need to do is to square that number. So, we have rowsum times rowsum will be rowsumsquare. That completes the inner loop, which is what we did, when we added the numbers along a given row and then finally, squared the sum. Now, what we need is an outer loop structure over these. So, we have a code that reads the next n integers from the terminal and sums them. Now, what we need is some further code, that takes the output of the previous code and then sums all those numbers up. Remember, when we did this by hand, this was the second operation we did, we went over the right most column and added all those numbers up and that was the result that we wanted. So, how do we modify the code? So, let us what we need is something like this. Assume that we have the output available from the previous code in some variable called rowsumsquare. And we need a loop over that, which is going from rowindex 0 to m minus 1 and tallying up all the numbers in rowsumsquare. So, for each row you will end up with a rowsumsquare and you have to add all those rowsumsquare to get in. So, in this the rowsumsquare comes from the previous code. So, this is how we will visualize the outer loop. Now, note that this is not completely specified code. This is just a very intuitive picture, that instead of rowsumsquare, it should come from some inner loop which actually calculates it. So, we should plugin the output from the previous inner loop and this is the outer loop over it.  So, here is how we put these two loops together, we have a while loop inside the while loop. Remember that, this was the previous loop that we had written. So, this was the inner loop that we have written, where at the end of the inner loop you have the rowsumsquare. Now, at the end of the code what you will end up is the exact rowsumsquare of a particular column. So, you can imagine that after this inner loop finishes execution, the rowsumsquare is the correct rowsum is the correct square of the sum of the elements in the row. Now, the outer index does the following, you start from rowindex 0 and sum the rowsumsquare over all columns. So, this is the structure of the code. Let us look at the code in slightly more detail. We have a rowindex, a column index, a column sum, a rowsum and the rowsumsquare, a is supposed to be the current number that we are read in. Suppose, we know that the size of the matrix is m cross n. So, rowindex can go from 0 to m minus 1. So, the termination condition of this while loop is rowindex equal to m. Now, for all that you are currently at a particular row. So, you have to initialize the rowsum to 0 and the column index to 0. Because, for a given row you have to start from row 0 for a given row you have to start from column 0 and you go on, until column n minus 1. Also this previous rowsum should not influence the next row. So , for every row you have to initialize the rowsum variable. Once that is done, you go over the columns of that given row and you scan the numbers add the number to the rowsum and increment the column index, until you hit n columns, column 0 through n minus 1. When you read all the columns in that row, you have the correct rowsum. So, that rowsumsquare can now be calculated. Once rowsumsquare is calculated, you have the rowsumsquare for that particular row. So, add the rowsumsquare to the previously computed columns. So, If you go back and think about how you did this by hand, you can convince yourself that this is exactly the coding of the logic that we had earlier. So, let us try this on a small example to see exactly, how the code works? Suppose, the input is 2 3 followed by two rows of three numbers each. So, the input matrix size is 2 cross 3 and the entries are 1 0 minus 1 and 0 1 1. Let us see, how the code executes on this? So, the output should be 4, if you do it by hand and let us see, the variables are m, n, a, rowindex, column index, rowsum and square sum. Finally, the result should be in square sum. You start with rowindex equal to 0, column index equal to 0 and you scan m and n. So, you already know the size of the matrix, when you scanned m and n. So, m becomes 2 and n becomes 3. Now, rowindex is 0 which is less than 2. So, it starts the loop which reads the row 0. So, notice the arrow here, you are starting to read this particular row, the first row, which is row 0. Or you initialize rowsum equal to 0, column index equal to 0 and while column index is less than n, you scan the next number which is 1. Add a to the rowsum. So, rowsum becomes 1, increment the column index. So, it reach column 1 row 0 read that number. Add it to the rowsum, go to the second column and read the number and add in to the rowsum. So, once you are done, now column index is 3. So, just means that we have read all the entries in the row 0. So, we have got the correct rowsum. What we will do is, add the rowsumsquare to the square sum. So, rowsum is 0, 0 square to square sum, so square sum remains 0. Now, you go to the second row. So, increment rowindex. Now, rowindex is less than 2 rowindex is 1. So, it is less than 2 we are reading row 1 and you repeat the same execution. We reinitialize the rowsum to 0, column index to 0. and then, scan the next number which is 0. Add it to the rowsum, increment the column index, scan the next number which is 1 and so on, until you finish reading the second row as well. So, once you read the second row, you will find that the rowsum is 2 and square sum would be square sum plus 2 square which is 4. After you do that, you increment rowindex and rowindex becomes 3, which is greater than the given rowindex. So, you exit the loop. So, we have correctly computed the sum that we wanted. In this session we will see a very popular loop construct in C. We have already seen while loops and do while loops, will see that do while loops are not all that common in C code, when C programmers code. Among the most popular loop construction C is this, for loop. So, let say what it stands for? The expression for the general form of the for statement, the slightly more complex than that of a while loop. While loop was very simple, while as the certain expression was true, you execute the statement and when the expression becomes false, you exit out of the loop, for loop is slightly more complex. So, it has the following components, it has an initialization expression, then the test expression, this the expression corresponding to the expression inside the while loop and then there is an update expression, followed by the loop statement. This looks complex at first,, but it is quit intuitive once you start using it. The execution is as follows, first you execute the initialization expression, then you test whether the test expression is true or not. If the test expression is true, you execute the statement and then come back and execute the update expression. After you execute the update expression go back to step 2, which is go to the test expression. So, init expression is the initialization expression, update expression is the update expression and test expression is the expression, that is evaluates to either true or false. So, if you look at the flow of how the code goes, then it is first you start from the initialization expression, then you go to first you start from the initialization expression, then you go to the test expression. If the test expression is true, you go to the statement, then you go to the update expression and you go to the test expression again. So, the loop is here you test the expression, execute the statement, update and test again, initialization is done only once. So, this is the first step and here is the loop, this sounds bit complex at first,, but it is quite simple to use, once you get the hang of it. So, the execution of the for loop can be understood in terms of the while loop. The execution of the for loop is almost equivalent to the following while loop, you have the initialization expression before the while loop, then the test expression, while test expression, then you have statement and then you have the update expression. So, if you have a for loop you can write the equivalent code using while loop. So, if you say that I do not want to use for loops, here is how you have a for loop and you can write the equivalent while loop in the following way. Or if you have a while loop, you can write a equivalent for loop by looking at the this form and how it is translate to the corresponding for loop? Now, there why did I say execution is almost equivalent, we will see this later in the course. Whenever, there is a continues statement or a break statement, you will see that we need to modify this as equivalents between the for loop and the while loop. But, for now for with the features of see that we have seen so far. The for loop is equivalent to the while loop and we will have to modify this slightly later. So, the init expression maps to the first part of the for loop, the test expression maps to the second part and the update expression maps to the third part. One important thing to notices is that, the update expression is after the statement. So, we have the following first we execute the initialization expression, then we test whether the expression is true. If it is true, you execute the statement, update expression and then again go to the test expression, if it is true you execute statement, update and then test again. So, you initialize the expression then when the test the test expression if it is true, you execute the statement after the statement is true, after the statement is executed you update the expression and go back to the test expression. Because, that is how you execute it in the while loop? You first initialize, then test whether it is true execute the statement, update and then go back to the test expression. So, this is how a while loop can be translated to a for loop and vice versa. So, let us do some examples very simple think, let us say that print the sum of reciprocals of the first 100 natural numbers. So, what do I want to do? I want to do the following, I want to do . So, how would I do it? I would initialize a variable call sum, sum will be initialized 1 and then 2 sum I will add , then to that I will add  and keep on going until .  So, let see how to code this in C using the for loop. So, I have a variable call reciprocal sum and even though I am summing over integers, we know that the reciprocal numbers will be real numbers. So, in order to keep the reciprocal sum I need a floating point number, floating point variable and then I have an integer variable, which goes from 1 to 100. So, here is how I will do the loop? First initialize i to 1, if i <= 100, you enter the loop and do reciprocal sum equal to the current reciprocal sum plus 1 over i. After doing that you update by saying i = i + 1,. So, increment i. Once the increment is done, you test whether the new number is less than or equal to 100, if it is less than or equal to 100, you do the reciprocal sum come back update, until you reach 101. At the point where you reach 101 you test whether i <= 100 that becomes false and you exit. So, you will see that when you exit out of the loop, the reciprocal sum will be the sum of reciprocals of numbers from 1 to 100. So, here is how the for loop functions.  So, instead of 100 let us try to executed on a particularly very small number to see how this for loop executes. So, let us instead of summing from 1 to 100, let us sum from 1 to 4. So, first you have the initialization expression. So, i is undefined before you enter the while loop, reciprocal sum is of course initialize to 0. So, I can after initialization i will be 1, as soon as it is initialized we will test whether it is less than or equal to 4, 1 is less than or equal to 4 that is true. So, you will enter the for  loop, then you add to the reciprocal sum 1 over i, i is 1,. So, 1 over 1 is 1. So, reciprocal sum will be updated 2 reciprocal sum plus 1. So, reciprocal sum would be 1, then you go to the update expression, at this point you have i = i + 1, So, i becomes 2. Now, test whether i <= 4 yes it is and enter the loop. So, 1 plus 0.5 then go back to the update expression i becomes 3 now and test whether 3 is less than or equal to 4 it is,. So, enter the loop. So, you add 1.5 plus , 1.833 and. So, on, update again you have 4, 4 is less than or equal to 4 that is true. So, you enter the loop one more time and add 1 over 4.25 to the current number. So, you get 2.0833 and. So, on update again i becomes 5, at this point 5 is not less than or equal to 4,. So, you exit out of the for loop. Now, you say that print that the sum of reciprocals from 1 to 4 is reciprocal sum, which is 2.0833. So, even though the for loop looks complicated, once you start using it, it is very nice to right, you have a initialization expression, you have a test expression and then you have the update expression, that you should do after every execution of the loop, after every iteration you should have the update expression. As soon as the update is over, you test whether I can execute the loop one more time, if I can enter the loop update and test again and. So, on, until the loop condition is false. Let us take another example, you have two lines, the first line contains a single number m, which specifies how many numbers are there in the second line. The second line contains m integers and we have to just output the sum of the m numbers. Now, we know how to do this, we have already done this using a while loop, let us try to do it using a for loop. So, the sample input is let say the first line is 5 and then I have 5 integers on the second line. The strategy is very simple, you read the number on the first line into m and then have a variable called sum, which will start with the first number and keep on adding the subsequent numbers, until you have read m numbers initialize sum to 0. So, run a for loop from the first number to the mth number and keep adding the numbers to sum. So, this loop will run for m times. So, let us code this up, you have m, i, sum and numbers which are all integers. First you scan the number m, initialize sum to 0 this is important. Because, if sum is not properly initialized it is sum garbage value and you keep adding numbers to it, you will get garbage value as the output. So, initialize the number sum properly to 0 and then here is the for loop, what the for loop does is, you start with i = 0 and go on until i less than m. Now, you could also do the following could start with i equal to 1 and go on until exactly m. So, if you start with i equal to 1 you will say i less than or equal to m, you can adapt either convention, in C it is more popular to start from 0 and go on until m minus 1. So, you break the loop when i is equal to m. So, here is the test condition for the loop and then you have the loop body, which is you read the number and add the number to sum and after you have done that, you have the update expression which is i = i + 1. So, here is the how the for loop looks you start from 0 and go on until i becomes m, you add the number and just increment i, which is i is the number of integers we have seen so far. Let us do trace of this execution, you start you have this integer variables and you first read m which is 5, the number on the first line and then we do things in order, you have initialized sum to 0, you start with i = 0. Once you do the initialization expression i become 0, i is less than m 0 less than 5 that is fine. So, you execute the loop, scan that next number, which is 2 add it to the sum. So, sum becomes 2 now update, update is increment i,. So, i becomes 1 and test whether 1 is less than 5 it is. So, you read the next number add it to the sum,. So, this sum becomes 1 update again and keep repeating this, until you have read all 5 numbers. So, when you read the 5th number i will be 4, after that you add the 5th number to the summation. Once you done i will be incremented to 5, 5 is not less than 5, 5 is equal to 5. So, you will exit out of the loop, at this point you will have the correct sum,. So, the correct sum will be 25 and you exit on. So, the printf will come out on one line, it will say that the sum of given 5 numbers is 25. So, what I will recommend is, write the same program using a while loop and a for loop and see how you can easily go from while to for and for to while. The advantage of the for loop and the reason why for loop become,. So, popular among programmers is that, in comparison to the while loop, it is first of all it is easier to read. Because, you have all the initialization expression, the update expression and the test expression all on one line. So, you see what the loop is about. The second is that, it involves fewer lines of code, then the corresponding while loop. So, it is a very popular loop among programmers. Now, here is a syntactic convenient that C providers and let me make this remark as the final thing in this session. So, notices that we had to initialize two variables here. So, the first is sum was initialized to 0 and the second was that i was initialize to 0. Now, would not be convenient, if I could do this together and that is what C provides us. So, I have something known as the comma operator. So, the normal comma that we have seen. So, in order to initialize multiple variables at the same time, I can say sum equal to 0 comma i = 0. So, C will initialize the variables in the order, that it is given, first it in will initialize sum to 0 and then it will initialize the i = 0. So, here is a very synthetically convenient notation that C provide for as the advantage again is that you end up with fewer lines of code.  In this section, we will use the, for loop to code of the matrix problem. So, remember that we have seen while loop and we have seen a do while loop. Inside while loops we have written nested loops or double loops. So, let us look at a for loop which problem, where the solution involves a nested loop. So, the for loops are a good choice when the number of iterations is known in advance. So, a good example of such a condition is when you program for matrices, because the dimensions of a matrices are known in advance. So, let us consider a sample problem. So, the first line of the input has a number n now the matrix size is n X n and there are n floating point numbers in the matrix given row by row, each line contains a distinct row. Now, the problem is to compute the trace of the matrix, the trace of the matrix is the sum of the diagonal elements. So, it is defined as . Notice that the matrix row indexing starts from 0, similarly the matrix column indexing also starts from 0. So, let us write a c program to solve this problem. Now, you should be familiar with how we compute the trace of a matrix. So, for example, if that matrix is given as let say 1 2 3 4 5 6 7 8 9. So, the way we do it by hand is, look at the first row only this element goes into the trace. So, it is trace is 1 +, no other element of the row goes into the trace, in the second row the second element goes into the trace. So, it is 5 + and then no other remaining element goes into that trace and you go to the third row. And the third element goes in to the trace so, 1 + 5 + 9, this is how we do it by hand. You go row by row and then pick out for each row pick some element which goes into that trace only the diagonal element will go into the trace. Let us try to code this. So, in this we have two variables i and j which I will use to iterate over the row indices and the column indices n is the designator for the size of the matrix. For example, the dimension of the matrix is n X n. Now, a is the variable in to which I will read the current entry and then trace is the sum of the diagonal elements seen so far. I assume that it is an integer matrix, it is not general enough you can use a float variable as well. I will first scanf the size of the matrix n, the matrix is of dimension n X n. Once I have done that, here is what I was talking about in the previous slide, once you scan the number n you know that the matrix is n X n. So, the number of times that you are going to iterate is known in advance. So, the number of times that you have to iterate is known before you enter the for loop. In such cases the for loop is more convenient to write than the while loop. So, the outer loop is for each row from i = 0, to i = n excluding i = n you increment the row. Similarly, for j = 0 to n you increment the column index so, j is supposed to be the column index. Now, you scan the number a now if i = j remember that we wanted to add the only the diagonal elements. So, the diagonal elements will be when the row index is the same as the column index. So, when the row index is the same as the column index, you should add the corresponding numbers to the trace. So, once j becomes n - 1, you will fail the test j < n. So, we will exit out of the inner for loop, and you will go to the outer for loop. In the outer for loop you have i iterating over the row indices. So, you will go to the next row and do the same processing for the next row, until you hit row index n at which point you will exit out of the outer for loop. So, let us look at a sample input let say that you have 1 2 3 1 3 3 and -1 0 -1. Here, is a particular convenience that c gives you which I have used in this code. So, notice that this if block I did not put the braces. So, it could have been necessary to put the braces according to the syntax that we have discussed so, far. But if there is only a single statement in the if block then, we do not need to put the braces and it is syntactically correct to do so. So, let us just run the program on a sample input. So, we have some sample array 2 0 -1 1 3 4 -1 0 1. So, initially there is this number 3. So, you know that it is a 3 X 3 matrix. So, once you do that you know that n is 3 so, representing that it is a 3 X 3 matrix. So, then you start with i = 0 and go on until i less than n incrementing i by 1 each time i is 0 i < n, because n is 3. So, you enter the outer loop the first statement of the outer loop is itself a for loop, you start with j = 0 j < 3. So, you enter the inner loop you scan a number a, which is a floating point number and if i = j. So, remember that we are looking for diagonal elements. So, we are currently at this point and i = 0 and j = 0. So, we are entering we are scanning the zeroth element of the zeroth column of the zeroth row. So, that element has to go into the trace. So, i = j is true and then you say that trace = trace + a trace was initialize to 0 so, trace becomes now 2. Once you do that, you iterate the inner for loop. So, you go to the updates statement in a inner for loop j becomes j + 1. So, you go to the next column and the j < 3. So, you scan the next number 0 if i = j that is false now, because i is 0 and j =1. So, you do not execute the if statement and go to the update statement. So, j becomes 2, 2 < 3. So, you scan 1 more number which is -1, i is not j. So, you update again j becomes 3, now 3 is not less than 3, so, you exit out of the inner loop. When you exit out of the inner loop there are no more statements to execute. So, you go directly to the update statement in the outer loop which becomes i = i + 1. So, you are reading the first row, row number 1 you are finished reading row number 0. Again you scan the numbers when j = 1 that is the second number in the second row, you will see that i = j, because i is 1 and j =1. So, you will add it to the trace. So, that is 2 + 3 which is 5. So, trace gets updated and after you do that you scan the remaining entry in the same row, but it does not go to the trace, and then you have done with the row.  After that again you go to the outer loop you update the row index of the row index is less is 2 which is less than 3. So, you exit so, you enter the if condition and you execute the inner loop when i = 2 and j = 2 you will find an element which is -1 which will go in to the trace. So, the elements that will be added to that trace are when 2 3 and -1. Once you are done you get out of the inner loop and then you go into the outer loop and update it, but then i becomes 3 it is no longer true that 3 is less than 3. So, you have done reading all the rows. So, you exit the program when you exit the program you have the correct trace which is 4.  In this session we will see one more feature that is present in C associated with loops.  So, we will in motivate these statements using the concept of an infinite loop. Here is a drawing that supposed to be a representation of an infinite loop.   And a trivia, for example, the apple head quarters; the address is one infinite loop.   So, let us see what is an infinite loop? So, the basic or the simplest kind of infinite loop is when you have a while statement. And the test condition, you can see that it will never be false. So, remember that 1 is true in c. So, this statement means that you will enter the while loop, you will test the condition. The test is true, so, you will execute the statement. You will go back and test the condition again, it is again true, does not changed; it is 1. Therefore, you will enter the statement again. So, you will have an infinity loop. If the test is executed then the control enters the body of the loop, and this happens without any change. So, let us look at this simple while loop which is while 1. The statement is print f Hi! I am an infinite loop. So, if you will run this code, compile and run this code after you write the mean function and all that, then the program will keep on printing the same message over and over again. And you cannot exit out of the program. If you are running a Linux system you can press control c, and the program will exit immediately. But here is an infinite loop; it executes an infinite number of times. So, is there a statement which helps us to exit from a loop? Now, this is useful not just to handle infinite loops, even when you write normal loops it is important to have these constructs; they make your programming easier. So, c allows a programmer to explicitly break out of a loop using a particular statement known as break. When the break statement is encountered, the execution breaks out of the inner most loop. So, what is a loop? So far we have seen while loop, do-while loop, and for loop; later we will see a construct called switch.  So, whatever is the inner most loop, notice that we have talked about double loops, we have talked about the while loop within a while loop, we have talked about a for loop within a for loop, whatever is the inner most for loop within which a particular break occurs, it will exit out of that.  So, let us write a very simple program which reads all numbers still -1 is seen and adds them up; -1 is excluded. So, you will, you can write a while loop; you have written this before where the while loops test condition was somewhat most sophisticated. Earlier we wrote something like while, if you recall, if you, we had written a loop saying, while (!(a == -1)). So, this was the earlier loop that we had written.  And in this case, let us write a similar program, but with a simpler test expression which is just while 1. So, you always enter the loop, no matter what number you read. So, initialize the variable sum to 0, declare the integer variable a, and then you enter the while loop because the test is true; you scan a number; and here is a use of the break statement.  If the scanned number is -1 you break out of the loop; if it is not -1, you go to the next statement which is sum = sum + a. So, you add the number. Again you go back to the loop; the test condition is always true, so, you enter and read the next number. So, the net effect of the loop is that whenever you see a -1, it immediately exits out of a loop; otherwise, it adds that number to the loop. So, let us look at using a sample input. Initially, a, is undefined; it is just declared. So, it has some garbage value. And sum is initialized to 0. Let us say that the input is 5, 3, 2, -1. While 1, so, 1 is true; therefore, you enter the while loop; you scan f, the first number. So, a, becomes 5; a, is not -1. Therefore, you go to sum = sum + a. So, sum becomes 5.  And then you go back to the while loop; the test condition is still true, while 1. So, you read the next number 3; 3 is not -1. So, you add it to the sum; sum becomes 8. And you go back; the same thing occurs. So, you have the third number read which is 2; add it to the sum, and sum becomes 10. Then you read the next number; and now, a, is -1. So, what happens? The, if condition, the expression within the if statement is true; and you execute the statement inside the if condition, the statement is break.  So, recall that the rule of break says that exit out of the inner most loop. So, in particular, what is the inner most loop? You look, you starting from here, and imagine that you are going outwards towards the top of the program. The first loop that you will encounter on its way that is the loop that you will exit out of… In particular, break does not mean that exit out of the if condition; break means that exit out of the first loop that you see when you start from the statement and work outwards. So, that is this while loop. Break means you will exit out of that while loop and print this statement. So, you will print that the output is 10. So, let we have been dealing with integers for a long time. Let us write a small program using characters. So, here is a problem, and let us say that we are writing a very simple editor. Now, the editor has the following property. There are a particular number of maximum characters that you can read; maybe it is 1000. So, you can type in a bunch of characters until one of the two conditions occur; either you enter a blank line by itself which is indicating that I am done entering the text or you enter more than the maximum number of characters available.  So, recall, there are two conditions for exiting out of our so called editor; you can type a lot of characters, if your limit was 1000 and you exit 1000 then you cannot type in any more characters, and you exit. Otherwise, if you are within 1000 characters but you entered a blank line that is indicating that you are done, you have nothing more to enter, then also you should exit. So, there are two conditions. Let us try to write this code.  So, you have maximum characters. And let us say, I scan that. Then an, i, which counts how many characters I have read so far; so, i should initialize to 0. And then there is a current character, and then there is a previous character. So, I will initialize current to the new line character. Now, there is a particular reason for that which will become clear later. So, you should initialize current to a particular character.  And then what I do is, use the getchar function. So, getchar function reads a particular character from the input and stores it in some variable if you need to. Instead you can also say something like scanf %c, and some, into some variable. So, you can do either of these two things. And they are almost equal. So, you read one more character. Now, what should you do? You initialize by starting from 0. So, you have read no characters until now. And until you read maximum member of characters, so you execute this loop. Remember that I said that for loop is good when you know the number of iterations in advance. So, we know that atmost we will execute maximum number of character times because that is the maximum number of characters we are allowed to field. So, for loop is slightly better than a while loop. You can also do it using a while loop if you want. So, you say for i = 0, i less than maximum characters, i = i + 1. Now, we will do this programming style that we should be familiar with right now. So, previous becomes current and current becomes the next character; so, previous equal to current. So, this will store the current character into the variable previous. Then you read the next character using getchar. And as I said before, you can also write equivalently scanf (“%c”, & current). So, both these are almost equivalent that is a slight difference, but we will it is not important as of now. Now, if current is new line and the previous was new line, so, when will that happen? Suppose I write this is a sentence, I will explicitly represent the new line. So, when I press enter I will have a new line character here. And when will a blank line occur? When the next character is also new line. So, by a blank line what I mean is that the current sentence is over, so I press a new line; and the next character on the next line is also a new line; that is what is actually meant by a blank line.  So, when that happens then we know that an empty line has been encountered; and here is the important thing break because one of the conditions to exit out of that loop was that either at maximum number of characters is encountered or a blank line is encountered. So, you may not have encountered maximum number of characters, but you have encountered a blank line. So, you should exit out of the proof, exit out of the loop. Again the rule is that break out of the inner most for loop, inner most loop, which in this case is just for loop. So, you get out of that loop and printf a new line.  Now, as with many constructs in c, you can avoid break all together. You can write code if you have used break, you can right equivalent logic without using break. So, here is a standard way to do it. So, here is the code that we just dealt with. It had 2 exit conditions - one is that the number of characters that you read is greater than the maximum allowed; another exit condition was that you had entered a blank line. So, here we used the break statement.  And now I want to write an equivalent loop without using the break statement. And here is a very standard programmatic style. These are known as flags. So, flag is just a variable which indicates that a particular condition has occurred. Initialize flag to just 0. In our code, what flag is supposed to do is that it will indicate whether a blank line has occurred or not. So, let us first look at the body of the loop; without looking at the loop head first. Let us just look at the body of the loop. So, it is similar to what went before. Instead of the break statement, what I will do is, if I realize that an empty line has happened then I will set flag to 1; notice that flag was initially 0.  So, flag = 1 will indicate that an empty line has been seen. Now, I will modify the loop as follows. Remember that the test condition here is just that maximum number of characters has occurred. Instead, I will check for two conditions in the for loop. I will check that maximum number of characters have not occurred, and I will also check that flag is not 1 because flag is 1 means that a new line, a blank line has been encountered. So, I will check for both these conditions in the for loop itself. If either of them is true that is; sorry, if either of them is false that is if i is greater than or equal to maximum characters, or flag = 1, then the test condition will become false and you will exit out of the loop. So, here is a standard way to avoid a break. And notice that this condition is negated in the for loop because the condition in the for loop is the condition for entering the loop. So, to exit out of the loop you need flag = 1. So, in summary, what I want to say is that if you want to write a code using break, you can also write it without using break. One of the standard way to do it is by using a flag variable for whatever condition that we want to check. You can pick either of this style whichever suits you more. So, how do we decide whether to use the break statement or not? Sometimes the use of the break statement can simplify the exit condition. And on the other hand, it could also make the code a bit harder to read. What do I mean by harder to read? When I see the for loop in the code on the right hand side, it is clear that there are two ways to exit out of the for loop - one is i greater than or equal to maximum characters, the other is flag = 1. Just by looking at the for loop, I can say that, ok, here are the two conditions for which the loop will terminate - i greater than are equal to maxchar, or flag = 1. On the other hand, if you look at this left hand side code, I actually have to look at the body of the code to realize what are the ways of exiting out of loop. So, you have to understand the body of the loop in order to see what are the conditions for the loop to exit. It is not just i greater than or equal to maxchar. So, in that sense, the code with break is harder to understand than the code without break. It still recommended to use break when you have two or more exit conditions out of a for loop. So, typically programmers do use break and it is just a matter of style whether you we will use break or not; I myself prefer using a break. One final thing about the break statement; when you use break statement initially, it is important to notice that break causes an exit immediately out of the loop. So, remember when you have a for loop, the normal execution order is you initialize, then you test. So, this is step 1, this is step 2, then you execute the body of the loop that step 3, and then you update this is step 4, and then go back to the test condition. So, this is the normal execution order of the loop. When you encounter a break, you exit immediately out of the loop. In particular, when you break you do not go back to the update statement. So, let us examine what this code will do? You have, i = 0, i<10; increment i. So, you start with i = 0; i%2 will be 0%2 which is 0. So, it will say, ok fine, you need not get into the if condition.  Then i = i + 1; so, i equal to 1; 1 < 10; you enter the for loop; 1%2 is 1; so, you will break. When you break you immediately get out of a loop. So, when you print this then i will be 1. So, in particular, i is not 2, which is what will happen if you go back and update i = i + 1, before exiting out of the loop. So, the important thing to notice is that it is not 2, since i = i + 1 is not done when you break. When you break you get out the loop immediately without doing the update state.  We have seen the break statement, which is a statement used when you are in the middle of a loop and you encounter a condition and you want to exit the inner most loop. There will also be occasions in a program, when you are in the middle of a loop and you encounter some condition and then, you realize that you do not need to execute this iteration, you just can go to the next iteration. So, skip the current iteration. The break statement was, you encounter a condition and you say, I am done, I will exit out of the inner most loop. Here, it is not exiting out of the inner most loop, it just skipping the current iteration. For this, we will see the continuous statement and let us motivate this by an example.  So, continue the statement causes the next iteration of the closest enclosing for while or do while loop. Let us motivate it with a very simple example. Let us say that we are reading numbers coming in a stream and what we have to do is to skip the negative numbers. So, we have to read all the positive numbers and reading should be finally over, when you encounter some input which is not a number. How do we do this? Let us imagine that you have the main and things like that written and the central part of the code can be analyzed as follows. So, you have integer variable a and let us examine the code in closer details. So, what we need to do is, we may have an input sequence that looks like this, 1, -1, 2 and then .. So, let us say that the input sequence is something like this. What we will do is, we will do this scanf operation to get the numbers. So, scanf operation will read the first entry as 1, it will read the second entry as 1. The third entry as -1 and the third entry is 2 and so, on. So, that is what is scanf( “%d”, &a ), we are already familiar with this. But, what does = 1 mean? So, this is something that we have not uncounted. So, far the scanf statement has a return value, it gives you the number of inputs that was successfully read. For example, we are trying to read an integer in the %d specifier. So, when we try to read the first entry, it should succeed. So, this will succeed, when you try to read the second entry, it should succeed, when you try to read the third entry, it should succeed. In all these, the scanf %d will return a 1. Because, one entry has been read correctly. Here, it will fail, because it tries to read a natural number here, but what it see is a ., a full stop character and that is not a number. So, scanf %d will simply fail. So, this is what I said, it returns the number of conversions that have been successfully made. So, when you try to read an input like 1, -1, 2, . it was succeed in a first three scanf and the last scanf, it will fail. So, that is what the scanf is supposed to do. So, as long as you have read a number. So, while you have read a number, you examine whether it is a positive number. If it is a negative number that is, if a < 0, then you say continue which is saying that, I do not need to execute the remaining part of the loop. So, this part of the loop will be skipped, if a < 0. Continue means, go from here and start executing the next iteration of the loop. Let us go head and complete the code. So, let us modify the problem as a little bit, read the integers until a non digit is found. And let us do something with the positive integers. Let us say that we have to find the largest of the positive integers. So, what should we do? Again, let us try to do it by hand to get a feel for, what I will be doing? So, I have 1 -1 2 .. Let us say that I initialize the maximum to some reasonable value. Since, we are looking at the largest of the positive integers I can initialize maximum to 0. Then, I look at the first one, the maximum read. So, for. So, it is a positive entry,. So, I will update max = 1. Then, I read the next number and it is a negative numbers,. So, skip it. Then, I read the third number which is a positive number. So, I will update the maximum to 2. So, this is the part that we want to focus, if it is a negative number, skip. So, here is the code for doing that, while the currently read input is a number, that is why the %d succeeded and one entry was correctly read. So, if the number was read, check whether the number is negative. If the number is negative, continue. Continue means go to the next iteration of the loop. Do not do, what is remaining in the loop. So, if the currently read number is non negative, what you will check whether their current maximum is less than the new number. If it is less than the new number, you reset the maximum to the new number. So, this is the code that we have written similar to other codes that we have seen. So, you update the maximum number and go and read the next number. If the currently read number is negative, then we will say continue. So, we will not update the maximum. This is what the continue is supposed to be. Now, as in break you can also write equivalent code without using the continuous statement. So, let us try to do that and for doing that all we have do is, make sure that the maximum is updated only if it is a non-negative number. So, this says if it is a negative number, do not do the next statement. This says, if it is a non-negative number, then update maximum if necessary. So, it can be written with one more level of nested if. So, this is that if a is non-negative, then execute the next statement. Here. it says that if a is negative, then continue which means skip to the next statement. So, notice that these two conditions are the negations of each other. The long and short of it is that continue is not really necessary. But, if you have it, then it is useful and it makes the code clearer in certain occasions. What happens to continue in a for loop? Noticed that, for loop has the following form, you have for, then there is an initialization expression. Then, there was a test and finally, there was update and then, you have the body of the loop. What happens if you encounter a continue in the middle of the loop? In the case of a while loop, it is very clear, you go to the test expression, you go to the next iteration. The only contention is, in the case of a for loop, do you go to the update statement? And the answer is yes, then you skip the remaining part of the loop. So, this is the remaining part of the loop that you would skipped. When you skip that you go directly to the update statement. Notice that, when you do the break. So, if the statement has a break, you break immediately out of the loop without doing the update. In the case of a continue, you have to do the update. And as with the break statement, the continue statement is also redundant, you can program without using the continue statement as well. But, it is useful if whereas, already a few levels of nesting of the if statements inside it. We saw in the previous slide that, you could avoid continue statement by using an extra level of nested if statement. Now, if you do not want to complicate the code in that way, you can use a continues statements. Otherwise, in other cases you may want to exit out of the loop, in that case you can use the break statement. So, they are extra feature that the C language provides, they are not really necessary, but they are used with. Let us do a sample program using continue statements, I will introduce the problem initially, the problem is that of finding Pythagorean triples. By the way Pythagorean triples are numbers like are triplets of numbers like 3, 4 and 5. Because, you know that . So, the Pythagorean triples because there can be a right triangle, where let say the base 3, the altitudes is 4 and the hypotenuse is 5. So, 3, 4 and 5 could be the sides of right triangle, because they satisfy the Pythagorean identity. So, here is a problem we a given a stream of numbers and let us say there are n numbers. So, the initial number says how many other numbers there are. So, 8 says that there are 8 numbers to process, after you read n,n >=2, you have to read n integers and then you have to identify Pythagorean triplets occurring consecutively. By consecutively we will say that consecutive positive integers. Because, in the middle there could be negative numbers sees you have to just ignore them. For example, you have that 3, 4 and 5 are consecutive, positive entries in this data. Because, -3, -4 and -5 are negative numbers. So, consecutive in this context need not mean that they occur together, it just means that, if we ignore the negative numbers and between then they are together. So, we have to identify all such Pythagorean triples. So, in this case the Pythagorean triple in the input sequence is 3, 4 and 5. So, let us try to code it. I hope you see how it can be done? So, let us try to do it my hand. So, let us say that I have and then some negative numbers in between and so on. So, some positive numbers, some negative numbers in between till I find the... So, I have let us if four, six numbers. So, the input is of the following for what I need to do is, at any point I may have to remember some triple. So for example, the first triple that I will find is the following. So, this is the first number, this is the second number and this is the third number and what I have to do is to check whether, . So, this is what I have to check? Now, suppose that 1, 3 and 4 are not a Pythagorean triple, they are not. Because,  is not . Then, what do you have to do? You have to advance all these first, second and third variables. So, let us try to advance the third variable, the next interesting number is 5, because that is the next positive number. So, the next iteration should check for the following, this should be the third number, 4 should be the second number and 3 should be the first number. If you do that, then you know that  and you will indentify a Pythagorean triple. So, what we do is, that we have to shift all these variables, first, second and third by one positive entry. So, this is what we have to do, we have to remember three numbers, the current number that we have seen, the previous positive number that we have seen and the previous to previous positive number that we have seen. So, this is one situation where you need to remember three variables. And once you check whether the current triplets satisfy it, if you satisfy it fine. If you do not satisfy it, you have to advance the variables by one. So, first will take over second, second will take over third and third will go to the next positive number. So, this is the method of programming this, let us try to code this out. So, we will write the code as follows, we need three variables, the current number, the previous number and the previous to previous number. Currently will leave all of them undefined, n is the number of integers to read, i is we will eventually try to do. So, for the for loop we need a counter. So, I will basically count from 1 to n to ensure that n numbers have been read. I will also have an extra variable call count, i is suppose to count the numbers seen so for and count will count the positive numbers seen, so for. So, I need two half them in this code I mean in that. Now, after you do that you scan the n, which tells you how many numbers are there in the input? Now, a for loop has to go here which will do most of the work in the code. So, let us see what that loop looks like? So, recall what we did by hand, you will look at the current number which is the next number to read, if the next number is 0 or less than 0 you say continue. So, this is the application of the continue statement here. So, if says if the current number is not positive, you just go onto the next iteration of the loop. Now, here is some logic which is not easy to read, but we can motivate it the following, if the current number that I have seen is the first positive number. When obviously, then this was the first number that I have read. Therefore, there was no previous number and there was no previous to previous number. So, I will because this the first positive number that I am reading, then I will just set there the previous to previous number is the current number, also I have seen one positive number. So, I will say increment count, count = 1. So, if the current number that I have seen is positive and it is not the first positive number. That means, if count = 1 I already seen one positive number, then what to you do is, you know that there is a previous to previous number, you set the previous number to the current number and you continue the loop setting that count = 2, which says that I have seen two positive numbers. So, I have a previous to previous number and I have a previous number, now I will read the next number. This is because in order to identify a triple, you need at least three numbers. So, previous to previous and previous should already been to some positive values in the input, this is why we initially said that, we need at least two inputs. So, we will go back to the loop if count = 1, otherwise let us say that count is at least 2, so it is 2 or more. So, in this case we will just say that as for as count is consent I do not need to keep track of how many positive numbers are needed? It was used only to see that I have at least two positive numbers to begin with. So, that I can add the next number as the possible third number in the triple. So, I will not update count from now one, you can also do that, but count after words serves no purpose. So, I will say that count is 2 and I will just adopt the convention that it will remain to. So, I will seen at least two positive numbers, now I have also a third number in the current. So, you have previous to previous, you have previous and you have current. So, these are the three numbers that you have. So, what you have to check is, whether. So, that is what we will check, we will check whether previous to previous square plus previous square is equal to current square, if that is true then you have found the Pythagorean triple. So, you will just say that I will printf that I have found the Pythagorean triple, which is found by previous to previous, previous and current. Now, what I will do if the Pythagorean triple is found is that I will advance previous to previous by one. So, previous to previous will become previous, previous will become current. So, recall that figure that I first true and then we will go back to the loop. So, this is the code for kind identifying the Pythagorean triples and the encodes exactly the logic that we did by hand. In this session, we will learn about one more fundamental data type in C. So, far we have seen ints and floats. Ints are supposed to represent integers and floats are supposed to represent real numbers. We will see the third most important data type which is character. So, it is called char in c or char. C allows a character data type to be 1 byte that is 8 bits wide, and 1 byte can hold exactly one character. For example, a character may be a digit like 0 so, on up to 9. It can be lower case letter like a up to z, it can be upper case letter like capital A through capital Z and so, on. Similarly, there are other characters question marks and sharp and so, on. So, how do you declare a character variable, how do you assign it and how do you print or scan it. So, these are the basic operations that you can do with any data type. So, you declare a character variable using the data type char ch will declare variable of name ch and of data type char. In order to assign it to any particular constant, any particular character, what you have to do is, you write ch = ‘A’. So, this is how you would assign any character in constants. All the character in constants are supposed to be enclosed in this single code. For example, ‘0’ stands for the character 0 and not the number 0 and similarly, a within single code stands for character a. Now, how do you prints print a characters you can use the format specifier %c. So, recall that %d prints an integer and %f prints of float, we have the third fundamental data type which is character which can be printed using a %c. So, if you say print f %c ch, it will print a. There is also an abbreviator notation where as soon as you declare the variable, you can initialize it using character ch equal to a. This is similar to saying int I equal to zero. It is the same concept. Now, what can we do with a character data type? For example, we can assign character constants to those characters variables. Now, what does a character variable mean? Here is the first surprise. The value of a character constant is an integer that the machines represent, machine stores which is usually the ASCII set. What does this mean? The machine deals with fundamentally bits. So, you have a data field which is 8 bits wide and this is sequence of bits say 1 0 1 1 0 1 1 1. Now, here is the bit pattern and if you see that this bit pattern is a char, then the machine takes this integer, takes this bit pattern as an integer and looks up a table known as the ASCII set table and sees which character it is. So, the value of the character constant is actually an integer. What does that integer represents? The integer represents a particular entry in an ASCII character table and what entry is in that particular location, that is the character constant. So, think of it like the following. The character is just an uninterpreted sequence of bites. If you tell the machine, please read this as an integer, it will read this as an integer. If you read this, if you tell the machine please read this as a character, it will take that integer, go look up the ASCII table and see that this integer stands for the character c and prints that. So, by itself the bit pattern can be interpreted in multiple ways. So, here is a surprising thing which is different from natural language. There are certain natural languages where this does not typically happen with Indian languages, but there are certain languages where you have a character and how you read it depends on where you saw it. So, if it was in the middle of a text, then this is an alphabet. If you saw this in the middle of a numbers sequence, then it is a number. What happens in the machine is somewhat similar. You have a bit sequence and this thing is interpreted as a character by looking up the ASCII set. ASCII stands for American Standard Code for Information Interchange, and it is one of the popular encodings for characters used in computers. So, the code chart looks something like this. You have 256 characters and characters can be looked up in a table. The table entries are in hexadecimal so, base 16. We will come to that little in the course why basic 16 is convenient,, but there are 8 rows and 16 columns in the table. So, in base 16 notation, a stands for 10, b stands for 11, c for 12 so, on up to f for 15. So, this is what is meant by base 16 notation. So, let us look at what does the number 7 a represent. 7 a is row 7 column number 10. So, that is the number that I am interested in. What does 7 a represents? It means 7 times 16 plus 10. So, in base 10 notations, the number 76 let us say so, if I have this number 7 in base 10 notation, this; obviously, stands for the numerical values 7 into 10 plus 6. Similarly, in base 16 notation, 7 a stand for 7 into 16 plus 10. Remember that a is 10. So, you have 112 and similarly, hexadecimal 2 3. So, row 2 column 3 for example, hexadecimal 2 3 means look up 2 time 16 plus 3, the 35th entry in the table. Now, here is the structure of the ASCII code set that you use in c, the first 32 characters basically from 0 0 hexadecimal to 1 f hexadecimal. So, these 32 characters which are shaded, are what are known as special characters, and they are not printable. They are required by the computer for certain special purposes. Code 2 0 that is decimal 32, 2 0 is 2 times 16 plus 0. So, this particular entry corresponds to the space characters. So, this is just a blank space. Code 21 corresponds to the exclamation character and so, on. So, the printable characters in the ASCII code are hexadecimal 20, that is decimal 32 until 126. So, what is enclosed in the green parenthesis, these are all printable characters. Now, out of this, the capital letters start from x 41 which is 65 in decimal and go on up till decimal 90. Small letters start from 97 and go on till 122 and so, on digits 0 to 9 occur before any character. So, why we need this information? This is how the characters are stored in the computer and do we really need to know it?  The point is not that you have to memorize this table. You do not need to memorize the table, but you need to remember certain abstract properties of the table. We will make that precise in a moment. We do not have to say that the ASCII code for a is 65 or 42 that is a waste of our memory. So, let us just see what we can do with this table without really remembering what that table looks like. So, there are some ideas behind the design of the table, how the table is structured which c programmers can use. There is no need to remember that a particular character has a particular ASCII value. So, let us just recall. A character constant is an integer, namely the ASCII code for that character now which means that I will emphasize this with a very strange code. I can declare character ch and say char ch =‘A’ that; obviously, initializes the character to a. It assigns the value a to the variable ch, but I could also do the following characters ch = 65. Why 65? The ASCII value for a was 65. So, instead of writing it as a within single code, I can write ch = 65, and it will be the correct ASCII character anyway. Now, this means that the same character can also be interpreted as an integer if you really want to think of it that way. So, for example, I can say %f %c ch if I do it in print f, it will print it as. So, the first print f will print a, but I could also take a character variable and ask c to print it as an integer using %d, it will print 65. So, remember that the external form that we see in some sense is the letter a. The internal representation is the number 65 because 65 is the entry in the ASCII table corresponding to the character a. Now, one more thing is that you can print arbitrary numbers, even non-printable characters you can sort of print them using c and one way to do that is I can print any 8 bit character with a hexadecimal representation like \s, \x followed by the hexadecimal to digit. For example, \x followed by 7 is the bell character. So, let me go back a couple of times, couple of slides. So, if you look at the 7th entry in the ASCII table, it is represented as bell. It is a small bell in your system. So, if you ask the system to print the 7th character in the ASCII table, what will happen is that your computer will make a small beep sound. So, there are certain non-printable characters which can also be printed directly using… ok. Similarly, let say \xb is the 11th number in the ASCII table, it is a vertical space. So, if you print that character, it prints a vertical space. Similarly, if I ask it to print hexadecimal 41 using \x41 so, x 41 is 4*16 + 1 which is 64 + 1=65 and we just saw that ASCII value 65 was the character a. So, if I ask it to print ch which is hexadecimal 41 as a character, then it will print the value a. So, when you run this program, what it will do is, first because you ask it to print a bell character, it will beep once, it will ring the bell and then, it will print the second character which is a vertical space. So, it will print a vertical space and then, the third character was a printable character a, it will print a. So, you can ask the system to print arbitrary entries in the ASCII table. If it is a printable character, it will print that corresponding character. If it is non-printable character, it might take a suitable action. So, just for information sake, instead of printing it as \x followed by the x code, c provides certain escape characters, some special sequences as well in order to print these non-printable characters. First of all until now we have seen one such number which is \n. So, \n is the new line character. It is a non-printable character, but it corresponds to some ASCII corrected. Similarly, for the other non-printable characters, c has some escape characters. For example, back slash a is the bell character and so, on. In the previous session, we were talking about ASCII character set. And I said that,  we do not need to remember the ASCII table. But, we need to remember some general properties of the ASCII table. So, what are those general properties? First, we know that the initial 32 characters of the ASCII table are non printable characters. Then, the remaining or rather from ASCII value 32 to ASCII value 126 are printable values. Among them, you know that the integers, the digits are occurring together. Similarly, the capital letters occur consecutively, one after the other. And the small letters occur consecutively, one after the other. So, this is an abstract property of the ASCII code chart that, helps us in writing some useful code. We will see in a minute, what kind of use we can obtain using these general properties. Rather, than knowing the specific things like, the character value of A is hex value 41 or decimal value 65. This kind of information, we need not remember this. For example, let us write a small program that prints… In our previous session, we had said that, we do not need to remember the exact ASCII code of certain characters. We just need to remember some abstract properties of the ASCII table. For example, abstract properties like all the digits occur together from 0 to 9. All the capital letters from A to Z occur together in the table, in the alphabetical order. Similarly, all the small letters occur together in consecutive locations in the ASCII table. Also, another property that you can observe is that, the small letters occur after all the capital letters. Let us see, how we can write some interesting code using these properties. And not by remembering the exact ASCII code of certain letters. So, let us write a simple program, to print the alphabet. The ASCII codes of the upper case letters are consecutive and the ASCII codes of the lower case letters are consecutive. This is the property that, we will exploit in order to print the alphabet. So, for example, let us say that, we are going to print the letters of the alphabet in capital letters. So, for that we can use the following program using a for loop. So, what you have to do is, to initialize a particular character variable to capital letter A so, the ASCII character A. So, note that A within single codes stands for the character constant A. If you look at the integer value, then it is the ASCII code for A. We are not particularly interested to know, what exactly the number is. Now, we can write the for loop in an interesting way. We can say that, start from capital A and then, print the characters until you hit capital Z. And the update statement is, after printing go to the next ASCII letter. So, what this is doing is, starting from A and then, it will go to A + 1, which is the ASCII code for B. Then, it will go to B + 1, which is the ASCII code for C, so on up till Z. So, once you reach Z, it will print that character. It will update once more, where it is the ASCII character one more than, the ASCII character next to Z in the ASCII table. We do not really need to know, what it is. But, certainly it will be greater than the ASCII value of Z and at that point, we will exit the code. So, the output of it will be consecutively A to Z. Let us look at, what is happening here in greater detail. All the characters are stored as 8 bit integers. Now, they can be assigned as integers, incremented, decremented, etcetera because, essentially they behave like integers. So, suppose A has ASCII code 65, but we are not concerned about that. Now, so ch equal to character constant A, sets c h equal to 65. Now, ch + 1 is the number 66, which corresponds to the ASCII code of B. So, addition, subtraction all these can be performed on character values because, internally they are represented as 8 bit integers. Similarly, relational operations like less than, greater than, <=, >=, all of these also make sense. So, for example, if we use the relational expression capital letter A, ASCII constant A less than character constant B. Then, notice that A is the ASCII value 65 and B is the ASCII value 66.So, A less than B is correct.  Now, for realizing that A less than B is correct, we do not need to know that, A is 65 and B is 66. All we know is that, the abstractly in the ASCII table, the character code for A is less than the character the code for 6 because, B occurs after A. So, if it is 65 and 66 or it is 0 and 1, the answer is still the same. Now, let us write a few more interesting programs, where the spirit is that, we do not need to understand what the exact ASCII code of a letter is. But, just we want to remember the layout of the ASCII table. For example, suppose I want to write a conditional expression an if condition, which says that, if the given character is capital letter, then print that, it is in upper case. So, all I need to do is, if the character value is >= the character constant A and <= the character constant Z. Then, you print that, the given letter is in upper case. Again, please remember that we did not need to know that, this was 65 and this was, whatever it is 90. It could as well have been 0 and 25. It would still have worked because, all we are need to remember in the ASCII table is that, A through Z occurs in consecutive locations in the standard alphabetical order. From that we can understand that, if I write this if expression, it will print up the message upper case, only if the given character ch is an upper case letter. Similarly, let us say that, if you want to check whether a character is in lower case. You can analogously write, character is >= ‘A’ , ‘a’. And it is <= little z, in single quotes. If that is true, then you print that, it is in a lower case. Now, if you want to check whether a given character is a digit, similarly you can say that, it is >= the character 0. And this is <= the character 9. Now, here is a suttle point which I hope, you notice. The character 0 is the ASCII constant, ASCII character constant 0. So, it corresponds to some particular ASCII value. It is different from the number 0. So, this is something that... So, we are looking for the ASCII value corresponding to 0 it is >= that and <= the character value corresponding to that character 9. So, if that is true, then the given character is a digit. Now, here is a snippet that, I would advise you to take a look at it. And tell me, what it actually does. So, take a moment yourself and try to figure it out. So, what it does is, the given character ch, if it is a lower case letter. Remember, this is the example that we just saw. This condition checks, whether the given character is a lower case letter, a small letter between a and z, little a and little z. If it is true, then what you do is, add capital A - a, to the character. So, what does it accomplish? So, let us say that, we actually had c h equal to little a. Now, for the purpose of illustration let us say that little a, was ASCII value 100. I do not know, whether that is true. But, it is not important. That is, what I want to illustrate. Now, what does capital A represent. It represents some ASCII value let us say 65. So, if the given character was little a, what I would do is, I would say character = ch - 100 +65 Similarly, if ch was character constant b, I would still add ch = ch - 100 +65 So, it is adding a constant difference to the given character regardless of what, whether it was a or b. The additive constant that we are adding is still the same. And if you think about, what is happening it is adding, exactly the difference between little a and capital A. Notice, that the difference between little b and capital B is the same as little a and capital A. Why? Because, all the capital letters occur consecutively and all the small letters occur consecutively. So, suppose a minus z, little a minus capital A is… Let us say 35, then little b minus capital B will also be 35, because you advance one in each case. So, if you think for a minute, you will see that what this code does is… Take the ASCII code corresponding to the small letter. And add a constant difference. What is that difference? That difference is, what will take you to the capital letter, corresponding capital letter.  So, in short what this does is, to convert the given character in lower case letter to an upper case letter. So, if it is a lower case letter, it will convert it to an upper case letter. Otherwise, it does nothing. Now, let us think about, what we mean by scanning a character verses scanning an integer. So, let us say that I have two variables, in number and character letter. So, let us say that I am scanning now n, which is a number and the input was 12. So, when I say scanf( "%d", &n), I am trying to read 12 into an integer variable. Now, on a typical machine an integer variable may occupy 32 bits. or 4 bytes. So, it has 32 bits in it. And if you know the binary notation, you will see that 1100 in binary is the number 12. So, this is 8 + 4, which is 12. So, when you see that, the input is 12. And then, I ask in the c program, I am doing scanf( “%d”, &n). What will happen is that, n is an integer with 32 bits wide. And it will have the following pattern encoded into it. This is what, it means by scanning an integer. And if you try to print it out, it will try to interpret n as a decimal number. And it will print and the digit 12, here the number 12. On the other hand, for the same input, here is the difference I want to emphasize. If the code was saying, %c and letter, so scan the input 12 using the scanf statement, scanf %c and letter. What will happen is that, the c program is looking at the first character, which is the digit 1 and scanning it in. Now, character 1 is ASCII 49 it is not important, you remember that. But, it has some ASCII value, and that ASCII value 49 is 31 in hexadecimal because, it is 3 * 16 + 1, which is 48 + 1= 49. So, that character 1 is 31 in hexadecimal. And hence, what will be stored? Remember, that a character ASCII character is 8 bits wide. So, it will store 31 in hexadecimal. So, it will be 3. This is the number 3 and this is the number 1. So, when you scan the input into a character variable called letter. What will happen is that, letter will have the number, hexadecimal 31 or ASCII value 49, which corresponds to the number, which corresponds to the character constant 1.  So, this is the difference between scanning a given input as a number and scanning a given input using a character. So, when you scan it using a number, this entire thing will be scanned. It will be converted into binary and you will store it in an integer variable. When you scan it as a letter, it will scan the first digit only because, that is the character and then store the ASCII value, inside the letter variable, inside the character variable. So, this corresponds to the letter variable 1 within a single quote, the character constantIn the session, we will discuss operators and expressions. So, we have already used C expressions in our programs before. And expressions in c are similar to expressions in mathematics and they follows tools, similar to what mathematical expressions also follow. They are a basic unit of evaluation and each expression has a value. Say, that an expression returns a value of a particular type. So, let us consider a few example expressions. For example, I have the following, a is 3, b is 4 and I have a variable c, which is just declared to be of type A. And then, say that c = (a * a) + (b * b). So, the right hand side of the assignment operator, this is a assignment operator. And the right hand side is an expression and that expression has sub expressions, a * a and b * b within parenthesis. So, an expression can be made up of variables, it can be made up of constants. These are the atoms or the basic components of an expression. And sub expressions can be combined into bigger expressions, using operators. Now, operators can be unary that is, they take one argument operation. For example, on unary operators the examples can be , which is the unary -. For example, -3 is a negative number. Similarly, NOT operator that we have seen in connection with logical operations so, NOT of zero, for example, the logical negation operator. Both of these operations take one argument. Now, there is also the binary operations like +, -, *, etcetera. So, + takes two arguments. For example, an expression like 2 + 3 and here is the binary -. So, if I say 2 -3, this is actually a binary operator which takes two arguments, which are 2 and 3. Similarly, the binary multiplication 2 * 3 would be the product of 2 and 3. So, notice the difference between… It is the same sign for the unary - and the binary -. But, the unary - takes only one argument and the binary - takes two arguments. We have used the assignment operation many times and let us understand that in, somewhat more detail. For example, if you consider the expression b = b + 1. Now, if you remove the semicolon at the end. So, the statement is b = b + 1 semicolon. And if you omit the semicolon, what you get is an assignment expression, b = b + 1 without the semicolon.  So, how does the assignment operation work? For example, consider an expression like a = (b = 10). What does this do? So, assume that a and b are integer variables. Now, assignment assigns to the left hand variable, left hand operand, the value of the expression on the right hand side. For example, in this assignment operation there are two assignment expressions. One is the expression b = 10. And the second is the expression a = b = 10. So, the first assignment expression is supposed to do the following, assign 10 to b. So, what it does is, it assigns the value of the right expression which is 10 in this case to the left hand side operand that is one thing, it does. And also, it returns the value after the assignments. So, 10 has been assigned to b. And the return value of this expression is 10. So, we can now analyze a = b = 10, as follows. First, evaluate the expression in parenthesis. The expression b = 10 has an assignment operator. So, evaluate the expression on the right hand side and then assign it to b. Now, that operation returns. So, that expression returns a particular value, which is 10. Now, the original expression can be thought of as, just a = 10. This is evaluated as usual. So, you take 10 and assign it to a. And the return value of the whole expression becomes 10. So, when executing this expression, when evaluating this expression, two variables are assigns their values. One is b, which is assigned the value 10 and the second is a, which is also assigned the value 10. The assignment operation can be used to initialize a number of variables, in one shot. For example, if I write a statement like a = (b= (c = (d= (e=0)))). What does this mean? Now, here there is some ambiguity here, because we do not know which order to evaluate this. Should, we evaluate from left to right. Should, we evaluate from right to left. Does it matter? So, should the assignment be treated as the following, where a = b is done first, then, = c, then, = d and. So, on. Or should it be the opposite way right to left, where e = 0 is first done. Then, d = that, then c = that,. So, on until a. So, the expression is evaluated from right to left, in the case of the assignment operation. For example, the above expression that we just saw will be done as, a =… So, e = 0,  first and then backward, until a is assigned. Now, this is also the standard mathematical convention. We are not introducing a new strange rule, here. Why is this? First, we will evaluate the inner most expression, which is e = 0. So, e will be assigned 0, then the return value of this sub expression. So, this sub expression will return the value 0. So, this becomes d = 0, d is assigned the value 0. And the return value of this sub expression becomes 0. So, then we have c = 0 and. So, on. So, finally, every variable here will be assigned the value 0. So, the reason for doing this is that, if you try to do it in the opposite way, you will see that uninitialized variables are initialized to other uninitialized variable. For example, if you go from left to right, in the previous. This simply does not make any sense, because you have just declared a b c and. So, on. And when you say a = b, a and b are not initialized yet. So, this assignment hardly makes any sense. The basic rule of assignment is that, left hand side = right hand side. So, the left hand side is some value that can be assigned to. For example, this is a variable. The right hand side can be anything, variable, constant or it can be an expression. So, all these are valid assignment. So, what is an invalid assignment? So, a = 0 can be a valid assignment but, 0 = a. So, the assignment operation is evaluated, right to left. Now, we have the concept of associativity of operators. So, what does associativity mean? It is, we have just argued that, a = b = c = d = 0. An expression like that will be evaluated from right to left. So, it is as though, we have parenthesized the expression as d = 0, inner most. Then, c = that, then b = that and. So, on. So, on the other hand, if you take an operator like binary + the addition symbol, then the usual custom is that you parenthesis from left to right. So, the evaluation is done, a + b first. Then, that sum is added to c. Then, that is added to d. So, the assignment operation goes right to left. The addition symbol operates left to right. So, this concept of associativity of an operator tells us, the order in which we evaluate the operations, if there are multiple occurrences of the same operator. So, the first there are multiple occurrences of the = sign. In the second, there are multiple occurrences of the addition symbol.So, associativity rules tells you that, if there are identical operators in an expression, in which order do you evaluate them? Do you evaluate them from left to right? If you do, then it is called a left associative operator. If you evaluate from right to left, in the case of, for example, the assignment, then it is called a right associative operator. Binary - is also left associative. For example, a - b - c - d is evaluated as a - b, then c then - c, then - d. So, for example, if you say 10 - 5 - 15, what will be done is 10 - 5 and then - 15. So, this is 5 - 15, which is - 10. Whereas, if the parenthesis had been in the opposite way, it would be 10 - 5 - 15, which case it could be 10 -, this is - 10 which is 20. Notice that, this is not how you are supposed to do it, even in mathematics. So, the way that c does handles the associativity of the binary operation, is correct. So, the correct parenthesis is 10 - 5 and then - 15. In general, for every operator c defines an associativity. So, let us see the part of the associativity of operations in c. There are several operations that we have seen,. So, far. The parenthesis, the Boolean naught, the logical naught and the unary -, the binary multiplication, division and. So, on. Addition symbol, comparison less than, less than or = and. So, on. Equality, logical AND, logical OR and then the assignment operator. We have seen, all these operations,. So, far. And of this, the typical associativity is left to right. There are couple of exceptions, one we have already seen. Assignment operation is right to left. The unary operations are also right to left. Most of the other operations are left to right. So, if you think for a little bit, you can see that the associativity for unary operations is also easily seen to be right to left. That makes more sense. So, the idea is not that you should memorize this table but, you should understand. Given the table, can I understand, what will happen with an expression? How c will evaluate it? It is not that, you should remember this. But, rather if you are given the table and an expression, can you correctly calculate what the value of the expression will be. This one more concept that we have to understand, before we really understand how c evaluates expressions, that is the concept of precedence. So, what do we mean by a precedence? Let us pick a expression which involves multiple operators. Like for example, in this expression you have two operations, the assignment operation and the addition operation. Now, how do we know, how to evaluate this expressions. So, what are the two ways in which the above expression can be interpreted, the first way is you could say a = b and then say + c or you can say a = b + c. To decide which of the above possibilities to really do, c also defines what is known as a precedence between operators. So, we have already seen in the notion of associativity which is what happens, when the many occurrences of the same operator occur in an expression. Precedence on the other hand is to mediate between two different or multiple different operations in the same expression. So, let us see what is an example of using precedence. So, in c the + operation is given more precedence than the = operation. So, I really want to interpret this expression as a = b + c. So, this is how I want to interpret their operation and not as a = b + c. So, I want to avoid this and I want to do it in this way. So, one way I can ensure that is by saying that, please do b + c first, then take that result and assign it to it. So, one way of doing that is to say, whenever = and + appear together give more importance to +, do that first. So, proceed means going first. So, + has a greater precedence over assignment + and - have the same precedence and both have the same associativity we have seen this, addition and subtraction have the same precedence,, but multiplication and division have a higher precedence. So, if I want to evaluate a complicated expression, let us say that a + b - c * d % e / f. So, suppose I have a fairly complicated expression, what I can do is, what are the operations here? So, the operations are +, -, *, % and /. Now, according to the precedence I know that *, % and / have equal precedence about + and -. So, I know that these operations have to be done before + and -. So, they have a lower precedence. So, these have to be done first,, but among them how do you know which to do first, for that we use the left to right associativity of these operations. So, as for as with in the same precedence is concerns, let us just simplify this situation in a little bit and think of them as the same operation, their different operations of the same precedence. But, I will just the thing a little bit to say that, let say that they are the same operation, all of them have left or right associativity. Therefore, I will according to the associativity rule I will do c * d first, then that % e and then that / f, because that is what the left to right associativity it says. So, by precedence we will know that these three operations have to be done first, among them how do you do this, * occurs first when you scan from left to right. So, c * d has to be done first and then the % operation and then the / operation. So, and once you done there then you come to + and -. So, currently once we have finished with this, you will have some situation like this, c * d % e / f and then on the remaining side you have a + b - this. And now you have to decide, which may you will do the + and -, again we know that they have the same precedence. So, let us found a little bit and think of them as the same operator, both of them have the left or right associativity. So, I do a + b first and then the -. So, with in the same precedence level, you will decide which operation to do first purely based on the left to right associativity. So, let us take a look at the precedence of associativity table. Again I want to emphasis is not to memorise, it is just that if you are given this table, you should be able to understand how an expression is going to be evaluated? So, parenthesis is above all because once a parenthesis an expression, then you really saying this is the order that I want. So, it over writes any other precedence or associativity rule. Then, you have the unary operations which have the second higher precedence, then the arithmetic operations, then the comparison operation, logical operators, assignment and so, on. The comma is an operation we will see later. So, with in the arithmetic operations multiply, divide and % operator have higher precedence over + and -. + and - have higher precedence over relational operations, like <, < or = and so, on. So, we will see a few examples of how to use this table to understand what will happen with an expression?So, let us take 10 + 5 * 4 % 2 and assign to a, let us examine what will happen here. So, what I will do is I will make a list of operations. So, they are =, +, *, % and then precedence I know that multiplication and % have very high precedence. Then, the next level is + and then assignment has the least precedence. Now, both of these occurring in this expression * and %, how do we decide which goes first, both of them have left to right associativity. So, whatever happens first in the looking from left to right, we will do that first. So, among all these operations we know that 5 * 4 will happen first, then this will be followed by % 2 and then this will be followed by 10 +. And finally, the last which is that you do all these operations get the value and assign it way. So, this is the way in which the above expression will be evaluated. So, the above expression corresponds to giving the parentheses in the wave that we have done. So, once you do that a will get the value 10. Let us see a few more examples of expression evaluation in C; what kinds of expressions are allowed, what kind of errors do people usually make, and so on. Let us say that we have given an expression a = 1, b = 1, c = 2. And then we have an expression a < b and then b >= c. So, this is the expression that we want to see how it will be evaluated. So, let us just go through it systematically. The operations on are <=, then we have the logical AND operation the >= symbol. Of these, the relational comparison operations <= and >= – have greater precedence over the logical AND. So, the precedence will be AND. And among operations of the same precedence level, we have left to right. So, whatever happens first when looking from left to right will be evaluated first. So, these two operations have the same precedence. So, we will have (a <= b); then (b >= c); these have to be done first and then AND. So, this will be done first, this will be done second, and this is the third operation. Conceptually, using just precedence and associativity rules, this is how the expression should be evaluated. So, when we evaluate it, a < are = b is 1 < are = 1. So, that is 1. b >= c is 1 >= 2. So, that is 0. So, this becomes 1 and 0; in which case, it is 0. Now, let us look at a few tricky examples. So, if you have an expression of the following form, if a = b > 1; then c = 1. So, let us see what happens here. We will do the same thing; operations sorted by precedence is… There is greater-than symbol, which has a higher precedence over the equal-to symbol. So, the expression a = b > 1 will be evaluated as b > 1, because that has higher precedence. So, this goes first. And then a = b > 1. Now, b is 2. So, b > 1 is 1. So, you have a = 1. And a = 1 is an assignment expression. It assigns the value 1 to a. And the return value is 1 because a is assigned to 1. So, then this whole if expression becomes if 1 – c = 1; in which case, we know that, c = 1; that statement will be executed. Now, typically, what is expected… The typical programming style is to say something like a assigned to b; and if that result is > 1. So, we may want to deliberately violate the precedence. How do you do that? So, C does it some way; if you do not parenthesize it, you can always change the order of evaluation in C by introducing parenthesis, so that the meaning is very clear. So, if you do not parenthesize it, then a = b > 1 is the same as a = b > 1. But, what if you really want to do a = b and then that > 1? So, that case, you parenthesize it. Why? Because parenthesis has the highest precedence. So, whatever is within parenthesis will be evaluated first. So, = b will be evaluated first and b is 2. So, a will get the value 2. So, the assignment a = b will have returned the value 2. And 2 is > 1. So, it will execute ((Refer Time: 05:17)) One particular way in which such an expression can be seen; we have already seen such an example is – you read all integers from the terminal until a -1 is read. So, suppose the input is of the form 3 2 -1; and then let us say dot or something of that sort. So, what this expression does is scanf returns a value, which is the number of tokens that – number of inputs that, it was successfully able to read. So, if you try to read a character as an integer, it may not succeed. And so, as long as you have correctly written the integer and the integer is not -1, then you do a particular ((Refer Time: 06:19)) So, this is the kind of expression that is often used; where, you assign some value to a using the assignment statement. Or, maybe you want to check the return value of a function whether it is positive or not. And based on that, you want to write a condition. So, the logical and operation does operates in the following way. It evaluates the left operand first. If this condition is false, then you know that, the whole expression is going to be false. If at least one of the terms is false, then you know that, the whole thing is false. So, it will not even evaluate the second operand. On the other hand, if the operation is true, then it will check whether the second operand is true. If the second operand is also true, then the whole expression is true. If the second operand is false, then the whole expression is false. This method of evaluation is also called short-circuiting because it may not evaluate the whole expression in order to get the result. So, if I know that, this expression is false; then there is no need to evaluate this, because I know that, the whole expression is going to be false. Here is a common mistake that people do, because this is similar to mathematical notation. When you want to check a condition that a is between 1 and 5; what happens if you right 1 < a < 5? Because this is the way we do it in mathematics. C will apply the precedence and the associativity. In this case, it is the same operation. So, only associativity applies. And according to associativity, it is left to right. So, this will be evaluated as 1 < a < 5. Now, a is 2. So, 1 < a is false. So, this becomes 0. So, the whole thing is 0 < 5. So, it is true. So, if you execute this code, it will eventually become an infinite loop, because this is an expression that always evaluates to true. Now, what you probably mean is that, I want to check that, a is between 1 and 5; a is 2. So, the correct way to write such an expression would be 1 < a and a < 5; that will check the betweenness condition. So, notice that, this is different from the way we normally write in mathematics. This is how we would write such a test in mathematics. But, that will cause an infinite loop. This is because C will apply the precedence and the associativity rules and not what you think it should do. Now, let us look at can there be expressions, which make no sense? We have seen several examples, where you can always make sense out of it. So, let us take this expression. Again, list out the operations; see you have = =; then you have the % operation, which is highest precedence; then you have minus; then you again have an =; and then you have a +. So, these are the operations in the expression. So, what needs to be done first? b % c. And then you have -a; and then you have a + 1. This is by following precedence and associativity rules. Now, we come to the assignment statement. Assignment statements are done right to left. So, the first thing that you would try to do is the following. So, you try to do the… So, here is a sub expression; here is a sub expression; here is a sub expression; and here is a sub expression. So, it is like assigning four terms. And the innermost thing will be done first; the rightmost thing will be done first. So, the rightmost assignment is b % c -a is assigned to a + 1. Now, this is a syntax error. So, what happen is as we just discussed if you work out the whole assignment; if you workout the whole expression, it becomes something like this. And somewhere when you work out the assignment from right to left, you will see that, it is trying to assign a number -3 to -7. That does not make any sense. The left-hand side of an assignment statement should be an assignable value, which is essentially a variable. And in this case, you are trying to assign a number to another number, which does make sense. So, here is a syntax error. We will conclude the discussion on operations with one more operation, which is quite common in C; which is the ; operator. Now, this is not very common in mathematics. But, let us just discuss what does it mean in C. So, let us say that, we have two expressions: expression 1 and expression 2 separated by a ;. Now, think of the ; as an operation just like any other operation like + or minus. So, it must have a precedence it must have an associativity and so on. So, what will happen when we have an expression like i + 2 ; sum = sum -1. So, how does it follows? First, you evaluate the expression 1. So, first, in this case, you evaluate i + 2; then you evaluate sum = sum -1; and return the value of the lost expression. So, the whole – the ; operation is involved in an expression called the ; expression. Every expression has a value and the value of the ; expression will be expression 2. So, what if you have multiple expressions? You figure out what is the associativity of the ; expression. The ; expression associates left to right. So, this expression will become scanf and so on; sum = 0; i = 0. So, this… For the first ;, this is expression 1 and this is expression 2. So, this expression evaluates to the result of sum = 0; which is 0 as we know. Now, the second level is you have 0 ; i = 0. So, the first ; expression is evaluated and its result is expression 2 of that expression, which is a value of sum = 0, which is 0. So, the outer expression becomes 0 ; i = 0. The value of that expression is the value of expression 2 in that bigger expression, which is the value of i = 0. So, here is how you will apply the rule that, it is the value of the second expression for a more general expression involving multiple commas. So, what you do is – first, evaluate the first expression and it has some value. For example, in this case, it is an assignment expression. So, it will have value 0. And then the second expression is evaluated. And the value of ; expression is the value of the second expression. Note that, you may… At first sight, you may see multiple commas in the same expression; but the way you do it is that, you group them using associativity rules into a sequence of ; expressions, where each ; expression has exactly two terms. This is what we did in the previous example. Now, ; expression is very convenient, because you can do things like when you want to initialize multiple variables in a for loop for example, you can just say sum = 0, ; i = 0. It will initialize both values at the same time; both variables at the same time. So, ; are evaluated left to right. This is what I just worked out an example of the following form. So, if you have multiple sub expressions in a ; expression; if we have multiple ;, what you do is you associate them just like you did with + and star; you have multiple ; expressions. And then group them two at a time. So, it becomes two ; expressions. And then evaluate them. Now, the ; expression has the lowest precedence of any operator in C. So, if you have an operation like a = a + 5 ; sum = sum + a, what will happen is you do this expression a = a + 5; then do this expression sum = sum + a. And then evaluate the ; expression. And therefore, when you have a ; expression, you do not need explicit parenthesis, because the precedence takes care of it; it has the lowest precedence. So, it will never get swallowed into a bigger expression, which involves other operations. So, it will always be evaluated at the end. So, just to remind you, here is the table once again. And notice that, as we discussed the ; operation is the lowest precedence and the associates left to right. This is also a slightly different meaning of the ; in C. We will just mention that in passing. There is also the normal separator. So, the separator can be seen in multiple occasions in C. When you initialize an expression; when you say sum = 0, ; = zero, ; j = 0; this is not the ; expression; it is just a separator as in English. So, similarly, when you call a function, you have ; to separate out the arguments. That does not mean that, the arguments are inside a ; expression. Here ; is just a separator as in English. And it is always clear from the context whether a ; is a separator or an operator. As an operator, it has a particular value; as a separator, it does not do anything other than saying that, this first and then this. So, we have seen several operators in C and discussed the concepts of precedence and associativity. And what is important is – given the precedence and the associativity tables, can you understand an expression; see whether it is a valid expression, and if it is a valid expression, what will be its value. In this session we are going to introduce a new concept of programming in C called functions. So, initially, let us just try to motivate why we need functions, and then we will try to see whether programming becomes easier, if we have functions. So, let us say that, why do we need functions? There are essentially two different reasons for it. And I will mention these reasons one after the other. The first reason is to break up a complex problem into simple sub problems. All of us, for example, like to drop to do less saying that these are the things I wish to accomplish today. So, step 1, you know, get to college, step 2 - attend classes, step 3 - finish home work or something like that. And then each of those main task will have several sub task. In order to get to college, maybe you need to renew the ticket subscription, get on the bus, get to college, and so on.  So, each of those higher level task involves several search smaller sub task. And conceptually, it is cleaner to say that these are the big level things that I want to do. Each of those big level task have several sub tasks, so that I can think of it, what I want to accomplish in a layer wise manner. So, this is something that we do intuitively. We always break up complex problem into simpler sub problems so that we can analyze the simpler sub problem and perform it completely, and then come back to the bigger problem. So, we need to solve it each separately.  And the main tool for this programming in C which allows you to accomplish breaking up a complex sub problem into simpler sub problems is what is known as functions. So, this enables you to do what is known as modular programming in c. And functions are not new. We have already seen three functions in particular - main was a function that we always wrote, and then we have printf and scanf which we use for outputting and inputting respectively. So, let us just motivate the notion of functions by using the second motivation that I was talking about.  So, suppose, you have, you want to say, I want to compute , which is , correct? So, this is the definition of n choose k for  as it is known. Now, suppose I want to write this, n code this into C program, so I will have, let us say, a main function. And then inside the main function I will have, let us say, three variables – a, b, c, and then float result because the result of a division will be a float. So, I will have, what should I do intuitively, one way to do it is I will have a block of code which says it will calculate n! which is the numerator, then I will say that a = n!; at end of this, let us say, that a stores n!.  Then, I will have another block of code which says that I will calculate k!. And then this will say, let us say, b = k!. And the third block of code will calculate n - k!; let us say, I will store this in c. And then I will say, ok result = , some code that looks like this. And you would notice what is inconvenient about it; all these three blocks of code, once we complete it, will look very similar. They are all calculating the! of a particular number. But, there is nothing in c, which will, that using the features that we have seen so far, which will tell us that this code, this code and this code are essentially the same, and I need to write that similar code only once. So, there is no simple way to use loops to accomplish these. So, it seems like this redundant business of writing similar code again and again can be avoided. So, this is the second motivation for introducing the notion of functions which is basically to avoid duplication of code. So, here is a side benefit of functions, avoid code replication. We have already seen loops to some extend avoid code replication. But, here is a newer method to avoid code replication in a greater unit. So, the second reason why we write functions is to avoid writing similar code again and again.  So, let us try to write functions by motivating it with the help of an example. This example will show the benefit of how we can avoid code duplication using functions, and also how we can breakup a complex problem into simpler sub problems. So, in this I will introduce the problems similar to what have we seen before. We have a sequence of numbers. The first number tells you how many inputs there are. And then what we need to do is to pick out the numbers which are relatively prime in these sequences. So, two numbers are relatively prime if there gcd is 1. So, 16 and 7 are relatively prime; 4 and 6 are not because they have a common factor of 2; 6 and 16 are not, they have a common factor of 2; 16 and 7 do not have a common factor other than 1; 7 and 8 are similarly relatively prime; 8 and 9 are relatively prime; 9 and 10 are relatively prime; and 10 and 11 are relatively prime.  So, these are the relatively prime pairs. And we need to write a function which given a sequence of these numbers count how many pairs, how many successively occurring numbers are relatively prime to each other. In this case there are 5 such pairs. So, in this problem we can clearly see that there is a sub problem which is, given two numbers are they relatively prime? That is one sub problem. And if we have the solution to that sub problem then we can compose the solution to the whole problem as follows. Given two numbers, I check whether they are relatively prime. If they are relatively prime I will increment the count of the relatively prime pairs I had seen so far, otherwise I will skip to the next pair and see whether they are relatively prime. So, for each new pair of numbers I am seeing that is the sub task of checking whether they are relatively prime.  So, let us say that suppose we have a function; a function is something that we will see in a minute. Suppose we have a small component which will perform the task of testing iscoprime a, b. So, iscoprime a, b, that function will take two numbers a and b and check whether they are relatively prime or not. If a and b are relatively prime it evaluates to 1. It is, we say that it returns 1 if they are relatively prime; and if they are not co-prime to each other, if there not relatively prime, then it has to return as 0. So, it has to evaluate to 0. Now, associated with every function there are three concepts. We will see them one by one. There is this declaration of a function which says what does the function look like, what is the type of the function. So, the declaration of the function will be written in the following way. It will be written as int iscoprime ( int a, int b ). This means that iscoprime is the function name, and then it takes two arguments - a and b which are of type int; so int a and int b. If we had written another function which takes a float a and int b, we would say, function int, float a, int b.  So, in this case we are taking two integers as arguments, so you have to say, int a, int b. A small syntactic point that you have to notice, that, you cannot abbreviate this as int a, b; so that is not allowed. Each variable needs to have a separate type signature. So, these are called the input arguments. So, that is the second part of the declaration. The first part of the declaration, the first, which says that, it is an int, is actually the type of the return value. So, the return value is 1 if the pairs is co-prime, and it is 0 if the pair is not coprime. So, the return value is an integer. So, we need a function name, we need a declaration of the input arguments. The arguments need to be named, and the return value of the output.  So, let us say how do we design the higher level function? So, here is how you use functions when you program. You assume that the function is already available to you, and it does what it is supposed to do. Using that how do I build the solution to the whole program? So, in this case, let us just assume that we have written int iscoprime; we have written that function. And we are interested in, how do we build the solution to the entire problem using that?  So, how do you do that? Use, have a flow chart which reach numbers one by one. And count is the number of co-prime pairs that you have seen so far. So, you check whether you have seen n numbers. If you have not seen n numbers then you read the next number and check whether the previous number and the current number form a co-prime pair. So, you give iscoprime prev current; it will return 1, if they are co-prime. So, that will get added to the count. If there not co-prime, they will, it will return a 0. So, count will remain as it is.  Once you do that you say prev is = current, and indicate that you are going to read the next number. This is similar to other problems where we scanned this bunch of numbers and did some function based on that. The new think here is the iscoprime function which we just assumed that it is correctly written, and it does what it is supposed do. So, this is the function declaration. Now, how do you code this up? You basically code this up in c, just as you did it with other program, other functions like scan f. You just say, count + iscoprime previous current. So, this is how you can encode the flowchart including the function called as a C program. Now, let us come to the interesting part which is, how do we design the int iscoprime function? So, the top is the declaration part of the function where I say that what is its type. So, the function name is iscoprime. It takes two variables a and b; a is of type int, b is of type int. And it is supposed to written in integer value. So, that much is clear from the type declaration the type signature so called of iscoprime.  Now, what you do with it? You say that, so this is the classic gcd code; you declare a t variable; if a is less than b, you swap a and b. And this part of the code is just calculating the gcd. This is code that we have seen before. And at the end of that, a, will become the gcd. If a and b are co-prime then a, will be 1. If, a, is any number greater than 1, then they are not co-prime. So, if, a is = 1, you return 1. And for returning, you use the keyword return. So, you return the value 1; otherwise you return the value 0. So, this is how you write the function iscoprime. So, now we have to put both these go together. So, I will say, include <stdio.h>; this is the first line of the code. Then I will have the source code for iscoprime. So, I will write that. And afterwards write name function, so that, when main calls iscoprime function, then we already have the code for iscoprime available. First this line, then the iscoprime function, and then the main function. So, let us look at the function in somewhat greater detail; a and b are what are called the formal parameters of the function. They are viewed as variables. Now, the formal parameters are visible only within the function. So, we say that their scope is inside the function.  Now, there is, this is what is known as the declared definition of the function. Every function can be called. Notice that we have already called the functions like print f and scan f. So, once you define a function you can call a function; calling a function will be evaluating that function with particular arguments; you can do that. So, when you call a function you execute the function with the given arguments. So, 5 becomes a, and 6 become b. Once a function call is encountered what happens is that formal parameters are mapped to actual parameters. So, a becomes; so the value 5 is copied to a, and the value 6 is copied to b. This process of copying values is known as parameter passing. Then what you do is, you store the return address of the call. The return address is the line of the main function where the function was called. So, let us say that it was called in the second line of main. Once the function finishes it has to come back to this point.  Now, in addition, we also create a box for storing the return value. At the end of function either 1 or 0 will be returned. So, we also need some space in memory to store that return value. So, to look at it in slightly greater detail, so let us say that iscoprime 9, 4 is called in step 20 a. So, this is the address; 20 a by which I mean it is line 20 and some location a. So, now, you have to allocate the space for the return value; store the return address and pass the parameters. Now, at, when you pass the inputs, 9 and 4, the space is allocated for, a = 9, and b = 4. This is the process of parameter passing. So, we visualize the memory as a stack. So, when you start the programs you start executing from line 1 of many; so x is initialized to - 1. And then you come to the function called iscoprime 9, 4. So, when you execute this you do the following: you allocate the space for the return value, you pass the parameters and then execute the function, and finally pass back the return value.  So, when you execute the function you imagine that the stack is now divided into a separate space. So, here is a clean separation between the memory that is required for main. So, above here is main, and below here is the memory required for iscoprime. So, in that I have stored a box for return value. I have stored the return address which is 20 a. And then I have, a = 9, and b = 4. Now, I will execute the function as though memory is limited to here. So, I will declare t, and then execute the gcd algorithm. So, this is stuff that we have seen before. And finally, a is the gcd which is 1. If a is 1 we have to return 1. So, the value 1 will be copied to the return value, and that is the value that will be passed back; so x will be 1. So, the return value will be copied back to the main function.  When comes to C functions, we have seen the following concepts. One is the declaration in the definition of the function by which I mean the declaration is what type is the function? What are the input arguments? What types are the input arguments? And what is the result return type? So, these form the declaration. Definition is the logic of a function. So, this is what is known as the declaration and the definition of the function and we do it only once. So, function is defined only once. Once we define a function we can of course, call the function multiple times. So, definition is done only once and calling can be done any number of times. Now, we refer to a stack which is, what is the central concept in executing a function. Stack is just a part of the memory, that goes only in one direction. So, that is what it is supposed to mean. Basically, you can think of it as a stack of boxes or a stack of paper on a table or a stack of a plates. So, it grows in one direction. So, the stack grows as the main calls of a particular function, that function calls a different function and so, on. And you can imagine the stack is growing upwards or growing downwards. It does not matter. As functions get called it either grow keeps growing upwards or keeps going downwards. We will usually represent it us keeping growing downward. So, let us look at this function that we were talking about earlier. So, n choose k is n factorial upon k factorial times n minus k factorial and let us try to code this up. We know that factorial is something that we will need over and over in this program. So, let us say that I write factorial as a function. So, factorial takes an integer and returns an integers. So, the declaration is int fact int r, r is a input argument and the return type is int. Now, inside that we will write the code for factorial. All variables declared inside the factorial or local or private to the factorial function, they cannot be seen outside. So, the input argument as well as any variables declared inside factorial or private or local to the factorial function. So, I have i and this encodes the logic of factorial that we have seen earlier. So, you start with the product equal to 1 and keep on multiplying the numbers, till you reach r factorial. So, once you reach r you return the r factorial. This logic is something that we have seen before. Now, we will see how do we put this together in order to produce the function. So, what we need to do is? We will just encode this solution that we have. So, it is (fact(n)/fact(k))/fact(n-k) . So, here are the encoded just a logic.  So, I will add slightly larger code, this is not proper c code. I let us say that I have three extra variables which have declared of int t1, t2 and t3. Now, t1 will be factorial of n, t2 will be factorial of k and t3 will be fact(n-k) , have separated this out. So, that, I can clearly explain what happens when the code executes. Let us say that I want to calculate 4 c 2. Now, first when the program starts executing, you start with code on the first line of the main. So, you scanf n and k. So, n is 4 and k is 2. Now, use do t1 = fact(n) . So, when t1 = fact(n)  is called, what you do is, you set up the return value and return address. So, return value is not yet decided to return address is 5, because, you have to go back to line 5 of the code. So, that is why the return value is 5. Also what you need to do, you need to copy the parameter value which is 4. So, this is the actual parameter 4 and you have to copy it to the input argument r. So, r is the input argument, r should be assign to the value n here, n is 4. So, that is known as passing the argument. Now, once that is done the code can be seen us jumping to factorial. So, as soon as the function is called, you actually pass the execution to the factorial function. Now, inside the factorial function you have two in local variables i and ans which is answered. And we start executing the factorial function. So, let us see what happens, when we execute the factorial function. So, far we have passed the arguments and so, on. Now, I have just hidden the part of the stack that was used for name. And let us focus just on the factorial function. This computes the factorial function, that we are familiar with this nothing new here. So, it has a variable I which keep track of how many times it has loop has executed and r is notice 4. So, you compute the factorial of 4. Finally, when r = 4 ; ans = 24  now, this 24 value we say return the answer value. So, answer value is 24. So, this will be copied to the return value location. So, the return value will get the value 24 and now jump back to return address. So, return address is line 5. So, will jump back to line 5 and there we will say that t1 = 24 . Only the return value is copied back to the main program all other things are irrelevant. So, the correct way to imagine what happens. When the function has returned is that, the stack that was allocated to main to the execution of fact is completely erased. So, once we go back to main as soon as the function returns back to the main. You should imagine that the entire stack is deleted, and only the memory that was originally allocated to main remains.  So, the correct way to think about a function executing, you can imagine that, you are main and you have a friend, who can calculate factorial for you. Now, you can ask your friend to calculate factorial for you and things are done in a very hygienic manner. So, what you do is, you write on a piece of paper the number 4 and give it your friend. Now, your friend is another room. So, he has at his disposal some black board. So, he looks at the number 4 and using the private local variables that he has, which is i and a result or answer, he calculates the factorial of these numbers. Once see does that, he copies the result back on to a piece of paper. So, 4 factorial is 24 and brings it back to you. Before he does that, he erases the black board and he will bring back the number 24 on a piece of paper. Now, you can imagine that the space that your friend used to compute 24 has now been wipe clean. And all that remains is the value 24 which you can copy back on to your note book. So, this allegory tells you exactly what happens in the case of function execution. You write down what you want the factorial of on a piece of paper, pass it your friend, he will go to a separate room. And he will calculate whatever he wants. Once he does that, he will clean his black board, right down the result on a piece of paper and bring that paper back to you. So, as far as you are concerned you are least bothered with how he is computing the factorial function. All you want as the result. And this is the basic way to thing about functions. You should be able to reason out a bigger program by saying, what does as a smaller program, what does as a smaller function do regardless of how that function does it. Now, let us get on with the remaining execution. We have just computed factorial of 4. Now, we need to calculate factorial of 2 and factorial of 4 minus 2. So, we go to the next line, the next line also involves the call to factorial of k. So, we do the same things again, we save the return address. Now, the return address is 6. Because, we are executing line 6, then we create a box for the return value and pass the parameters, and finally, jump to the called function. So, we do all that we have some memory for main. But, we allocate a new space in the stack for executing factorial. At this point return address is 6. Because, it is a second factorial that is being called, r is 2, because, k is 2 and you execute the factorial function. So, you again go to the factorial function and calculate 2 factorial, 2 factorial is 2. So, that will be transferred back to the return value And now you can imagine that, you will get back to the address 6, where t2 will have the value 2. So, once you do that again the thing to imagine is that, this slate is wiped clean. And all the memory that you allocated to the stack is now free. So, all once you are back in main all you have as the memory for me. Now, there is the third call to factorial. Fact(n-k)  and it is done in exactly the same manner without much elaboration. So, it will create n - k is 4 - 2 which is also 2 and the return address is 7 equation n. And once you do that, it will execute the factorial code again, and calculate the factorial of 2 which is again 2 and return to line 7. So, 2 will be copied as the return value and once the execution finishes, you return to line 7 of main program. At this point, you say that t3 = 2. And you can imagine that the stack allocated to factorial is now erased. So, at this point main has t1 = 24 , t2 = 2 and t3 = 2. You have all the information that you need in order to calculate your result. So, you calculate (24/2)/2 and the answer is 6 which is 4 choose two. So, this illustrates how do you write a function? How do you define a function? And how do you call it? And what actually happens when you execute a main function? So, the execution of a function can be visualized as a stack. A stack is a part of memory, that is allocated as private to a new function that is being called. Once that function finishes execution, the stack is erased and you go back to the previous function. And you go back to the calling function. We have been talking about designing programs using functions. And the general  philosophy is that, you have a large task that you want to accomplish and you break it in to sub task, may be each of those sub task are split it in to smallest sub task  and so on. So, break them until some sub task can be easily solved by single function. And then, you put all these function together in order to solve the whole problem. So, design your program from top down, big task decomposing into small task and so on. And debug your program or make sure that they are free of errors from the bottom up. So, test each functions thoroughly and then test the overall program. In this, we will discuss a few technical details about how C executes its functions. In particular we will see how C passes arguments to it is functions, and also how does a return values. When passing arguments will talk about issues like evaluation order, in what order are arguments evaluated, if there are multiple arguments. And we will discuss what are known as side effects. So, let us start by considering a very simple example. I have very simple function called sum which just adds up two variables x and y which are integers. Therefore, the return value is also an integer. Now, inside the main program I will call a = sum(a,b). A is 1 and b is 2. And then, you will sum this up and the return value is assigned to a. So, this is suppose to do 1 plus 2 3 and a is assigned the value 3. So, after passing the parameters sum is called with x as a, which is 1 and y as b which is 2. So, sum returns 3. So, the return value is 3 and the 3 is assigned back to a. So, when you print it, the output will be 3 followed by 2. So, this is simple enough. Now, let us try, slightly more tricky example. So, here is the novelty in this example. Some instead of being declared with x and y are now being declared with two variables called a and b. The main program also has two variables, named a and b. So, what will happen here? The output is the same as before. So, 3 2 if you compile the program and execute it, it will be same as before. So, what really happened here? After passing the parameters sum is call with a as 1 and b as 2. And so it returns a value 3 assigned to the a of mean. Now, these variables are called a and b in main and they are called a and b in sum as well. Now, the variables a and b inside sum are different from the variables a and b inside main. So, the scope of these variable is mean and the scope of these variables a and b is the sum function. So, in other words the a and b inside sum has scope just this function, they are not visible or addressable outside especially in main. So, if you want to think of it, you can think of them as sum.a, sum.b. So, they are the a variable belonging to sum and the b variable belonging to sum. So, even though you would think that this a and this a may get confused they are actually different variables. One is the a variable belonging to main, and the other is the a variable inside sum and they are different, even though they have a common name.  So, now let us a try a slightly more elaborate program, what happens if you have sum(sum(a,b),b), this is the program. In this case what will happen? So, first evaluate the in a program, in a function sum of a b. So, a is 1 and b is 2. So, that will return 3, then you add b again to it b is 2, you have 5 as the total sum. So, the total the complete output is a will be assigned 5 and b is still 2. So, this is similar to evaluating a normal mathematical expression. One thing that we need to take care of is to handle expression with side effects. Now, what are expression with side effects? So, let us classify expression into two kinds, one is what are known as pure expressions. So, they are the normal mathematical expression, like a- b * c/d and so on. Similarly evaluating function, these normally do not have any effect other then returning you the value. So, they will they will be correctly evaluated and they will return some value, other than that, they have no effect. Now, expressions with side effects change the state of the program. For example, when I execute an expression a = a +1. Now, this is an expression, it has a value. So, let us say that a was 1 before a = a +1. A plus 1 has value 2 and a is assign the value 2. The state of the program involves, for example, what values are stored in the variables. When you execute the expression a = a +1, the value of the variable a changes. Contrast this with previous expression, like a minus b star c slash d. You can see that, unless you assign to something no variables value is changing, it will just evaluated and the value will be return. Here, the value will be returned also variable a is changing. Here, in this second function you have two arguments, two function f. The first is the expression a = b +1, the second is an expression b = a + 1. This might sound like a very strange way to code. But, you know that any expression can be given as arguments. So, in particular assignment expressions can be given as arguments. For example, a = b +1 is an assignment expression, which is given as an argument to the function. Now, such expressions are called expressions with side effects, because, the change the state of the program. When you have side effects you should be careful. For example, what will happen in the following program? You have function int minus(int a, int b) and it returns b - a. Now, in this program main calls the minus function with two expressions as arguments a = b +1 and b = a + 1. They are expressions with side effects, because, once evaluate these arguments, you know that the variable a will change in the first expression and the variable b will change the second expression. So, what will happen in this program? So, how should we evaluate it? The general rule is that all arguments are evaluated before the function call is made. So, before the function is executing, we know that a = b +1 and b = a + 1 both will be executed. But, and here is the major problem, we know that both have to be executed. But, C does not specify in which order they have to be executed, so, it was the left to the compiler. So, let is evaluate it in first in left right order. So, this expression first and then b = a + 1. So, what will happen then? a = b +1 b is 1. So, a will get the value 2, b = a + 1 will be executed after that a is now 2.  So, b will get the value 3. Now, you execute minus. So, you will return 3 - 2 which is 1 and b has value 3. So, this is the expected output. But, when you run it on some machines, you may get the output -1 3. So, what happened here? Now, this happens for example, when the compiler would evaluate it right to left. So, when you evaluate it right to left what will happen is that b = a + 1 will be executed first. So, b = a + 1, b gets the value 2 plus 1 3. And then, you will execute a = b +1, b is now 3. So, a gets the value 4. So, when you call minus of 4 comma 3 minus will return 3 -4 which is -1. So, in this case you know that b gets the value 3, a gets the value 4 and the result will be -1. So, what was the mistake? The mistake was that we assume that both arguments will be evaluated before the function is called. But, we assume that it will be evaluated left to right. And the first expression will be evaluated before the second expression, that is the reasonable assumption to make. But, c does not guarantee you that, c leaves this decision to the compiler. Now, compilers may evaluate arguments in different orders. For example, a very common order is right to left. So, both answers like 1 and 3 and -1 and 3 are both consistent with the c specification. Now, this is the very troubling is scenario, what should we do? So, we should write this function in such a way that, they do not depend on whether the arguments are evaluated left to right or whether they are evaluated right to left. So, write expressions in such way, that they are free of side effects, when you pass them into functions. So, how do we do that? We can do the following. For example, if we really wanted the left to right order, that is if you want a = b +1 to happen first and then b = a + 1. Why not write them explicitly that order in the main function. So, first this will be executed then b = a + 1 will executed. So, a will get the value 2 and then b will get the value 3. So, minus ( a, b) will execute as 3 - 2 in which case you will get 1. So, the important thing to note is that, in this particular function called, the arguments do not have any side effects. Because, we explicitly coded them up before to specify that, this is the order in which I want. If put it here, then it is up to the compiler, the compiler can do whatever is best in for several criteria. So, now let us come back to what the  function, we have the function definition which is the entire function. The logic of the function is what is known as the function body. And the heading is what we call the type signature. The type signature has for example, two arguments a and b these are call the formal parameters. Now, we focus on the return expression. So, return followed by some expression is the only mechanism for returning the value from a function. If the type of return expression does not match the declare type of the return. So, if for example, a is of a variable which is different from int. In this case they are the same, then it is fine. But, otherwise the return expression is converted to this type and then returned. So, it might lead to some undesirable variable. Now, we have discussed parameter passing’s in when passing parameters in c, the values from the calling function are copied to formal parameters in the called function. So, the actual parameters are converted to the formal parameter type and separate copies made. So, this is known as call by value. So, formal parameters and local variables are the function are accessible only within the function, we have already see in this. And memory for the formal parameters and the local variables of the called function will be erased as soon as function returns. So, executing return any where inside the function will immediately return from the function. And transfer control back to the calling function at the specified return address So, when you execute there are few things keep in mind. Whenever, you execute any return expression, it will cause the function to immediately return. Now, main is a function so, we can use return statement inside main what; that means, the main will immediately stop execution. That is the whole program will stop execution. Now, when you return a particular value, the calling function may choose to ignore the value. For example, let us say that I write some dummy function int f and it takes two argument float a and int b and we some code here. And then, I have the main function in which I have two variable int x and float y. Then, I have some code and here is the interesting thing, I call f(y,x), y is an float x is an int. So, I am find, but this function returns an integer value. But, I am not assigning it to anything. So, I am not saying something like x = f(y,x). So, this is not required. So, if this is the case, then why call the function in the first place? This is, because the function also may have side effects. So, remember that side effects are something some expressions, we change the state of the program. So, functions may have side effects, your already seen one such function which has the side effect for examples, scanf. So, the side effect of calling scanf is that the input from the keyboard is copied into some variable. So, function may have side effect, this is why you can call the function and choose to ignore the output or the return value. Now, just for curiosity sake executing return will calls the function to immediately return to the return address. Now, the return value if you omit it, then the return value is unpredictable. So, here is a example, you should in general avoid doing things like this. But, just for completeness, I am supposed to return a float value instead if I just say a return, the program will compile. But, when you execute some unpredictable behavior may result. So, the printed value in this case can in general will not predictable. With the concepts we have seen so far, let us design a sample program. So, the… What we … The problem that we want to solve is we want to write a program that reads the input line-by-line, and counts how many lines has the user input. Program should terminate when the end-of-file character is encountered. So, we will try to solve this problem. By the way, the end of file is a character, which you can enter using control-D if you are running Linux. So, the flowchart at the very top level can be envisioned as follows. So, we will just check has the end-of-file been reached. If the end-of-file has not been reached, you read the next line. If it is has been and check again. If the end-of-file has been reached, then you halt; otherwise you read another line. So, here is the very toplevel picture of what we want to do. So, this design is just meant to read the input lineby-line. So, it is a very vague flowchart, but at the top level, this is what we want to do. So, let us say more details about how we are going to accomplish this. In particular, we want to see how we can read and put line-by-line. So, here is the top-level design. And now we are going to essentially expand this box. We want to say how do we read the next line. So, let us design the read next line box. So, the read next line box, first you read a character and then you check whether the character read is new line character; that means that the user has pressed an enter. So, the line is ended at that point or the user can enter a bunch of characters; and instead of pressing enter, press control D. So, the user can enter end-of-file. If either of these are true, then the line has ended. So, you halt. Otherwise, if the character is neither new line nor end-of-file, then you read the next character. So, here is the design for the function to read the next character – next line. So, you read character-by-character; after every character, you check whether a new line or an end-of-file has been encountered. If either of them happen, then the line has ended; otherwise, you go back and read another character.  So, let us start by writing the top-level function. So, let us translate the top-level function into code. So, here we will introduce a new concept called what is known as a forward declaration. So, when you define a function, you can either give the logic – the full function body when you define the function or you can just say that, here is what the function will look like; here is the type signature; basically, it is taking no arguments and it will return an integer value. And I will terminate that statement by using a semicolon; which says that, this function… I will currently just say the type of the function; I will define the function later. This is done, so that we can write a function, which uses this particular function. So, when we write a function, which uses that function, the type of the function should be known. For that we can just declare the type of the function. This is what is known as a declaration of a function. Unless you define the function, you cannot use it; but in order for another function to just see what the function looks likes, declaration is sufficient. So, let us design the top-level function. So, we declare this function that, we will use in this function that we are about to write. So, this user function will be called read all lines. Now, in that, we will keep a line count initialized to 0; and then I will keep a flag called isline. Now, what this will do is we have to check for whether an end-of-file has been reached or not. For that, I will use the function feofstdin. We will see that in a minute. While the end-of-file has not been encountered, you say that, read next line; read next line will return a 1 if a line has been encountered; otherwise, it will return a 0. So, line count will be incremented by 1 if I read another line; otherwise, it will remain as it is. Finally, you return the number of lines read. So, this is a realization of the flowchart on the left. Now, there are a couple of things that require explanation. First is that even though the read next line function has not yet been defined, just based on the declaration, I can say that, it is going to return an integer and I can use the integer here.  The other thing is what do we mean by feofstdin? So, what do we mean by the function feof? So, feofstdin is a function that is part of the stdio library. We have already used other functions from that library. For example, printf and scanf. Now, the feof function – what it does is – it returns a function; it returns a value 1 if the end-of-file has been encountered in the input argument. So, stdin means that, I am using the standard input, which is the keyboard input. So, if and end-of-file has been entered via the keyboard, then feofstdin will return 1. So, stdin is usually the keyboard input. And usually, if the user enters the control D character, then feof will say 1, because end-of-file has been entered.  Now, let us design the function to read a line. We earlier wrote a function, which assumed that, there is a function, which will read the next line; and based on that, I will keep on reading lines until the end-of-file is encountered. So, we are now about to write the bottom function. So, we want to read a line. So, we have already drawn the flowchart for that. Now, let us try to make it into code. So, we have to design a few variables; we will have int ch for reading a character; we will come to that in a minute; then we will keep a count of how many characters have been read. And let us write the basic loop. So, we will just write the loop corresponding to the flowchart; ch will be getchar. So, get the next character. And while ch is… While the read character is neither end-of-file nor new line, you should keep reading characters. So, if neither of this is true, then you should read the next character, which is what the flowchart says. A slight… a small point here is that, getchar returns an integer. This is a technicality because end-of-file is negative 1. ASCII characters if you remember, go from 0 until 127 or something like that; whereas, end-of-file is defined to be -1. So, because of this -1, you cannot keep the return value of getchar as a character; it technically has to be an integer. Now, this is a technicality. So, keep that in mind. Now, we need to do something further in the loop. So, we will complete this in a minute. So, what should we do inside the loop? This should be character. So, what is this function supposed to do overall? We have to return a 1, if the number of characters in the current line that we have read is at least 1. So, if the current line contains at least a character, then we have to return 1. For example, if the user just entered a new line, which is just press the enter key, there is a blank line. In that case, we would not say that, we have read a line, because it was a blank line. So, if there is at least one character, which is neither new line nor end-of-file in that line, we have to return a 1; otherwise, let us say we return a 0. So, one way to do that is to keep a count of the number of the characters we have read. So, for every character read, we will keep a count of every character, which is neither end-of-file nor a new line; we will keep a count of characters. So, notice the way that, the loop has been return. So, if the first character is a new line, it will not enter the loop. Hence, count remains 0. At the same time, the way the loop is returned; count will count exactly those characters, which are neither new line nor end-of-file.  So, now, let us decide what should be the return value. We have to return a 1 if the number of characters in the current line including new line is at least 1. So, if count is greater than 0, we can return a 1. If exactly 1; if the last character was end-of-file without having any other characters, then will return a 0. So, how we do that? We can check whether at least a character has been read by just checking the value of count.  So, if count is greater than 0, then at least one character has been entered; otherwise, for example, we can also say that, if the user has just entered a blank line, then also we can say that, one more line has been entered. So, that is up to the way you want to do it; you can also take the stance that, maybe a blank line does not count as a line. If that is the case, then you do not have to do it; but in this case, let us just assume that, if at least a character has been entered, which is either a normal character on a new line, we will say that, return 1. If the only character entered in that line is end-of-file, we will say that, there is no more new line. So, what we have to do is return count greater than 0; this tells you how many non-new-line, non-end-of-file characters have been entered. So, this should be at least 1; or, there is exactly one character entered, which is a new line. So, neither these cases we will return a 1; otherwise, we will return a 0.  So, we can put these programs together by concatenating all the code that we have written. Notice one thing that declare the function first; we use the function here. So, here is a top-level function, which will use read next line. When read all lines uses read next line; read next line has not been defined yet. So, you can go here after read all lines has been defined, you can define read next line. So, here is a function here. So, this is function 1, this is function 2, and finally you have made. Read all lines does not need any forward declaration, because when main uses read all lines, it has already been defined. That was not the case here. When read all lines used to read next line, read next line was not defined yet. That is why we needed a forward declaration. In this program, you can reorder the code such that read next line code can be written before in which case you do not need the forward declaration. But the concept of forward declaration is useful for later discussion. So, I have just introduced that.    This session will learn about arrays in C. Now, what is the word array mean, it means a grouping or a collection of objects. So, for example, you could say that he could not dismiss the array of facts. So, that means, a collection of facts and it also implies a regular order or arrangement that is in the case of a series. So, what do we mean by an array? And why do we need it?  So, let us consider that I have a bunch of numbers say 1,2,3,4 and I want to consider them as being part of the sequence. Let us say 1 , 2 , 3 , 4. So, the first element is 1 and so on. Now, I want them to be stored and one way I can do it is that, I can store them in to separate variables. For example, I can say that a is 1, b is 2 and c is 3 and d is 4. But, when I do it in that way, they are separate variables and the relationship between those variables, the fact that b comes after a and things like that is something that the programmer knows, but it is hard for somebody else looking at the code to figure out. Often we need to store sequence as a sequence itself.  So, an array has the following properties, one it is a collection of objects of the same type. Second, is that it has some size, some finite size say n there are n elements in the array and the third is that, I should be able to selectively update only a single element in the array. By which I mean, suppose I have four elements in the array I should be able to say that, I want to replace the third element by 5. So, 3 will be replaced by 5 without touching the other elements, that is what the third thing is about The first thing says that I want a collection such that it is a collection of objects of all of type integer and not of any other type. And the second says that, it has a some finite size so, it is not an infinite collection, so, that is what an array is supposed to do. Now, let us see how we can define arrays, will try to motivate why arrays are needed by introducing certain problems. And I will try to convince you that it is easy to do using arrays and whereas, it was difficult to do without using arrays, using only the facilities in c that we have seen so, far.  So, an array is defined in c, similar to how we define a variable. If we had an integer variable we would say int a semicolon instead of that when we declare an array we have int a 5. So, this would declare that it is an array containing 5 integers. Now, one thing that is certain about arrays in c is that, the five integers which makeup the array will be allocated consecutively in memories so, they will happen one after the other. Also one think to note is that, arrays in c start with index 0 so, the first element is a 0. So, if we have an array of five elements it will go from a 0 to a 4. So, have we seen arrays and mathematics for example, you can think of vectors similarly matrices these are all arrays and c arrays will have similarities to mathematical vectors and mathematical arrays. But, note that in mathematics, it is customary to start from index 1, here it is from index 0. So, the boxes are addressed as a 0 to a 4 these are called the elements of array. The array is the whole collection of boxes and each box in it will be called an element of array.  Now, let us consider a simple program using an array. So, I mentioned that the third requirement that I want for in array is that… So, that first requirement was that all elements of the array are of the same type. Second requirement was that, it has a finite size and that the third requirement is that I should be able to selectively update only one element of the array without touching the other elements. So, let us see a program where we can do all that. So, here is a simple program it declares an integer I and integer array a five and then a for loop. So, let see what the for loop is supposed to do. So, the for loop starts from i qual to 0 and then goes from i = 0 to 5, filling in the elements by sing the statement a[i] equal to i. So, let us  see what that is supposed to do.  So, this is the notation a i is the notation used to address the elements of the array. So, notice the similarity here a 5 when you declare it say's that it is an array of size 5. a[i] is saying that I want the I th element in the array. So, when i = 0 it will refer to the 0th element in the array until i = 4. It will go on and till the fourth element of the array. So, a of 5 similar to a of 5 the way we row declare the array say's I want the ith element of the array. So, the variable I is being used as an index for a, that means, if I say a[i] will pick the ith cell, in the ith element in the array. Now, this is similar to the mathematical notation a subscript i, which is what we normally use for vector and matrices.  So, let us run through the program once to see what is doing. So, first we declare a 5, which is five consecutively allocated integers in the memory. And we also have a variable i, i starts with 0 and for this 0th iteration a[i] is allocated let say i + 1, so, a 0 will be 1 then we update i. So, this statement becomes  a[1] = 1 + 1which is 2. So, and then execute it a 2 becomes 3, a 3 becomes 4 and a 4 becomes 5. So, notice that because we have indices, and indices can be numbers, they can also be replaced by integer expressions,, this is the trick that we have used here. So, a a[i] goes from a 0 all the way up to a 4.   So, one thing is, we have to take care of the size of the array. For example, if we have an integer array of size 5x this means that 5 integer variables named x0 to x4 are allocated. Now, the variables x0 to x4 are integers and they can be assigned and also they can be operated on, they can be part of other expressions and so, on. Now, what about arbitrary integers, we know that 0 to 4 are valid integers what about 5 and so, on. What happens to x5, x66 something like that. Similarly, what happens what will happen if I right x[-1] what are these valid. So, the answer is no, you cannot in general assume that indices other then 0 to 4 make any sense. Your program may crash and this is the most important thing in c programing when we use the array it is the main part of it, because it is not even guaranteed that a program will crash. So, you may run the program once with x of 5 let us say and the program will work fine. And you will be under the false impression that everything is correct in our program, but the next time you run it, may be your program will crash. So, it is not even guaranteed that it will crash, if it is guaranteed that it will crash, then of course you can know that there is an error, and you can go back to the code. In this case you just you have to be careful when you write the code. So, x 5 x 6 and so, on are undefined, these are names, but there are no storage location that they correspond to, so, you should not access them.  So, if you ask a very specific question, shouldn’t I access them are can’t I access them. So, what will happen if I write a code like this where I declare an integer array of size 5 then I know that x0 to x4 are valid location they are the first five locations. But the problem comes with statements like x[5] = 5 x of 6 equal 6 5 and 6 do not refer to valid locations in the array so, what will happen. So, the initial statements up to x[4] are all fine, but the last two statements x[5] = 5 x[6] = 6 lead to arrays will it compile? Yes, if you just give the source code, with these erroneous locations it will compile, but c compiler does not check that the indices are within the proper range. So, it will compile and the compile will not tell you that there is anything wrong with there, but when you run a program the program will give something called a segmentation fault it may are may not give that. So, this is one of the most notorious errors when you program in c. So, we will see this error in greater detail when we understand something called pointers. But in general when you exceed the bounce of the array, when you go beyond the locations permissible in the array, your code may crash and the code will crash usually with the error segmentation fault. So, if you run the program and if you see a segmentation fault this is a good indication that may be you are referring to locations in your array that do not exist. So, you should go back and rectify the code, but the danger is that, it may not always crash. So, the only way to be really sure is to go through your source code and examine it.  Your program may crash, so, we have seen certain aspects of arrays in c so far.  So, for example, let say that I declare a character array str of size 5, so, it has five characters inside it. And let us say that I use the variable I as an index into the array. So, str[0] to str[4] can be addressed using the index i. So, if I have the index, I know that I can set particular values as str[i] = ‘a’. Since, i is 0 this will set the 0th element in the array to character a. Similarly, if I say ch equal to str[i + 1] it will take whatever is in the first cell in str[1] and assign it to the variable ch. So, we can set particular element in an array like this. Similarly, we can also read the value in an element and then assign it to something else. So, these are possible with the help of an array now let us consider a particular example, which is the problem is as follows. We want a character array let say a size 100 and then we have to read input which is from the key board and store them in the array, After we have stored it we should stop, once at least hundred character have been written, because that is array size or when the user first end a file. Remember that you can press <Ctrl-D> to enter the end of file.  Now, what we have to do is take the error, take the array and print it in the reverse order. Now, if you think for a little bit you can see that it is difficult to do this without an array. Instead of an array, if you are storing it in a single character, there is no way to store hundred characters in one variable and then print them in the reverse order right. Because the first character has to be printed at the end and last character entered has to be printed first. So, you need to remember all the characters, this is an intuitive reason why arrays are important for this problem. So, what is an example problem let say that we have m e or then new line then Moo <Ctrl-D>. So, when you reverse it, you will have oom then the new line then or emn and so, on. So, you have to reverse everything input. Similarly, if you have a string what you have to output is the exact reverse of the string including the spaces.    So, this is what we just mentioned, the end of file character is usually -1. So, it is not a valid as key value. So, the code at the top level looks like this, we have the logic to read a next character into the ch using getchar, and then we have a let us say while loop which says that, while the character is not the end of file ant the number of characters read count is less than 100. You store the character into the array increment count and then read the next character. So, please look at the structure of the loop very carefully the s is a character array. So, technically it cannot hold end of file, but then if you think about it little bit you will see that we will never encounter the situation where, you will store end of file into the s array, because suppose first character is end of file then we will not even enter the loop. Now, at any point when we enter end of file, it will be at this point right we will read the character only here, before storing it into the array we will actually check whether it is end of file. So, we will not accidentally set the array to -1 at any point, so, character array suffices. So, think carefully about the way this loop has been interpreted.  In particular, if I had just done this as the last line before the loop ended then, you would run into problems because you could store the end of files character into the s array by mistake so, just think about that issue. Now, here is an initial design and so, the overall design is that first you have to read into the array and then you have print it in reverse. So, let us make the read into array little bit more precise. So, we have ch = getchar() and because you are using the getchar function we have int ch, because it could also be an end of file. Now, the while loop says that while the ch is not end of file and the number of characters read is strictly less than hundred increment. So, you first set s[count] equal to the character read,, the increment count and then get the next character. So, this loop keeps on filing characters into the character array until you see either end of file or you have enter 100 characters.   So, this is the array that we were doing and so, here is the code for printing the characters in reverse. So, here is the pseudo code where we said print s of I instead of that in c we have a particular function which will print the character which is put char. So, due to this the dual function of getchar. So, put char takes an character as an argument and prints it on to the standard output. So, you have int i i is set to be count -1 because that way we will get the last index of the character in the array and then you start counting down until use print the first character and till the end of the array ok.  So, putting these two together, you have the read into array part and then you have the reverse part print in reverse part. So, when you put these two together the first thing you do is, bring all the declarations together.  So, this is the declarations for read into array as well as print to put together. Similarly, first you have to print, you have to put the code for the read into array part and then the code for the print in reverse part ok.  So, let us trace the execution for a small sample input. So, then we have the input is hello and then the user presses <Ctrl-D> for end of file, let see what will happen. So, you start reading into the array. So, s[count] with count equal to 0 starts setting the array. So, s 0 will be h and then h s 1 will be e and so, on. So, once ch becomes <Ctrl-D> the end of file character you will exit the loop. So, the character array is hello.    In this lecture will just talk about how to initialize arrays. So, recall that we have  defined arrays as follows, if you declare an array float w[100], it will declare an array of floats 100 floats consecutively allocated in memory. And we have also mention the fact that there is a separate box w, which will point to the first location in the array. So, it contains the address of the first location. In num[10] will declare and integer array of 10 integers plus one box which will hold the address of the first location, and so on. So, the arrays names, the cells of the array or the elements of the array are index from w[0] through w[99] the indices start from 0. And we also mentioned that conceptually there is a separate variable called w, the name of the array which stores the address of w[0].   Now, it is not important that we use numbers as the size of the arrays, we can also use constant expression; for example, we can say float w[10 * 10]. So, instead of saying 100, we can give an arithmetic expression which evaluates 200, and this has the same effect it will evaluate an array of 100 elements staring from w[0] to w[99]. And there is a separate box called w which move to the address of the first location, but what about using variables or variables size arrays, this is feature that we often which we had. So, what do I mean by that? I could declare the following code int size, and then float w size and I could say scanf ( “%d”. &size );. So, user enters the size of the array, and then I can enter 10 elements in to the array for example, but here the size of the array itself is a variable which depends on the user input. And we often wish that we would we would be able to allocate variable size arrays, but this is not allowed in Ansi C, it is allowed in the latest versions of C 99 C 11 and so on. We will avoid this feature for the purposes of this course, let us assume that array means they are declared to be of constant size. By constant size you can give the size as a particular number or you can give it as a constant expression, that is an arithmetic expression involving constants, but not general expressions.  Now, let us just look at how can we create an integer array num and also initialize it to particular values; for example, I want the num array to look like the following, it contains 7 cells having the values - 2, 3, 5, - 7, and so, on. Now I know that if C did not allow me to initialize arrays when I declared it, I could declare the array as int num 7 and then I will just write num[0] = - 2, num[1] = 3, and so on until num[6] = 11. So, here is a way that I can create an array and ensured that this state is reached, but is there more convenient way of doing it. Can I start of the array with these contents. So, C allows you two ways do it. The first is I declare an int num[] and then specify what are the initial values, so - 2 so on up to - 11 within {}.  So, this is one way to that C allows you to do this. The initial values are placed within curly braces and separated by ,, the size of the array need not be specified. So, I need not say that num[] has size 7, it will allocate an array with enough space to hold 7 integers. Array elements are assigned in the order that you specified. So, num[0] will be - 2, num[1] will be 3, and so on. So, it is done in a reasonable manner. This also another way to do it, which is slightly different from way above, I can declare the size of an array. So, I declare an array of size 10, and then give this initial value. What will happen in this case, is that it will make sure that the size of the array is at least equal to the size of list that I have given. So, I have given 7 elements, and I have declared an array of size 10, 7 is less than 10. So, it is fine. So, I can declare an array of size 10, I should give a value, I should give values at most 10 in number. So I can give a 10 or below. In this case, I give 7 numbers. So, what happens is that, array is initialized in the order elements given num[0] will be - 2, num[1] will be three and so on, until num[6] will be 11. 7 elements are filled; the remaining 7 elements are unspecified. So, they will be initialized to 0.  Now let me just remained you that if I had just declared an array int num[10], and then put a semicolon. So, I had just declare an array without saying any initialization at all, then you should assume that the array contains or arbitrary values, you should assume that array contain Junk values, but if you initializes an array of size 10, and give only 7 initialization values, then the C standard gives you the guarantee that the remaining elements are initializes to 0. So, they are not junk.  The recommended method to initialize an array is to give the list of initial values, and let the compiler decide what the size of the array it should be. So, if you give 7 initial values, it will decide that the array is of size 7. Now is the following code correct, if I declare an array of size 100 num and give four initial values. So, this is correct, it creates num as an array of size 100, the first four entries will be initialized as given. So, num[0] will be 0, num[1] will be - 1, num[2] will be 1, num[3] will be - 1, and then num[4] until num[99], they are all set to 0. So, after the initializations the array will look as follows; the first four values are what we given and the remaining value are 0’s. Now is the following code correct, num[6] = and then you give a list of 7 values to initialize, is this correct? The answer is no, it will not compile. So, if you right this code, and compile it using gcc, it you will get a completion error. Why is that? We have declared an array of size 6, but we have given 7 initial values. So, there is no way to do this. So, the rule of thumb is that either give no size for the array, and let the compiler figure out or if you do give a size it has to be at latest 7, which is the number of values that you give, it can be 10, it can be 100, but it cannot be less than 7. Now just like size can be not just numbers it can also be constant expressions, we can also have constant expressions as initialization values ok.  So, for example, I can give num[] = 109, then the character value A, character value A means it will take the ASCII value of A, 65 or whatever it is. So, the first number will be 109, the second number will be 65, let us say if the ASCII value A is 65, and the third value will be 7 * 25 * 1023 + ‘1’. So, whatever the ASCII value of the character one is let say 90 or something. So, it will be added two this, constant expression, and it will be initialize to that value; num[] two will be the result of evaluating this expression. So, the type of each initialization constant should be promotable or demotable to the array element type. So, the each value in the initialization list should be compatible with let us say integer, because we have declared the array of size of type integer. So, what do I mean by that, for example I can initialize an array num[] with initialization list 1.09, then , A , 25.25. So, this is ok, because the floating point values can be downgraded to integers. So, may be this will be initialize to one then whatever the ASCII value, A is let us say 65, and then 25. Now, these are about constant expression. What about expression involving variables when we initialize an array. So, can we do something like this. int curr = 5, and then the num[] array is initialize with {2 , curr*curr+5}, will this work. The answer surprisingly is yes that it will work on most compilers. So, the ANSI C allows constants expressions, and simple expressions for initialization values. Now simple is of course dependent on which compiler we are using. So, if you write a code, and compile using gcc with such an initialization may be or code will compile, and the movement you compile your code with a different compiler it may not compile.  So, earlier I had said that the size of the array cannot be initialized using variable expressions. In ANSI C that is forbidden, but the initialization value, so the value that goes in to the array can involve variable expressions, this may or may not be supported. So, it is safe to assume that both the size of the array, and the initialization value can be done only using constant expressions, even though some compilers allow simple initialization values using variable expressions.   Now how do we initialize character arrays? Character arrays can be initialize like arrays of any other type, suppose we want the following array. s[] = ‘I’ , ‘ ’,’a’, ’m’,’ ‘, etcetera. So, I can initialize it just like a initialize the other array, I will not specify their size of s and then give this characters, I am DON. So, this is another way to specified and the last character is a null character, but C ‘also allows you to define what are known as string constants. So, we can also write s[] = “I am DON”, but now with in double quotes. So, this is known as a string constant, the null character is an implicit ending character inside a string constant. So, it is automatically added to the int. Now the string constants in C are specified by enclosing it in double quotes.  In this video, will talk about initializing character arrays which are a special kind of arrays and has more features then, when it comes to initialization as compared to arrays of other type. So, they may be initialized just like any other array and suppose I want to initialize an array to the following values, the first is I second is a space character then a then m and so on. And the final character is a null character which will be given as ‘\0’ now we can write s. So, character s = [ ] without specifying a size and then followed by the list of characters. Notice that each character is enclosed in single quotes right. So, the space character is a ‘ ‘ and so on until the last which is a null character, which is ‘\0’. But C also allows us to define what are known as string constants. So, in order to initialize an array a character array I can also write character s[] = “I am DON”. So, I am DON is a string constant in a every string constant that is a string enclosed in double quotes the null character is automatically added to the end. So, I want you to note this difference that, here we explicitly gave a null character at the end here we do not have to give that. Now C; C string constant are specified by enclosing some text with in double quotes for a example, “I am a string”  Now, we will talk about how do we prints strings we have used sting constants many times. So, just take a moment to think back to see whether you can figure out where we have used string constants. So, we have used for them for example, in printf and scanf the first argument of a printf or a scanf was always a string constant, because if you recall we had some text in which involved special characters like new line. It involves formats specifiers as like %d, but whatever it was, it was a bunch of characters. So, it was a text inside a pair of double quotes that is a string constant. So, the first argument is the string constant followed by what all arguments we want to print. Similarly, even for scanf we had some say formats specifier enclosed in double brac double quotes, so, that is a string constant and then you say and value. So, strings are printed using the %s option. So, any of the basic data types in C can be easily printed using the printf statement if you give the correct format specifier. So, if you have a string constant you can print it using the %s option. For example, if I want to print the string “I am DON” then what I can do is I can say printf(“%s”, ”I am DON”). And this will print I am DON which is exactly what I wanted to print. Now, what if I initialize a character array character str[ ] without specifying the size. I initialize it using a string constant I am great DON within double quotes. Then I print it using printf( “%s”, str), will this work? And the answer is yes it will work, because C will consider this as a string constant and it will print it using %s and you will get the correct output. So, state of memory after definition of this string in example two is that, it has a list of all these characters ‘I’,  ‘ ‘, ‘a’, ‘m’,’ ‘ and so on and note the implicit null at the end. So, even though the double quotes ended just after n when you stored it in an array there is an implicit null that is inserted at the end of the array. So, when you print it will print until the null character. So, null character itself at the end of the string is not printed when you print it using %s.   Now, let us look at the following fragment to understand slightly in a deeper way what %s thus when you print it using printf. So, suppose I declare an character array using character str[ ]= “I am GR8DON”. So, this is initialized using the string constant which means that after the last end, there will be a null character in the array. Now, I initialize i I said str[4] = ‘\0’ note that there are 11 non-null characters in the string constant. So, this goes from str[0] to str[10] followed by str[11] which is a null character. So, now, I said str[4] = ‘\0’. So, somewhere in the middle of the string I put a null character. What will happen if I print it using printf %s? So, let us see what happens here I declare the array and initialize it using a string constant. So, it has all these letters followed by a null at the end. Then when I said str[4] = ‘\0’ what it does is it goes to the fourth location in the array and changes that to null. So, what that does is there was a space there before, but now you insert a null character there. After the null character there are other non-null characters and then there is a second one. What will happen when you print? It will just print I am and stop that it will not print the remaining characters and why does that happen? So, string of C as for as C is concerned is a sequence of characters terminated by a null, this null is not part of the string. So, they may be non-null characters after the first occurrence of null in str, but they are not consider part of the string str their part of the character array. But when you look at str as a string it is just till the first null character. So, when you print it using %s only the part until the first null is printed. So, that is considered the string the character array is bigger.   So, it will just print I am and stop there. So, do I lose the characters after the first null and where do they go? Well, of course they do not go anywhere they remain where they were. So, what is the new state of the array? The new state of the array is I am and then there is a null and then there are some other characters. So, if I print it using %s it will only come up to I am and then stop there. So, is there any way to print the remaining characters? Of course, there is a way right. So, if I print that using %s I will get I am, but I could easily write a loop like this. I will say int i and then for i = 0, until 11, i++ and then putchar(str[i]). So, this will print the character str[0] str 1 and so on up to str[11], regardless of whether that character is null or not if it is null it will do something, but it will still go on to the next character. If you run this what you will see is, it will print the first character which is I, then it will print the second character which is space, then it will print the third character which is a. So, these three are printed as they are and then m and the fifth is a null character. What do you mean by printing a null character? It may not print anything. So, it may be just kept, but then it goes on to the next character GR8DON and there it stops, because it does not print the eleventh character. So, the null character in this example is not printed. Now, the way the null character is treated on different terminals may be different. So, on some Linux terminals if you ask to print null character it will just not print anything, but other character terminals may print them in different ways.    In this video, we will *t with a topic that is considered one of the trickiest concepts in C. These are what are known as pointers. We will just recap what we know about arrays, because arrays and pointers are very closely related in C.  The memory allocated to any array has two components. First is there are a bunch of consecutively allocated boxes of the same type. And the second component is there is a box with the same name as the array. And this box contains the address of the first element of the array. So, that let us be clear with the help of concrete example. So, let us consider a particular array of size 10 declared as int num[10]. Conceptually, there are 10 boxes from num[0] through num[9]. These are all containing integers. Plus there is an additional eleventh box – num. So, it has the same name as the name of the array. And it contains the address of the first location of the array. So, it contains the address of num[0]. These are num[0] through num[9] are located somewhere in memory. So, maybe this is memory location 1000. So, num contains the number 1000, which is supposed to indicate that, the address of the first location in the array is 1000 or num points to the memory location 1000. So, conceptually, this gives 11 boxes, which are 10 integer boxes plus 1 box, which holds the address of the first box. Now, we represent the address of a box x by an arrow to the box x. So, addresses are referred to as pointers. And this is all there is to C pointers. Pointers in some sense are variables, which hold the addresses of other variables. That is an exact description of the concept of pointers. Now, we will see now what that means and what can we do with pointers.  Let us just step back a minute and say what can we do with a particular box or particular variable in memory, which is an integer. So, that is very simple. For example, you can scanf into that box; you can print the value in that box; you can do arithmetic operations on that box like plus, division, %, and so on. And you can do this for each of the boxes from num[0] through num[9], because each of them by itself is in integer. But, we will also see a new operation, which is that, you can take the address of a box. So, we have already done this when we did scanf. So, we mentioned & of a variable. So, we will see these & operator in somewhat more detail. So, suppose I want to take the address of num[1] and store it in an address variable ptr. So, what I am essentially saying is that, you can say ptr = &num[1]. So, num[1] is an integer box; it is an integer variable; & of num[1] is the address of that integer in memory. So, you assign it to the variable ptr. But, every variable in C needs to have a type. What is the type of ptr? And how do you declare or define such a type – such a variable? Now, ptr holds the address of an integer. In C, you denote that by saying that, the type of ptr is int *. So, here is a new type that we are seeing for the first time. We are saying ptr is of type int *. Just like you can say that, if I have int a, you can say that, a is of type int. In this case, we can say ptr = &num[1].  We have discussed right now we have int num[10], int *ptr, and ptr = &num[1]. So, ptr is the pointer to an integer. But, what does ptr = &num[1] really mean? So, let us look at the memory status once we declare this array. So, we have num, which is the address of the first location. And then we have somewhere in memory, we have 10 consecutive locations corresponding to the array – num[0] through num[9]. Now, I declare int *ptr. So, I create a box. Now, this box is supposed to hold the address of some integer variable. So, ptr is of type address of an integer box or more commonly referred to as pointer to integer. The statement ptr = &num[1] says that, now, points to num[1] or ptr contains the address of num[1]. And pictorially, we denote an arrow from ptr to num[1] just like I denoted an arrow going from num to num[0], because the name of the array is a pointer to the first location of the array. The name of the array is a box, which holds the address of the first location of the array. Similarly, ptr is a box, which holds the address of num[1]. So, we say that, ptr points to num[1]. And we denote it pictorially by an arrow.  The program status is like this – state is like this. Now, suppose I add one more statement after all these three statements; I say scanf(“%d”,ptr). Now, earlier when we declared an array and we read into an array directly, I said that, you can do the following. I can write scanf(“%d”,&num[1]). So, this will value whatever the user input into the first array using the & operator. Now, ptr = &num[1]. So, it is a reasonable thing to ask – can I say scanf(“%d”,ptr)? There is no & operator here because ptr is &num[1]. This was our original statement and this is our new statement.  And the answer is yes, you can do it. Suppose the input is 5, does num[1] become 5? So, scanf(“%d”,ptr) really does work like scanf(“%d”,&num[1]). So, it reads the value input by the user and it looks up ptr. So, it is an address. So, it goes to that address and stores it there. So, now, we can clarify a long standing mystery, which is the & operator in the case of scanf. So, we can say that, scanf second argument is a pointer; which says where should I put the input by the user? For example, if I have float variable and I scanf as %f and then sum address of a float variable, it is done similar to reading an integer into an integer variable. What scanf takes is an address of int variable or float variable as it may be. If you have a %d, then it takes a pointer to an integer variable and takes the input value by the user and puts it into that address. So, as far as scan f is concerned, it does not matter whether you gave it as &num[1] or whether you initialized ptr to &num[1] and then gave ptr. It is an address and it will put the integer input by the user into that location. So, num[1] indeed does become 5.  So, the location of the num[1] is now containing the value 5. Now, what else can you do with a pointer? Num is an array; it is of type int [ ] – pair of square brackets. And in C, the box num contains the address of the first location of the array, which is num[0]. So, internally, as far as C is concerned, the address of num[0] is just like address of any other integer location. So, the type int * can be interchanged with int [ ]. So, you can think of num itself as just a pointer to an integer; or, you can say that, it is a pointer to an array; which gives you the additional information that, the next 10 values are also integers. If you just say pointer to an integer, the next location may be something else. But, internally as far as C is concerned, an array name num can also be treated as pointer to an integer. Now, here are some other interesting things that you can do with pointers. Whenever you declare a data type, you also define what all operations can you do with a date type. So, 2 and 3 are fairly simple; we have already seen it with integers, floating points and so on. You can do simple arithmetic + and - with pointers. You cannot do * and /. You cannot do that. But, you can do + and -. Similarly, if you have two pointers, you can test for = =, you can test for <, you can test for > and so on as though you are comparing ordinary integers. So, 2 and 3 are what we have seen before; except that, in 2, you cannot do multiply and / and %. All these things are not done with pointers. But, addition and subtraction can be done. But, there is a new operation, which is dereferencing a pointer. We have not seen this operation before with earlier data types. (Refer slide Time: 11:10)  What is dereferencing? Let me pictorially represent what it does. Suppose you have int *ptr and int a. So, a is an integer variable and ptr is a pointer to int. If I want to store the address of a int ptr, I do it as follows: ptr = &a. So, this means that, take the address of a and store it in ptr. So, now, you can say that, ptr points to a. Now, I can also think of a reverse operation; which is ptr contains some address. Go look up that address; so that will be an int. And store that value in int.  So, that is what is known as the * operator – a = *ptr. This means that, ptr is an integer pointer. So, ptr will point to a location, which contains an integer. *ptr will take the contents of that location and store it in a. So, this is known as the dereferencing operator. So, the address operator takes an integer variable and stores the address in a pointer. The dereferencing operation takes a pointer; looks up that address; and stores the value in a. So, you can visualize the & operator and the * operator as sort of reverse operations of each other. & takes an integer and takes the address of that; * takes a pointer and takes the value of the address pointed to that.  Dereferencing a pointer therefore gives you the value contained in the box pointed to by the pointer. The dereferencing operator is *. So, if I say printf %d * pointer, what it will do is – look up the location pointed to by ptr. In this case, it is this integer box. The contents of that box is 5 and it will be printed. So, the output will be 5. Not for example, the content of ptr. So, the content of ptr may be like 1004; it will not print 1004; but what it is supposed to do is look up the location 1004; it contains the value 5; print that value. So, *ptr is the box num[1]. And printing it gives you the output 5. Now, can I consider a statement like *ptr = *ptr + 5? This is perfectly legal. What this will do is *ptr is an integer value. It is equal to 5, because look up this location ptr; that is an integer; take that value; which will be 5. So, this will be 5 + 5 – 10. And where do you store it? You store it in the integer variable corresponding to *ptr. The integer variable corresponding to *ptr is num[1]. So, I would have normally said num[1] equal to *ptr + 5; but num[1] is the same as *ptr. So, I can say *ptr = *ptr + 5. So, this will look up that location; add 5 to its contents; and store it in that location. So, num[1] will now become 10.  Similarly, you can consider other examples. For example, I can consider a statement like num of 2 equal to *num + *ptr. The novelty here is that...  In this video let me, so some cool stuff which is pointer arithmetic which helps you to understand the relationship between pointers and arrays in C.    So, let us consider in array declared as follows int num, and then it has 5 numbers in the initialization list. So, the array will be initialized as follows; there are 5 consecutive integer locations in memory with the given elements + there is a 6th cell which points to the first location in the array. So, num points to the first location in the array. If num points to the first location, then you can do the following operator num + 1. So, num + 1 with point to the integer box write mix to the integer box pointed 2 by num. And we also know that arrays are consecutively located. So, the integer box next to num is exactly num 1. So, num + 1 points to num[1]. Similarly num of num+2 points to num[2], and so on. Until num+4 = num[4]. So, this particular box, for example, num[4] can be accessed in two ways; you can write num[4] or you can write *(num+4). Can you tell me the output of the following printf statement. So, think about this for a minute, you have 3 integers to print using %d %d %d, and what are to be printed are *(num+1) *(num+2) and *(num+3). So, think about it for a minute…  Now, let us look at the slightly different array. What happens if you have a character array. So, I have char str array which is initialize to let say given string BANTI is a nice girl, and then I have a character pointer. So, char *ptr and it is assigned str + 6, it is initialize to str + 6, what will happen here? What is different about this example is that, earlier I said that in an integer array + 1 for example, would go to the next integer location in memory. So, wherever num was num+1 would go to the next integer location here, str is a character array. So, it has to go to the next character location, and that is exactly what it does. So, what is printed? Lets first consider the state of the memory. So, you have an array which is a character array, it starts from str[0], and goes on up to str[20]. So, there are 19 characters followed by the null character. Why is the null character there, because I initialize the two a string constant; every string constant has a null character implicitly at the end. So, this is the straight of the str array. Now I say that I declare a pointer, the pointer is pointing to a char. So, it is a char * pointer and what is the location it points to it points to str + 6. Str is a point out to the first location of the character array, and + 6 would jump 6 character locations away from str[0]. So, you would reach this character. The important difference between this example at the previous example is that, if you declared an integer array + 1 would jump 1 integer location + 6 would jump 6 integer locations. Here since such a character array str + 6 would jump 6 character locations. So, how the + operator is interpreted in the cases of pointer depends on what array am I pointing to right now? Now what will happen with the printf statement? So, if I say printf % as ptr what will happen? So, ptr points to str 6. So, printf will print whatever string is starting from that location until the first null character. So, it will start printing from this i, and then go on tip printing till it reaches the null characters. So, the output will be just is a nice girl. So, when you want to printf it is not important that you start from the absolute beginning of the array. We can start from arbitrary location in the character array, and if you say printf %, it will start from there and go on and print until the first null character.  So, let us look at it once more. So, it was the code that you had, and let say that the onedimensional array for this seek of convenience, I will just… So, it like this. It is actually in a row, but here is the first part, here is the second part, and so on. So, when I say str, str is a character array, and ptr + 6 would goes 6 locations away from the first location. So, str is pointing to then first location in the array, it will go to the 6th location in the array ptr, and ptr is pointing to the 6 location.  So, you can ask more expressions do the make sense, can I say str + 5 is the this location. Similarly can I say str + 10 is this location, and so on. So, these are all correct expressions. Now can you tell the output of printf % ptr -5, we have talked about + operator on pointers. So, it will whatever the nature of array that the pointer is pointing to it will jump n locations away from it. So, if I say ptr + n, it will jump n locations of that type away from it. So, by the same logic can I argue that if I do -5 ptr -5 can I say that it will go 5 locations previous to what ptr is pointing to right now. And the answer is yes.  So, it will behave exactly as you expect. So, ptr is pointing to this location, here is the previous location. So, it will jump to 5 locations before the location pointer 2 by ptr, I will happens to be A. So, the location which is str[1], that is = ptr-5. So, if you printf on that location, it will say BANTI is a nice girl, that is the output.  Before I proceed this one thing that I want to emphasize, and it is often not emphasized when you see online material on pointer arithmetic. C pointer arithmetic is not suppose to be meant for navigating the array, meant for navigating arbitrary locations in the memory. So, you cannot take a pointer. Let say character pointer and just say pointer + 1000. It will give you some location in the memory, but the behavior of the program will be undefined. So, the c pointers are well defined, pointer arithmetic using C pointers are well defined only when the pointers are pointing to locations within an array. So, within an array + n will take you n locations away from the given pointer, -n will give you -n away from the give behind the given pointer and so on. Whatever type the character of whatever type the given pointer is pointing 2. So, the main point of lecture was that if you have let say for example, and integer array int num 10, then num of 5 which is the array notation is exactly equivalent to *(num+i). And I am not saying this that you can think of num of 5 as *(num+i), it is not an analogy this is exactly what C actually does. So, num of 5 is translated to *(num+i). So, arrays and pointers in c are very intimately related.   So, here is the stuff that we have seen about pointers. First we have defined what is a pointer? A pointer is just a variable that holds the &another variable. We say that pointer points to another variable. And depending on what variable it points to, the type of that target, we say it is an int pointer or a character pointer or a float pointer and so on. So, this is the first thing what is a pointer? And then we have seen what all can you do with a pointer; what are the operations that you can do in a pointer. So, if you have a normal variable, you can take the &that variable using the & operator. If you have a pointer, then you can dereference the pointer by using *(ptr). That will go to the location pointer 2 by ptr and take the value of that target. Further we have seen pointer arithmetic involving + and -. And I have introduced you with the caution that they are meant to navigate within arrays; they are not meant to navigate to arbitrary locations in the memory. If you do that, it may or may not work. And further we have touched up on the intimate relationship between arrays and pointers in C. As captured by the formula, array[i] is *(array+i). A special case of this is to say that the name of the array is an &the first entry in the array. For example, array[0] is the same as *(array+0). We have seen this and think about them once more to get comfortable with the notion.  In this video, we will talk about how pointers interact with functions. When we introduced arrays, we first said here are arrays; here is how you write programs with arrays. And then we introduced… Here is how you pass arrays into functions. Let us do that the same thing with pointers. So, here are pointers. And how do you pass them to pointers? Before coming into how do you pass them to pointers, we will go into – why should you pass pointers to functions. So, let me introduce this with a very standard example. This is a classic example in C. How do you exchange two variables? We have seen the three-way exchange; where, I said that, if you have three rooms: A, B… I have two full rooms: A and B.  And then I want to exchange the contents of these rooms; then I can use a third room. First, move the contents of A to T; that is your first move. Then move the contents of B to A; that is your second move. And then afterwards, A now contains the contents of B; and B is empty; T is containing the contents of A. So, the third move is – move T to B. So, the net effect will be that, B contains the whole contents of A; A contains the whole contents of B; B contains the whole contents of A; and T is empty. So, this was the threeway exchange, which we did within main function. This is long back when we discussed GCD algorithm.  Now, let us try to do that using a function. So, I have a swap routine, which takes two integer arguments: a and b; and it is meant to exchange the values of a and b. So, inside main, I have a = 1, b = 2. And I call swap a and b. And swap a and b – what it does is this three-way exchange that, we have discussed. Now, just to test whether things are working, I have a bunch of printf statements, which says what is the value of swap, what is the value of a and b after swap has executed. Similarly, when I come back, I will just print the values of a and b to see what has happened after swap. So, when you call swap and you output it within swap, it is very clear that, a = 2, b = 1. So, the three-way exchange would work as you expect. And you have whatever was passed, which is swap1, 2. So, it will exchange those variables and it will print a = 2 and b = 1. Now, within main, a was 1 and b is 2. Now, when you print these statements inside main, surprisingly, you will find that, a = 1 and b = 2. So, the effect of swap is completely absent when you come back to main. Within swap, they were exchanged. But, when you come back to main, they were not exchanged. Why does this happen? This is because remember that, some space is allocated to a function; and whatever space is allocated to the swap function, all the variables there is erased – are erased once you return from the swap function. So, within swap function, a and b are exchanged. But, all that is gone when you return to main. So, passing integer, float, character variables as parameters, does not allow passing back to the calling function; you have only the return value to return back. Any changes made within the called function are lost once this function returns. So, the question is can we now make a new function such that work done within that function will be reflected back in main.  Now, here is an intermediate solution. We know that, if we pass arrays, then work done in the called function will be reflected back in the calling function. So, you could think of the following intermediate function. So, if I have int num 2 and then I say that, num[0] is 1, num[1] is 2. This is in the main function. And then I call swap of num. Now, we will call it swap1(num); I have a new function. Now, what swap1 does is – so int swap1 int arr. So, suppose I have this function; inside that, I will just say that, I will have an intermediate variable t; and then have t = num or arr[0]. Then arr[0] = t; arr[0] = arr[1]; and arr[1] = t. Suppose I have this function. And now, you can sort of argue that, this will also swap the two cells in the num array. So, the dirty trick that I am doing is that, I want to swap two variables; instead, I will say that, instead of these two variables, I will insert them into a array of size 2; and then call swap1 on that array. Now, what swap1 does is – it will exchange – it will do the three-way exchange on the array. Now, I know that because of the way arrays are passed in C, any change that happens to the array arr inside swap1 will be reflected back in main. So, when I print these num array back in main, I would see that, num[0] is now 2 and num[1] is 1. So, this is an intermediate trick in order to write the correct swap function. But, you will agree that, this is a kind of a dirty trick, because in ordered to swap two variables, I created an array; and then depended on the fact that, swap will change the array in such a way that, the change will reflected back in main. So, is there a nicer way to do it? That is what we are interested in. And the answer is let us just think about that array trick. What we did was – when we passed an array, we were of passing the &the array.  This is how arrays are passed to functions. So, now, let us just take that idea that, we are passing the address. So, let us try to write a swap function, where you are passing the &variables instead of the variables themselves. So, here is the correct swap function. And what I write is void swap. So, void is a new keyword that you will see; but it is not a big deal; it is just a function that does not return a value; it just performs an action without returning a value. So, such functions you can write it as void – void swap int *ptra, int *ptrb. So, ptra and ptrb are pointers. Now, inside the code, you have something that looks like a three-way exchange. It is very carefully return, because the obvious way to quote the function is not right. So, you have to be slightly careful; you have to declare an integer variable. Now, t contains *ptra; *ptra = *ptrb; and *ptrb = t. The obvious way to write it seems to be – you declare an integer *ptr t and then do this. It is not quite right; we will come to that later. So, here is the swap function. And how do you call the function? You declare two integer variables in main: a = 1 and b = 2; and then pass the addresses using &a and &b.  So, let us just trace the function. You have two variables in main; a = 1, b = 2; and call swap(&a and &b). Now, just to denote that, these are addresses, I will say that, these are… a is situated at location 1024 in hexadecimal. So, this is some location in memory – hexadecimal 1024. And this is some other location in memory; b is say at hexadecimal location 2000. Now, do not be distracted by the hexadecimal notation if you are uncomfortable with it; just write 1024 in an equivalent decimal notation; and you can say that, it is at that location. So, it is at that location. And I am representing the location in hexadecimal, because it leads to shorter addresses. And this is also an address. So, when I will take &a, I will get 1024x in… When I take the &b, I will get 2000x. So, this is the &a. And it is located at memory location 1024 when represented in the hexadecimal notation.  What happens when you call the swap function? So, here is the state of main. And when you call the swap function, a new bunch of memory – a new block of memory is allocated on the stack. So, first, the formal parameters are copied their values from the actual parameters. So, ptra will get &a, which is 1024; ptrb will get &b, which is 2000. Now, I declare a new variable t; t = *ptra. So, what does that mean? ptra is an address – dereference the address; which means go look up that address. So, it will go to this location and get that value. So, t will now become 1. And the next statement is somewhat mysteries; please understand it very slowly. So, on the right-hand side, you have *ptrb. This means dereference ptrb. So, we are saying ptrb is address 2000; when you dereference it, you will get the value 2. Now, where do I have to store that value 2? For that, dereference ptra. So, 1024 – dereference it; you will go to this box. That is where you have to store 2.  So, 2 will go to that location. So, what has happened due to that is that, a in name has now changed. Why? Because within the swap function, we were dealing with pointers. So, as a result of the statement *ptra = *ptrb, it has taken 2 from the main functions b and put it back into the main functions a. And that was accomplished through variables inside swap. So, think about it for a while. And the last statement of course is *ptrb = t. So, dereference ptrb and put the value 1 there. So, here is a three-way exchange that works through variables only in swap. But, since they were pointer variables, you ended up changing the locations in the main as well.  And once you return, all the memory corresponding to swap will be erased. But then when you to main, a and b will have changed. a and b were 1 and 2 before. Now, a is 2 and b is 1. So, it has correctly swapped. Now, as an exercise, I said that, the obvious way to write the swap function is as follows. Void swap a int *ptrb; ptra and int *ptrb. And then I declare int *ptrt. And then I write these statements. This is a very obvious way to code swap. This does not work. So, try to draw these pictures as we have done with a swap function that actually worked. Try to draw the picture of what happens in main and what happens in the swap function. And understand why this particular swap function does not work. One final word about passing pointers to functions; C has something called a call by value mechanism. What is meant by call by value is that, when you call a function, remember the original picture that, your friend came with his note book and copied down the numbers in your page. So, your friend created a separate copy of your arguments; then computed what had to be computed and returned you a value. That picture is essentially still correct. Even though you are now dealing with functions, which can manipulate memory inside main, the passing mechanism is still call by value. It is just that, what is being copied are the addresses. So, when you manipulate the addresses through dereferencing, you end up changing the location inside main. So, even with pointers in C, what happens is call by value.  Since pointer arithmetic is a tricky concept let us solve one more problem to try to get comfortable with that notion.  So, the problem here is copying a sub array into another array. Now, let us explain what that means?  Suppose, I have written a function copy_array() which has three arguments an integer array a[ ] and integer array b[ ] and n which is the size, I want to copy n successive index elements from a and put it into b. So, a is 0 through a n - 1 have to be copied to b. I can easily write it in the following function has int copy_array int a, int b, int n and then I have one variable to keep track of the index and that variable goes from 0 to n, for i = 0, i < n, i = i + 1 and then I simply say b[i] = a[i] within the loop. So, this would copy whatever a[i] is into the location b[i]. So, once the loop executes, I would have copied n elements from the array a to the array b. But, this is not general and I want to solve the following problem, I have two arrays let us name them from( ) and to( ) and I want to copy n numbers from the array from[ ] to to[ ]. But, I have an additional requirement, I want to copy n elements from index i. So, the earlier code solve the problem from index 0 in general I want to copy from index i of from[ ] in the elements into the locations starting at index j in to[ ]. So, the earlier function assume that i and j were both 0. In the general function I want arbitrary i and arbitrary j. So, I need a declaration like the following, I have int copy_array_2. So, this is the second function I am writing and I have from i to j and then n is the number of elements to copy. So, what I have to do is from i from i + 1. So, on up to from i + n - 1 have to be copied to to[j], to[j+1] so, on up to to[j + n - 1]. So, for the purposes of this lecture let us just assume that from[ ] and to[ ] are big enough. So, that you will never ever over suit the arrays by taking i + n -1 and j + n - 1. Can you write this function? Now; obviously, you can write a separate function to solve this. Now, the trick is can you use the copy_array() function, the copy_array() functions copied n elements starting from index 0 of a to index n - 1 to the array b starting at index b [0] to b[n – 1]. So, that is what is it means. And this should be strange, because if you think about it in a mathematical way, you are saying that a general function is being solved in terms of s particular functions. So, you are reducing a general case to a special case at sounds a bit strange. But, we can do this with pointer arithmetic.   So, here is a problem that I have and I want t[j] = f[i], t[j + 1] = f [i + 1] so, on upto t[j + n – 1] = f [i + n -1]. So, let us try to see what happens in this function? Suppose, I call copy_array_2() from name, using the arrays f, t, i, j, n and that function nearly calls the old copy_array() function, using f + i, t + j and n. So, this state of execution at the start of copy_array_2(), let say that f [ ] is an array with say 10 elements and t[ ] is an array with say 10 elements arbitrary and what I want is I also assume that i is 2 and j is 4. So, I want to copy 5 elements starting from the second location or the third location in f f[2] onwards to the fifth location in t onwards. So, here is what I want to… So, I want to copy this - 1, - 1, - 1, - 1, - 1, to t [4] onwards. So, I will copy them here, so, 5 elements are to be copied.  Let see; how our, function is able to do this. So, t + 4 is this location f + 2 is just location. So, what I am calling is the old copy_array() function with f + i,. So, f is the address of the first location of the array. Therefore, f + 2 using pointer arithmetic is the second integer box after that. So, it is pointing to f[2], similarly t + 4, t + j in this case is pointing to the fourth location after the location pointer 2 by t, t is an array. So, t points to the first location in the array therefore, t + 4 will point to the fifth location in the array. So, when I say f + 2 f + 2 is a pointer 2 here and t + 4 is a pointer 2 here and I am calling copy_array() function with these as the arguments and n is the number of elements I want to copy.  So, here is the state just before I call, copy_array() function. Now, for example, this particular box has several names, the most common name for it will be f[3]. But, I can also write it as *[f + 3], this says jump 3 integer boxes after f and then dereference that address. Now, if you are comfortable with the notion that let us say f[i] is the same as *[f + i]. If you are comfortable with that notion, then you should be easy to see that (f + 2)[1] is just *[f + 2 + 1] . It is the same formula that I am using and this happens to be f + 3, which happens to be f [3]. So, *(f+3) would be f[3] and so, on. So, this formula that f[i] is the same as dereferencing the address f + i, f[i] = *(f + i) is applicable even for more strange looking expressions. (Refer Slide Time: 09:to6)  Now, here is a trivia about c, that because of the way it is defined. So, if you say that f[i] is the same as *(f+i), then you could think that this is the same as *(i+f). So, I can write this as i of f never do this, but it will actually work. So, f[i] you can also write it as i of f. For example, 3 of f and it will also work, because internally c translates it to *(f+i) and we know that *(f+i) is a same as *(i+f). So, never do this, but this helps you to understand that f[i] is being translated by c into this format.   So, now, that we know this, similarly you can argue about *(t+4) and (t+4)[0] and. So, on all of them refer to the same box.  Now, let us see what happens when we call copy_array(). So, we have the stack space for copy_array_2() and copy_array_2() calls copy_array(). The formal parameters are a and b, a copies the address it was passed to, it was passed the address f + i. So, a points to f + 2, similarly b points to t + 4,. So, b points to this. Now, as for as copy_arrays concerned it is not too bothered by the fact that, it was not passed the absolute first address of the array. It will think that whatever address it has been passed is the start of an array and it will work from there. So, copy_array() does not bother the fact that, I was given the second element of the array, rather than the first element of the array and so, on, it will work as though the array started from there. And here is where we are exploiting that fact so, you now copy n elements from this location to this array, so, n is 5.   And when you execute the loop, it will start from this location copied to t + j then f + i + 1 will be copied to t + j + 1 and so, on. So, it will copy these five locations to here in the t array.  And after you do this copy_array() returns and every variable that was allocated to copy_array() is erased. But, then because of pointers it was actually working with the arrays in copy_array_2(). So, even when you erase all the memory allocated to copy_array(), once you return these arrays would have been changed. These five locations starting from f + 2 have been copied to these five locations starting from t + 4. So, changes made to b[] by copy_array(), is still maintained after you returns to the calling function copy_array_2().  In this lecture will see some more pointer arithmetic operators, and we will introduce those by talking about them through a problem.    So, the problem that I have is that of reversing an array. So, we have to write a function to reverse an array, and let say that the declaration of the function is void rev_array (int a[ ], int n[ ]). Now if you have to reverse an array, what is one way to do it you take the array copy to into another array, and then copy back in the reverse fashion. So, you have an array a[ ] copy all the values in to b[], and now you copy those values back to a in the following way that the b, b is last value will go to a[0], b is second value last value will go to a[1] and so on. Now, let us try to do it slightly more cleverly, we want to take an integer array and reverse the array in place. That means that essentially using no extra space. So, do not use and extra array in order to reverse it, reverse it within a itself. So, the array before calling reverse array will look like a[0] upto a[n-1] in this way. And after calling reverse array it should look like a[n-1] a[n-2], etcetera up to a[0], and we doing that we should not use an extra array.    Let us try to code this up. So, how is the reverse array return first I need... So, remember how we did this by hand, we exchange the 0 th location with the last location, then we exchange the first location within second last location, and so on. So, it is easy to code, if you have two pointers; initially one pointers starts to at the beginning of array, the second pointer is to the last of the array exchange those values, then the first pointer goes to the next location, and the second pointer goes to the previous location, that is how you did it by hand. So, let us try to code that up I will have a pointer *b, which points to the last element of array a + n - 1. Now, the loop is as follows, I will discuss this in a minute while b < a. So, remember in the example by hand, we had to exchange till we reach the middle of the array. How do you find the middle of the array, I will just write it as b > a, and I will explain it in a minute. So, while this is true that you have not a ((Refer Time: 04:25) the middle of the array. You exchange swap a and b, here we use the swap function which we have seen in the previous lecture. So, for example, it will swap the 0 th element with the n - first element. After that is done you increment a and you decrement b. So, the design logic is that a initially points to that first element of the array - the left end of the array, and b points to the right end of the array.  So, we are seeing a new concept which is relational comparison between two pointers. If a and b are pointers to variables of the same type like int *a, int *b. We can compare them, compare these pointers using =, and not =. This can be done for arbitrary locations a, and b as long as those locations are of the same type. So, a = b is true, if and only if a and b are pointing to the same location; that is natural to expect. Otherwise if they are pointing to different locations a not equal to b is true. Now there is another case, if a is pointing to an integer let say, and b is pointing to a float then equal to and not equal to are undefined. So, notice that even though this behavior looks natural, it is natural only if there pointing to this same type. So, here are operations equal to and not equal to.  What about less than less than or equal to greater than greater or equal to and so on. And this is surprising, because here is something that you do not expect. You cannot compare less than less than   equal to on arbitrary locations in the memory. We can compare a and b using less than for this they must be pointing to the same locations in the array. Earlier when we discussed + and -, we were saying that + and - are well behave the only when you are navigating within an array. Similarly, when we are comparing 2 pointers using greater than greater than or equal to less than less than or equal to, then they should all be point then a and b should be pointing to the same array, different locations in this same array. If that is true then a < b, if a is pointing to a location which is before b in the same array. Similarly a < or = b yes true if a is pointing to a location which is b or before b, and so on. So, for example, we can say that if you have an array int a[10], then a + 1 < a + 2, that is clearly true. Because a + 1 is pointing to the location one in array and a + 2 is pointing to location two in the array.  So, if you have an array for an example let say a[0] through a[9], and ptra is pointing to location one, and ptrb is pointing to location three. Then ptra < ptrb here the comparison is well defined and it is true.   But on the other hand let say that ptra is pointing to a[1], and ptrb is pointing to b[1]. In this case ptra < ptrb is undefined, because their pointing to two different arrays. So, may be in memory a is lead out before b and so on, but that is not what the < or = operation is supposed to do. It is suppose to compare pointers only within the same array.   So, with this understanding let us understand how the reverse array works. So, in the first iteration, you have an array a[ ], let say that array is 101, 21, and so on, it has 6 locations. And we will run through that trace of the execution for an even length array, and I would encourage you to create and odd length array, and trace to the executions to ensure that the code works for odd length arrays as well. So, in this lecture will do it for an even length array. So, a is initially pointing to the beginning of the array, b is pointing to the end of the array, a + n - 1 will go to the end of the array. Now b < a that is true. So, we will enter the loop and in the first iteration we will swap a and b.    So, it will go to the swap function, and this is the swap function that actually works from the previous video. So, you can assume that a[0] will be swapped with a[1]. So, they were initially 101 and 0, and after swap they will be 0 and 101. Come once that happens a advances by one integer location b goes back by one integer location. So, this the state after the first iteration. In the second iteration you start with a at 21, and b at - 101, again b < a, so is swap.    So, 21 - 101 becomes - 101 and 21, so they are swapped. And you advance a by 1 and you take back b by 1, again b < a.   So, you go to the third iteration. In the third iteration this the state of the beginning of the iteration, and the swap these contents. So, you swap - 1 and 121 it becomes this becomes the state of the array, and once that is done b over suits. So, b b goes before a, and a go goes after b, swap denoted there with two colored arrows. So, here is the b arrow, it goes to location 121, and a arrow goes to location - 1. When this happens b is now < a. So, this means that you have cross the middle of the array. Therefore, you should stop now. So, now b < a, and the loop terminates, and we have seen that this correctly reverse the array. So, here is how the reverse array works, we have seen the concept of relational comparison operators using pointers. How do make sense when they are pointing to locations with them the same array, and how that can be used to write code to using arrays.  In this video, we will see the sizeof operator, which is a slightly advanced topic, in relation to pointer arithmetic. This is explaining, how pointer arithmetic freely works. And it is also important to understand one topic that, we will see later on and called malloc.  So, the sizeof operator and note that, it is an operator and that highlighted that in red, it looks like a function call, but it is not. The operator gives the number of bytes that any value with the given type occupies. So, sizeof is an operator which takes the name of a type of as an assigned argument, it can also take other kinds of arguments, we will see that. So, you could ask, what is the sizeof an int? What is the sizeof a float? What is the sizeof a character? And the answer, the value that it will come out to be will depend on some particular machine. So, the reason why we use the sizeof operator is that, it helps you to write the code that is general enough for any machine, we will see, what that means? So, right now you just returns you the size of any given data type.  So, the sizeof operator has an effect on the way data is allocated and the way details allocated depends on the machine, we will see that. So, for an example if you have a character array, the cells are 1 byte apart. So, sizeof operator returns you the number of bytes that a data type occupies. So, in the case of a character, the character occupies 1 byte. So, if you have a character array declared as char s[8], what you have are, 8 cells and each of those cells occupy a width of 1 byte. So, let us say that the character arrays starts at hexadecimal address 1000. So, the next cell will be at the next byte, which is byte address hexadecimal 1001. And this goes on until the last cell which is hexadecimal 1007. So, this contains a null terminator character array with the letters s u c c e s s and then followed by a null. What happens with an integer array? So, in an integer array, sizeof an int is 4 bytes. So, the successive elements of an integer array are 4 bytes apart. So, let us say that I have declared an integer array as int a[4]. This means, that a 0 let us say, it starts at hexadecimal address 2000. Then, a 1 will start 4 bytes away, because the size of an int is 4 bytes. So, it should start at address hexadecimal 2004 and I have sort of indicated it pictorially I want to say that a character is a narrower data type than an integer, an integer occupies 4 bytes. So, the next integer cell, the next integer element in the array will start at hexadecimal address 2004. The third element will start at hexadecimal address 2008 and the last at hexadecimal address 200c. So, notice that I should have started it at 2012. But, 12 in hexadecimal addressing scheme is c. So, in base 16, c is the same as decimal 12. So, that is why I have written it as hexadecimal 200c.  Now, let us look at pointer arithmetic in greater detail with our current understanding of the sizeof operator. So, suppose you have an int *pointer. If you have an int  *pointer and then you want to say that ptr + i is equal to, what it should? So, notice that + make sense, when you are navigating within an array. So, ptr is let us say pointing to some cell within the array and ptr + i should go to the ith cell after ptr, that is what, it should do. Now, the i th cell after ptr means the i th integer after ptr. So, we should skip 4 i bytes in order to reach the i th integer cell after ptr. So, thus is what we have written here ptr + i is the byte number, ptr + i*sizeof(int), the machine addressing goes in terms of bytes. So, in order to jump to the ith integer cell, we have to know, how many bytes to skip? And the size of an integer is 4 bytes. So, this means we have to skip ahead 4 i bytes, in order to reach ptr + i. Now, if have we declared character *ptr, then ptr + i is supposed to jump to the i th character after ptr size of a character is 1 byte. So, ptr + i*sizeof(char) would be ptr + i*1, it is the same as ptr + i. So, notice that let us say that, machine understands only byte addresses. So, in order to execute ptr + i correctly, we have to tell which byte should I go to, should the machine go to? And in order to do that, you utilize the sizeof operator. So, since we have declared character *ptr, you know that it is sizeof character, i*sizeof character those many bytes I have to skip. In the previous case, I have declare int *ptr. So, in that case I have to skip i*sizeof (int), in order to reach the correct cell. So, here is the actual reason why ptr + i would magically work correctly. Whether, it was an integer array or it was a character array? This is because, at the back of it all, you translate everything to byte addresses using star sizeof whatever type. So, in general if you have type *ptr, then ptr + i is the byte number ptr + i*sizeof (type). So, this type is the same as the declared type of pointer, ptr is a pointer to that type. Therefore, you multiply it with sizeof(type) and this is the general formula for pointer arithmetic. Now, one of the side effects of that or one of the consequences of this kind of addressing is that, array + i is *(array + i) and it will correctly jump to the i th location in that array, regardless of whatever type the array was. Why is that? Because, array + i is then translated to array + i*sizeof whatever type the array has been declared to be. So, you will correctly jump to the byte address corresponding to the i th element in the array. So, here is how array arithmetic in c works, in full. What do we mean by this? Let us see that with the help of an example.  Suppose, you have an integer array declared as int a[10] and it starts at the address 2000. And I want to know, how is it that you get this third element of the array a[2]. So, a[2] we know is *(a + 2), a is a pointer to the first element of the array. And you have to now understand, how + 2 is executed? So, + 2 should be the content located at byte address a + 2*sizeof(int). Why is this? A is been declared as integer array. And in c, integer array has the same type as int *. So, a is a pointer to int. Therefore, we know that, we have to do a + 2*sizeof (int). Whatever the argument is, it will do 2*sizeof the type pointer 2 by that pointer. So, we will do a+2*4, which is hexadecimal address 2008, a was 2000. So, if you have an array int a[4], let say and it started at address 2000, then you will jump to array address 2008. And this is the reason, why c arrays start at index 0? Because, it is a very easy formula, a[0] would be *(a+0), which is simply *a. In that case, you have the consistent explanation, that the name of the array is a pointer to the first element of the array, you do not need a special rule to do that. Think of what would have happen, if arrays started at 1. Then, a[2] would be a+1*sizeof(int). So, a[n] would be a + n - 1 times sizeof whatever and that is an uglier formula than what we have here. So, it is better for arrays to start at location 0, because it makes the pointer arithmetic easier.  So, in summary the sizeof() operator is used in pointer arithmetic and we will see one more common use of the sizeof() operator, very soon.  So, the general usage is you can give size of an expression. What will it do is, it will take the type of that expression. So, if I say sizeof(10), then 10 is an int,. So, it will execute sizeof int and let us say that, on a particular machine it is 4 bytes. Similarly, you could also say sizeof type name. So, for example, I could say sizeof(int). Rather than giving an integer as an argument, I could also say sizeof(int), where int is the name of the type and it will return 4 on some particular machine. A less common usage is, you could give sizeof array, if the array is some particular array and it will return you the size of the array in bytes and this is important. It will not return you exactly the number of elements in the array, it will return the total size of the array in bytes. What do I mean by that? If I say, int num[10] and then I say sizeof(num), it will return is 40 because, there are 10 integers, each integer occupying 4 bytes. So, in order to calculate the number of elements in the array, for example, you could do the following, you could say sizeof(num) / sizeof(num[0]). So, this would evaluate to 40/4 which is 10. So, size of the operator on the array does not exactly give you the number of elements in the array, it will give you the total number of bytes in the array. But, if you also know how many bytes, the particular element in the array occupies, then you can easily figure out the size of the array, in terms of the number of elements. So, also note that c does not say that, an integer is 4 bytes or float is 4 bytes and so, on. What it specifies is the relationship between the sizes of various types and we will not get in to it, right now. But, just keep in mind that the size of a particular type is depended on, which machine you are running the code on.  In this video, we will discuss slightly advanced usage of pointers. Even though, the title of the first slide is, how to return pointers from a function? That is just a motivation for introducing a slightly more advance topic in pointers.  So, let us just see what is the problem with returning a pointer from a function? We know that, any variable can be passed as argument to a function, can be declared as a local variable within a function, and can also be a return from a function. So, is there something and we have already seen that, in the case of the swap function how we pass pointers to a function and what new kinds of functions does this enable us to write?  Let us examine that in slightly greater detail. What happens when we call the increment function? Inside the main function, we have an int pointer p and then it is declared, it is not pointing to anything and immediately, you will call increment(1). So, you call increment(1), n is a local variable in increment, it is the argument. So, n is 1 and then, you declare a temp and then, you declare a pointer to temp,. So, there is a ptr. Let us say that, temp is a address hexadecimal 1000. So, ptr contains 1000 and it points to temp, temp is at address 1000. Now, in the next statement you increment temp, you set temp to n + 1,. So, n is 1 and temp is 2. Now, ptr points to temp and now, I will return ptr. So, the return value is 1000, which is the address of temp.  Now, what happens when you return to main? As soon as increment finishes and we have said this several times before, as soon as any function finishes, the memory with that is allocated to the function is erased. So, when you return to the main function, what happens is that, you have p and p will contain the address 1000. So, it is meant to point to temp. But, the space meant for temp has already been erased. So, p is pointing to a junk value in memory, it is pointing to an arbitrary location in memory. So, this is known as a dangling pointer. Hopefully, the picture is a representative of a dangling pointer. The fact that, it points to a location, which is no longer meaningful. Notice that, what I am talking about is the ideal situation, when you code it in c and try to run it, may be p does point to the location with address two. This is because, c may not be aggressive in re cleaning the memory. But, you should always assume that, the safe thing is to assume every location that was allocated to increment is erased immediately after increment returns. In practice, it may not be the case,, but you should never assume that, you still have the temp variable. In general, what you will have is a dangling pointer. Because, p points to a location which no longer contains any relevant information. So, when you print p, you will have a danger. So, how do you return pointers from a function? So, we have seen what a dangling pointer means? And here is a very silly function, which will create a dangling pointer. Now, what is the problem with this function, it returns the address of a local variable temp. But, temp is erased as soon as increment n returns. So, the return value is not a meaningful address to the calling function, which is mean. Can we get around this?  So, the main problem here is that, anything that is allocated to the called function on the stack is erased as soon as it returns. Is there any way at all to meaningfully return pointers to new variables? Then, use a new concept that is a globally accessible memory called heap, we have already seen a stack. Now, we will understand what a heap is. So, roughly the idea is that, if you allocate value on the global memory, it is not erased when the function returns.  I will explain this with the help of a slightly a broad analogy. Hopefully, this is indicative of what actually happens with the heap? So, think of executing a function as writing on a classroom blackboard, when a lecture is going on. Once the function finishes execution, which is like the class is over, everything on the blackboard is erased. Suppose, you want to retain a message after the class is over. Now, the solution could be that you can post things on a notice board, which is global to all class rooms. So, it is common to all class rooms. So, things on the notice board are not removed as soon as a class is over. If you write something on the blackboard, which is similar to storing something on the stack, as soon as the class is over, it will be erased. So, if you have something to communicate back to another class, may be you can post it on a notice board. Now, the notice board is globally accessible to all class rooms. The black board is like a stack and the global notice board is like a heap and contents on the heap is not erased, when the function finishes.  So, how do you allocate things on the heap? There is a standard library function called malloc, in the file stdlib.h which can be used to allocate space on the heap. Roughly, this is what it does, if you ask for malloc(n), there n is an positive integer, it will allocate n bytes of memory on the heap and it will return a pointer to the first location of the allocated space. Now, that pointer can be converted to pointer of any type, malloc just allocates n bytes. Now, you may want to interpret those bytes as n divided by 4 integers. In that case, it will return a pointer,. So, you convert that pointer to an int pointer. Let us see an example I may have an ints pointer for ptr and now, I want to allocate 10 integers on the heap. How do you I do that? I will allocate 10 * sizeof(int). So, this will allocate on some particular machine, let us say 40 bytes and it will return an address of the first location. Now, that address I want to treat it as an integer address. So, I will convert it to an int as int * and then malloc (10*sizeof(int));. So, this style of writing code means the code portable. Because, suppose you write the code and on a machine, where integer was 4 bytes and you take your code and go to a bigger machine, which has 8 bytes as the size of an integer. Then, you compile the code on that machine and your code will still allocate 10 integers. Why? Because, on the new machine sizeof(int) will be automatically 8. So, it will allocate 80 bytes. So, in order to write portable code, you can use sizeof(int), instead of assuming that, integer is 4 bytes. So, I want to allocate malloc (10*sizeof(int));, this will allocate 10 integers no matter, which machine you do it all. So, and it will return you the address of the first byte in that allocated space, that address you convert to an integer array, integer pointer. Here is, how you allocate memory on the heap.  So, when we think pictorially, think of heap has a separate space in the memory. In this case, ptr will be allocated some space on the heap. Let us say 10 integers on some particular machine, it will say 40 bytes and it will return the address of the first byte. Now, that first byte you treat it as a pointer to int, that is done through the conversion int *.  Now, it is nice that you can allocates space on the heap. But, in order to be hygienic, you should also remove the allocated space, once you have done with it. There should be a reverse operation to allocate and that is free, it is in the same library, stdlib.h. And if I just say free(ptr) and ptr was originally allocated using malloc. Then, it will correctly remove,; however, many bytes were originally allocated. So, let us say that I have int *ptr and then ptr, I allocate 10 integers on the heap and ptr is the address of the first allocated location. Now, I may do a bunch of processing here and once I have done, it is just nicer me to de allocate things on the heap. This is like, saying that things on the notice board once some condition occurs, where you know that the notices no longer needed, you just remove that posting from the notice board for that, we use free of ptr. Now, notice the asymmetry here, malloc took the number of bytes to be allocated free just wanted to say, which pointer is to be free? It does not ask for, how many bytes to free? So, you can imagine that malloc does some kind of book keeping, where it says that I allocated 40 bytes and that was return to ptr. So, if I just say free(ptr) it automatically knows that, 40 bytes are to be free, you do not have to give the extra argument saying, how many bytes to free? Once you free the pointer, you just set it back to null, this is just a safe practice and it is not absolutely necessary,, but it is recommended.  So, let us solve our earlier problem using malloc. Our earlier problem was that, ptr was pointing to some location within the stack. So, as soon as the function returned, the return address no longer meant any meaningful address. So, let us now solve this problem. I have included stdlib.h, because I will allocate memory on the heap. So, the increment function is modified as follows strictly speaking, I do not need a temp variable any more. I have an int pointer and I will use the pointer to allocate one integer on the heap, this is a really wasteful practice but, it just illustrates a point. So, it will allocate one integer on the heap and then, return that address and treat that address as int *. Now, I will use * ptr = n + 1 to dereference that location on the heap and set the value to n + 1. Once I am done, I will return the ptr I will return the address on the heap.  What happens here is that, the increment function ptr points to some location on the heap, using malloc. So, one integer is allocated on the heap and when you say, *ptr = n + 1’s, then the location in the heap will contain 2.  And here is the catch, earlier p was just dangling, it was just pointing to an arbitrary location in the memory. But, increment allocated something on the heap and returned that address. As soon as increment returns, the stack is a waste. So, everything that was allocated on the stack for increment is erased,, but things that are allocated on the heap remain. So, p points to a meaningful address on the heap, then once you are done you can say free(p) and things will be erased, when you print it, the output will be 2.  Malloc and free are prone to a lot of errors and a lot of programming errors in c, can be trace back to incorrect use of malloc and free. So, there are some categories of errors for example, you may forget to malloc in the first place. So, you will lead to dangling references or dangling pointers, as we saw in the first example. Now, you could allocate some space. But, you may not allocate enough space, that is a very common error. Commonly, you could allocate of by one errors I wanted to allocate really len + 1 number of bytes. But, instead I allocated only len number of bytes. Another very common error is something known as a memory leak, which is that you allocate things on the heap,, but you forget to free memory after use, this is called a memory leak. Notice that, if you allocate space on the stack, it will always be cleaned up as soon as the function returns. So, memory leaks usually happen, when you malloc space on the heap. But, you forget to free them, once you have done and a lot of software ships with memory leaks and this is a major concern in the industry. This is also an obscure error, which is freeing the same memory more than once. This is uncommon when a single programmer is working on a code. But, when multiple programmers are working on the same piece of code, you may end up freeing the same memory twice, this will lead to some run time errors.    In this lecture let us look at an application of malloc and free to solve some problem that we are interested in. So, the problem that I will define is to write a function to return the duplicate of a string; a string is given us the argument and you have to return the duplicate of that string. So, we have to write a function to take a string as input and return the copy. Now let us assume that the input string is s, and it ends in a null character. Assume that we can find the number of null non null characters in the string. So, this is will be refer to us the length of the string. What we will do is allocate length + 1 characters. So, there are length non null characters, and then one more for storing the null characters. So, we will allocate len + 1 characters on the, heap using malloc, and we will copy the contents of s to that space on the heap. And finally, return the address of that location. So, that will be the t th the new array. So, notice that the original array may be on the stack, and the new array the duplicate array will be on the heap. Let us write this function.       So, I will call it duplicate it takes one array which is the same as a pointer. So, I can declare it has char *s or char s with square brackets, it does not matter. So, I will just declare it has a character *s, and what will it return? It will return another array, and array is the same as a pointer. So, I will return character star. So, the input argument is an array, and the output is also an array. I will declare 3 variables; i which is for the loop, len which will store the number of non null characters in s. So, let us be very specific, I do not want to store the number of characters in s, because I want to say that I do not want to count null.  Now if you want to count null as well in the length then you will modified the code, but typical convention is that when you mention the length of a string, you do not count the null character. I will also declare a char *t. Now the code proceeds and stages; first I have to write a loop to find the length of the string, I can write a very simple loop to do that I can say for i = 0 as long as s of i is not null, do increment i. So, as soon as I see the first null in s, I will stop. When I exit out of the loop, I will be the number of non null characters in s. So, I can say len = i. So, in the first step of the function, we just find the length of the string excluding the null character at the end.  Now comes the important thing, we have to copy that array to somewhere. If we copy that array to the stack itself that is if I copy that array to some space within the duplicate functions stack, it will be erased when I return. So, I should allocate the space on the heap. I can allocate space on the heap using the malloc function. So, let us look at the malloc function. I want to allocate a bunch of space on the heap, how much do I have to allocate, I have to allocate len + 1 number of characters. In other words, I have to allocate len + 1 times sizeof a single character; these many bytes on the heap. Notice that it is not len times sizeof(char), because if I allocate only that much then I will not have to space to copy the last null character. So, I should the input is a null terminated character, it is duplicate should also the null terminated. So, I should makes space for all characters including the null character on the heap. So, I will allocate (len+1) * sizeof(char) many bytes on the heap, it will return you the address of the first byte and that address I will convert to a char star. So, malloc returns a kind of an unsorted. So, here are these many bytes. Now it will return you the address of the first byte that was located, now I want to treat that as a character pointer. So, I will can do that using the casting operator. Why do I have to do that think about it for a minute, because you want pointer arithmetic to work. When I say t[i], I should correctly execute star of t + i. So, go back to that lecture and understand why it is important that you know the it is not just a byte address, it is a character pointer. Once you do the allocation, you can copy s array into t array. We do not really care about the fact that t is not on the stack, t is on the heap, because copying is done exactly the same way. So, I can say i = 0, i < len, i ++ t[i] = s[i]. And then finally, this will copy all the non null characters, and finally I will say t[i] = null, the last character will be the null character. Now, if you want to understand it in slightly greater detail understand why the character star cast was required in order for t[i] to work properly. Once I have done copying the array, I can just return t, and I will not leap it will not lead to a dangling pointer because t is allocated on the heap. So, let us pictorially understand what happens during the execution of this program. I have main function, and I allocate a char array. Now this is allocated on the stack. As soon as I declare a character array and initialized it with in main, it is allocated in the stack corresponding to main. So, s is a pointer to the first location in the array. And I declare another *t, and then I call t = duplicate(s), I should return a separate copy of s. Let see what happens in the duplicate function? We do allocation for all the local variables all that, but important thing is that we have s and t which are new pointers. Now s is the input argument to duplicate, and it will be pointing to the array in the main function, because I call duplicate(s). So, duplicates s will point to the same array as the s of mean. So, it is pointing to the array on the stack, Now as soon as I allocate memory for t on the heap, which was step 3 of duplicate, I would say t = (char *)malloc( (len+1) * sizeof(char) ). What is len here? len is 6; there are 6 non null characters len + 1 is 7. So, I allocate 7 characters on the heap, and its return address will be cost to a character pointer. So, t is now pointing to this space on the heap. Now, once I am done ((Refer Time: 08:33)) creating the space on the heap, what I can do is, I can copy the location the s array into the t array on the heap. So, once that loop executes it will look like this, here is the s array inside main, here is the heap the array allocated by duplicate, and you will just copy t[i] = s[i] for. So, you will copy ‘s’ ‘a’ ‘m’ ‘p’ ‘l’ ‘e’, that is within the loop. And then finally, I will say that t[6] = ‘\0’. So, here is an array of size 7, it has a 6 non null characters and the last element is null.   And then once I am done, I will return from duplicate. Again keep in mind what is erased is the stack. Everything that was allocated to duplicate on the stack is erased. Those s t and the local variables in duplicate no longer exist, but the work that was done by allocating on the heap that still remains. So, the return value t, that is return value which is the address of the array in heap will be assign to t. So, t now points to heap. Notice how it executed s was allocated on the stack, and the effect of the duplicate function will be that, the duplicate of the array will be created on the heap.  So, notice what we understood about the sizeof operator. Sizeof operator was use to know the number of bytes need at the stored data type. It is used in pointer arithmetic, it is used in array index calculation, and it is also used when allocating memory on the heap, because malloc needed to know how many bytes to allocate. And suppose I have wanted to allocate 10 integers, instead of me saying that on this machine I know that and integer is 4 bytes. So, you go ahead in allocate 40 bytes. The problem with doing that is you take your code to another machine, and that machine integer is 8 bytes; and your code will no longer allocate sufficient space. So, the real way to write portable code would be to say 10 times sizeof int, that code will work regardless of which machine you execute on.  So, here is the use of sizeof operator when you call malloc, it helps you to write portable code which will execute on any machine. So, we have seen that allocating memory on the heap can be done using malloc, we have understood what it means to allocate memory on the heap the difference between stack and heap; stack is erased as soon as a function returns, heap is not erased when a function returns you have to explicitly say that i ((Refer Time: 11:39)) now freeing that using free function. Again remember the asymmetry within malloc and free; malloc needed to know how many bytes you allocate, free just needed to know which pointer to de allocate, which pointer to free. Did not want to know how many bytes to free, it does that automatically. And to repeat common errors using malloc you could forget to malloc. Now you could not allocate enough space in heap. For example, in the code that we have just seen, suppose you are allocated just len number of characters instead of len + 1. Then you would not have enough space on the heap to copy the last null character. So, you will violet that t is an exact duplicate(s). Now you could forget to free memory after use, this is called a memory leak, and you could have the sub square error of freeing the same memory twice, that leaves to run time errors.   Now, recursion is usually something that is completely new. it is a new way of thinking about problems that might sound unfamiliar at first, but eventually it is a more natural way of solving problems than other techniques. So, we will carefully examine what recursion means. So, this is the video of a media player having a copy of itself inside the video and it goes on forever. We will see what does this have to do with recursion.  So, recursion in English means roughly say again i am function defined in terms of itself are called recursive functions. Now, this is not completely accurate. We want to say that functions defined in terms of itself in a particular way, these are valid recursions. Recursion is a powerful tool for program construction and for thinking about and reasoning about functions in general. So, it is a general purpose technique of programming, and you can do any kind of program using only just recursion. We will not see such general types of recursion in this course, but we will see fairly common examples for recursions.  So, for example, let us consider a very simple function which will search for a key within a given array and we know how to write this. What i will do is, i will take an integer, initialize it to 0, for i = 0 to n. N is the size of the array. i will increment i and if at any i, i find the key, i will return 1 indicating that i have found the key. if i have not found the key and i have reached the end of theory, i will return-1. This is a typical way to search for a key inside a given array. Now, we will approach the idea of recursion by looking at a recursive solution to this. Hopefully, while seeing this program, we will get an idea of what recursion means.  So, what do we mean by a recursive solution to this, right. Rather than defining it and describing abstract properties of recursion, why not let write an actual program which is defined in the recursive manner and through these kinds of examples will eventually get the hang of recursion. So, we have to write a function search it will return whether a key is found or not. if the key is found, it returns 1. if the key is the not found, it returns a-1 and you have to search an array a of size n for the key. Now, we have written this function just now using loops. Now, let us write this using recursion.   So, let us say that i will in some unspecified syntax, this is not going to be valid c, but this is just so that we see the idea in a very clear manner. i have to search for an array of size a of size n for key. Now, if the array is empty that is n is equal to 0, you can have more conditions here. N can be < 0 as well, but let say that empty array is n is equal to 0, then you say that i have not found the key because it is an empty array. So, you give back the value-1. So, n = 0 implies the value to be returned this-1. That is what this notation is supposed to stand for. Suppose n is not 0, so, this means that an array is non-empty. Now, how do we solve this, recursively right. So, this look for the first element whether it is the key or not. if the first element is the key, we do not have to do anything further. We know that the key is present in the arrays, so you return 1. So, the key has been found and you return 1, and now is the big step for recursion. How can we search for the key in an array of size smaller than n? So, if a[0] is not equal to key, then this means that key can be somewhere in a 1 through a n-1 or it is absent in the array. in any case what we now have to do is search for the arrays starting at a 1, so by a 1 this is not strictly c notation. What i mean is the sub arrays starting at a + 1. So, search in the sub array starting at a + 1. Now, the sub array has one element less because we already know if you are here that a 0 is not equal to key, so there are only n-1 element in the smaller sub problem. What do we have to search for, we have to search for the key. So, this says that either the key is present as the first element of the array or you have to solve the sub problem of searching in the sub array of size n-1 for the same key. So, here is the key to thinking about a problem in recursive terms. What you first do is, consider the case when you have the trivial array which is the empty array in this case. So, we have the base case and then, these are the recursive case. So, the recursive case consists of doing something at size n. So, in this case, it is search whether the first element is the key or not. if it is true, then we do not have to do anything further, we have found the key, otherwise solve the sub problem. Now, the sub problem is a smaller copy of the old problem. So, this is what is known as the inductive case or the recursive case. The reason i am calling it inductive case is that recursion has very tight connections to the idea of mathematical induction. if you know how to write a proof by mathematical induction, what you normally do is you consider a base case. So, you have a theorem and you want to prove this by mathematical induction. You consider the base case probably n = 1 or n = 0. These will be the base cases for an association about natural numbers and then, if the base case is true, then you say that i assume that the problem is true for size n and now, i want to prove that the theorem is true for size n + 1. This is how a mathematical induction proof looks like and in the case of a recursive program, there is a very tight analogy. Recursion in fact is just a mathematical induction in the context of writing programs. We have to solve a problem. First we will see what is a problem in the base case and the base case is a very trivial case usually, but it is important that you think about base case. You say that if the array is empty and then, i will return-1 because the key cannot be in the array. Then, you say that i will now define the problem of size n in terms of a sub problem of size n-1 for example. So, we will solve the same. We will solve the bigger problem in terms of a smaller copy of itself and this is the key to thinking about recursive programs.  Let us code this in c. So, we code this in a very straight forward manner. i will write a int search, int a[], int n which is the size of the array a, int key which is the key we are searching for. if n = 0, then return-1 because the key is not found. This is the base case and otherwise n > 0, so you can search for a 0 is equal to key or not. So, you can search for whether the first element is the key. if it is, then you have found the key, otherwise what you do is you call search a + 1 which is the sub arrays starting at size 1. The sub array has size n-1 and key. So, when you search or write a recursive program, there are a few things that you want to check. The first is that the base case is properly handled. The second is that when you define the sub problem, you want to ensure that it really is a sub problem because if you solve the problem in terms of an equal size problem or even a bigger size problem, your program may not terminate. We will see this in a moment. So, this part which is highlighted in green which is calling search itself, but on a smaller sub problem is a + 1 n-1. This is what is known as a recursive call to the same function. So, we have seen functions that can call other functions. Now, we have seen functions which can call themselves and this is what is known as recursion.  Let’s see how this function behaves. Now, before we go into the execution trace of this function, i want to add a word of caution. The actual way to understand recursion is not to think about the stack and how functions are calling other functions. The real way to understand recursion is to think about this program as a problem defined in terms of sub instance. But in any case we will just see the execution of this function through the stack trace just to get comfortable with what happens at the back of all of this. So, let us do a quick trace. Suppose we have an array 31 4 10 35 59. it is an array of size 5 named a, and we are searching for the key 3. Now, we know that this key is not present in the array, but let see how the function executes. So, first we call search(a,5,3). A 0 is 31 which is not the key. So, it calls search a + 1 4 because now we are searching in the sub array of size 4 for the same key. So, that is in effect, the same as calling the same search function on this sub array highlighted in grey. This is because the answer to search in the whole array is now the same as answer to the search in the sub array. That is what the recursive statement is. Now, (a+1)[0] is 4 this is the first element of the sub array. A 4 is not 3 and a, and at this point you call the sub sub problem which is search a + 2, the sub array of size 3 for the key 3. Here is the sub array of size 3 and you are searching for 3 in this sub array. Again the first element of the array is 10, which is not 3. So, you call the sub problem of this which is a + 3. Now, the array is of size 2 and you will search for 3 and this goes on until you find that you have exhausted the array. Finally, the array is of size 0 and you will finally say that since the array is of size 0, i have not found the key. So, you return-1.  Let us just look at this stack of function cause and see how it looks like. Search(a,5,3) is called by mean and let say that it has some return address. We do not care about it right now, but search(a,5,3) calls search(a+1,4,3) and the place to return is some line in search function. This calls the sub sub problem a + 2 3 that calls a + 3 2 that calls a + 4 1, and that calls a + 5 0 at which point you realize that the sub problem now is empty and then, you return a-1. So, at this point you have reached the base case. if n = 0, return-1. So, that will return a-1. Where will it return to? it will return to the function which immediately called it which is search(a+4,1,3). So, this guy gets a-1. Therefore, it just returns that-1, return the value of whatever is returned by the sub problem, ok. So, it is-1 and that-1 gets returned. So, it gets bubbled up all the way back to main, and main you can realize that the element is not present in the array because the return value of search(a,5,3) was-1. At this point, the call stack terminates.  So, what was special about the recursion call stack? it was just that most of the stack was involved by a function calling itself over and over, but each time the function called itself, it was calling on a smaller version of the problem. Here is how, you think about a very simple program in terms of recursion. Earlier, we saw how to solve this using iteration which was using a loop and we have seen the problem how to be solved using recursion. Now, a word of caution, we will see this in further examples. it is very important that you handle the base case properly. Now, this is something that we are not used to in normal way of thinking. When we think about solving a problem, we are thinking about solving substantial sizes of the problems. We are not concerned too much with what happens with an empty array, what happens when n is-1 and things like that, but even in this problem, we know that when we call search(a + 5,0,3) we know that the function terminated because we had a base case which said that if n equals to 0, then return-1. if we did not have this case, you could see that probably it will go on calling itself infinite number of times. So, just like when you are writing for loop or a while, loop you have the case of infinite loops. in the case of recursion, you can have an infinite recursion and you have to guard against that. The only way to guard against that is to get the base case correct. So, here is something in counter intuitive about programming recursive functions. You know almost half of your intellectual effort is in handling the base case properly, and only the remaining is involved in solving the recursive case.   In this video will look at linear recursion in a bit more depth, while I describe what I mean by linear recursion. We have mentioned earlier that when designing recursive programs, think about the problem in recursive terms, do not think in terms after stack that is used in execution. When it is actually executed that will be a stack created and use for the execution, and that depth of recursion is a term which means the maximum size of the stack, while you execute the program on given input. The memory used by the programs includes the local memory of the function, + the depth of the stack.  .  Let see with an example. We will consider actually two examples; one for even length array, and another for an odd length array. Let say that a is an even length array with six elements and we want to reverse it, using the function reverse a[6], and we have to do it in a recursive way. So, what you do is first swap a[0] with a[5]. And now what is the sub problem left be solved. We have to solve reverse of this intermediate array, which starts from a[1] and contains four elements. So, we have to reverse the array with starts from a + 1, and there are four elements to be reversed. So, in one step even though we have only a single call to a sub problem, we have actually reduced the size by 2. Now use a reverse or rather swap a and a[1] and a[4], and now the sub problem that remains is, to reverse this sub routine which is a + 3, and you have two elements to reverse. So, you do this, and in this point you have a sub array which starts at a + 3 and has zero elements to reverse. At this point that is nothing but. Now, for in odd length array let us take a very small array which contains three elements, and we have to reverse it. What you do is, you reverse you swap b[0] with b[2]. At this point you have a sub problem which has exactly 1 element, and you do need to reverse that array, that arrays it is soon reverse. So, the problem just stops there. So, notice that difference between the even length array the odd length array. In the case of even length array, the step, just before the last step involved an array of size 2, and you still had to reverse that is array. In the case of an odd length array this, the last of involves has a single length array, which is soon reversed. So, you do not have to do anything. So, there are two base cases to worry about; one is where the sub array is of size zero, and another is where the sub array is of size 1, 0 corresponds to even length arrays, and one corresponds odd length arrays.  Let us write this code now. So, we have reverse a containing n elements, and we have return type void, which means that this function is not going to return you value, but it is going to do something. So, if n=0 or n = 1 return, because in that case a is, it is on reverse; otherwise you swap the first element with a last element, that is this operation a and a + n - 1. So, notice that swap is a function that takes two pointers to int and exchanges them. Once you do that you call the sub problem, which is reverse(a + 1, n – 2). Notice that unlike the previous examples we have discussed, the sub problem reduces by 2 insides. Even though you have a only single call, the sub problem is not of size n - 1, it is of size n - 2. So, look at the case of the odd length array and the even length array that we have seen before. And you can notice that the sub problem reduces by 2 in size for every step. Now what is the depth of the stack. you know that ruffle n upon to calls will be done, because you start at a size n, the next call will be of size n - 2 and so on until you hit either one or zero. So, you can work out that there will be about n/2 steps, before you reach one or zero. The accurate expression is, ceiling of the expression n / 2 + 1. So, many calls will be there, before you hit 1 or 0. So, each function call will take, let us a constant among space and there are about n/2 function calls. So, the stack depth is n/2, and therefore, the wholes space which is stack depth times the number of variables at each function that will be about n/2.  So, now let us consider a third example which is, computing the size, the maximum of a particular array. For concreteness let us consider in integer array, and we have to compute the following function int max array. It takes two arguments; one is the array itself, and the second is m, which is the number of elements in the array. Again let us think about the problem recursively, we have return loops to solve the problem earlier, but now let us think about it in a recursive manner. If the array contains 0 elements, then what is the maximum. So, here it may be slightly counter intuitive if you are saying for the first time. The maximum of an empty array is some large a negative value. Think of it has minus infinity. Why do we do this this is, because let us take a concrete example 1 2 3. We know that the maximum of this array is three. Now, what happens when you take a larger array or list of numbers. So, what happens if you take, let us keep this unspecified a is an int. You know that if a is less than 3 then the maximum of this array is going to be three. If a > 3 then the maximum of this the second one is going to be greater than that. So, in any case, whatever be the nature of a you can always say that maximum {1 2 3} a is going to be >= the maximum {1 2 3}. Now what; that means is that, if you take a larger set, its maximum is always going to be >= the maximum of a sub set.  Note that this is independent of a, because you can analysis my cases, if a <= 3 then this maximum will 3 itself and 3 >= 3. If a > 3, then this maximum is strictly greater than the previous maximum. So, maximum is always monotone according to the sub set relation. Now this means that what will be the maximum of the empty set. The empty set is a sub set of every set. So, no matter which s I pick, maximum s has to be >= maximum of the empty set. This means that a reasonable value for maximum of empty set is minus infinity. So, the set... So, this is a reasonable convention; that is why when n is of size zero, we returns some really large negative value. By which I mean the absolute value of the number is really big, because we are trying to say that it essentially minus infinity. If n is of size 1, then you just return a[0], because the array contains only 1 element, it is maximum will be a zero. If n has size at least 2. Now we are in business, we have to solve the problem in terms of a sub problem. So, here was an example where the base cases had to be really thought of, but now we are at the case where we are thinking about the recursion. So, what is the recursive step here.  So, let us take a concrete array. We have array a, which contains the numbers 2 4 3 7 5 23, - 3 and 9, some concrete array. And I want to calculate the maximum of the array a in terms of some sub problem. The natural sub problem that we can think of, is the sub problem of finding the maximum of this sub array, which start from a[1] and goes on until the last element. So, recursive call should be something like max array a + 1, and there are n - 1 elements in it, because we omit the first element. Now, maximum value, how can we solve the whole problem in terms of the sub problem. Suppose we note what is the maximum value in the tail; a + 1, 2 containing n - 1 elements. The maximum of the whole array will be the greater of the two numbers, which two numbers, the maximum of this sub array and a[0]. So, maximum value is the large of a zero and the maximum of the tail sub array, which is a + 1 to a + n - 1. Now in order to compute the sub problem we called a recursive call to the same function, looks for the max array from a + 1 containing n - 1 elements.  So, in this example, the maximum of the tail sub array will be 23. And let say that a zero is 25. So, the maximum of the whole array will be the greater of the two numbers 25 and 23. So, in this case, the maximum value will be 25 which is a[0].  So, now let us write this code. So, the recursive function is very simple, and this is one of the reasons why people like to write recursive functions, because from a recursive function it is very clear what the function is going to do. Usually recursive functions are shorter than their loop versions, and they are easier to understand when you read someone else code. So, let us solve max array using the recursive function in c. We have int max array, because it is finally, going to return in int value which is the greatest value in the array. Now you have an int array a, and n is the size of the array. Let say that we set some max val if n is 0, then the maximum is simply something like minus infinity. Let us keep it a very large number - 9 9 9 9 9. So, - 5 9, some large value does not matter, and then if n = 1 then the array contains only one element and therefore, it is the maximum. So, you just return a[0]; otherwise n is at least 2. So, in this case, you say that the maximum value of the sub problem is max array a + 1, n - 1. So, this is the maximum of the tail array.  Now once you have the maximum of the tail array, the maximum of the whole array is the grater of the two numbers which is a[0] and max val. So, we return max{a[0],  max val}. Now max is a function that is already there in the standard math library in c, but if you want to write it, it is not a difficult function to write it, you can take two integers and return the greater of the true integers. Now we can think about is a better then the loop version of the program. The advantage of the recursive program is that, it is easier and in some sense it contains fewer number of lines then the loop program. The disadvantage is that it takes subs more space while executing. So, the questions are how much time does the function take, how much space does the function take. So, these are things which are concrete and can be measured, there is also software question which is, how you see is set for programmer to look at this function and understand what it does. In the second criteria and it is the recursive function that is course. In the first criteria it is often the iterative function, the loop function that is course.  So, please think about the questions, and you can work through it and say that in order to solve max_array of an array of size n. Let us take an array size 8, you will see that these other recursive calls it will make (a + 2,6) so on up to (a + 7,1), and when you hit an array of size 1 you get to one of the base cases, which is that when you have an array which contains a single element, the maximum is the only element in the array. So, once you hit here, you will start returning. So, the maximum depth of function calls in this will be the size of the array. So, you can say that stack depth is n.  Now, recursive programs are general programs, just like look loop programs are general programs. You have return loops even before you saw what are arrays in C? Similarly you can write recursive programs which deal with general data, not just array data. And in all of these questions, you can ask the following question how much time does the function take, and how much space does the function take.  We will see an example for a recursive function, that will read n numbers and returns the maximum. Before we came to know of C arrays, this is the kind of loop functions that we used to write, we would take n numbers. So, first you will read how many numbers to read, then you will read exactly those many numbers and find their maximum using a loop. Now Let us try to do that using recursion. We are not going to use any arrays. So, what we have to do is, write a function to read_max, it takes n elements. And the logic is the same as finding the maximum of an array, but we will do it without using arrays. How do you do this. If you have zero numbers to read then you return minus infinity, or some approximation, some large negative value; otherwise you read the first number. If n = 1; that is we have to read only one number, then you just say that x the maximum; otherwise n >= 2, and we have read one number.  So, you say that return the maximum of the two values, which is x and what goes inside, inside you have to solve a sub problem, which is the sub problem of reading n - 1 numbers and returning the maximum. Go back and compare the program with finding the array maximum, and the recursion works exactly in the same way. So, we will read n - 1 numbers, and return the maximum of those, and then you compare maximum of the first number and the maximum of the sub problem. This is exactly as before except that we did not use any arrays. And how do you call this function, you just declare a main function with n, you scan it how many numbers to read, and call the function read max n. Finally, it will return the maximum of the n numbers read and you just print the value.   Now, there are other functions which are typically return in a recursive manner. We just saw that you can use recursion with arrays.
 am storing the temp
and what is temp? Temp is after I divide I get the remainder and that I am storing in temp
and that temp is coming in A all right it is being stored in a and that is also copied in B,
but in the next loop that is being divided by. So, here you are having 3 9 and here 3. So,
look at this iteration 1, here looking at this picture first temp will become 9, B is 12 and
A is 9.
Next time temp is becoming 3, B is 9 this 9 and A is becoming 10 and whenever I find
that B divided by A this part is 0 remainder is 0 then that is my GCD A is my GCD, I get
the 3 there is another very interesting example of computing using this while loop and
repeatedly I am doing this till I find the remainder to be 0. So, there are many such nice
examples and we will give you some more during for assignments, which we will have
to solve and get more you will get more confidence about it. So, next we look at we will
come to some of the pitfalls of loop, and then move to something more useful something
very useful that is the concept of arrays ok.
Thank you.

So, we have seen the application of the constructs of if then and if else as well as while,
do while and for constructs. Till now you have seen examples in of while and do while,
will see more examples for loops for example.

Let us also see another application for the application of for loop. Say for example, I
want to print I want to add 20 numbers I think we have seen such examples will see more
interesting examples a little later. But before that let us look at some common errors that
take place often unintentionally in writing loops and that gives rise to a number of logical
problems in a program.
For example, let us look at this. Here you can see the first line what will happen, the
intention was that while sum is less than equal to NUM; that means, it is less than equal
to sum a particular value may be 20 we are adding sum plus 2. What does this mean? Let
us try to understand this example forget about this, forget about this part. What would
what is the intention of doing this? That means, suppose NUM is 10 and sum is 0. So,
while sum is less than NUM I will be adding sum and 2. So, sum will be, sum will be 2

and then sum is still less than num so again it will be 4, sum is still less than NUM it will
be 6, still less than NUM it will be 8, still less than equal to NUM it will be 10, then still
less than equal to NUM it will be 12 and then when it goes there it will stop. So, what
will be the sum? Sum will be 12. But that was my intention of the program.
But unfortunately I have put a semicolon here. What does that imply? That implies that
the entire while statement ends here; that means, while sum equal to NUM do nothing all
right. So, that is the end of the statement. So, nothing has been specified there and
whatever some was there suppose sum was 0 sum will perpetually remain less than 10 or
NUM and will go on forever. So, this semicolon should not to be given because the
while statement is actually extending up to this point up to this point that is the whole
statement.
So, next example we take is this one, for i assign 0, i less than equal to NUM plus plus i,
forget about, again about this.

What is the intention of this program? What will it do? i is 0 all right and NUM was say
something like 20 then sum will be added to i. So, sum will be 0, then i will be
incremented, so i will become 1 less than NUM it will be added. So, sum will now be,
sum was 0 so sum will now be 1, here was sum, sum was 0, sum becomes 1, then sum
becomes 2, sum becomes 3 like that it will go on all right.

However, since I have put a semicolon here this part is not a part of this for statement.
Consequently this loop is a non loop nothing is being done here and for i equals 0, iless
than equal to NUM i plus plus do nothing all right. So, nothing will happen here this
statement will not be executed.
Here is another type of pitfall where let us study this for i equal to 1, i not equal to 10, i
assigned i plus 2. What will happen to this loop? Can anyone guess?

i is 1, so sum has been computed sum is sum plus i sum was 0. So, 0 plus 1 sum is 1,
then i is incremented to 3, then sum equals sum plus i. So, sum becomes 4 then this is
incremented to 5. After each incrementation I am checking with this condition, so i is 5
not equal to 10 fine. So, I will add 5 with this, it will become 9, then becomes 7 i is
change to 7, I check with this still not equal to 10. So, 7 is added to this 16, this becomes
9 still not equal to 10. So, then 9 plus; 16 plus 9 maybe 25 and then this is incremented to
11 because i plus 2, still it is not equal to 10. So, what will happen? It will go on it will
never be equal to 10. This means as long as i is not equal to 10 you will go on. So, this
will be a case of any another infinite loop all right.
Just as in this case this is a null statement this will be done and then this statement will
be done only once. Here it will be an infinite loop because this condition will never be
made. So, these are some points where we should be very careful about.

Now, let us have a very interesting program. We want to print we want to print, we want
to print a pattern like this. We want to print the pattern like this say 5 stars in a row and 3
such rows, this sort of pattern. How can I do that? My algorithm will be, I want to print, I
want to print a row of stars. How many? 5 stars. So, how can I print 5 stars in a row? If I
just write one statement printf, star I do not give a backslash n; then what will be done?
A star will be suppose this is my screen all right a star will be printed and if I put it in a
loop say for i assign 0, i 5 I want to do, less than equal to 5 i plus plus and I do this then
what will happen, i 0, so once it is printed then i 1 once it is printed, again in the same
line then again another one.
So, since I am giving a gap what I can do here I can keep a space here star and then a
space I show space by blank. So, exactly a star in the blank will be printed. So, i 0, i is 1,
i is 2, i is 3, i is 4 and then it is incremented and checked is 5, so less than 5 it will not
happen then. So, this will be a loop after doing that. So, in a loop I will be printing one
row then I will give printf I have to come to the next line. So, I will simply give a
backslash n; that means, I will come to the next line. And this again loop I will carry out
how many times? 3 times because I need 3 rows. So, what should I do? I should do this
again loop this 3 times so how should I write it, how would that look like now.

It should be something like this for j, j is another variable assign 0, j less than 3, j plus
plus for i assign 0, i less than 5, i plus plus and then here printf star followed by a blank
and then the quote no backslash at the end of this. So, after this loop is done then I will
do printf backslash n backslash n. So, this part will be repeated 3 times and in this part it
will be this one will be done 5 times. So, star star star star star will be printed. Then we
will come to the next line and here this is my next for loop. So, I come to printf and
again do the same thing this part start start start start star 5 times, this printf by this loop.
This is printed row, printing a row by 5 times. And then again I will come and do a
backslash n, I come here and do the same thing 3 times and then come here backslash n
and then stop.
So, print a row of 5 stars and repeat therefore, I am repeating this print star 5 times in a
loop. So, that is a very nice interesting application of for loop. I hope you have
understood this.

So, here that is exactly what I have I was showing you. Look at this, here the number of
rows and columns have been made little flexible rows 3 columns 5. Now, row equal to 1,
while row is less than rows print a row or 5 stars. This I have done it is the for, here it is
shown using a while.
So, let us see while whether you can understand this also with the while. Row is 1, now
row is less than rows; how many rows we will do, row is less than rows that means, as
long as it is sorry as long as it is 3 rows will print a row of 5. And how do I do a row of?
I will that we have already shown that how we do it and then we increment the row all
right. So, here while row is less than rows print a row of 5, printing a row of 5 is done
through in this manner. So, this is the outer loop, this is outer loop. Column is 1, while
column is less than columns, so 5 columns 1 2 3 4 5 while column is less than column
printf star and blank and then column is incremented.
Now, since I am doing it in a while it is done in this way. I have already shown you in
the earlier this thing how we can do it with for. I can do the same thing with for right, the
same thing with for and here it is being shown how it can be done with a while. And then
I print of n and do this. You can try to understand this again yourself.

Next, say here this being done again in the way that I had written using for. Here only 3
and 5 these things are variable for row equals 1 to row less than equal to 3, plus plus row.
Here it is plus plus row; that means, first is incremented. Then column is less than equal
to columns. Why it is less than equal to, while if you remember when I was doing it here
when I was doing it I had less than 3 less than 5, less than 3 less than 5, but here it is
being less than equal to 3 less than equal to 5 why because I started my index with 0 and
here I am starting my index with 1, all right. So, this you should be very careful and you
should always hand trace your program and see whether you have done it correctly if
there is a little bit of confusion because this is very, this very important and you should
be very careful about it.

So, same thing that I have shown is written again here. Another 2D figure this a little
more interesting. First row we print 1 star, second row we print 2 stars, third row we
print 3 stars, 4th row we print 4 stars and then 5 stars. So, how many stars I will print that
is also variable. So, if we think about that how many times I will print in a row that is
also a variable. How many times I am doing this?

So, for the first when a row is equal to 1 then I am printing 1 star, when row is equal to 2
I am printing 2 stars, when row is equal to 3 I am printing 3 stars. So, every time I can

also say that I am printing row stars, I am printing row stars, row number of stars
therefore, how many times I will do in a loop in the inner loop. You could see that when
I we had drawn this thrice or twice whatever there was here, there is an inner loop 5
times and an outer loop that was doing 2 times right. Now, here what will change it to is
inner loop row times outer loop maybe 3 times. So, this is variable.
Now, let us see how we can program it. Constant integer rows is 5 that I have not made
variable there are 2 integers row and column. For row equal to 1, I start with rows row as
an index and row less than rows less than 5 plus plus row. What do I do? Column equals
one I will do up 2 column less than equal to row. So, first row column 1, column is less
than equal to the only ones I will print then plus plus column, so column becomes 2, but
what is my row? Row is 1 still I am pointing at this row, row is 1. So, I will do printf.
Now, the value of row becomes 2 as I increment, but then the column this is a column
this is row the column will be less than row because row has become 2. Now, it is
pointing to this row, this row. So, column being less than that I will come out of the first
row.
Second row, what will happen? Column will start from one and row is 2. So, column less
than row I will print once, I will go back here column is becoming 2 and column is still
equal less equal to row all right not less than, but equal to row therefore, I will again
print here then I will come back here and now column is 3 column is 3, but row is 2
therefore, I will not print any longer will come out of this loop and go here. Then low
will be incremented here all right, row has been incremented here. And, now again
column is initialized to 1 for the third row first it is printed incremented column comes
here all right then columns column comes here, so column is 3 still less than equal to
row. So, I print the third one and then it is incremented, so the row becomes 4, but my
column is sorry the column becomes 4, but row is 3 therefore, the column is I go out of
the loop and again column is initialized to 1 and my row is incremented to this.
So, that is how it is done. You please look at it more carefully and you will have to
understand it and this will give you a very clear idea how a nested loop is working. So,
this is one example.

Here, what we are trying to do just think of this figure. First row is 5. So, row is this,
column is here how long shall I print in the columns keeping the row fixed. What will be
my logic? The logic will be well here I started row with 0 and less number of, less than
number of rows, rows is 5 that is not that important. Here let us look at this, first I will do
5, then I will do 4, but there is another one. For the second row I am shifting one space I
am shifting this should have been aligned and then I am shifting and giving a space and
then doing it. So, gradually it is being shifted.
So, let us see what is being done. Let us look at the first for loop here this is the outer for
loop, let us outer for loop is up to this, outer for loop is up to this and let us see what is
happening. Row is 0 to number of rows less than. So, I have started with 0. So, I did not
make it less than equal to it is less than less than 5 I will do this number of times.
Internally what am I doing this doing here column is 1 and column is less than row
because less than equal to row because row is 0, row is 0 and column is 1. Look at the
trick here, the trick that has been applied is column has been in is starting with a value 1
and as long as column is less than row I am printing blank.
So, how many blanks should I print for the first column? 1 blank then column less than.
Now, here from the first column look at this point. Column equals 1, 1 column less than
equal to rows, rows is 5 as long as column is less than equal to rows minus row. What is
my row? Initially my row is 0, so rows minus row is 5, it is 5. So, column is one column

is less than equal to 5 plus plus, so I do printf, I do a printf and I go on doing this as long
as the column is, so column is now incremented to 2 3 4 how long will it come for the
first row it will come 5 times because rows minus rows 5 minus 0. So, I will print this
and then I will come back this loop is over, this loop is over, I will a print a backslash n
up to this sorry I am sorry this for loop is actually extending up to this. So, from here I
go back. So, I come to the second row.

Now, row becomes 1 let us see, now row becomes 1. Less than 5 for column equal to 1,
column less than equal to row 1 still valid I give one blank here, one blank here for the
second row. My row pointer as come here, row is 1. Then I will do column 1, 2 column
minus rows ones blank I have already given. So, I am. Now, my starting is here how
many? Now, row is 1, 5 minus 1 so that means 4, 4 times this will loop and print star and
then printf n.
Next time I go back here and this becomes 2. So, row 2 to less than 5 column is again
now 2 blanks, column is 1 2 less than equal to row and row is 2, so 1 to 2. So, there will
be 2 blanks here one blank here, one blank here. So, I am coming here and then I am
printing this is 2, so 5 minus 2 3 stars. So, in this way I can go on and print this figure by
an intelligent way of applying the for loops or the nested loops and putting in the spaces
together spaces properly. I think this gives a very interesting example for you to look at.

So, these are some of the examples that we have seen. We will come to this for thing
again later, but let us just remind you a little bit about some things that we had
mentioned in passing.

For example, this operator plus equal to as for example, here a plus equal to b this means
a assigned a plus b these are some shortcuts all right, a minus equal to b that means, a is
assigned a minus b. Here a star b plus 10, a as star assigned b plus 10; that means, a will
be assigned a times b plus 10. So, in that way we have got this one also, say a assigned b

that means, a is assigned a divided by b these are some of the shortcuts. So, this is just to
wrap up some of the assignment operations that we are talked about. But these are as I
said that you can keep this for later use. Right now more fundamental thing that you need
to know is a use of if else for, while, do while etcetera.
In the next lecture we will start with a new concept called arrays and there you will find
that these loops are becoming so important and will have many interesting applications
using arrays that will be done from next lecture onwards.
Thank you.

Till now we have looked into, we have seen different programming constructs using
which we can implement repetition; that means, a set of statements will be repeated in a
loop. And in C such contracts where while do while and for loop, right? Now also we
have seen how we can branch out. Coming through a sequential one after another
execution of the instructions depending on the condition we can go out to one path or
another path through if else structures. And we have also seen some examples by in
which the combination of the, if else structure as well as the while structure are
combined together to give us more powerful and useful programs.
Today we will start discussing about a new form of representation of data that is very
useful and very fundamental that is called arrays ok. Arrays the word array simply means
arrangement of data. So, we can think of for example, an array of soldiers or array of
people standing in line.

So, people are standing in a line, this is an array ok. We can also have 2 rows of people
standing alright. This is a very regular structure we can have 3 rows also. So, these are
arrays of people.
Now, if I just have only one row; in that case say for example, I consider one row then it
is a one-dimensional array. When I consider rows as well as columns then it is a 2-
dimensional array; however, we will now initially concentrate on one dimensional array
like this ok. What is this? This is an array of people similarly, we can have array of
numbers.

For example, 1 7 0 5 3 that is again an arranging of data arrangement of data in a linear
near fashion ok, this is the first element and this is the last element of this arrangement.
So, this is also an array, array of some numbers. So, in an abstract way we can say that
an array can be drawn in this form it can be an array of integer or an array of real
numbers depending on what I want to store here, suppose this b and array of integers.
Then each of this places can have one integers stored in this 2 6 5 3 may be again 2 and 9
so this is an array.
Now, how any elements are there in the array? Each of these are elements of the array
how many elements are there in the array 1 2 3 4 5 6. So, this is the size of the array and
these are the elements of the array this all these are elements of the array. Also another
thing we need to know is how do I identify one element of the array, say this element 6

of the array this array how do I identify that what is it is identification, the identification
is the position. So, this is a second position alright this is the first position this is the third
position 4th position so and so forth.
Now, this positions in the array is known as index. Index is the position in the array;
index determines position in the array position of what? Position of an element in the
array so, for the time being we assume that arrays are linear structures linear arrangement
of data. Now one point to remember is one array can store data of the same type. For
example, it is not possible to have an array.

In which there will be some integers some real numbers and some again characters ok.
So, that is not possible that is not allowed.
So, an array will is allowed to store data of only one type. We now that int float, char all
these are defining different types of data or data type, right or data type. So, an array can
store data of only one data type whatever that is it can be all floating point numbers, it
can be all characters, it can be all integers whatever, alright?
So, these are 2 words of cautions. So, what have we learnt? We have learnt that array is
an arrangement of data of the same type and the array has a is identified as a whole by a
name and say for example, this array this is not a valid array so let us have a valid array.

Let us have a valid array of 4 elements say of real numbers may be, right?
So, this array will have name let us say arbitrarily put a name A ; that means, A is the
name to this array and this array has got a type, what is the type of this array? The type is
float so array A is a float. So, A is a is an array of type float; that means, it can store only
floating point data. Also, an array consists of different elements each of these are
elements and each element each element can be a floating-point number. And the
particular element is identified by the index of an array, alright?
Now, and also, we have we know that an array has got a size, given this let us think of
why are we talking about all these things, why is this needed after all? We have
encountered till now quite a few example problems for example; let us again come back
to the old problem of finding the maximum of a set of integers.
Now, in that case what did you do? We read one integer we initialized a variable.

So, first integer we read let me once again do it. So, if you recall we I am writing the
flow chart I am not writing the c program. Read a number you know how to read a
number by scanf then put that number to be max read again read number. And if number
is greater than max then I am writing pseudo code. So, I can write then max is getting the
number, again I read number and in that way I go on or you can say that ok, why should
I write in this way? I shall simply implement a loop wile loop or for loop. So, that this
thing is carried on till I stop, say for n numbers or for ah. So, here I can use for I assigned
1 to I less than equal to n I plus plus to implement the loop here, but that is possible
when I know the total numbered of numbers.
If I didn’t know the number of numbers there are some other ways of doing it say for
example, I am reading integers and I say when I want to stop I will enter a 0. So, here I
could have put in something like this while num is greater than 0 do so we do this as long
as num is greater than 0 I am going on doing this. And if num is 0 or num that we decide
or some negative number I know that my job is done. So, but in this case if I want to
remember what were the numbers already given to me suppose the numbers that were
given were 5 initially here then 2. So, nothing was done next was 5 then 7 then here there
has been a interchange. So now, here max becomes 7 then again it was 3. So, nothing
was done then it was 8 and max became 8.

So, that will work for this sort of program, but if I want to know what where the numbers
he was saying max is 8, but what where the numbers that where input by the user we
have not remembered them anywhere is not it, you have not remembered them
anywhere. So, here in my program, I will not be able to say what was the second number
entered, what was the first numbered entered, was there any 0 entered or was there any
anything greater than 3 entered, we cannot answer these questions because we read this
and we operated on this and we forgot them.
Now, if you can think of that if I had used an array.

This sort of thing and I had as the user give the numbers I stored them here 5 then 3 user
gave 3. I stored 3 here then user gave 7 I stored 7 here, then the user gave something may
be again 4 I stored 4 here, and then the user gave 9 I stored 9 here. Then even after or 8
here I even after reporting the max that this is the max I have got these in my array. So,
my name of the array is still A which A is an array of integers. Then this is stored here I
have remembered them in the array.
So, I can now say what was my first element I go to the first element of the array using
the index value ok, and second, I go to the this value ok. What was the 4th value? First
second third 4th I come to this point and I can say the 4th value was this. So, all these
things I can remember because I have been able to store them in the form of an array.

So, that is. So, array is again an arrangement in the memory alright.

So, an array when I. You know that every variable is stored in a memory location, right?
So, when we had num and the program that I had written that num initially I sorry I
initially I read num. And then I do this and then again read num if num is greater than
max, max assign num when I do this thing in a loop or whatever, what is happening?
Whenever I have got variable num is a variable one location in the memory. This is num
and max is another variable I have declared all of them here int num, int max I have
declared them.
So, here there is another location which is known as max. So, when I did this read num
and suppose some data 5 was read that 5 is stored here alright, 5 is stored here when I
come here and I put max num assigned to max so it comes here. Now I read num again
so suppose num is 4 and no update in max next time I read it 7. So, this is updated here
and this becomes 7. So, this is the process that goes on alright.
Now, may so every time I am losing the old value of num and storing the current value
of num and similarly whenever there is an update required I take the current value the
max up to now ok. So, I am having 2 variables of integers, but if I had done it in the form
of an array then I could have thought of like this that I have got suppose the array size is
5.

Suppose the array size is 5. So, that means, conceptually I am talking of something like
this that there are 5 positions in this array. And as I am getting the data it is coming over
here 5 3 7 2 9 whatever. Now actually internally what it is happening internally this is
being stored in the memory the array size is 5 here. So, I have got 5 locations in my
memory 4 5.
So, these 5 locations of the memory are being given to the array a suppose the name of
the array is array A. So, for the array A so, the first element is coming here when I am
actually writing it here it is coming here, second element is coming here, next element is
coming here, next here next here so these are the memory locations. So, an array is
actually a a representation in the memory which are contiguous and you know each
memory location has got an address.
So, suppose hypothetically the address of this is 1000 and each of them are integers and
integer if I say integer is requiring 2 bytes. Then if this is thousand location the next one
will be 1002, next one will be 1004, then 1006, then 1008, 1008 to 1009, right?
So, 1000 to 1001 is for the first element this one coming here 1002 to 1003 for this
element, 1004 to 1005 is this element. 6 to 7 is this element 1008 to 1009 will be this
element. So, 1000 to 1009; that means 10 locations we are requiring for these 5 elements
of the array. Now since also in my program I have got 2 other variables one is the num or
one is the max, alright? I can manage it with one more variable max is separate variable.

Suppose. So, that is here this variable is max let me delete this for you this is not
required, alright? It is because this diagram has re-ductant because max is another
variable which I have here. Will write a program will show later how we can write a
program to deal with this.
So, everything. So, since I have computed I have red the numbers I have stored them in
the memory locations and since I am going through an array I am not written overwritten
one number by another therefore, I can remember all the numbers. So, this is one basic
reason of usage of array where I want to remember the numbers in the memory given
this let us quickly recapitulate what we have said till now.

So, many applications require multiple data items, but have a common characteristics,
what is that common characteristics? Common characteristics like whether they are
integer or float or character whatever that is it can even more complex. So, we call say;
so that numbers that we are showing say we can in mathematics we often represent them
as x 1, x 2, x 3, x 4 say up to x n. And that hold thing I can represent as an array x where
x 1 is the first element, x 2 is the second element, x 3 is the second third element like that
Now, here is the example finding the minimum set of numbers minimum of a set of
numbers. How we can find a minimum of a set of numbers. So,. So, this is what I have
already discussed.

But just for the sake of revision let us look at it once again say for 3 numbers you know
we can this program must be familiar to you now, you should be able to understand it
quickly if a is less than b and a is less than equal to c then a is the minimum I was
showing the maximum here it is an example of the minimum else if b is less than c then
b is the minimum else c is the minimum.
So, first so fine as soon as I extend from 3 numbers to 4 numbers you see the program
becomes a little bigger. If a is less than equal to b and a is less than equal to c and a is
less than equal to d then minimum is a, otherwise if for you see if everywhere I have
brought in more number of comparisons and the program code has also been bigger
alright? And I am not storing the numbers as yet I am not storing the numbers that is one
issue.

The problem is so from 3 to 4 we need needed so much extension.
Now, suppose we have got 10 numbers to handle that will be even bigger 20 numbers
even bigger 100 numbers. So, how do you do that? The solution is the solution to the
problem is what is a solution? The solution to the problem is use of arrays right using
arrays, right?

Now as I said that all the data items constituting the group share the same name all these
data items that I had shown say integers like 5 7 6 3 2 all these can share the same name
x or may be let me give a meaning full name NUM.
Now, this one is NUM 1, this one is NUM 2, this one is NUM 5 ok. So, I have got just as
we had shown x 1 x 2 up to x n so here n is 5 so I have got this 5. Individual elements are
accessed by specifying the index; this is the index which is telling me in which position
which number in this array of numbers I am looking at ok. We will look at this further
the use of arrays and anymore things are to come.
So, we were looking at arrays and we have seen that all the data items constituting the
array shared the same name.

So, we can call an array to be A, an array A or a array num. If the array be A then the
elements are a 1, a 2 like that up to a n, where n is the size of the array and each
individual elements are being accessed by this indices, these are the different indices.

So, for example, here when we declare here comes a new thing. Suppose we have an
array where the size is 10, so there will be 10 elements of the array, 10 elements of the
array. Just as and just like variables array as a whole is also a variable. So, suppose I
name this array to be x these are x 1, x 2, x 3, x 4, x 5 like that up to x 10. Now, just like
we had to declare the variables like int float here, here also we need to declare the array
and the way we declare the array is shown here int x 10 what does it mean; that means, x
is an array of now I am introducing a term of dimension 10. Earlier I was talking calling
it size and here I am calling it dimension. For the time being assume that both these both
of these are the same thing, but actually there is a difference, we will explain that in the
course of discussion.
So, we declared it first of all the type of the array as I had said that an element all the
elements of an array has to be of the same type. So, either all of them will be integers or
all of them will be floats therefore, this entire array has is of a type int which says that all
the elements of this array are integers and x 10. So, let us quickly have a look at the
memory scenario. Say in the memory, this is my memory and this is the memory and in
the memory some locations are kept for the array x; that means, start from here and
maybe up to this.

Now, how much space will be given to the array must be known to the compiler because
the compiler just like the compiler allocates variables to different memory locations the
compiler will also have to allocate locations memory locations for the array elements.
Now, when I said int x 10; that means, the compiler will store space equivalent to 10
integers, 10 integers in the memory, 10 consecutive places for 10 consecutive one after
another no gap elements, 10 consecutive integer places in the memory. Therefore, how
many can you tell me, how many bytes are required for that? Integers and I have
assumed that any every integer is taking two bytes, integer is taking two bytes. If I
assume that then I will require 20 bytes here. So, there will be 20 locations each location
consisting of two bytes in this way we will go on, right.
So, you must understand when I declare this, what is the meaning of this. Dimension of
the array means that I am storing, I am reserving, I am reserving the compiler reserves
the space for 10 integers and that has to be done before the array is used, before the array
is used therefore, it must be declared before so that the compiler while it is compiling the
program can allocate enough space.

So, and now individual elements are accessed by specifying the index. So, here x, this x
is a 10 element one dimensional array linear. Now, comes a peculiar thing if you look at
this, we are saying that each of these elements are stored in these locations and which are
identifiable and accessible by the indices. Now, in C language each index, the index
value starts from 0. So, the first element although while discussing we are saying x 1 say
I was drawing an array like this where I was saying that these elements are the first
element x 1, x 2, that is true, x 3, x 4, x 5, but in C these elements are counted the
counting is started from 0, there is a reason for that which will also be evident soon.
Just remember for the time being that the first element therefore, x 1 is actually
represented in C as x then the square bracket followed by the index and the first one will
be x 0, second one will be x 1, therefore, can you tell me what will be the last element of
this array? How do I represent that? Yes, you are right x 5 will be nothing, but x 4 yeah.
Since I am starting with 0 I can go up to 4. Here in this example as you can see that I
have got 10 elements in the array therefore, I start from 0 and go up to 9 that is what is
followed in C language. There is a reason for that let me just briefly mention the reason
the reason would be this.

As I said that in the memory the array is stored in a particular region. When I declared it
as int x 10 then 20 bytes have been given to me and the array starts from this point which
has got some address maybe 1000 and this address is starting is 1002.
Now, and I know that each one is of size 2. So, when I say what is the address of x 1.
What is x 1? x 1 means here and I know the starting of this array. So, start address plus
index times number of bytes for integer will give me the actual address. So, for the first
address what will be the index x 0? So, my start address is thousand for the first one
thousand plus 0 times 2. So, that will be 1000 for x 1 1000 plus 1 times 2. So, that will be
1002, for x 5, x 5 in this way is which element; 6th element.
So, that one will be here 1 2 3 4 5 6, 1 2 3 4 5 6 this element. And what would be its
address? The address will be 1000 plus 5 times 2; that means, 1010 it starts from 1010.
So, 1002, 1004, 1006, 1008, 1010 here it will start. So, this is basically the offset. How
much I shift from the top, that is the reason the ease of computation of the address of any
of the index any index, any element with any element with a particular index can be done
using this method this formula and therefore, we start with 0 that is a specific reason for
starting with 0, all right. So, this is a 10 element one dimensional array that we have
seen. Let us move ahead.

So, like variables the arrays that are used in a program must be declared before they are
used the general syntax. Just like in integer or float we had declared them as in float
before they are used. Why do I need to declare them before they are used? Because the
compiler needs to allocate space for that otherwise the compiler does not know what type
of variable it is therefore, we also have to do the same for the array and the general
syntax will be type, array name, size. Now, again here the size I mean the dimension.
Type specifies the type of the element that will be contained in the array it can be int,
float, char or whatever.
So, I have got fields like say here I can have an array I can dictate as float the array name
can be my array and size may be 20. Now, this one specifies that this array can hold only
floating point numbers, and suppose floating point numbers are 4 bytes each then for
how much memory will be reserved for this 80 bytes will be reserved for this because 20
is a size; that means, the maximum size that the array can take. And what is my array?
Everything a just like every variable must have a name this array my this area also has
got a name called my array. And so what will be the indices? I am repeating the thing my
array is 0. So, I am writing ma for short 0 and what would be the last element here ma
for size 20, it will be 19, is it all right.
So, this is the general syntax which a must put and also there should be a semicolon at
the end, just like other declaration there is no other major difference here.

Size is an integer constant here I am calling it dimension that is it is a maximum number
of elements that can be stored inside the array. Suppose I have got so much space kept
for storing an array all right, so much space many many elements can be stored I have
reserved so much space, but in my actual working I am using only some spaces and these
are not touched that is allowed that means, but the reverse is not allowed. Unless I can, I
have got the space unless I have got space I cannot store them. So, I must reserve the
space beforehand but. So, that is why I want to I was mentioning this maximum space as
dimension and the actual number of spaces which you are using to be size of the array all
right.

The reverse is not true because suppose I have an; I have reserved. So, much space for an
array and I go I go beyond that then these marks are spaces for other variables like a b c,
their data will be destroyed by my data which I am taking as an array. Therefore, we
must restrict to this, but suppose out of this I am using only this much in my parlance I
am calling it size and this to be the dimension you can call it in this example in the slide
we are calling this to be the size of the array there is a maximum size of them. So, what
is dimension? Dimension is the maximum size that the array can be off, but in practice in
actual running it can be less than that, but not more than that.

So, I hope that part is clear to you. So, here what did I write? int marks 5 what does it
mean? It means I am storing marks and the marks are all integers right 50, 55, 60, 100 I
am storing integer marks; and how many marks can I store? 5. So, what will be the
indices? 0 marks 0 to marks 4 that is the index limit because I am starting from 0 I can
have only 5 positions. So, marks is an array containing maximum of 5 integers.
If a teacher decides that he will give fractional marks that somebody can get 62.5
somebody can get 70.2, somebody can get 59.7 then what change should we do the
change that we should do is this will be replaced with float. And if I say in my class there
can be maximum 20 students then what else should I change, I should change this and
make it 20 that is how I should declare all right.

Here are few examples int x 10; that means, x is an integer. How do we read it? x is an
integer x is an array of integers of size or dimension 10. char line 80; that means what?
that means, line is a variable array of type character. So, what will it be? There will be 80
such positions usually when we take a printout usually when we take a printout of
characters the lines were conventionally 80 characters in a line. So, there will be there
will be positions like this all through maximum 80 all right. So, the size will be 80 and
this variable is known as a line and what can it hold it can hold a characters like a, sorry
a there can be a space, space is also a character I denote space as a blank like this then

maybe x is a character, then there is a blank a blank is also varied character then c, then
d, all those things can be there.
So, it is an array of say ultimately say p is the last character something like this.
Altogether 80 spaces for character I keep in my variable line and what is the type of the
variable that type of the variable is an array, array of character all right.

Similarly, I am saying that there are 150 points, there can be 150 points and each of those
points are floating point numbers. Say name, I just stored a name, I want to store the
name of a person say name S Ravikumar is the name of a student and I want to store it in
a computer. How do I store it? I can store it in the form of an array where each of the
elements is a character first one is S then dot then r then a v i k u m a and I need one
more space r.
So, you see I needed one more space here. Why? Because I had taken I did not have
enough space here. Now, each of them is a character by the way you know that a
character is denoted like this so and so forth. Now, what this line says is that name is a
variable which has got that the capability of holding 35 such characters, it has got the
ability of storing 35 such characters at the most.
Now, how much space should we keep? How much should I keep here? If we are not
sure of the exact size of the array we can define an area of large size. Say if I think if I

have got no idea of how the what are the typical Indian names for example, or American
names for example, I can keep name 100, but is it advisable not always. When I really do
not have any idea I have got no other way, but to do it, but if I have an idea of how much
the name length can be at the most I should keep so much size because if I keep an
arbitrarily large size then what am I wasting, I am wasting my memory space because
each of these are a memory location.
Suppose beyond this never a name can extent to then I should not keep this part in the
name. But when I have got no idea of course, I have to keep a bigger large size. So, that
is the difference between the actual dimension of the array how much reserve we do and
for a S Kumar, S Ravikumar for example, my actual size is 1 2 3 4 5 6 7 8 9 10 11 all
right out of 35, 35 was the available number of spaces.

So, when we say it is int marks 50. Suppose in my class I have got say 10 students and I
am going to store the marks of only one subject in that case there is no point storing so
much space I mean it is like reserving so much space for the variable marks. If I know
since I know only 10 students are there, if I know beforehand then I can I could have
written int marks 10 or if I had known that sometimes the number of students in the class
are 10 sometimes 15, but never more than 20 then I could have kept marks 20, but I
should not keep marks 50. I hope the point is clear now.

Now, I have already described this how an array is stored in a memory. Starting from a
given memory just let us have a revision of this, starting from a given memory location
the successive array locations this is very important, the successive array elements are
allocated spaces in consecutive memory locations one after another.
So, array a will have memory locations one after another like this let now the same
computation let us do it again. Let x be the starting address of the array sorry let x be the
starting address of the area address, this is the address and k is the number of bytes
allocated power array element I had shown it for an integer now I am showing it in a
generalized form, x was the first starting location say 1000 or whatever and k is the
number of bytes allocated.
Now, then the next one will be x plus k because it started with x and needed k locations
the next one will start from x plus k, the next one will start from x plus 2 k like that the
ith element therefore, will be as we had computed earlier will be x plus i k and since we
started with 0 that will be perfectly all right. Element a i will be located some a i will be
located the address say a i here will be located starting at x plus i times k. Just a little bit
of puzzle here I have written it here. Like this a common mistake could be that I what
would have happened if I had written it like this. What is the problem of writing in this
way? the problem is; what is i k? i k is not i times k not i multiplied by k, but i k is
another variable name all right.

So, these two are not the same thing. Whenever we go for programming we should be
very careful. So, first array index is assumed to start at 0, in C we are doing that.

So, a particularly element of an array can be accessed by specifying two things. What are
the two things? Name of the array? Index, index is nothing but the relative position of the
array. We will continue with this discussion further.

So, we now know that an array is identified by a name of the array. Some name like x,
num, whatever and there is an index num i or say num 4, num 5 etcetera. So, by this
index, by this index we identify which particular element of the array I am referring to.

Now, in c also you have said that the array starts from 0, the index of, the value of the
index starts from 0 ok.
Next. So, when we have an area defined as int x 10, the index are from 0 x, x 0 to x 9 all
right. The first element can be accessed as x 0 first element can be accessed as x 0 and
the fourth element as x 3, the tenth element as x 9.

I hope this is clear to you by now that this one is arrays x. So, this is x 0, this is x 1, the
fourth element will be 3 and the last element will be x 9.
So, that is how the array elements are addressed, how they are referred to by the indices.

Now, these indices must be integers. Now, the indices must be
integers that is very important. So, if I have got an array defined as int x n, where n is the
size of the array then the value of this n this index value of this index must lie between 0

to n minus 1. So, if it were twenty then the value must lie between 0 to 19 where n is the
number of elements in the array.
Now, you can see here in this example that it is not the case that always I have to put a
fixed integer as the index of course, I can write for an array, say an array is a I can
always refer to some element of the array as say a 4 for the fifth element or I can have
some other integer value x and suppose x is 2 now and if I refer I can refer to the same
thing as a x plus 2; that means, this will also evaluate to 4 and this will also point to the
fifth element of the array. Now, one thing that we have to be careful about that this value
that is computed lies between in this range between 0 to n minus 1.
So, here is another example where the array index value has been computed through an
expression 3 times x minus y is assigned. So, suppose here you can see that we are
talking of two variable, two array variables.

So, let us draw a picture. A picture always clarifies the things much better. So, let us
have an array a and array b, a and b are two arrays right.
So, suppose x is 2 and y is 3 then this statement what does it do? A assigned x plus a x
plus 2, x is 2 plus 2; that means, a 4 right. So, a 4 the fifth element is being assigned the
value 25. And what is being done here? x is 2 a 10 minus x. So, that is a 8; that means,
the ninth element, let us have the fifth let me make it a little bigger suppose this is the

suppose this is the ninth element a 9, a 8 sorry a 8 this is 8. So, that was suppose 30 that
is being taken plus 5 is being added to that. So, 30 plus 5 that is 35.
Now, note this, this part is being evaluated. What is being done in evaluating this part? I
have got x to be 2. So, I am computing 10 minus x I get that to be 8; that means, I want a
particular variable which is stored in stored as a 8; that means, in the nineth location of
the array a and that is 30. I take that value 30 and add 5 to that, so I get 35. And then
what do I do? I store it in the array b and wearing in the array b.
Now, I will compute this part 3 times x, x was 2. So, 3 times 2 is 6 minus y, y was 3. So,
it will be 3. So, in b 3, b 0, b 1, b 2, b 3; that means, again in the 4th element of this array
b 3 I will be storing the value 35. So, now, the array b will have the value 35 here. I hope
this is clear. So, you have to be very clear about the distinction between the array index
and the value of the array.
So, this 30 that I got after computing the index a 8 that was telling me where in the array
I should look at to get that value. And then that was just a value and with that value I had
another value 5 I added them together, I added them together and got the value 35. Now,
I see where I am going to store that for that again I compute the index here and I
compute the index the index must be within the range 0 to n minus 1, I compute that and
I find that the index is 3; that means, in b 3 I have to store the value and go to b 3 and
store the value. I hope this is clear right.

Now, in C, there is a word of caution here that in the language C the array bounds are not
checked for example, int I have got declared int marks 5; that means, I have got an array
marks whose size is 5, a dimension is 5; that means, at least I can have 5 elements in that
all right. Now, here what I am trying to do, here what I am trying to do is I am trying to
write 75 in marks 8, but there is no space for marks 8, it was 5 6 7 8 this is the place
where I am going to trying to write 75.
Now, it would be good if the compiler could give me any error that hey you had declared
it that size to be 5 and you are going beyond the border all right, you are crossing the
border. So, be careful warning syntax error or whatever syntax error and you are not
allowed to do that, but unfortunately array bounds are often not checked. So, what can
happen if you are not careful, then it will not necessarily cause an error, but will be
writing something here all right, it will be writing something at this point which might be
when I allocated the compiler allocated the memory this part was for the marks and this
part were for other variables x y p and whatever value of p was there that is overwritten
with 75. So, one must be very careful about this when writing the programs and running
it.
Suppose it is a very common thing that often you will find that there are some funny
errors occurring and the reason for that maybe you have crossed the array boundary.

So, it can result in unpredictable results. So, general form of initialization of arrays
whereas, the array name size with some list of values how do we. So, recall that we had
done we can do initialization slight int x equal to 25 semi code, where I declare x to be
an integer and also initialize it to a particular value.
The same thing can be done for arrays for example, I can write int marks 5 72, 83, 65, 80
16. Note that this initialization is within this two curly braces. That means, here I am
creating an array whose name is marks and the values are 72 for mark 0, 83 for marks 1,
65 for marks 2, 80 for marks 3 and 76 for marks 4, 0 1 2 3 4 5 elements. I can declare in
this way this is one form of initialization. Remember that here we are putting square
brackets for declaring the dimension, but here we are putting curly braces.

Similarly, this one char name 4 I have just typed in an array, so the array has got 4
elements and what is stored here A m i t, Amit. So, basically the name is Amit. So, that
is coming as a string of 4 characters. Although I use the word string be careful about that
because string has got a little more thing to it which I will describe later, but right now it
is an array of characters, the characters array of characters of size 4.
Now, there are some special cases the number of the, if the number of values in the list is
less than the number of elements the remaining elements are automatically set to 0 are
automatically set to 0. For example, in this case I have got a variable what is the name of
the array here the name of that is total and what type of array is it, it is an array of

floating point numbers and so there are 5 elements, 1, 2, I have got 5 spaces, 2 3 4 and 5.
There are 5 spaces yeah and I have loaded initialize it to this value.
So, here it is 24.2, the next one is minus 12.5, the next one is 35.1. The remaining
elements which are not filled up are filled up with 0s automatically by the compiler if it
is less. Now, be careful that sometimes some compilers behave in a are implemented
without doing this bit and therefore, you must check whether your compiler usually the
standard compilers do that, but you should be careful about it.

So, total will be this as I have said here. The size may be omitted in such cases the
compiler automatically allocates enough space for the initialize variables. So, when I am
initializing it then it is possible that I can write I can leave out this size because I am
already writing it here in this form therefore, in this case what will happen flag and array
will be created just for the initialized values. So, a 4 element space will be given to you
which will be 1 1 and 0 because I have not mentioned anything here, but I must give this
symbol because just to distinguish it between int flag and int flag this because this is just
a variable integer variable this is an integer array. So, you must be careful about this too.

So, similarly I could have done char name, I did not put anything here and just write A m
i t.

Now, let us come to this example finding the minimum of 10 numbers. Now, we are
doing our first programming with arrays. We are doing the first programming using the
arrays.
Now, here what we are doing is first we are reading the numbers I am reading the
numbers all right. I am reading the numbers so and then I am storing them in an array.

So, let us look at this line by line. Let us look at the declarations; int a 10 what does it
mean that I have got an array of size 10 and the name of the array is a all right, there is
space for 10 elements a 0 to a 9.
Next, I have got another variable I one variable another variable mean. So, that is my
declaration part now I am printing here give 10 values. So, on the screen I will find that
give 10 values and then backslash n.
So, now the user is entering 10 values and what am I doing? I am reading those 10
values. Now, compare when you till now when we read the different integers what did
you do we wrote it like this right, scanf, percentage d meaning that is an integer
ampersand, num something like that we did to read an integer called num. Compare that
with what we have done here. Here what we have done is scanf percentage d remains the
same because whatever I am reading is nothing, but an integer and ampersand a i; that
means, this array is ith element I am reading, this means a I means I am reading the ith
element of this array a. What is the value of i? i is 0 initially.
So, first time whenever I am I have asked 10 values. So, i is 0, first i is pointing here. So,
i is 0. So, this; that means, this is pointing here. I read a particular value 25, I store it here
all right. Then I go in the loop what happens? i plus plus, i is incremented to 1; please
observe this carefully this variable is incremented to 1; that means, now the index shifts
from here to here a 1 and I read and that is less than 10 typical for loop. So, I come here
read the second value say 3. Go back increment I it becomes 2 less than 10 I come here
let this brings 2, means again this is changed to the next element all right and I read the
next value which may be 37. In that way I go on and read 10 values. Every time I am
reading one particular integer and that is being, where am I storing it that that is the
importance of this ampersand; that means, that I am reading this at the address of a i, so
at this location.
So, this is the first part, first part of the program that has read the array. Now I want to
find out the minimum of the array. Now, let us see.

Let me now. So, is this part clear how we read the array now? So, in this way suppose I
have read the array some array like say 5, 3, 200, 75, 1. Now, in this part of the program
I am trying to find the minimum and that is typically what we did last time, done here in
a little bit different way I am starting with a min mean which is very large. So, I am
assuming that there will be no data given at this point, at this point no data will be given
which is as large as 9 9 9 9 9, I am assuming that.
So, again in a for loop here i is starting from 0, that is i is pointing here. I am comparing
a i; that means, a 0 a 0 we with min a 0 is less than min therefore, I can assign a 0 to min.
So, my min becomes 5. I go back to the loop i is incremented. So, i is incremented and i
comes here; less than 10, so I come here and again compare a i. What is a i? a i is this
value 3, is 3 less than min yes. So, the min becomes 3. I again go back increment the
index.
So, you see in this for loop I am incrementing the index. We will see how we can write it
in different ways. Now, this is a very important exercise and you will have to program it
yourself meet with errors at several times, but then ultimately we will find it that is not
that difficult. So, i is now 3, I again compare 200 with min now 200 is not less than the
min. I go back to the loop I is incremented, 75 is not less than the min I come here, 1 is
less than the mean. So, this will be like this in this way it goes on.

So, here we could find two distinct applications of this for loop, one for reading the array
and storing it in a set of locations and the other one is looking through that array for
every element I am looking through this area and I am finding the minimum. Now, let us
do a little bit of exercise before we conclude this lecture today. Say I want to read an
array of integers and I want to print the array. So, what should I do? I am leaving out the
standard include stdio dot h declaration, declarations let me do; int let me call it, an array
m underscore a meaning my array and let the size be 10 all right.

Also i, and then index i index need not be i, but it must be an integer variable and then I
am starting to read the array, I am trying to read the array. So, my program started here.
For reading the array, I am doing for i assign 0, i less than less than 10, i plus plus scanf
percentage d. And what am I reading? m a i. So, in a loop I will be reading m a 0, m a 1,
m a 2 like that and then I want to print the array.
So, suppose I have read an array which is something like 3 2 4 5 1. Now, I want to print
the array. So, what shall I do? I will just simply again I will take one elements one by
one and will be printing them. So, I can write for i assign 0, i less than 10 i plus plus; that
means, I will be doing this. So, i is starting with 0 and will go up to this here I am
assuming that there are 10 elements here although I have shown only 5, then printf I can
say that, so I am printing the value of m a this percentage d. So, these things will be as it

is printed except for this is percentage d backslash n and sorry backslash n and then it is
continuing m underscore a i. Let us see what will happen and then I conclude this.
So, I have stored this now I am printing this. What will be printed? Some printing will be
something like this let me use another color for this. What will be printed is the value
first iteration. First iteration what will be printed. The value of m a; what is the value of
i? I am sorry here, there should be another one I have written wrong they are two
percentage d is, so here should be i comma this all right. So, I will repeat again. The
value of m a. Then this, then this part will come and this will correspond to the first
variable that is i. What is the value of i? Value of i is 0 is, then the second with, second
place holder that is m a 0s value; that means, it is 3 backslash n. Again it will go in the
loop and what will it again print, the value of m underscore a will be printed as it is
percentage d the value of the index of m a 1 is then the value m a 1 is 2, is 2 like that it
will be printed. So, these are two fundamental operations of reading an array and printing
an array. We will continue further with the arrays.

So, we saw a program where we are finding the minimum of a set of 10 numbers.

So, here the program is restricted as you can see to 10 numbers and accordingly I have
declared the array a to be of size 10 and also this iteration values are also iteration limit
has been kept to 10. Now, when we did that just a quick recapitulation of what we did in
the last lecture that here is the array declaration and this is where we are accessing the
array elements. Here you can see I am accessing the array element a i, a particular array
element here and assigning that to another variable mean.
Now, here it is very important how am I reading the element. Now, since an array
consists of a number of elements sorry, the since the array consists of a number of
elements I have to read them in a loop that is a very fundamental thing that you one
should understand that at a time I cannot read the entire array in one shot, except for the
case where I initialize it and when I declared the array I give int a, so and so values
within curly bracket that is one way. But if you have to do it at runtime; that means,
whenever the you asking the program is running and you asking from the user that you

entered the values then you have to take one bit of value at a time just like this and store
it in the array.
So, that has to be done in a loop for by varying this indexes one after another as the
index moves I load the different locations with the values. Now, given this we can have
an alternate version of the same program.

You can see that here we have added one line that is this line, define size 10. This is
again the use of hash define that we had learnt when we defined pi to be 3 point we had
encountered this defined pi 3.14 etcetera etcetera. So, similarly here I am defining size a
variable size to have the value 10, therefore, I now, can write this dimension as size.
Now, please note that the compiler look at it from the angle of the compiler, the compiler
will try to allocate some memory location some amount of memory location ok. Now, if
there be a variable size it really does not know how much memory location to allocate,
but since I have defined it earlier it now, knows size means 10. So, it will replace int size
with int size sorry, int a size to be int a size 10.
Now, next thing you do is wherever I had i less than 10 I make it size i less than size here
also for the for loop I make i is less than size. Why did I do that? What is the advantage
of doing it? Now, suppose you have got this program and how many places is size being
used it is being used in 1 2 3 places in another program it could have been used in more

number of places. Here we have not printed the array, I have only printed the minimum.
So, there could be more places where sites could be used.
Now, suppose I want to modify this program, or reuse this program for an array of size
100 only thing I need to do is I change this 10 to 100. And please note that after defined
any hash define does not have a semicolon because these are not part of the program,
these are commands to the compiler or pre processing commands.

So, I if I could make it 100 then this would be replaced by 100 it would be a 100 and
here it should be i less than 100 automatically, i less than 100. I need not change it at all
the places that is the advantage of the hash define.

So, we change we can change only one line to change the problem size. The problem
size from 10 to 100 to 1000 we can change by just changing one line.

Here is another version of the program. Here we have not defined hash defined, but I
have kept a large size 100. Now, so, I have got an array space of 100 elements all right
100 elements. So, much space is kept for me by this line. Now, what I am doing is I am
asking from the user you please tell me how many elements you are going to input.
Suppose here and that I am taking as a variable n, n is a variable where I am just asking

the user give the number of elements n and when the user is typing say 25 then that goes
as n. So, out of now, this 25 is of course, less than the size of this which is 100 it is less
than that.
So, now, I will just work not for 100 elements, but for 25 elements why because the user
has already told me that I want to input 25 elements. Therefore, what modification
should I do? Again here I want to make it interactive. So, I again tell the user on the
screen you will see this message input all in integers and the user is entering them one
after another. He can type in 25 enter 35 enter 42 enter like that or he can give space and
go on typing that.
So, for i less than 0 to n, now what is n? n is 25. So, now, it is for i to i, 0 to 25 I read the
number. So, I will be reading 25 numbers here 5, 20, 16, 12, 9 etcetera etcetera I go on
and I will go up to 25 not 100 all these. So, this space will be wasted, there is a wasted
space. Why wasted space? Because I had deserved 100 locations, but the user has just
agreed to give only 25 numbers and then the remaining part remains the same here also I
will be dealing with n. Why n? I will be searching. So, when I did this the array that I got
is actually although they were 100 elements the array was actually of 25 elements right,
the array was of 25 elements. So, I will have to find the minimum within this zone and I
need not go here.

So, that is another version of the same program. So, here what is done is we define an
array of larger size and only use the required amount out of that all right. Now, let us do
a programming ourselves. Suppose I want to read the some integers and I want to find
out the sum of all the integers that old example that we had done earlier. How did we do
it earlier let us recall.

We did let me write it in this way sum there was something like sum assign 0, then
printf, enter the number, then scanf percentage d and num sum equals sum plus num and
then this has to be done in a loop ok.
So, watch how can I make a loop out of this. So, I also read another variable the number
of numbers. So, sum n was read here. So, I had done some scanf. I would say let us say
of 10 numbers. So, I need not scanf. So, this thing I have to loop right this part I have to
loop how long. So, what should I put here? At the beginning for doing the loop for i,
since I know beforehand that there are 10 numbers, i assign 0, i less than 10, i plus plus
then I put a parenthesis here and a parenthesis here. So, and the first statement comes
here. Confusing? Should I write it again or is it clear.

So, I can write for i assign 0, i less than 10, i plus plus, printf please enter the number
backslash n, then here I had done sum assign 0 scanf percentage d and num sum assigned
sum plus num that is how the loop will go on. But here I am not remembering the
number.
So, what I can do using an array what I can do is, let me now do it using an array int,
num say 10, comma i is another integer variable. Now, and also I need sum sorry sum is
also another integer, sum.

Now, I will first read the array, the first is reading the array. So, let me put a comment
read the numbers all the numbers earlier you see the scanf every time I was doing scanf I
was reading the number. Here I am reading the numbers and storing them.
So, what should I do? For i 0 to i less than 10, i plus plus let us increment the array.
What am I doing? Printf enter number backslash n scanf. Now, what should I do? I am
reading an integer, so percentage d and ampersand. What should it be? What am I
reading first? Here is an array whose name is num. So, what is the first thing that I will
be reading? First thing that I will be reading is num 0 this element, so scanf percentage d
and num i. Why i? Because i is the index and I can see that initially i is 0. So, whatever is
being scanned will be stored here then I will go back in this loop then the next one will
be stored then the next one will be stored in this way the entire array will be stored after
that I am trying to find the sum. So, now add the next part that I do is add the elements.
Now, in this here I will have to again add the elements. So, suppose the, suppose the
array that has been formed has got some elements like say 5 7 13 12 6 so and so forth.
So, this I have to add this with this then I will get a sum and with that 12, I will be
adding 13. So, I will be getting 25, then 25 and 12, 37 in that way I will go on.
So, here I initialize sum to be 0 and then for again I assign the same index I can use, I
could have used other index also i less than 10 sorry i plus plus. I hope you remember
that after each of these we put a semicolon right in for loop, some assigned some plus
num i. So, what will happen? Sum was 0, sum is 0. First, in the first iteration of the loop
what will happen? I take my value of i is 0. So, num i will be taken and what is num i,
the first element of the num array. So, that is 5 sum plus 5. So, sum will be 5.
Now, next I go back here i becomes 1. So, i come to the second element and i add that
with sum. So, sum becomes 12 automatically go there I take the index is updated, i is
being updated here. So, I take the third element and add with sum, so it becomes 25 and
in this way I go on adding them all the elements in an area. So, the same thing I could do
using, but in this case what is the advantage that I am getting? I have got, I have not
forgotten the numbers that I have read. So, I can do that and again I can print all these
numbers I can say now, the sum of these numbers is so much.
So, that is how we can use an array. Now, suppose I had, I had to find the average of the
elements what should I do? I have got the sum here. And then find average, what should

I do here? Here of course, I will need another variable average and so I can say and
average is sum divided by 10. There is a mistake that is there. What is the mistake can
you find out? Here I found sum that is ok, and then I am finding the average and why I
am why while I am finding the average I am dividing some whatever sum I got here by
the number of elements which is 10, I knew beforehand that these are 10 elements.
Where is the error? What is the mistake? The mistake is that the average cannot be need
not be an integer right. Suppose my sum was 25 and I divide by 10, so it to be 2.5.
Therefore this average should not be kept here I should have declared it as a float
average and not with the int right. So, you must be very careful about it. So, this is how
what we have shown here is how we can read an array and how you can use an array.

So, let us look at this example of computing the grade point average of the students. Let
us try to understand what this program does.
We have defined a variable n sub to be 6, this n sub means number of subjects all right.
Now, there are 6 subjects. So, 0, 1, subject 0, subject 1, subject 2, subject 3, subject 4,
subject 5, now for each of them we are taking a great point which is nothing, but a mark
say, an integer 3 or 5 or 6 whatever, for every how many 6. Here you see I have used
define so this line essentially means great point, 6, for 6 subjects and credit for each
subject. So, suppose I have got the subject and the great point and each subject has got a
credit and I have got 6 subjects.

So, subject 0 has got a great point, he has got a great point of 3, maybe he has got a b
grade or whatever and the credit; that means, the importance of that subject is 5, subject
1 he has got a great point of 5, he did really well here and the credit of that was also 5.
There was another subject 2 in which his great point was 4 and the credit of that subject
was 4 that is the importance weightage. The subject 3 he got 5 and the credit was 3 like
that and since we have got 6 subjects let us do that. Subject 4 his credit he got 3 and the
importance was 4 and this one he got 5 out of 5 and the credit was again 4.
Now, the credit point is the great point is computed here as for each of them we will
multiply the great point with the credit. So, it will be 3 times 5; that means, 15 plus 5
times 5 that is 25 plus 4 times 4 that is 16, then 15, then 12, then 20 and all these are
added up. So, 40, 56, 66, 71 and 12, 71 and 12 is a 83 and 20. So, he got 103 points. And
how many credits were there? 5 5, 10, 10 and 7 17 and 8, 25.
So, his grade point average gpa will be when I divide this by 25 his thing will be 4 point
something, 4.1 etcetera. So, 4.15 or something like that. So, this is what I want to
compute.

Therefore, what I need is to find out that, I have to find the sigma of the sum of the credit
for a course i times the great point of that course i, I will do it for all the courses and then
the whole thing should be divided by the total number of credits, total number of credits.

Now, let us see how we have done, we can do this program. Here we can find that the
great point for 6 and credit for 6 and there is I the great points sum. So, I have to do this
sum is 0 credit sum is 0 and I have to find out a gpa. So, what I am asking from the user
here input great points and credits for the 6 subjects.

So, where are those being stored? Those are being stored in two different arrays. Here is
the great point array, this thing and there is another credit array 6 subjects.
So, I read for each of the subjects i less than, i 0 to n sub, I read the great point say 3 and
the credit for that subject say 4. And again I go and store the great point of that subject
great point that is been obtained is 5 and say credit is 3. In that way I go on filling up
reading 2 arrays. So, here I am reading two arrays you see, here I am reading two arrays
in one scanf statement and through one for loop, through one for loop I am filling up
these two arrays. So, the reading part is complete here.
Next I come to the computation. Grade point sum will be you, now know what is meant
by this. This means grade point sum is equal to grade point sum plus grade point i times
credit i. So, it is gp sum is whatever is the gp sum initially gp sum was made 0, gp sum
plus grade point i times the credit of i and that has to be done in a loop just as we had
added the elements of an array. So, and credit sum also I am also finding out the credit
sum the credit sum was 0. So, whatever the credits are I am also adding them. So, by
adding this array I am getting the total number of credits here and here I am getting the

grade points sum. Now, the grade point I have sum, grade point average is grade point
sum by credits sum and then I print out the gpa.
So, please try to understand this part. What I am trying to do is sigma grade point i, times
credit i divided by sigma of credit i. So, the sigma of credit i is being computed here this
is computing sigma of credit i. Why? Because this is being done in a loop and here I am
doing this part sigma of grade point 5 times credit i and adding that with grade point
sum. So, these are very useful program which illustrates a number of things and in the
assignments you will be given more number of programs to do which will give you a
very good practice.

We were discussing about arrays and we have seen how we can read an array, we have
seen how we can print an array, we have also seen how we can access the different
elements of an array using for loops and while loops.

Now, couple of things that we cannot do using an array are as you can see here we
cannot use. These equalities, this assignment for assigning one array variable to another,
for example, if I have, suppose I have one array A suppose I have one array A which is
this array having some elements suppose it is an integer array and the elements here are 1
5 6 7 9 10.

Now, and there is another array B like this, I want that this data be transferred to 1 to this
array B as 1 5 6 7 9 10. Now, that I cannot do using A assigned B, I cannot do this or B
assigned A, I am sorry this is wrong using B assigned a i cannot do that. However, it is
true that A is also a variable of type array and B is also a variable of type array. But for
other variable types for example, if A let us say A is a integer variable and B is another
integer variable and a was 15 and then I could have assigned B assigned A. So, B will
become 15, but this sort of straightforward assignment cannot be done in the case of an
array. What we have to do in order to, this such in order to do such assignments in an
array is that we will have to do it component by component element by element.

For example, I can do this let me again take another array A. Now, this time I take an
array A to be a little smaller of say 4 elements 1 3 2 7 and there is another element B and
I actually intend my intention is that the data in A goes to the array B. Now, as I said for
an array I have to do it element by element. So, suppose this there are 4 elements in the
array and I write a for loop for i equals 0, i less than equal to 3, i plus plus. B i is
assigned A i what will happen through this? A i, i is 0. So, A i; that means, 0 this element
will be taken and that will be copied to the 0th element of B here, both of them are i, so
that 0. So, this will become 1.
Next i is incremented, so i becomes 1. So, this element is being pointed at and I transfer
this element to the corresponding element this will also be incremented i, this is also i, so
i is 1. So, this will be copied here similarly for this element next in this loop I will be
incremented and this will be loaded here. Similarly, for the last element it will go on.
Therefore, ultimately I will get the same thing 1 3 2 7 as was my intention, but I cannot
do it directly I have to do it in the form of a loop, element by element I have to transfer
them all right. So, we cannot use this assignment directly. What else am I prohibited to
do. So, A and B are two arrays I cannot do this.
Also I cannot compare two arrays using this sort of equality checker. Earlier we have
seen that I can check whether two elements are equal logical operation I could do it using
normal a equals b, I am sorry a is b. If a was a variable 15 and b was another variable 15

in that case a equality checker b will lead to a value 1 or 2. But if a is an array and b is
another array I cannot do it directly in that way.

There also I can write a piece of program in which I can check them element by element.
So, please note suppose I have got an array a which is 2 4 5 7. Another array b is 2 4 5 7
then these two arrays are equal. However, if I have an array with the same elements, but
in a different arrangement say for example, 2 5 4 7 these two l this a and c are not the
same therefore, how can I compare how can I compare these two arrays how can I
compare them. In order to compare these two arrays a and b what I need to do is I have
to again write a small loop like for let me do it clearly.

Say I have got an array 2 5 7 4 another array 2 5 7 4, a and b are the equal I can compare
them I want to compare them compare a and b. Now, what can I do? I can do it in this
way for i 0, i less than equal to 3 because there are 4 elements in the array, i plus plus.
Suppose I put a flag here a variable flag equals 1, suppose I keep a flag variable I have
initialize it to 1 all right. Now, for i equal to 1 to 0 or let me make it simpler I keep it 0
initially this is 0.
So, now I do if a i is equal to b i flag is assigned 1 and flag is assigned 1, else flag
assigned 0 and I come out of this. So, what I am trying to do is here let me let me the
avoid this part for the time being let us see we will develop it gradually. What will
happen here if this is done let us see, for if I do this piece if I run this piece of code then
what will happen. For i equal to 0; that means, I will be comparing with this.

And if a i is equal to a i; that means, I am comparing these two if these two are equal
then flag is 1; that means, till. Now, it is one, but this will go on here, so here 1. Now, 5
and 5 is 1 fine, 7 and 7 is compared again it is written 1, 4 and 4 again it is written 1. So,
it has been done and ultimately come out with the value of flag ultimately I come out
when I come out of this the value of flag is 1 and so I can say if flag is one then they are
equal. But there is some problem with this program what is that? First of all every time I
was assigning flag to be 1, that is one problem.
Now, suppose another problem is suppose this value is 6 then what will happen let us
trace this once again 2 and 2 will match. So, the value of flag will be 1 fine. 5 and 5 will
be matched, again I am not bothering about how many times unnecessarily I am writing
into flag that apart flag will be 1. Now, 7 and 6 they are not equal to 1. So, I will come
out of this if statement, but will go again in the loop. So, what should I do here? If these
are this is not equal, not equal then I will have to set flag to 0 if there is a mismatch. So,
if I do it like this then what will happen? It is this part, if a i is equal to b i then flag will
be one and else; that means, with this else flag will be 0.
So, ultimately now, suppose, but here again there is a problem what will happen. So, 7
and 6 are not matching. So, this is not true. So, flag will be 0 and then I will again go into
the loop because the loop is loop has not yet ended and here I will find that these two
elements are equal 4 and 4. So, it will come at this point and flag will be 1 and then I

come out of the loop I will come out with flag equal to 1, but these two arrays are not
equal because I can see that the elements are different.
So, this problem this program will not solve my purpose. I leave it to you for a while to
see how to think how you can solve this problem you need to apply your mind a little bit
to write this piece of program which will simply check whether two arrays are equal or
not if they are equal. That means, if the elements are the same at every position
corresponding position the elements are same in that case it will come out with a flag
value is 1, otherwise it will come out of the flag value of 0, that is the task. I hope you
understand where the problem is in this problem, in this program.

You see here had the mismatch been at the last point last moment, at the last element 7 6
then it would have worked fine. So, that is why at the beginning we said this is not just C
programming, it is learning to write programs using logic. Suppose this. this was 7 and
this was 3 then the errors are not equal, array are not equal, here flag would be 1, here
flag would be 1, here flag would be 1, here flag would be 0 and I had come out and my
answer would be correct by chance. The answer is correct by chance because as we have
seen that here if I have an error if I have a mismatch here and suppose here the things are
all right then I would once gate the flag is 0, but next time that flag will be made to 1 and
ultimately when I come out I will have the flag value to be 1. So, the correct answer has

eluded me. So, you just think of how I can modify this program such that I get the
correct result as I intended.
So, we cannot use these directly, directly it compare the array variables I cannot
compare. What else? So, if a assigned b this sort of thing I cannot do. Also the other
thing that I cannot do is scanf and printf statements I cannot read the array in one shot
that is not allowed; scanf and printf I could normally, normally what could I do.

Normally if I have a variable a sum variable value 5 I could have simply done printf
percentage d a. So, this could be printed. Similarly I could have done scanf, percentage d
and they I could have read a value here. But if it is an array I cannot do it in this way we
already know how we can do that. We know that in order to read an array what we need
to do is read it again in a loop in a for loop element by element so, it can be for i assign
0, i less than equal to whatever 3, i plus plus, scanf percentage d and a i.

So, this array a will be red element by element I equal to 0. So, first this element will be
red same might be 5, whatever element is 5 there might be 7 etcetera in that way I can
read them element by element. Similarly for printing an array 6 4, for printing an array I
can simply again do that for say j assign 0, j let me change a little bit, is any trouble here
j less than 3, j plus plus, printf percentage d a i. Here of course, I do not give the scanf
again.
Now, is any problem with this? Here I made i less than equal to 3, here I am making j
less than 3 for the same size of array you can think of, you can look at it this is also
correct because here I am starting with 1. So, 1 I am looking at. Now, there is a mistake
here, I have done a couple of mistakes. What will happen here? j first of all this was a
unintentional mistake. So, this is j.
Now, how will the array be printed here if I do it in this way? What will be printed? Here
first thing that we printed is j, a j. What is the value of j? 1. So, what is a j a 1; that is this
element. So, 7 will be printed. Suppose I have got a backslash n here. So, 7 will be, 7
will be printed, then 6 will be printed because i is now 2, i is now 3, then 4 will be
printed, but till less than 3. So, therefore, 1 2 3 this will not be printed. So, and also again
I am missing this one. So, what should I do? What should I do? I can make it j minus 1
what will happen in that case? I am printing j is 1 and I am printing a j minus 1; that
means, I am printing a 0 5. Next a j becomes 2. So, I will be printing j minus 1; that

means, 2 minus 1 a 1, 7 then 6. So, 7 then j becomes 2 then j becomes 3. So, 3 minus 1 2,
I have printed a 2 have printed.
Now, j will be increment it will be 3 the last one will not be printed. So, the here also I
have to make it less than equal to 3. Was this one alright? Just quickly check. This is a
common source of error I am reading this array. Let me do it again I am reading this
array, a 0 then I have read a 0, then i is incremented, so the 4 elements, so I will come up
to a 3. So, the second one I am reading the second one a i is 1. So, a 1, i is next 2 a 2 and
then a 3. So, this is ok. So, you have to be a little careful about all this.
So, reading and printing, reading and printing we cannot directly do we have also to do it
through a loop. So, I cannot do like this.

How to copy elements of one array to another? By copying individual elements I have
already shown that. So, that is what we have to say about arrays right. Now, will come to
some examples say I want to this is an example of copying an array there are, there are
two arrays a 25 and B 25. So, I am trying to copy them. So, you know that I can do it by
copying it in this way.

Now, some problems we will like to try out. Now, one is finding the mean and standard
deviation of a set of n numbers. I leave this standard deviation part we can try to do that
mean you know mean is the arithmetic average. So, I will first try to find write a program
where all of you will be able to write find the mean and standard deviation of a set of n
numbers.

So, what are you going to do? Mean means the average right. So, I add the numbers all
the numbers suppose my array is a. So, each element I designate as a i is an element. So,

I will have sigma a i, i varying from 1 to n whatever this size is divided by n that is the
average I add all the numbers. So, it is simple to write the program. Suppose I have read
the array I have first of all I have to read the elements in an array.
So, summarizing all what we have learnt what should be my first statement first
statement is declaring the array. So, let me declare an array, int a suppose the size of the
array is 5, maximum size possible. And I also have sum and I have got another variable
avg all our integers, again avg may not be integer, mean may not be integer. So, and then
I have got another float avg right.
Now, first I have to read the array. So, read the numbers, I am making a shortcut I am
leaving out the printf statement please enter the array that part I am leaving out. Then
what I am doing here? Here of course, for i assigned 0, i less than suppose there are 5
elements, i less than 5, i plus plus. If it was some other value then I would have put it n
here and I had to read the n before I read the array, all right.
So, I do this and then initially I can make it the sum here to be sum is initialized to 0 all
right. Now, for i equal to 0, i less than m, i plus plus I read the array I am just now
reading the array. So, what I do? Scanf, percentage d, ampersand, a i, I am reading that
and then here in this for loop I can repeatedly compute the sum, sum equals sum plus a i.
So, I will get the sum here ultimately at the end of the loop, at the end of the loop I will
get the sum. So, now, here I can write average is sum divided by whatever the value was
I have taken 5 to be a fixed value, so I divide with 5 and that is the average. So, in that
way I can find out the mean this value. The next task is computing the standard
deviation. So, that I leave to you for the time being. We will take it up later.

So, we were looking at computing standard deviation. So, standard deviation is mean; we
have seen.

Now, standard deviation is if the mean is suppose the mean is represented by mu then I
take the sum of the deviation from the mean for every element of the array. So, the array
was a with every element being called a i.

So, what I am trying to do is, I am taking the difference of a i from the mean and since its
difference can be suppose there are some values and this is the mean and the value can
be a little away from the mean on this side more than the mean or less than the mean. So,
we take the square of the mean square of the difference and I do that for all the elements
I equals 1 to n right and then I take the square root of the whole thing. That is my
standard deviation other my variance. So, I can compute either this or this, whatever I
like.
So, you will simply understand that in the code that we have given little earlier then there
we had computed the mean; that means, mu has been computed which was the average
that we computed last time. So, if I have read the elements in an array whatever the
elements are 5 7 3 2 and I have computed the mean mu who has been computed mean is
of 12 3 15; 17 divided by 4. So, it is 4 point something 4.1, 4.25 right that is my mean.
So, now, for every element again in this array I find out for i assign 0, i less than equal to
3, i plus plus what do I do? For every element I have got the mu and let us call it average
right.
So, sum was 0 what is it look like, sum was 0, sum will be now sum plus I am getting
sigma of mu minus a i whole square. So, sum plus average minus a i times average
minus a i, all right. So, that is the square average is mu minus a i that is. So, I am doing
this square and I am repeatedly doing this and getting the new sum and at the end of this

loop therefore, I have got this. So, I can see std, it is a dev let me call it standard
deviation is square root of the sum all right, in that way I can find out the standard
deviation also.

Now, let us come to the now what is the application what is the meaning of this. So, with
these say in a class you are you are supposed to write a program where you want to find
out say in a class of physics. What is the average of the numbers of all the students? So, I
will find out the mean and mean of the class marks right. Similarly I can find out that
what is the standard deviation, how much did it vary, that also I can find out.
Now, let us look at this new another problem. Say a shop stores in different types of
items, n different types of items. Now, given the number of items of each type sold
during a given month and the corresponding unit price is compute the total monthly sell.
So, what is the scenario? The scenario is this.

I have got say 5 items, item 1, item 2, item 3, item 4 and item 5. And let me call it the
item, let me call it on this side let me call it this array is item price, item cost, item cost.
Suppose the cost here is 7 and half rupees per item of type 0, 25 for item of type 1, this is
0, this is 1, this is 2, this is 3, this is 4. So, the item cost for this for item of type 2 is 12.5,
item of type 3 is 10, item of this is item of type 4 is 50 rupees.
Now, I want to store how many items of each type has been sold. So, I take another array
and call it items sold. Suppose 5 items have been sold of type 0, 6 items here of type 1, 2
items of type 2, 4 items of type 3 and 2 items of type 1. Now, my question is what is the
total sell? So, what should I do? You can easily understand that the here is the item cost.
So, I have to multiply this with this, this with this and add all these costs. So, it will be
7.5 times 5 it will be 7.5 times 5 plus 25 times 6 plus so and so forth in that way I can
find the total cost. So, what will the program look like? The program will look like I will
be needing to arrays item cost and items sold and they should be of the same size,
assuming that I know beforehand that there are 5 items.

So, I can start with item cost of type 5, but this will be cost will be of type float and there
will be another the number of items is, item sold the number of items sold is integer. So,
I will have this, I am not showing the part that here I am reading the two arrays. So, after
I read the arrays I will have two arrays like this, one is an integer array another is a
floating point array this is the float and this is an integer.
Now, my actual body of the program will be in a loop for say I am doing it using for say
i assign 0, i less than equal to 4 since the size is 5, i plus plus. And what do I do here?
What do I do in the body of the for loop? I take ok, I write actually only one statement
will do there is no harm in putting this bracket. Total sale which was a variable of type
float total sale is, total sale was initialized to 0, total sale plus item cost i times multiplied
by item sold i. So, this will be done in a loop.
And so I will take the first item, item cost 0 multiply with that with item cost item sold 0,
add that with the total sale which was initialized to 0. So, here I can have float total sale
initialized to 0, 0 point 0 all right, I can do that. So, now, I am doing it in a loop. So, first
I multiply these two add it to total sales, next again in the next iteration i is implemented
I take these two and multiply them and add it to the total sale then I do this two and
multiply them add it to the total sale and I go on in this way. This is, this is in this way
by using this array I will be able to add all these values and I will get the total sale at the
end.

So, here we could see two very nice examples of application of arrays. Now, one another
problem that I gave you I mean as I was while comparing the arrays you can do it in
multiple ways that they were as two arrays you must have solved it by now, that they
were two arrays like this 7, 7, 5, 5, here 6, here 4, but again 3, 3.

So, everywhere they are matching, but intermediate they were affected and I had a flag
value so flag was initialized to 1. And then in a for loop then in the for loop I was
checking this was a and this was b, flag was initialized to 1, if a i is equal to b i this I can
do because here I am doing it element wise then flag equal to 1 else flag equal to 0 and I
can do exit and I come out of the loop straightway, I come out of the loop. Because it
does not really matter at which position the mismatch occurs, as soon as the mismatch
occurs I can say that flag is 0 and so I come out. So, when I was comparing this
whenever I find a mismatch the flag will become 0 and it will not be reset to 1 again
because of this match, because this part is not being computed I need not compute it. I
need not compute it because my objective was to see if the two arrays are equal and here
the violation has already occurred. So, they are not equal.
However so, that is one way you can try it with while loop also. You can try with while
to solve the same problem. Another point is here the time and again here, here,
everywhere I am setting the flag to 1, I could have changed that also here if what did I

need to do I go on I haves in take flag to 1 and the condition I simply change I just
change the condition if a i is not equal to b i, then make flag 0 exit.

I could have done this. As long as this condition is not holding I am going on doing the
loop is it clear, I will go on doing the loop as long as there is no mismatch, this condition
means mismatch. As soon as there is a mismatch I will set the flag to 0 and exit. There is
another way of solving the problem. So, you have to think logically what exactly you
need to do and what exactly you are writing what is the flow and what is happening with
the variables and I always suggest that you have small pictures of the different variables
and see how they are changing in the course of running the program.
Now so, we have seen a useful commercial. So, called toy commercial problem that how
I can find out the cost of a total sales or monthly sales. So, and here the number of items
sold per month are given then you can do it.
Well, next let us look at a very important thing called searching. Searching is a
fundamental task in any and in fact, in many computations. In many computations we
need to search. What do we search? There are different types of searches, but we will be
now talking about the simplest possible search that is we are trying to find out whether a
particular element is there in an array right.

Say, so the purpose is to check if a given element which is known as the key is there in
the array or not. We will first talk about the array is not arranged in any order and we
will do that.

So, suppose I ask the question that is there any even number in the set of numbers given,
suppose there are some numbers given 5 7 2 9 1 8 3 like that. I want to see and suppose
this is a huge this is a list of hundred numbers. I want to find out whether there is any
particular number forget about even number, for the time being for the timing let us

assume that I want to see whether in this list any 4 is there, is there any 4 in the list that is
the question that we are asking. The answer can be either yes or no.
If it is yes then the next question comes where in the list is it there, is it where means in
which position it is there. I may ask like to know the position or I may not like to know
the position I would be satisfied to know whether this list contains any 4 or not all right;
so 5 7 2 9 1 8 3.

So, again 5 7 2 9 1 8 3 and my key is 4 because I am interested in the existence of 4. So,
instead of writing the c which you will be writing I will be discussing how to approach
this problem what would the pseudo code be and I am sure in the assignments in your
practice you can write the program. So, I know I need to know beforehand this list. So,
so I need to know a list which may be an integer list of might be here 7 numbers, I need
to know that also I need to know which key I am searching for.

Once I know these two, I know 5 7 2 9 1 8 3 is my list and I know that 4 is my key then
how should I go about it.
I have got 4 in mind. I start to look at as if I am looking at through some means at
different positions I look at this position and check this element and compare this
element with the key and I ask are they equal. If the answer is yes, then obviously I can
say that 4 is in the list. But as you can see it is not true, so in case of no I will shift my
focus from here to here and I will now compare with 4 this element 7, are they equal, no
then I will again shift the focus and I will go on shift the focus and I will compare with
this element with the key all right. In that I will go on. How long shall I go on till the end
of the list.

If suppose here there was a 4, instead of 1 there was a 4 here, suppose instead of 1 there
was a 4 here. Then when my focus changes to this point and then again comes to this
point and then I find that this element is matching the key value, then I can exit and say
yes, 4 is there in the list. Then if there is other question has to be answered that 4 is there,
but where is 4, where is 4, in that case what would be an answer be. Your answer would
be this position. And what is this position? This position is nothing, but the current index
current value of the index. Here the index started this is my index which was shifting.

So, now we can think of the algorithm I have got 5 7 2 9 1 8 3 and my key is 4. So, I will
be doing. So, this is a loop which is a list for i equals 0; that means, the focus or the
index i less than equal to 1 2 3 4 5 6 7 6, i plus plus, i plus plus. If least i, that means, the
ith element of the list is equal to the key then I can say found assigned 1. And what is
found? Found is some variable which I have initialized at this point initially nothing is
found it is not found. So, found is 0 initially I have not found the key here I am
comparing as soon as I compare I put found equal to 1 and then I can exit or this
automatically this loop will go on.
Now, if I do it in this way what is the problem? Suppose my key was, suppose my key
was 1 then it goes on i 0, this is never happening found is still 0, it goes on it comes to
here and I count come to found equal to 1 and then I can say if found equal to 1, I can
printf, printf key found at position percentage d i. So, at that point I can also print that it
has been found here right. In the worst case what can happen? Found will remain 0,
found will remain 0 and I will come to the end of this point when I come here I can
check if found is 0, printf key not found; if I do not find it. There can be different flavors
of the same problem.

The other flavor could be that suppose this element 1 is there at multiple places suppose
it is also here. Then what will this program result in? What would be its output? I will go
on checking here I will check the for loop is extending up to which part; the for loop is

extending up to this, this position and this is separate I should not have I should have
written it on the on this side.
So, I go on checking this. So, key is found at position number 0 1 2 3 4, key is found at
position 4. The list is not exhausted ultimately it will come to this point and when it and
again it will say the key is found at position 6, twice it will it is found it will be told like
that keys it will print twice. If at the end it comes and still the key the value of the
variable found is 0 then it will say print is not found.

I could have also say the same thing same problem I do, say suppose I have got a list 5 7
9 2 1 3 1 the question is how many ones are there. The same algorithm will do, the same
algorithm will work right. What is the same the algorithm? The algorithm is I start from
one point from this beginning I let me draw it in this way if this be an array where all my
elements are there, 5 7 9 2 1 3 1 I start from the beginning i equals 0 and for every
element I compare with the key and go on till the end.
Now, if I want to do this what is the additional variable that I will require? I will require
another variable count which is initially 0 other than found which is also false. So,
whenever I find a 1 and my key is 1. So, whenever I find a 1 I will say found is equal to
1 and also I will do count plus plus and I will continue. Here I come and I will find I will
have the value of count to be 2. So, I can also, so I can say that here I could print where

found is becoming 1. So, I can also, I can say at which position it is a found and how
many times it is found.

Now, it can another flavor could be that I have got this say this array; I have got this
array and some array 6 3 2 9 1 5 and whenever I have been given a key say the key is 2,
as soon as I find 2 that is enough for me. I just want to know whether 2 is there in the
list, I am not interested to know how many times it is there or in which position it is there
or at best I may like to know at which position I you found it first. So, what I can do, I
will go on searching like this and whenever you find 2 then you print that I have found 2
here and exit.
So, what will you do? The loop will be, the loop inside the loop you will have you can do
it like this that if a i or list i, let us I was writing list i is not equal to key all right for you
could have done it by while also n minus 1 i plus plus you go on doing this. If list i is not
is sorry is if it is equal to the key what I have done is equal to key say found equal to 1
and printf the position and exit and you need not go through the entire loop. Now, there
are, so that is this sort of search which I am doing in a linear way from one side to the
other is known as linear search. It is the simple, very simple search for a particular
element. We will see a little bit more on this in the next lecture.

We were discussing about strings and in today’s discussion, let me recapitulate what we
or the last part of what we discussed in the earlier lecture.

How can we read words from this from an input say? So, there we had introduced, this
percentage is format with that, with percentage is if we read a name, then it has to be
noted that the ampersand is not needed in this case right the ampersand is not needed
when I am reading a string when I am reading a string I do not need that ampersand.
Now, the point to remember is that whenever I am reading this in this way the string will
be read until there is some blank white space this is also called as white space or a tab
sign or a carriage return or enter is pressed. So, if I type on a b c and then I type blank,
then this a b c will be taken as the word. So, when I perform scan if in this form in name
then a b c will go in the name alright. So, this is what we had seen last time.

So, that is why this example was given if we type Rupak Biswas since after Rupak, there
is a blank we will stop at that point of time. The name will be assigned to Rupak ok
name will be assigned to the string Rupak name will be assign the string Rupak.

On the other hand when we read a line of text if I suppose I want to read say this Rupak
Biswas, I want to read this blank also this entire thing the entire sentence, I want to read
a quick brown fox I want to read.
So, I want to read this characters as well as this blank space is everything then what will
be my delimiter? My delimiter will be the carriage return the return carriage return or
that is often designated as backslash n. So, till I get a backslash n, I will go on reading
this that is how I want I can read a line.

So, in order to do that we can use the gate care function for the purpose by gate care
function we will be getting the characters one after another, and I will go on getting the
functions till the I mean I will be going on getting the characters, till I come to a
character that is carriage return designating that there is an that is an end of the line.

So, for example, here a line has been defined to be of maximum length 81, typically as I
said a line consist of 80 characters and you must be understanding now realizing now
that why I put 81, the reason is here I need a space for backslash 0. And I put c to be 0 c
is the number of characters c is here designating the number of characters read, all right.

Now, here we are doing it through a do while statement, you can see that we can do a we
are doing it through a do while. So, I am reading one character here say x and that I am
reading it though to get char, and that character that has been read is coming to the
variable array line all right line c c was initially 0.
So, here I put x, then I go up then character I go on I read it and then found that their
character is not ampersand. I go back again and read another character say x y increase c.
So, c is now pointing here, c is now pointing here and I again go back now suppose a
blank has been typed in. So, I come here get char is blank. So, that comes here and then c
is pointing to the next position here, and then I go again here and suppose I type in p. So,
the c is now pointing here, and then after that I read the character and the character was
ampersand I mean the character was backslash n; that means, the end of the character.
So, I put backslash n here, whatever it was there and c is pointing here. Now I have after
insertion of backslash n, I come and find here that well what I have entered is backslash
n. Now backslash n should not be there instead of that we should have backslash 0
therefore, I will come back I will decrement c by ones position. So, it will come here and
I will replace this with backslash 0 right here I will bring in backslash 0 will come here.
So, the pattern that will be stored do will be x y blank p backslash 0. So, that is what this
thing will look like in that way I am reading a line that is how we are reading a line. So,
we have seen that we can read characters as a character array.

Char some line in this way line 81. Now this line I can read character by character or I
can type in line to be x y blank p that is also will do the same thing, otherwise, I could
have copied it character by character both of them are equivalent, all right.

So, here we have read the character until the char return or backslash n is encountered
and then we make it a valid string by replacing backslash n by backslash 0.

An alternative approach of reading a line can be this that I just specify the format, here
till now what we have seen is that our formats could be percentage s percentage d

percentage f like that. I can also specify my format in this way as you can see here, what
it means is anything I am sorry what happened; anything that is a b c d or whatever that
this entire thing and here there is a blank, I do not know what is happening here, here
you can see there is a blank here.
So; that means, what is allowed? Anything including bank blank capital A to Z
everything is allowed as members of the variable line. Similarly here the specification is
that it can be char at this is a wild card it is called; that means, we can put in anything
preceding backslash n. So, this means it is a wild card; that means, anything can come
here as a character, that can be a member of the variable line. So, that is also another way
of specifying it.
Now, these are specifics to the language c of course.

Now it is easier relatively simpler to display strings on the screen we can simply do a
string, we can display the string with percentage x s and followed by the string name that
is simpler now we come to a very important aspect how do we process character strings.

Now, for that we have got several c library functions we will soon come to functions and
we have already seen different types of functions like square root, maybe did you see and
we have seen we have seen the standard functions like scan f, print f all those things.
Similarly we have got c libraries built in library functions, for character string
manipulation how are they looking like? They are we have to in order to do that.

Say one is s t r c p y; that means, string copy; that means, if I have a string here say
string here is my sorry let me put a blank here, my space job. Suppose these are string A
and I want to copy it to another string B. So, B will also therefore, have my blank job.
So, that is that can be done by string copy function s t r c p y how can that be done? We
also have a similar thing like string length s t r l e n which means that I have got a string
say my job again, blank job and automatically there is a backslash 0 at the end.

So, when I copy it, then this will also be with s t r c p y 