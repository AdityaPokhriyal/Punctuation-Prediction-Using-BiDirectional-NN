There <sil=0.000> also <sil=0.000> I can <sil=0.000> write <sil=0.000> a piece <sil=0.000> of <sil=0.000> program <sil=0.000> in <sil=0.000> which <sil=0.000> I can <sil=0.000> check <sil=0.000> them <sil=0.000> element <sil=0.000> by <sil=0.000> element <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  please <sil=0.000> note <sil=0.000> suppose <sil=0.000> I have <sil=0.000> got <sil=0.000> an <sil=0.000> array <sil=0.000> a which <sil=0.000> is <sil=0.000> 2 4 <sil=0.000> 5 7 <sil=2.000> .PERIOD  Another <sil=0.000> array <sil=0.000> b is <sil=0.000> 2 4 <sil=0.000> 5 7
then <sil=0.000> these <sil=0.000> two <sil=0.000> arrays <sil=0.000> are <sil=0.000> equal <sil=2.000> .PERIOD  However <sil=1.000> ,COMMA  if <sil=0.000> I have <sil=0.000> an <sil=0.000> array <sil=0.000> with <sil=0.000> the <sil=0.000> same <sil=0.000> elements <sil=1.000> ,COMMA  but
in <sil=0.000> a different <sil=0.000> arrangement <sil=0.000> say <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  2 <sil=0.000> 5 4 <sil=0.000> 7 these <sil=0.000> two <sil=0.000> l this <sil=0.000> a and <sil=0.000> c are <sil=0.000> not <sil=0.000> the
same <sil=0.000> therefore <sil=1.000> ,COMMA  how <sil=0.000> can <sil=0.000> I compare <sil=0.000> how <sil=0.000> can <sil=0.000> I compare <sil=0.000> these <sil=0.000> two <sil=0.000> arrays <sil=0.000> how <sil=0.000> can <sil=0.000> I
compare <sil=0.000> them <sil=2.000> .PERIOD  In <sil=0.000> order <sil=0.000> to <sil=0.000> compare <sil=0.000> these <sil=0.000> two <sil=0.000> arrays <sil=0.000> a and <sil=0.000> b what <sil=0.000> I need <sil=0.000> to <sil=0.000> do <sil=0.000> is <sil=0.000> I have
to <sil=0.000> again <sil=0.000> write <sil=0.000> a small <sil=0.000> loop <sil=0.000> like <sil=0.000> for <sil=0.000> let <sil=0.000> me <sil=0.000> do <sil=0.000> it <sil=0.000> clearly <sil=2.000> .PERIOD 

Say <sil=0.000> I have <sil=0.000> got <sil=0.000> an <sil=0.000> array <sil=0.000> 2 5 <sil=0.000> 7 4 <sil=0.000> another <sil=0.000> array <sil=0.000> 2 5 <sil=0.000> 7 4 <sil=1.000> ,COMMA  a <sil=0.000> and <sil=0.000> b are <sil=0.000> the <sil=0.000> equal <sil=0.000> I can <sil=0.000> compare
them <sil=0.000> I want <sil=0.000> to <sil=0.000> compare <sil=0.000> them <sil=0.000> compare <sil=0.000> a and <sil=0.000> b <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  what <sil=0.000> can <sil=0.000> I do <sil=0.228> ?QUESTIONMARK  I <sil=0.000> can <sil=0.000> do <sil=0.000> it <sil=0.000> in <sil=0.000> this
way <sil=0.000> for <sil=0.000> i 0 <sil=1.000> ,COMMA  i <sil=0.000> less <sil=0.000> than <sil=0.000> equal <sil=0.000> to <sil=0.000> 3 because <sil=0.000> there <sil=0.000> are <sil=0.000> 4 elements <sil=0.000> in <sil=0.000> the <sil=0.000> array <sil=1.000> ,COMMA  i <sil=0.000> plus <sil=0.000> plus <sil=2.000> .PERIOD 
Suppose <sil=0.000> I put <sil=0.000> a flag <sil=0.000> here <sil=0.000> a variable <sil=0.000> flag <sil=0.000> equals <sil=0.000> 1 <sil=1.000> ,COMMA  suppose <sil=0.000> I keep <sil=0.000> a flag <sil=0.000> variable <sil=0.000> I have
initialize <sil=0.000> it <sil=0.000> to <sil=0.000> 1 all <sil=0.000> right <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  for <sil=0.000> i equal <sil=0.000> to <sil=0.000> 1 to <sil=0.000> 0 or <sil=0.000> let <sil=0.000> me <sil=0.000> make <sil=0.000> it <sil=0.000> simpler <sil=0.000> I keep <sil=0.000> it <sil=0.000> 0
initially <sil=0.000> this <sil=0.000> is <sil=0.000> 0 <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  now <sil=0.000> I do <sil=0.000> if <sil=0.000> a i <sil=0.000> is <sil=0.000> equal <sil=0.000> to <sil=0.000> b i <sil=0.000> flag <sil=0.000> is <sil=0.000> assigned <sil=0.000> 1 and <sil=0.000> flag <sil=0.000> is <sil=0.000> assigned <sil=0.000> 1 <sil=1.000> ,COMMA  else <sil=0.000> flag
assigned <sil=0.000> 0 and <sil=0.000> I come <sil=0.000> out <sil=0.000> of <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> I am <sil=0.000> trying <sil=0.000> to <sil=0.000> do <sil=0.000> is <sil=0.000> here <sil=0.000> let <sil=0.000> me <sil=0.000> let <sil=0.000> me <sil=0.000> the
avoid <sil=0.000> this <sil=0.000> part <sil=0.000> for <sil=0.000> the <sil=0.000> time <sil=0.000> being <sil=0.000> let <sil=0.000> us <sil=0.000> see <sil=0.000> we <sil=0.000> will <sil=0.000> develop <sil=0.000> it <sil=0.000> gradually <sil=2.000> .PERIOD  What <sil=0.000> will
happen <sil=0.000> here <sil=0.000> if <sil=0.000> this <sil=0.000> is <sil=0.000> done <sil=0.000> let <sil=0.000> us <sil=0.000> see <sil=1.000> ,COMMA  for <sil=0.000> if <sil=0.000> I do <sil=0.000> this <sil=0.000> piece <sil=0.000> if <sil=0.000> I run <sil=0.000> this <sil=0.000> piece <sil=0.000> of <sil=0.000> code <sil=0.000> then
what <sil=0.000> will <sil=0.000> happen <sil=2.000> .PERIOD  For <sil=0.000> i equal <sil=0.000> to <sil=0.000> 0 <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> be <sil=0.000> comparing <sil=0.000> with <sil=0.000> this <sil=2.000> .PERIOD 

And <sil=0.000> if <sil=0.000> a i <sil=0.000> is <sil=0.000> equal <sil=0.000> to <sil=0.000> a i <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> comparing <sil=0.000> these <sil=0.000> two <sil=0.000> if <sil=0.000> these <sil=0.000> two <sil=0.000> are <sil=0.000> equal
then <sil=0.000> flag <sil=0.000> is <sil=0.000> 1 <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  till <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> one <sil=1.000> ,COMMA  but <sil=0.000> this <sil=0.000> will <sil=0.000> go <sil=0.000> on <sil=0.000> here <sil=1.000> ,COMMA  so <sil=0.000> here <sil=0.000> 1 <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  5
and <sil=0.000> 5 is <sil=0.000> 1 fine <sil=1.000> ,COMMA  7 <sil=0.000> and <sil=0.000> 7 is <sil=0.000> compared <sil=0.000> again <sil=0.000> it <sil=0.000> is <sil=0.000> written <sil=0.000> 1 <sil=1.000> ,COMMA  4 <sil=0.000> and <sil=0.000> 4 again <sil=0.000> it <sil=0.000> is <sil=0.000> written <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
it <sil=0.000> has <sil=0.000> been <sil=0.000> done <sil=0.000> and <sil=0.000> ultimately <sil=0.000> come <sil=0.000> out <sil=0.000> with <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> flag <sil=0.000> ultimately <sil=0.000> I come <sil=0.000> out
when <sil=0.000> I come <sil=0.000> out <sil=0.000> of <sil=0.000> this <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> flag <sil=0.000> is <sil=0.000> 1 and <sil=0.000> so <sil=0.000> I can <sil=0.000> say <sil=0.000> if <sil=0.000> flag <sil=0.000> is <sil=0.000> one <sil=0.000> then <sil=0.000> they <sil=0.000> are
equal <sil=2.000> .PERIOD  But <sil=0.000> there <sil=0.000> is <sil=0.000> some <sil=0.000> problem <sil=0.000> with <sil=0.000> this <sil=0.000> program <sil=0.000> what <sil=0.000> is <sil=0.000> that <sil=0.228> ?QUESTIONMARK  First <sil=0.000> of <sil=0.000> all <sil=0.000> every <sil=0.000> time <sil=0.000> I
was <sil=0.000> assigning <sil=0.000> flag <sil=0.000> to <sil=0.000> be <sil=0.000> 1 <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> one <sil=0.000> problem <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  suppose <sil=0.000> another <sil=0.000> problem <sil=0.000> is <sil=0.000> suppose <sil=0.000> this <sil=0.000> value <sil=0.000> is <sil=0.000> 6 then <sil=0.000> what <sil=0.000> will <sil=0.000> happen <sil=0.000> let <sil=0.000> us
trace <sil=0.000> this <sil=0.000> once <sil=0.000> again <sil=0.000> 2 and <sil=0.000> 2 will <sil=0.000> match <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> value <sil=0.000> of <sil=0.000> flag <sil=0.000> will <sil=0.000> be <sil=0.000> 1 fine <sil=2.000> .PERIOD  5 <sil=0.000> and <sil=0.000> 5 will
be <sil=0.000> matched <sil=1.000> ,COMMA  again <sil=0.000> I am <sil=0.000> not <sil=0.000> bothering <sil=0.000> about <sil=0.000> how <sil=0.000> many <sil=0.000> times <sil=0.000> unnecessarily <sil=0.000> I am <sil=0.000> writing
into <sil=0.000> flag <sil=0.000> that <sil=0.000> apart <sil=0.000> flag <sil=0.000> will <sil=0.000> be <sil=0.000> 1 <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  7 <sil=0.000> and <sil=0.000> 6 they <sil=0.000> are <sil=0.000> not <sil=0.000> equal <sil=0.000> to <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> come
out <sil=0.000> of <sil=0.000> this <sil=0.000> if <sil=0.000> statement <sil=1.000> ,COMMA  but <sil=0.000> will <sil=0.000> go <sil=0.000> again <sil=0.000> in <sil=0.000> the <sil=0.000> loop <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> should <sil=0.000> I do <sil=0.000> here <sil=0.228> ?QUESTIONMARK  If <sil=0.000> these
are <sil=0.000> this <sil=0.000> is <sil=0.000> not <sil=0.000> equal <sil=1.000> ,COMMA  not <sil=0.000> equal <sil=0.000> then <sil=0.000> I will <sil=0.000> have <sil=0.000> to <sil=0.000> set <sil=0.000> flag <sil=0.000> to <sil=0.000> 0 if <sil=0.000> there <sil=0.000> is <sil=0.000> a mismatch <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
if <sil=0.000> I do <sil=0.000> it <sil=0.000> like <sil=0.000> this <sil=0.000> then <sil=0.000> what <sil=0.000> will <sil=0.000> happen <sil=0.228> ?QUESTIONMARK  It <sil=0.000> is <sil=0.000> this <sil=0.000> part <sil=1.000> ,COMMA  if <sil=0.000> a i <sil=0.000> is <sil=0.000> equal <sil=0.000> to <sil=0.000> b i <sil=0.000> then <sil=0.000> flag <sil=0.000> will
be <sil=0.000> one <sil=0.000> and <sil=0.000> else <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  with <sil=0.000> this <sil=0.000> else <sil=0.000> flag <sil=0.000> will <sil=0.000> be <sil=0.000> 0 <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  ultimately <sil=0.000> now <sil=1.000> ,COMMA  suppose <sil=1.000> ,COMMA  but <sil=0.000> here <sil=0.000> again <sil=0.000> there <sil=0.000> is <sil=0.000> a problem <sil=0.000> what <sil=0.000> will <sil=0.000> happen <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  7
and <sil=0.000> 6 are <sil=0.000> not <sil=0.000> matching <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> not <sil=0.000> true <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  flag <sil=0.000> will <sil=0.000> be <sil=0.000> 0 and <sil=0.000> then <sil=0.000> I will <sil=0.000> again <sil=0.000> go <sil=0.000> into
the <sil=0.000> loop <sil=0.000> because <sil=0.000> the <sil=0.000> loop <sil=0.000> is <sil=0.000> loop <sil=0.000> has <sil=0.000> not <sil=0.000> yet <sil=0.000> ended <sil=0.000> and <sil=0.000> here <sil=0.000> I will <sil=0.000> find <sil=0.000> that <sil=0.000> these <sil=0.000> two
elements <sil=0.000> are <sil=0.000> equal <sil=0.000> 4 and <sil=0.000> 4 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> come <sil=0.000> at <sil=0.000> this <sil=0.000> point <sil=0.000> and <sil=0.000> flag <sil=0.000> will <sil=0.000> be <sil=0.000> 1 and <sil=0.000> then <sil=0.000> I

come <sil=0.000> out <sil=0.000> of <sil=0.000> the <sil=0.000> loop <sil=0.000> I will <sil=0.000> come <sil=0.000> out <sil=0.000> with <sil=0.000> flag <sil=0.000> equal <sil=0.000> to <sil=0.000> 1 <sil=1.000> ,COMMA  but <sil=0.000> these <sil=0.000> two <sil=0.000> arrays <sil=0.000> are <sil=0.000> not
equal <sil=0.000> because <sil=0.000> I can <sil=0.000> see <sil=0.000> that <sil=0.000> the <sil=0.000> elements <sil=0.000> are <sil=0.000> different <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  this <sil=0.000> problem <sil=0.000> this <sil=0.000> program <sil=0.000> will <sil=0.000> not <sil=0.000> solve <sil=0.000> my <sil=0.000> purpose <sil=2.000> .PERIOD  I <sil=0.000> leave <sil=0.000> it <sil=0.000> to <sil=0.000> you <sil=0.000> for <sil=0.000> a while <sil=0.000> to
see <sil=0.000> how <sil=0.000> to <sil=0.000> think <sil=0.000> how <sil=0.000> you <sil=0.000> can <sil=0.000> solve <sil=0.000> this <sil=0.000> problem <sil=0.000> you <sil=0.000> need <sil=0.000> to <sil=0.000> apply <sil=0.000> your <sil=0.000> mind <sil=0.000> a little <sil=0.000> bit
to <sil=0.000> write <sil=0.000> this <sil=0.000> piece <sil=0.000> of <sil=0.000> program <sil=0.000> which <sil=0.000> will <sil=0.000> simply <sil=0.000> check <sil=0.000> whether <sil=0.000> two <sil=0.000> arrays <sil=0.000> are <sil=0.000> equal <sil=0.000> or
not <sil=0.000> if <sil=0.000> they <sil=0.000> are <sil=0.000> equal <sil=2.000> .PERIOD  That <sil=0.000> means <sil=1.000> ,COMMA  if <sil=0.000> the <sil=0.000> elements <sil=0.000> are <sil=0.000> the <sil=0.000> same <sil=0.000> at <sil=0.000> every <sil=0.000> position
corresponding <sil=0.000> position <sil=0.000> the <sil=0.000> elements <sil=0.000> are <sil=0.000> same <sil=0.000> in <sil=0.000> that <sil=0.000> case <sil=0.000> it <sil=0.000> will <sil=0.000> come <sil=0.000> out <sil=0.000> with <sil=0.000> a flag
value <sil=0.000> is <sil=0.000> 1 <sil=1.000> ,COMMA  otherwise <sil=0.000> it <sil=0.000> will <sil=0.000> come <sil=0.000> out <sil=0.000> of <sil=0.000> the <sil=0.000> flag <sil=0.000> value <sil=0.000> of <sil=0.000> 0 <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> the <sil=0.000> task <sil=2.000> .PERIOD  I <sil=0.000> hope <sil=0.000> you
understand <sil=0.000> where <sil=0.000> the <sil=0.000> problem <sil=0.000> is <sil=0.000> in <sil=0.000> this <sil=0.000> problem <sil=1.000> ,COMMA  in <sil=0.000> this <sil=0.000> program <sil=2.000> .PERIOD 

You <sil=0.000> see <sil=0.000> here <sil=0.000> had <sil=0.000> the <sil=0.000> mismatch <sil=0.000> been <sil=0.000> at <sil=0.000> the <sil=0.000> last <sil=0.000> point <sil=0.000> last <sil=0.000> moment <sil=1.000> ,COMMA  at <sil=0.000> the <sil=0.000> last <sil=0.000> element <sil=0.000> 7 6
then <sil=0.000> it <sil=0.000> would <sil=0.000> have <sil=0.000> worked <sil=0.000> fine <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> why <sil=0.000> at <sil=0.000> the <sil=0.000> beginning <sil=0.000> we <sil=0.000> said <sil=0.000> this <sil=0.000> is <sil=0.000> not <sil=0.000> just <sil=0.000> C
programming <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> learning <sil=0.000> to <sil=0.000> write <sil=0.000> programs <sil=0.000> using <sil=0.000> logic <sil=2.000> .PERIOD  Suppose <sil=0.000> this <sil=2.000> .PERIOD  this <sil=0.000> was <sil=0.000> 7 and
this <sil=0.000> was <sil=0.000> 3 then <sil=0.000> the <sil=0.000> errors <sil=0.000> are <sil=0.000> not <sil=0.000> equal <sil=1.000> ,COMMA  array <sil=0.000> are <sil=0.000> not <sil=0.000> equal <sil=1.000> ,COMMA  here <sil=0.000> flag <sil=0.000> would <sil=0.000> be <sil=0.000> 1 <sil=1.000> ,COMMA  here
flag <sil=0.000> would <sil=0.000> be <sil=0.000> 1 <sil=1.000> ,COMMA  here <sil=0.000> flag <sil=0.000> would <sil=0.000> be <sil=0.000> 1 <sil=1.000> ,COMMA  here <sil=0.000> flag <sil=0.000> would <sil=0.000> be <sil=0.000> 0 and <sil=0.000> I had <sil=0.000> come <sil=0.000> out <sil=0.000> and <sil=0.000> my
answer <sil=0.000> would <sil=0.000> be <sil=0.000> correct <sil=0.000> by <sil=0.000> chance <sil=2.000> .PERIOD  The <sil=0.000> answer <sil=0.000> is <sil=0.000> correct <sil=0.000> by <sil=0.000> chance <sil=0.000> because <sil=0.000> as <sil=0.000> we <sil=0.000> have
seen <sil=0.000> that <sil=0.000> here <sil=0.000> if <sil=0.000> I have <sil=0.000> an <sil=0.000> error <sil=0.000> if <sil=0.000> I have <sil=0.000> a mismatch <sil=0.000> here <sil=0.000> and <sil=0.000> suppose <sil=0.000> here <sil=0.000> the <sil=0.000> things <sil=0.000> are
all <sil=0.000> right <sil=0.000> then <sil=0.000> I would <sil=0.000> once <sil=0.000> gate <sil=0.000> the <sil=0.000> flag <sil=0.000> is <sil=0.000> 0 <sil=1.000> ,COMMA  but <sil=0.000> next <sil=0.000> time <sil=0.000> that <sil=0.000> flag <sil=0.000> will <sil=0.000> be <sil=0.000> made <sil=0.000> to <sil=0.000> 1 and
ultimately <sil=0.000> when <sil=0.000> I come <sil=0.000> out <sil=0.000> I will <sil=0.000> have <sil=0.000> the <sil=0.000> flag <sil=0.000> value <sil=0.000> to <sil=0.000> be <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> correct <sil=0.000> answer <sil=0.000> has

eluded <sil=0.000> me <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you <sil=0.000> just <sil=0.000> think <sil=0.000> of <sil=0.000> how <sil=0.000> I can <sil=0.000> modify <sil=0.000> this <sil=0.000> program <sil=0.000> such <sil=0.000> that <sil=0.000> I get <sil=0.000> the
correct <sil=0.000> result <sil=0.000> as <sil=0.000> I intended <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  we <sil=0.000> cannot <sil=0.000> use <sil=0.000> these <sil=0.000> directly <sil=1.000> ,COMMA  directly <sil=0.000> it <sil=0.000> compare <sil=0.000> the <sil=0.000> array <sil=0.000> variables <sil=0.000> I cannot
compare <sil=2.000> .PERIOD  What <sil=0.000> else <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  if <sil=0.000> a assigned <sil=0.000> b this <sil=0.000> sort <sil=0.000> of <sil=0.000> thing <sil=0.000> I cannot <sil=0.000> do <sil=2.000> .PERIOD  Also <sil=0.000> the <sil=0.000> other
thing <sil=0.000> that <sil=0.000> I cannot <sil=0.000> do <sil=0.000> is <sil=0.000> scanf <sil=0.000> and <sil=0.000> printf <sil=0.000> statements <sil=0.000> I cannot <sil=0.000> read <sil=0.000> the <sil=0.000> array <sil=0.000> in <sil=0.000> one <sil=0.000> shot
that <sil=0.000> is <sil=0.000> not <sil=0.000> allowed <sil=0.354> ;SEMICOLON  scanf <sil=0.000> and <sil=0.000> printf <sil=0.000> I could <sil=0.000> normally <sil=1.000> ,COMMA  normally <sil=0.000> what <sil=0.000> could <sil=0.000> I do <sil=2.000> .PERIOD 

Normally <sil=0.000> if <sil=0.000> I have <sil=0.000> a variable <sil=0.000> a sum <sil=0.000> variable <sil=0.000> value <sil=0.000> 5 I <sil=0.000> could <sil=0.000> have <sil=0.000> simply <sil=0.000> done <sil=0.000> printf
percentage <sil=0.000> d a <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> could <sil=0.000> be <sil=0.000> printed <sil=2.000> .PERIOD  Similarly <sil=0.000> I could <sil=0.000> have <sil=0.000> done <sil=0.000> scanf <sil=1.000> ,COMMA  percentage <sil=0.000> d
and <sil=0.000> they <sil=0.000> I could <sil=0.000> have <sil=0.000> read <sil=0.000> a value <sil=0.000> here <sil=2.000> .PERIOD  But <sil=0.000> if <sil=0.000> it <sil=0.000> is <sil=0.000> an <sil=0.000> array <sil=0.000> I cannot <sil=0.000> do <sil=0.000> it <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=0.000> we
already <sil=0.000> know <sil=0.000> how <sil=0.000> we <sil=0.000> can <sil=0.000> do <sil=0.000> that <sil=2.000> .PERIOD  We <sil=0.000> know <sil=0.000> that <sil=0.000> in <sil=0.000> order <sil=0.000> to <sil=0.000> read <sil=0.000> an <sil=0.000> array <sil=0.000> what <sil=0.000> we <sil=0.000> need
to <sil=0.000> do <sil=0.000> is <sil=0.000> read <sil=0.000> it <sil=0.000> again <sil=0.000> in <sil=0.000> a loop <sil=0.000> in <sil=0.000> a for <sil=0.000> loop <sil=0.000> element <sil=0.000> by <sil=0.000> element <sil=0.000> so <sil=1.000> ,COMMA  it <sil=0.000> can <sil=0.000> be <sil=0.000> for <sil=0.000> i assign
0 <sil=1.000> ,COMMA  i <sil=0.000> less <sil=0.000> than <sil=0.000> equal <sil=0.000> to <sil=0.000> whatever <sil=0.000> 3 <sil=1.000> ,COMMA  i <sil=0.000> plus <sil=0.000> plus <sil=1.000> ,COMMA  scanf <sil=0.000> percentage <sil=0.000> d and <sil=0.000> a i <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> array <sil=0.000> a will <sil=0.000> be <sil=0.000> red <sil=0.000> element <sil=0.000> by <sil=0.000> element <sil=0.000> I equal <sil=0.000> to <sil=0.000> 0 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  first <sil=0.000> this <sil=0.000> element <sil=0.000> will <sil=0.000> be
red <sil=0.000> same <sil=0.000> might <sil=0.000> be <sil=0.000> 5 <sil=1.000> ,COMMA  whatever <sil=0.000> element <sil=0.000> is <sil=0.000> 5 there <sil=0.000> might <sil=0.000> be <sil=0.000> 7 etcetera <sil=0.000> in <sil=0.000> that <sil=0.000> way <sil=0.000> I can
read <sil=0.000> them <sil=0.000> element <sil=0.000> by <sil=0.000> element <sil=2.000> .PERIOD  Similarly <sil=0.000> for <sil=0.000> printing <sil=0.000> an <sil=0.000> array <sil=0.000> 6 4 <sil=1.000> ,COMMA  for <sil=0.000> printing <sil=0.000> an <sil=0.000> array <sil=0.000> I
can <sil=0.000> simply <sil=0.000> again <sil=0.000> do <sil=0.000> that <sil=0.000> for <sil=0.000> say <sil=0.000> j assign <sil=0.000> 0 <sil=1.000> ,COMMA  j <sil=0.000> let <sil=0.000> me <sil=0.000> change <sil=0.000> a little <sil=0.000> bit <sil=1.000> ,COMMA  is <sil=0.000> any <sil=0.000> trouble <sil=0.000> here
j <sil=0.000> less <sil=0.000> than <sil=0.000> 3 <sil=1.000> ,COMMA  j <sil=0.000> plus <sil=0.000> plus <sil=1.000> ,COMMA  printf <sil=0.000> percentage <sil=0.000> d a <sil=0.000> i <sil=2.000> .PERIOD  Here <sil=0.000> of <sil=0.000> course <sil=1.000> ,COMMA  I <sil=0.000> do <sil=0.000> not <sil=0.000> give <sil=0.000> the <sil=0.000> scanf
again <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  is <sil=0.000> any <sil=0.000> problem <sil=0.000> with <sil=0.000> this <sil=0.228> ?QUESTIONMARK  Here <sil=0.000> I made <sil=0.000> i less <sil=0.000> than <sil=0.000> equal <sil=0.000> to <sil=0.000> 3 <sil=1.000> ,COMMA  here <sil=0.000> I am <sil=0.000> making <sil=0.000> j
less <sil=0.000> than <sil=0.000> 3 for <sil=0.000> the <sil=0.000> same <sil=0.000> size <sil=0.000> of <sil=0.000> array <sil=0.000> you <sil=0.000> can <sil=0.000> think <sil=0.000> of <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> look <sil=0.000> at <sil=0.000> it <sil=0.000> this <sil=0.000> is <sil=0.000> also
correct <sil=0.000> because <sil=0.000> here <sil=0.000> I am <sil=0.000> starting <sil=0.000> with <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  1 <sil=0.000> I am <sil=0.000> looking <sil=0.000> at <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  there <sil=0.000> is <sil=0.000> a mistake
here <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> done <sil=0.000> a couple <sil=0.000> of <sil=0.000> mistakes <sil=2.000> .PERIOD  What <sil=0.000> will <sil=0.000> happen <sil=0.000> here <sil=0.228> ?QUESTIONMARK  j <sil=0.000> first <sil=0.000> of <sil=0.000> all <sil=0.000> this <sil=0.000> was <sil=0.000> a
unintentional <sil=0.000> mistake <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> j <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  how <sil=0.000> will <sil=0.000> the <sil=0.000> array <sil=0.000> be <sil=0.000> printed <sil=0.000> here <sil=0.000> if <sil=0.000> I do <sil=0.000> it <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=0.228> ?QUESTIONMARK  What <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=0.228> ?QUESTIONMARK  Here
first <sil=0.000> thing <sil=0.000> that <sil=0.000> we <sil=0.000> printed <sil=0.000> is <sil=0.000> j <sil=1.000> ,COMMA  a <sil=0.000> j <sil=2.000> .PERIOD  What <sil=0.000> is <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> j <sil=0.228> ?QUESTIONMARK  1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> a j <sil=0.000> a 1 <sil=0.354> ;SEMICOLON  that <sil=0.000> is <sil=0.000> this
element <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  7 <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=2.000> .PERIOD  Suppose <sil=0.000> I have <sil=0.000> got <sil=0.000> a backslash <sil=0.000> n here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  7 <sil=0.000> will <sil=0.000> be <sil=1.000> ,COMMA  7
will <sil=0.000> be <sil=0.000> printed <sil=1.000> ,COMMA  then <sil=0.000> 6 will <sil=0.000> be <sil=0.000> printed <sil=0.000> because <sil=0.000> i is <sil=0.000> now <sil=0.000> 2 <sil=1.000> ,COMMA  i <sil=0.000> is <sil=0.000> now <sil=0.000> 3 <sil=1.000> ,COMMA  then <sil=0.000> 4 will <sil=0.000> be
printed <sil=1.000> ,COMMA  but <sil=0.000> till <sil=0.000> less <sil=0.000> than <sil=0.000> 3 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  therefore <sil=1.000> ,COMMA  1 <sil=0.000> 2 3 <sil=0.000> this <sil=0.000> will <sil=0.000> not <sil=0.000> be <sil=0.000> printed <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  and <sil=0.000> also <sil=0.000> again
I <sil=0.000> am <sil=0.000> missing <sil=0.000> this <sil=0.000> one <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> should <sil=0.000> I do <sil=0.228> ?QUESTIONMARK  What <sil=0.000> should <sil=0.000> I do <sil=0.228> ?QUESTIONMARK  I <sil=0.000> can <sil=0.000> make <sil=0.000> it <sil=0.000> j minus <sil=0.000> 1
what <sil=0.000> will <sil=0.000> happen <sil=0.000> in <sil=0.000> that <sil=0.000> case <sil=0.228> ?QUESTIONMARK  I <sil=0.000> am <sil=0.000> printing <sil=0.000> j is <sil=0.000> 1 and <sil=0.000> I am <sil=0.000> printing <sil=0.000> a j <sil=0.000> minus <sil=0.000> 1 <sil=0.354> ;SEMICOLON  that
means <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> printing <sil=0.000> a 0 <sil=0.000> 5 <sil=2.000> .PERIOD  Next <sil=0.000> a j <sil=0.000> becomes <sil=0.000> 2 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> be <sil=0.000> printing <sil=0.000> j minus <sil=0.000> 1 <sil=0.354> ;SEMICOLON  that

means <sil=1.000> ,COMMA  2 <sil=0.000> minus <sil=0.000> 1 a <sil=0.000> 1 <sil=1.000> ,COMMA  7 <sil=0.000> then <sil=0.000> 6 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  7 <sil=0.000> then <sil=0.000> j becomes <sil=0.000> 2 then <sil=0.000> j becomes <sil=0.000> 3 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  3 <sil=0.000> minus <sil=0.000> 1 2 <sil=1.000> ,COMMA 
I <sil=0.000> have <sil=0.000> printed <sil=0.000> a 2 <sil=0.000> have <sil=0.000> printed <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  j <sil=0.000> will <sil=0.000> be <sil=0.000> increment <sil=0.000> it <sil=0.000> will <sil=0.000> be <sil=0.000> 3 the <sil=0.000> last <sil=0.000> one <sil=0.000> will <sil=0.000> not <sil=0.000> be <sil=0.000> printed <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> here <sil=0.000> also <sil=0.000> I
have <sil=0.000> to <sil=0.000> make <sil=0.000> it <sil=0.000> less <sil=0.000> than <sil=0.000> equal <sil=0.000> to <sil=0.000> 3 <sil=2.000> .PERIOD  Was <sil=0.000> this <sil=0.000> one <sil=0.000> alright <sil=0.228> ?QUESTIONMARK  Just <sil=0.000> quickly <sil=0.000> check <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> a
common <sil=0.000> source <sil=0.000> of <sil=0.000> error <sil=0.000> I am <sil=0.000> reading <sil=0.000> this <sil=0.000> array <sil=2.000> .PERIOD  Let <sil=0.000> me <sil=0.000> do <sil=0.000> it <sil=0.000> again <sil=0.000> I am <sil=0.000> reading <sil=0.000> this
array <sil=1.000> ,COMMA  a <sil=0.000> 0 then <sil=0.000> I have <sil=0.000> read <sil=0.000> a 0 <sil=1.000> ,COMMA  then <sil=0.000> i is <sil=0.000> incremented <sil=1.000> ,COMMA  so <sil=0.000> the <sil=0.000> 4 elements <sil=1.000> ,COMMA  so <sil=0.000> I will <sil=0.000> come <sil=0.000> up
to <sil=0.000> a 3 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> second <sil=0.000> one <sil=0.000> I am <sil=0.000> reading <sil=0.000> the <sil=0.000> second <sil=0.000> one <sil=0.000> a i <sil=0.000> is <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  a <sil=0.000> 1 <sil=1.000> ,COMMA  i <sil=0.000> is <sil=0.000> next <sil=0.000> 2 a <sil=0.000> 2 and
then <sil=0.000> a 3 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> ok <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you <sil=0.000> have <sil=0.000> to <sil=0.000> be <sil=0.000> a little <sil=0.000> careful <sil=0.000> about <sil=0.000> all <sil=0.000> this <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  reading <sil=0.000> and <sil=0.000> printing <sil=1.000> ,COMMA  reading <sil=0.000> and <sil=0.000> printing <sil=0.000> we <sil=0.000> cannot <sil=0.000> directly <sil=0.000> do <sil=0.000> we <sil=0.000> have <sil=0.000> also <sil=0.000> to <sil=0.000> do <sil=0.000> it
through <sil=0.000> a loop <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> cannot <sil=0.000> do <sil=0.000> like <sil=0.000> this <sil=2.000> .PERIOD 

How <sil=0.000> to <sil=0.000> copy <sil=0.000> elements <sil=0.000> of <sil=0.000> one <sil=0.000> array <sil=0.000> to <sil=0.000> another <sil=0.228> ?QUESTIONMARK  By <sil=0.000> copying <sil=0.000> individual <sil=0.000> elements <sil=0.000> I have
already <sil=0.000> shown <sil=0.000> that <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> what <sil=0.000> we <sil=0.000> have <sil=0.000> to <sil=0.000> say <sil=0.000> about <sil=0.000> arrays <sil=0.000> right <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  will <sil=0.000> come <sil=0.000> to
some <sil=0.000> examples <sil=0.000> say <sil=0.000> I want <sil=0.000> to <sil=0.000> this <sil=0.000> is <sil=0.000> an <sil=0.000> example <sil=0.000> of <sil=0.000> copying <sil=0.000> an <sil=0.000> array <sil=0.000> there <sil=0.000> are <sil=1.000> ,COMMA  there <sil=0.000> are
two <sil=0.000> arrays <sil=0.000> a 25 <sil=0.000> and <sil=0.000> B 25 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> trying <sil=0.000> to <sil=0.000> copy <sil=0.000> them <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you <sil=0.000> know <sil=0.000> that <sil=0.000> I can <sil=0.000> do <sil=0.000> it <sil=0.000> by
copying <sil=0.000> it <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  some <sil=0.000> problems <sil=0.000> we <sil=0.000> will <sil=0.000> like <sil=0.000> to <sil=0.000> try <sil=0.000> out <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  one <sil=0.000> is <sil=0.000> finding <sil=0.000> the <sil=0.000> mean <sil=0.000> and <sil=0.000> standard
deviation <sil=0.000> of <sil=0.000> a set <sil=0.000> of <sil=0.000> n numbers <sil=2.000> .PERIOD  I <sil=0.000> leave <sil=0.000> this <sil=0.000> standard <sil=0.000> deviation <sil=0.000> part <sil=0.000> we <sil=0.000> can <sil=0.000> try <sil=0.000> to <sil=0.000> do <sil=0.000> that
mean <sil=0.000> you <sil=0.000> know <sil=0.000> mean <sil=0.000> is <sil=0.000> the <sil=0.000> arithmetic <sil=0.000> average <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> first <sil=0.000> try <sil=0.000> to <sil=0.000> find <sil=0.000> write <sil=0.000> a program
where <sil=0.000> all <sil=0.000> of <sil=0.000> you <sil=0.000> will <sil=0.000> be <sil=0.000> able <sil=0.000> to <sil=0.000> write <sil=0.000> find <sil=0.000> the <sil=0.000> mean <sil=0.000> and <sil=0.000> standard <sil=0.000> deviation <sil=0.000> of <sil=0.000> a set <sil=0.000> of <sil=0.000> n
numbers <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  what <sil=0.000> are <sil=0.000> you <sil=0.000> going <sil=0.000> to <sil=0.000> do <sil=0.228> ?QUESTIONMARK  Mean <sil=0.000> means <sil=0.000> the <sil=0.000> average <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> add <sil=0.000> the <sil=0.000> numbers <sil=0.000> all
the <sil=0.000> numbers <sil=0.000> suppose <sil=0.000> my <sil=0.000> array <sil=0.000> is <sil=0.000> a <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  each <sil=0.000> element <sil=0.000> I designate <sil=0.000> as <sil=0.000> a i <sil=0.000> is <sil=0.000> an <sil=0.000> element <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 

I <sil=0.000> will <sil=0.000> have <sil=0.000> sigma <sil=0.000> a i <sil=1.000> ,COMMA  i <sil=0.000> varying <sil=0.000> from <sil=0.000> 1 to <sil=0.000> n whatever <sil=0.000> this <sil=0.000> size <sil=0.000> is <sil=0.000> divided <sil=0.000> by <sil=0.000> n that <sil=0.000> is <sil=0.000> the
average <sil=0.000> I add <sil=0.000> all <sil=0.000> the <sil=0.000> numbers <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> simple <sil=0.000> to <sil=0.000> write <sil=0.000> the <sil=0.000> program <sil=2.000> .PERIOD  Suppose <sil=0.000> I have <sil=0.000> read
the <sil=0.000> array <sil=0.000> I have <sil=0.000> first <sil=0.000> of <sil=0.000> all <sil=0.000> I have <sil=0.000> to <sil=0.000> read <sil=0.000> the <sil=0.000> elements <sil=0.000> in <sil=0.000> an <sil=0.000> array <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  summarizing <sil=0.000> all <sil=0.000> what <sil=0.000> we <sil=0.000> have <sil=0.000> learnt <sil=0.000> what <sil=0.000> should <sil=0.000> be <sil=0.000> my <sil=0.000> first <sil=0.000> statement <sil=0.000> first
statement <sil=0.000> is <sil=0.000> declaring <sil=0.000> the <sil=0.000> array <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> me <sil=0.000> declare <sil=0.000> an <sil=0.000> array <sil=1.000> ,COMMA  int <sil=0.000> a suppose <sil=0.000> the <sil=0.000> size <sil=0.000> of <sil=0.000> the
array <sil=0.000> is <sil=0.000> 5 <sil=1.000> ,COMMA  maximum <sil=0.000> size <sil=0.000> possible <sil=2.000> .PERIOD  And <sil=0.000> I also <sil=0.000> have <sil=0.000> sum <sil=0.000> and <sil=0.000> I have <sil=0.000> got <sil=0.000> another <sil=0.000> variable
avg <sil=0.000> all <sil=0.000> our <sil=0.000> integers <sil=1.000> ,COMMA  again <sil=0.000> avg <sil=0.000> may <sil=0.000> not <sil=0.000> be <sil=0.000> integer <sil=1.000> ,COMMA  mean <sil=0.000> may <sil=0.000> not <sil=0.000> be <sil=0.000> integer <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  and <sil=0.000> then
I <sil=0.000> have <sil=0.000> got <sil=0.000> another <sil=0.000> float <sil=0.000> avg <sil=0.000> right <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  first <sil=0.000> I have <sil=0.000> to <sil=0.000> read <sil=0.000> the <sil=0.000> array <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  read <sil=0.000> the <sil=0.000> numbers <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> making <sil=0.000> a shortcut <sil=0.000> I am
leaving <sil=0.000> out <sil=0.000> the <sil=0.000> printf <sil=0.000> statement <sil=0.000> please <sil=0.000> enter <sil=0.000> the <sil=0.000> array <sil=0.000> that <sil=0.000> part <sil=0.000> I am <sil=0.000> leaving <sil=0.000> out <sil=2.000> .PERIOD  Then
what <sil=0.000> I am <sil=0.000> doing <sil=0.000> here <sil=0.228> ?QUESTIONMARK  Here <sil=0.000> of <sil=0.000> course <sil=1.000> ,COMMA  for <sil=0.000> i assigned <sil=0.000> 0 <sil=1.000> ,COMMA  i <sil=0.000> less <sil=0.000> than <sil=0.000> suppose <sil=0.000> there <sil=0.000> are <sil=0.000> 5
elements <sil=1.000> ,COMMA  i <sil=0.000> less <sil=0.000> than <sil=0.000> 5 <sil=1.000> ,COMMA  i <sil=0.000> plus <sil=0.000> plus <sil=2.000> .PERIOD  If <sil=0.000> it <sil=0.000> was <sil=0.000> some <sil=0.000> other <sil=0.000> value <sil=0.000> then <sil=0.000> I would <sil=0.000> have <sil=0.000> put <sil=0.000> it <sil=0.000> n
here <sil=0.000> and <sil=0.000> I had <sil=0.000> to <sil=0.000> read <sil=0.000> the <sil=0.000> n before <sil=0.000> I read <sil=0.000> the <sil=0.000> array <sil=1.000> ,COMMA  all <sil=0.000> right <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> do <sil=0.000> this <sil=0.000> and <sil=0.000> then <sil=0.000> initially <sil=0.000> I can <sil=0.000> make <sil=0.000> it <sil=0.000> the <sil=0.000> sum <sil=0.000> here <sil=0.000> to <sil=0.000> be <sil=0.000> sum <sil=0.000> is <sil=0.000> initialized <sil=0.000> to <sil=0.000> 0 all
right <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  for <sil=0.000> i equal <sil=0.000> to <sil=0.000> 0 <sil=1.000> ,COMMA  i <sil=0.000> less <sil=0.000> than <sil=0.000> m <sil=1.000> ,COMMA  i <sil=0.000> plus <sil=0.000> plus <sil=0.000> I read <sil=0.000> the <sil=0.000> array <sil=0.000> I am <sil=0.000> just <sil=0.000> now
reading <sil=0.000> the <sil=0.000> array <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> I do <sil=0.228> ?QUESTIONMARK  Scanf <sil=1.000> ,COMMA  percentage <sil=0.000> d <sil=1.000> ,COMMA  ampersand <sil=1.000> ,COMMA  a <sil=0.000> i <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> reading <sil=0.000> that
and <sil=0.000> then <sil=0.000> here <sil=0.000> in <sil=0.000> this <sil=0.000> for <sil=0.000> loop <sil=0.000> I can <sil=0.000> repeatedly <sil=0.000> compute <sil=0.000> the <sil=0.000> sum <sil=1.000> ,COMMA  sum <sil=0.000> equals <sil=0.000> sum <sil=0.000> plus <sil=0.000> a i <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> get <sil=0.000> the <sil=0.000> sum <sil=0.000> here <sil=0.000> ultimately <sil=0.000> at <sil=0.000> the <sil=0.000> end <sil=0.000> of <sil=0.000> the <sil=0.000> loop <sil=1.000> ,COMMA  at <sil=0.000> the <sil=0.000> end <sil=0.000> of <sil=0.000> the <sil=0.000> loop <sil=0.000> I will
get <sil=0.000> the <sil=0.000> sum <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  here <sil=0.000> I can <sil=0.000> write <sil=0.000> average <sil=0.000> is <sil=0.000> sum <sil=0.000> divided <sil=0.000> by <sil=0.000> whatever <sil=0.000> the <sil=0.000> value <sil=0.000> was
I <sil=0.000> have <sil=0.000> taken <sil=0.000> 5 to <sil=0.000> be <sil=0.000> a fixed <sil=0.000> value <sil=1.000> ,COMMA  so <sil=0.000> I divide <sil=0.000> with <sil=0.000> 5 and <sil=0.000> that <sil=0.000> is <sil=0.000> the <sil=0.000> average <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  in <sil=0.000> that
way <sil=0.000> I can <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> mean <sil=0.000> this <sil=0.000> value <sil=2.000> .PERIOD  The <sil=0.000> next <sil=0.000> task <sil=0.000> is <sil=0.000> computing <sil=0.000> the <sil=0.000> standard
deviation <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> I leave <sil=0.000> to <sil=0.000> you <sil=0.000> for <sil=0.000> the <sil=0.000> time <sil=0.000> being <sil=2.000> .PERIOD  We <sil=0.000> will <sil=0.000> take <sil=0.000> it <sil=0.000> up <sil=0.000> later <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  we <sil=0.000> were <sil=0.000> looking <sil=0.000> at <sil=0.000> computing <sil=0.000> standard <sil=0.000> deviation <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  standard <sil=0.000> deviation <sil=0.000> is <sil=0.000> mean <sil=0.354> ;SEMICOLON  we
have <sil=0.000> seen <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  standard <sil=0.000> deviation <sil=0.000> is <sil=0.000> if <sil=0.000> the <sil=0.000> mean <sil=0.000> is <sil=0.000> suppose <sil=0.000> the <sil=0.000> mean <sil=0.000> is <sil=0.000> represented <sil=0.000> by <sil=0.000> mu <sil=0.000> then <sil=0.000> I
take <sil=0.000> the <sil=0.000> sum <sil=0.000> of <sil=0.000> the <sil=0.000> deviation <sil=0.000> from <sil=0.000> the <sil=0.000> mean <sil=0.000> for <sil=0.000> every <sil=0.000> element <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> array
was <sil=0.000> a with <sil=0.000> every <sil=0.000> element <sil=0.000> being <sil=0.000> called <sil=0.000> a i <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  what <sil=0.000> I am <sil=0.000> trying <sil=0.000> to <sil=0.000> do <sil=0.000> is <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> taking <sil=0.000> the <sil=0.000> difference <sil=0.000> of <sil=0.000> a i <sil=0.000> from <sil=0.000> the <sil=0.000> mean <sil=0.000> and <sil=0.000> since <sil=0.000> its
difference <sil=0.000> can <sil=0.000> be <sil=0.000> suppose <sil=0.000> there <sil=0.000> are <sil=0.000> some <sil=0.000> values <sil=0.000> and <sil=0.000> this <sil=0.000> is <sil=0.000> the <sil=0.000> mean <sil=0.000> and <sil=0.000> the <sil=0.000> value <sil=0.000> can
be <sil=0.000> a little <sil=0.000> away <sil=0.000> from <sil=0.000> the <sil=0.000> mean <sil=0.000> on <sil=0.000> this <sil=0.000> side <sil=0.000> more <sil=0.000> than <sil=0.000> the <sil=0.000> mean <sil=0.000> or <sil=0.000> less <sil=0.000> than <sil=0.000> the <sil=0.000> mean <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
we <sil=0.000> take <sil=0.000> the <sil=0.000> square <sil=0.000> of <sil=0.000> the <sil=0.000> mean <sil=0.000> square <sil=0.000> of <sil=0.000> the <sil=0.000> difference <sil=0.000> and <sil=0.000> I do <sil=0.000> that <sil=0.000> for <sil=0.000> all <sil=0.000> the <sil=0.000> elements
I <sil=0.000> equals <sil=0.000> 1 to <sil=0.000> n right <sil=0.000> and <sil=0.000> then <sil=0.000> I take <sil=0.000> the <sil=0.000> square <sil=0.000> root <sil=0.000> of <sil=0.000> the <sil=0.000> whole <sil=0.000> thing <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> my
standard <sil=0.000> deviation <sil=0.000> other <sil=0.000> my <sil=0.000> variance <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> compute <sil=0.000> either <sil=0.000> this <sil=0.000> or <sil=0.000> this <sil=1.000> ,COMMA  whatever <sil=0.000> I
like <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  you <sil=0.000> will <sil=0.000> simply <sil=0.000> understand <sil=0.000> that <sil=0.000> in <sil=0.000> the <sil=0.000> code <sil=0.000> that <sil=0.000> we <sil=0.000> have <sil=0.000> given <sil=0.000> little <sil=0.000> earlier <sil=0.000> then <sil=0.000> there
we <sil=0.000> had <sil=0.000> computed <sil=0.000> the <sil=0.000> mean <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  mu <sil=0.000> has <sil=0.000> been <sil=0.000> computed <sil=0.000> which <sil=0.000> was <sil=0.000> the <sil=0.000> average
that <sil=0.000> we <sil=0.000> computed <sil=0.000> last <sil=0.000> time <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> I have <sil=0.000> read <sil=0.000> the <sil=0.000> elements <sil=0.000> in <sil=0.000> an <sil=0.000> array <sil=0.000> whatever <sil=0.000> the
elements <sil=0.000> are <sil=0.000> 5 7 <sil=0.000> 3 2 <sil=0.000> and <sil=0.000> I have <sil=0.000> computed <sil=0.000> the <sil=0.000> mean <sil=0.000> mu <sil=0.000> who <sil=0.000> has <sil=0.000> been <sil=0.000> computed <sil=0.000> mean <sil=0.000> is
of <sil=0.000> 12 <sil=0.000> 3 15 <sil=0.354> ;SEMICOLON  17 <sil=0.000> divided <sil=0.000> by <sil=0.000> 4 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> 4 point <sil=0.000> something <sil=0.000> 4 <sil=2.000> .PERIOD <sil=0.000> 1 <sil=1.000> ,COMMA  4 <sil=2.000> .PERIOD <sil=0.000> 25 <sil=0.000> right <sil=0.000> that <sil=0.000> is <sil=0.000> my <sil=0.000> mean <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  for <sil=0.000> every <sil=0.000> element <sil=0.000> again <sil=0.000> in <sil=0.000> this <sil=0.000> array <sil=0.000> I find <sil=0.000> out <sil=0.000> for <sil=0.000> i assign <sil=0.000> 0 <sil=1.000> ,COMMA  i <sil=0.000> less <sil=0.000> than <sil=0.000> equal <sil=0.000> to
3 <sil=1.000> ,COMMA  i <sil=0.000> plus <sil=0.000> plus <sil=0.000> what <sil=0.000> do <sil=0.000> I do <sil=0.228> ?QUESTIONMARK  For <sil=0.000> every <sil=0.000> element <sil=0.000> I have <sil=0.000> got <sil=0.000> the <sil=0.000> mu <sil=0.000> and <sil=0.000> let <sil=0.000> us <sil=0.000> call <sil=0.000> it <sil=0.000> average
right <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  sum <sil=0.000> was <sil=0.000> 0 what <sil=0.000> is <sil=0.000> it <sil=0.000> look <sil=0.000> like <sil=1.000> ,COMMA  sum <sil=0.000> was <sil=0.000> 0 <sil=1.000> ,COMMA  sum <sil=0.000> will <sil=0.000> be <sil=0.000> now <sil=0.000> sum <sil=0.000> plus <sil=0.000> I am <sil=0.000> getting
sigma <sil=0.000> of <sil=0.000> mu <sil=0.000> minus <sil=0.000> a i <sil=0.000> whole <sil=0.000> square <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  sum <sil=0.000> plus <sil=0.000> average <sil=0.000> minus <sil=0.000> a i <sil=0.000> times <sil=0.000> average
minus <sil=0.000> a i <sil=1.000> ,COMMA  all <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> the <sil=0.000> square <sil=0.000> average <sil=0.000> is <sil=0.000> mu <sil=0.000> minus <sil=0.000> a i <sil=0.000> that <sil=0.000> is <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> doing
this <sil=0.000> square <sil=0.000> and <sil=0.000> I am <sil=0.000> repeatedly <sil=0.000> doing <sil=0.000> this <sil=0.000> and <sil=0.000> getting <sil=0.000> the <sil=0.000> new <sil=0.000> sum <sil=0.000> and <sil=0.000> at <sil=0.000> the <sil=0.000> end <sil=0.000> of <sil=0.000> this

loop <sil=0.000> therefore <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> see <sil=0.000> std <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> a dev <sil=0.000> let <sil=0.000> me <sil=0.000> call <sil=0.000> it <sil=0.000> standard
deviation <sil=0.000> is <sil=0.000> square <sil=0.000> root <sil=0.000> of <sil=0.000> the <sil=0.000> sum <sil=0.000> all <sil=0.000> right <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> way <sil=0.000> I can <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> standard
deviation <sil=0.000> also <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> come <sil=0.000> to <sil=0.000> the <sil=0.000> now <sil=0.000> what <sil=0.000> is <sil=0.000> the <sil=0.000> application <sil=0.000> what <sil=0.000> is <sil=0.000> the <sil=0.000> meaning <sil=0.000> of <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  with
these <sil=0.000> say <sil=0.000> in <sil=0.000> a class <sil=0.000> you <sil=0.000> are <sil=0.000> you <sil=0.000> are <sil=0.000> supposed <sil=0.000> to <sil=0.000> write <sil=0.000> a program <sil=0.000> where <sil=0.000> you <sil=0.000> want <sil=0.000> to <sil=0.000> find
out <sil=0.000> say <sil=0.000> in <sil=0.000> a class <sil=0.000> of <sil=0.000> physics <sil=2.000> .PERIOD  What <sil=0.000> is <sil=0.000> the <sil=0.000> average <sil=0.000> of <sil=0.000> the <sil=0.000> numbers <sil=0.000> of <sil=0.000> all <sil=0.000> the <sil=0.000> students <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  I
will <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> mean <sil=0.000> and <sil=0.000> mean <sil=0.000> of <sil=0.000> the <sil=0.000> class <sil=0.000> marks <sil=0.000> right <sil=2.000> .PERIOD  Similarly <sil=0.000> I can <sil=0.000> find <sil=0.000> out <sil=0.000> that
what <sil=0.000> is <sil=0.000> the <sil=0.000> standard <sil=0.000> deviation <sil=1.000> ,COMMA  how <sil=0.000> much <sil=0.000> did <sil=0.000> it <sil=0.000> vary <sil=1.000> ,COMMA  that <sil=0.000> also <sil=0.000> I can <sil=0.000> find <sil=0.000> out <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=0.000> new <sil=0.000> another <sil=0.000> problem <sil=2.000> .PERIOD  Say <sil=0.000> a shop <sil=0.000> stores <sil=0.000> in <sil=0.000> different <sil=0.000> types <sil=0.000> of
items <sil=1.000> ,COMMA  n <sil=0.000> different <sil=0.000> types <sil=0.000> of <sil=0.000> items <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  given <sil=0.000> the <sil=0.000> number <sil=0.000> of <sil=0.000> items <sil=0.000> of <sil=0.000> each <sil=0.000> type <sil=0.000> sold
during <sil=0.000> a given <sil=0.000> month <sil=0.000> and <sil=0.000> the <sil=0.000> corresponding <sil=0.000> unit <sil=0.000> price <sil=0.000> is <sil=0.000> compute <sil=0.000> the <sil=0.000> total <sil=0.000> monthly <sil=0.000> sell <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> the <sil=0.000> scenario <sil=0.228> ?QUESTIONMARK  The <sil=0.000> scenario <sil=0.000> is <sil=0.000> this <sil=2.000> .PERIOD 

I <sil=0.000> have <sil=0.000> got <sil=0.000> say <sil=0.000> 5 items <sil=1.000> ,COMMA  item <sil=0.000> 1 <sil=1.000> ,COMMA  item <sil=0.000> 2 <sil=1.000> ,COMMA  item <sil=0.000> 3 <sil=1.000> ,COMMA  item <sil=0.000> 4 and <sil=0.000> item <sil=0.000> 5 <sil=2.000> .PERIOD  And <sil=0.000> let <sil=0.000> me <sil=0.000> call <sil=0.000> it <sil=0.000> the
item <sil=1.000> ,COMMA  let <sil=0.000> me <sil=0.000> call <sil=0.000> it <sil=0.000> on <sil=0.000> this <sil=0.000> side <sil=0.000> let <sil=0.000> me <sil=0.000> call <sil=0.000> it <sil=0.000> this <sil=0.000> array <sil=0.000> is <sil=0.000> item <sil=0.000> price <sil=1.000> ,COMMA  item <sil=0.000> cost <sil=1.000> ,COMMA  item <sil=0.000> cost <sil=2.000> .PERIOD 
Suppose <sil=0.000> the <sil=0.000> cost <sil=0.000> here <sil=0.000> is <sil=0.000> 7 and <sil=0.000> half <sil=0.000> rupees <sil=0.000> per <sil=0.000> item <sil=0.000> of <sil=0.000> type <sil=0.000> 0 <sil=1.000> ,COMMA  25 <sil=0.000> for <sil=0.000> item <sil=0.000> of <sil=0.000> type <sil=0.000> 1 <sil=1.000> ,COMMA  this <sil=0.000> is
0 <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> 1 <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> 2 <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> 3 <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> 4 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> item <sil=0.000> cost <sil=0.000> for <sil=0.000> this <sil=0.000> for <sil=0.000> item <sil=0.000> of <sil=0.000> type <sil=0.000> 2 is <sil=0.000> 12 <sil=2.000> .PERIOD <sil=0.000> 5 <sil=1.000> ,COMMA 
item <sil=0.000> of <sil=0.000> type <sil=0.000> 3 is <sil=0.000> 10 <sil=1.000> ,COMMA  item <sil=0.000> of <sil=0.000> this <sil=0.000> is <sil=0.000> item <sil=0.000> of <sil=0.000> type <sil=0.000> 4 is <sil=0.000> 50 <sil=0.000> rupees <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  I <sil=0.000> want <sil=0.000> to <sil=0.000> store <sil=0.000> how <sil=0.000> many <sil=0.000> items <sil=0.000> of <sil=0.000> each <sil=0.000> type <sil=0.000> has <sil=0.000> been <sil=0.000> sold <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> take <sil=0.000> another <sil=0.000> array
and <sil=0.000> call <sil=0.000> it <sil=0.000> items <sil=0.000> sold <sil=2.000> .PERIOD  Suppose <sil=0.000> 5 items <sil=0.000> have <sil=0.000> been <sil=0.000> sold <sil=0.000> of <sil=0.000> type <sil=0.000> 0 <sil=1.000> ,COMMA  6 <sil=0.000> items <sil=0.000> here <sil=0.000> of <sil=0.000> type <sil=0.000> 1 <sil=1.000> ,COMMA  2
items <sil=0.000> of <sil=0.000> type <sil=0.000> 2 <sil=1.000> ,COMMA  4 <sil=0.000> items <sil=0.000> of <sil=0.000> type <sil=0.000> 3 and <sil=0.000> 2 items <sil=0.000> of <sil=0.000> type <sil=0.000> 1 <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  my <sil=0.000> question <sil=0.000> is <sil=0.000> what <sil=0.000> is <sil=0.000> the
total <sil=0.000> sell <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  what <sil=0.000> should <sil=0.000> I do <sil=0.228> ?QUESTIONMARK  You <sil=0.000> can <sil=0.000> easily <sil=0.000> understand <sil=0.000> that <sil=0.000> the <sil=0.000> here <sil=0.000> is <sil=0.000> the <sil=0.000> item <sil=0.000> cost <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> to <sil=0.000> multiply <sil=0.000> this <sil=0.000> with <sil=0.000> this <sil=1.000> ,COMMA  this <sil=0.000> with <sil=0.000> this <sil=0.000> and <sil=0.000> add <sil=0.000> all <sil=0.000> these <sil=0.000> costs <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be
7 <sil=2.000> .PERIOD <sil=0.000> 5 times <sil=0.000> 5 it <sil=0.000> will <sil=0.000> be <sil=0.000> 7 <sil=2.000> .PERIOD <sil=0.000> 5 times <sil=0.000> 5 plus <sil=0.000> 25 <sil=0.000> times <sil=0.000> 6 plus <sil=0.000> so <sil=0.000> and <sil=0.000> so <sil=0.000> forth <sil=0.000> in <sil=0.000> that <sil=0.000> way <sil=0.000> I can
find <sil=0.000> the <sil=0.000> total <sil=0.000> cost <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> will <sil=0.000> the <sil=0.000> program <sil=0.000> look <sil=0.000> like <sil=0.228> ?QUESTIONMARK  The <sil=0.000> program <sil=0.000> will <sil=0.000> look <sil=0.000> like <sil=0.000> I will
be <sil=0.000> needing <sil=0.000> to <sil=0.000> arrays <sil=0.000> item <sil=0.000> cost <sil=0.000> and <sil=0.000> items <sil=0.000> sold <sil=0.000> and <sil=0.000> they <sil=0.000> should <sil=0.000> be <sil=0.000> of <sil=0.000> the <sil=0.000> same <sil=0.000> size <sil=1.000> ,COMMA 
assuming <sil=0.000> that <sil=0.000> I know <sil=0.000> beforehand <sil=0.000> that <sil=0.000> there <sil=0.000> are <sil=0.000> 5 items <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> start <sil=0.000> with <sil=0.000> item <sil=0.000> cost <sil=0.000> of <sil=0.000> type <sil=0.000> 5 <sil=1.000> ,COMMA  but <sil=0.000> this <sil=0.000> will <sil=0.000> be <sil=0.000> cost <sil=0.000> will <sil=0.000> be <sil=0.000> of <sil=0.000> type <sil=0.000> float <sil=0.000> and <sil=0.000> there
will <sil=0.000> be <sil=0.000> another <sil=0.000> the <sil=0.000> number <sil=0.000> of <sil=0.000> items <sil=0.000> is <sil=1.000> ,COMMA  item <sil=0.000> sold <sil=0.000> the <sil=0.000> number <sil=0.000> of <sil=0.000> items <sil=0.000> sold <sil=0.000> is <sil=0.000> integer <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
I <sil=0.000> will <sil=0.000> have <sil=0.000> this <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> not <sil=0.000> showing <sil=0.000> the <sil=0.000> part <sil=0.000> that <sil=0.000> here <sil=0.000> I am <sil=0.000> reading <sil=0.000> the <sil=0.000> two <sil=0.000> arrays <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  after
I <sil=0.000> read <sil=0.000> the <sil=0.000> arrays <sil=0.000> I will <sil=0.000> have <sil=0.000> two <sil=0.000> arrays <sil=0.000> like <sil=0.000> this <sil=1.000> ,COMMA  one <sil=0.000> is <sil=0.000> an <sil=0.000> integer <sil=0.000> array <sil=0.000> another <sil=0.000> is <sil=0.000> a
floating <sil=0.000> point <sil=0.000> array <sil=0.000> this <sil=0.000> is <sil=0.000> the <sil=0.000> float <sil=0.000> and <sil=0.000> this <sil=0.000> is <sil=0.000> an <sil=0.000> integer <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  my <sil=0.000> actual <sil=0.000> body <sil=0.000> of <sil=0.000> the <sil=0.000> program <sil=0.000> will <sil=0.000> be <sil=0.000> in <sil=0.000> a loop <sil=0.000> for <sil=0.000> say <sil=0.000> I am <sil=0.000> doing <sil=0.000> it <sil=0.000> using <sil=0.000> for <sil=0.000> say
i <sil=0.000> assign <sil=0.000> 0 <sil=1.000> ,COMMA  i <sil=0.000> less <sil=0.000> than <sil=0.000> equal <sil=0.000> to <sil=0.000> 4 since <sil=0.000> the <sil=0.000> size <sil=0.000> is <sil=0.000> 5 <sil=1.000> ,COMMA  i <sil=0.000> plus <sil=0.000> plus <sil=2.000> .PERIOD  And <sil=0.000> what <sil=0.000> do <sil=0.000> I do <sil=0.000> here <sil=0.228> ?QUESTIONMARK 
What <sil=0.000> do <sil=0.000> I do <sil=0.000> in <sil=0.000> the <sil=0.000> body <sil=0.000> of <sil=0.000> the <sil=0.000> for <sil=0.000> loop <sil=0.228> ?QUESTIONMARK  I <sil=0.000> take <sil=0.000> ok <sil=1.000> ,COMMA  I <sil=0.000> write <sil=0.000> actually <sil=0.000> only <sil=0.000> one <sil=0.000> statement
will <sil=0.000> do <sil=0.000> there <sil=0.000> is <sil=0.000> no <sil=0.000> harm <sil=0.000> in <sil=0.000> putting <sil=0.000> this <sil=0.000> bracket <sil=2.000> .PERIOD  Total <sil=0.000> sale <sil=0.000> which <sil=0.000> was <sil=0.000> a variable <sil=0.000> of <sil=0.000> type
float <sil=0.000> total <sil=0.000> sale <sil=0.000> is <sil=1.000> ,COMMA  total <sil=0.000> sale <sil=0.000> was <sil=0.000> initialized <sil=0.000> to <sil=0.000> 0 <sil=1.000> ,COMMA  total <sil=0.000> sale <sil=0.000> plus <sil=0.000> item <sil=0.000> cost <sil=0.000> i times <sil=0.000> multiplied
by <sil=0.000> item <sil=0.000> sold <sil=0.000> i <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> will <sil=0.000> be <sil=0.000> done <sil=0.000> in <sil=0.000> a loop <sil=2.000> .PERIOD 
And <sil=0.000> so <sil=0.000> I will <sil=0.000> take <sil=0.000> the <sil=0.000> first <sil=0.000> item <sil=1.000> ,COMMA  item <sil=0.000> cost <sil=0.000> 0 multiply <sil=0.000> with <sil=0.000> that <sil=0.000> with <sil=0.000> item <sil=0.000> cost <sil=0.000> item <sil=0.000> sold <sil=0.000> 0 <sil=1.000> ,COMMA 
add <sil=0.000> that <sil=0.000> with <sil=0.000> the <sil=0.000> total <sil=0.000> sale <sil=0.000> which <sil=0.000> was <sil=0.000> initialized <sil=0.000> to <sil=0.000> 0 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> I can <sil=0.000> have <sil=0.000> float <sil=0.000> total <sil=0.000> sale
initialized <sil=0.000> to <sil=0.000> 0 <sil=1.000> ,COMMA  0 <sil=0.000> point <sil=0.000> 0 all <sil=0.000> right <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> do <sil=0.000> that <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> doing <sil=0.000> it <sil=0.000> in <sil=0.000> a loop <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  first
I <sil=0.000> multiply <sil=0.000> these <sil=0.000> two <sil=0.000> add <sil=0.000> it <sil=0.000> to <sil=0.000> total <sil=0.000> sales <sil=1.000> ,COMMA  next <sil=0.000> again <sil=0.000> in <sil=0.000> the <sil=0.000> next <sil=0.000> iteration <sil=0.000> i is <sil=0.000> implemented
I <sil=0.000> take <sil=0.000> these <sil=0.000> two <sil=0.000> and <sil=0.000> multiply <sil=0.000> them <sil=0.000> and <sil=0.000> add <sil=0.000> it <sil=0.000> to <sil=0.000> the <sil=0.000> total <sil=0.000> sale <sil=0.000> then <sil=0.000> I do <sil=0.000> this <sil=0.000> two <sil=0.000> and
multiply <sil=0.000> them <sil=0.000> add <sil=0.000> it <sil=0.000> to <sil=0.000> the <sil=0.000> total <sil=0.000> sale <sil=0.000> and <sil=0.000> I go <sil=0.000> on <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=2.000> .PERIOD  This <sil=0.000> is <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> in <sil=0.000> this <sil=0.000> way
by <sil=0.000> using <sil=0.000> this <sil=0.000> array <sil=0.000> I will <sil=0.000> be <sil=0.000> able <sil=0.000> to <sil=0.000> add <sil=0.000> all <sil=0.000> these <sil=0.000> values <sil=0.000> and <sil=0.000> I will <sil=0.000> get <sil=0.000> the <sil=0.000> total <sil=0.000> sale <sil=0.000> at <sil=0.000> the
end <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> we <sil=0.000> could <sil=0.000> see <sil=0.000> two <sil=0.000> very <sil=0.000> nice <sil=0.000> examples <sil=0.000> of <sil=0.000> application <sil=0.000> of <sil=0.000> arrays <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  one <sil=0.000> another
problem <sil=0.000> that <sil=0.000> I gave <sil=0.000> you <sil=0.000> I mean <sil=0.000> as <sil=0.000> I was <sil=0.000> while <sil=0.000> comparing <sil=0.000> the <sil=0.000> arrays <sil=0.000> you <sil=0.000> can <sil=0.000> do <sil=0.000> it <sil=0.000> in
multiple <sil=0.000> ways <sil=0.000> that <sil=0.000> they <sil=0.000> were <sil=0.000> as <sil=0.000> two <sil=0.000> arrays <sil=0.000> you <sil=0.000> must <sil=0.000> have <sil=0.000> solved <sil=0.000> it <sil=0.000> by <sil=0.000> now <sil=1.000> ,COMMA  that <sil=0.000> they
were <sil=0.000> two <sil=0.000> arrays <sil=0.000> like <sil=0.000> this <sil=0.000> 7 <sil=1.000> ,COMMA  7 <sil=1.000> ,COMMA  5 <sil=1.000> ,COMMA  5 <sil=1.000> ,COMMA  here <sil=0.000> 6 <sil=1.000> ,COMMA  here <sil=0.000> 4 <sil=1.000> ,COMMA  but <sil=0.000> again <sil=0.000> 3 <sil=1.000> ,COMMA  3 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  everywhere <sil=0.000> they <sil=0.000> are <sil=0.000> matching <sil=1.000> ,COMMA  but <sil=0.000> intermediate <sil=0.000> they <sil=0.000> were <sil=0.000> affected <sil=0.000> and <sil=0.000> I had <sil=0.000> a flag
value <sil=0.000> so <sil=0.000> flag <sil=0.000> was <sil=0.000> initialized <sil=0.000> to <sil=0.000> 1 <sil=2.000> .PERIOD  And <sil=0.000> then <sil=0.000> in <sil=0.000> a for <sil=0.000> loop <sil=0.000> then <sil=0.000> in <sil=0.000> the <sil=0.000> for <sil=0.000> loop <sil=0.000> I was
checking <sil=0.000> this <sil=0.000> was <sil=0.000> a and <sil=0.000> this <sil=0.000> was <sil=0.000> b <sil=1.000> ,COMMA  flag <sil=0.000> was <sil=0.000> initialized <sil=0.000> to <sil=0.000> 1 <sil=1.000> ,COMMA  if <sil=0.000> a i <sil=0.000> is <sil=0.000> equal <sil=0.000> to <sil=0.000> b i <sil=0.000> this <sil=0.000> I can
do <sil=0.000> because <sil=0.000> here <sil=0.000> I am <sil=0.000> doing <sil=0.000> it <sil=0.000> element <sil=0.000> wise <sil=0.000> then <sil=0.000> flag <sil=0.000> equal <sil=0.000> to <sil=0.000> 1 else <sil=0.000> flag <sil=0.000> equal <sil=0.000> to <sil=0.000> 0 and <sil=0.000> I
can <sil=0.000> do <sil=0.000> exit <sil=0.000> and <sil=0.000> I come <sil=0.000> out <sil=0.000> of <sil=0.000> the <sil=0.000> loop <sil=0.000> straightway <sil=1.000> ,COMMA  I <sil=0.000> come <sil=0.000> out <sil=0.000> of <sil=0.000> the <sil=0.000> loop <sil=2.000> .PERIOD  Because <sil=0.000> it
does <sil=0.000> not <sil=0.000> really <sil=0.000> matter <sil=0.000> at <sil=0.000> which <sil=0.000> position <sil=0.000> the <sil=0.000> mismatch <sil=0.000> occurs <sil=1.000> ,COMMA  as <sil=0.000> soon <sil=0.000> as <sil=0.000> the <sil=0.000> mismatch
occurs <sil=0.000> I can <sil=0.000> say <sil=0.000> that <sil=0.000> flag <sil=0.000> is <sil=0.000> 0 and <sil=0.000> so <sil=0.000> I come <sil=0.000> out <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  when <sil=0.000> I was <sil=0.000> comparing <sil=0.000> this
whenever <sil=0.000> I find <sil=0.000> a mismatch <sil=0.000> the <sil=0.000> flag <sil=0.000> will <sil=0.000> become <sil=0.000> 0 and <sil=0.000> it <sil=0.000> will <sil=0.000> not <sil=0.000> be <sil=0.000> reset <sil=0.000> to <sil=0.000> 1 again
because <sil=0.000> of <sil=0.000> this <sil=0.000> match <sil=1.000> ,COMMA  because <sil=0.000> this <sil=0.000> part <sil=0.000> is <sil=0.000> not <sil=0.000> being <sil=0.000> computed <sil=0.000> I need <sil=0.000> not <sil=0.000> compute <sil=0.000> it <sil=2.000> .PERIOD  I
need <sil=0.000> not <sil=0.000> compute <sil=0.000> it <sil=0.000> because <sil=0.000> my <sil=0.000> objective <sil=0.000> was <sil=0.000> to <sil=0.000> see <sil=0.000> if <sil=0.000> the <sil=0.000> two <sil=0.000> arrays <sil=0.000> are <sil=0.000> equal <sil=0.000> and <sil=0.000> here
the <sil=0.000> violation <sil=0.000> has <sil=0.000> already <sil=0.000> occurred <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  they <sil=0.000> are <sil=0.000> not <sil=0.000> equal <sil=2.000> .PERIOD 
However <sil=0.000> so <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> one <sil=0.000> way <sil=0.000> you <sil=0.000> can <sil=0.000> try <sil=0.000> it <sil=0.000> with <sil=0.000> while <sil=0.000> loop <sil=0.000> also <sil=2.000> .PERIOD  You <sil=0.000> can <sil=0.000> try <sil=0.000> with <sil=0.000> while
to <sil=0.000> solve <sil=0.000> the <sil=0.000> same <sil=0.000> problem <sil=2.000> .PERIOD  Another <sil=0.000> point <sil=0.000> is <sil=0.000> here <sil=0.000> the <sil=0.000> time <sil=0.000> and <sil=0.000> again <sil=0.000> here <sil=1.000> ,COMMA  here <sil=1.000> ,COMMA 
everywhere <sil=0.000> I am <sil=0.000> setting <sil=0.000> the <sil=0.000> flag <sil=0.000> to <sil=0.000> 1 <sil=1.000> ,COMMA  I <sil=0.000> could <sil=0.000> have <sil=0.000> changed <sil=0.000> that <sil=0.000> also <sil=0.000> here <sil=0.000> if <sil=0.000> what <sil=0.000> did <sil=0.000> I

need <sil=0.000> to <sil=0.000> do <sil=0.000> I go <sil=0.000> on <sil=0.000> I haves <sil=0.000> in <sil=0.000> take <sil=0.000> flag <sil=0.000> to <sil=0.000> 1 and <sil=0.000> the <sil=0.000> condition <sil=0.000> I simply <sil=0.000> change <sil=0.000> I just
change <sil=0.000> the <sil=0.000> condition <sil=0.000> if <sil=0.000> a i <sil=0.000> is <sil=0.000> not <sil=0.000> equal <sil=0.000> to <sil=0.000> b i <sil=1.000> ,COMMA  then <sil=0.000> make <sil=0.000> flag <sil=0.000> 0 exit <sil=2.000> .PERIOD 

I <sil=0.000> could <sil=0.000> have <sil=0.000> done <sil=0.000> this <sil=2.000> .PERIOD  As <sil=0.000> long <sil=0.000> as <sil=0.000> this <sil=0.000> condition <sil=0.000> is <sil=0.000> not <sil=0.000> holding <sil=0.000> I am <sil=0.000> going <sil=0.000> on <sil=0.000> doing <sil=0.000> the
loop <sil=0.000> is <sil=0.000> it <sil=0.000> clear <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> go <sil=0.000> on <sil=0.000> doing <sil=0.000> the <sil=0.000> loop <sil=0.000> as <sil=0.000> long <sil=0.000> as <sil=0.000> there <sil=0.000> is <sil=0.000> no <sil=0.000> mismatch <sil=1.000> ,COMMA  this <sil=0.000> condition
means <sil=0.000> mismatch <sil=2.000> .PERIOD  As <sil=0.000> soon <sil=0.000> as <sil=0.000> there <sil=0.000> is <sil=0.000> a mismatch <sil=0.000> I will <sil=0.000> set <sil=0.000> the <sil=0.000> flag <sil=0.000> to <sil=0.000> 0 and <sil=0.000> exit <sil=2.000> .PERIOD  There <sil=0.000> is
another <sil=0.000> way <sil=0.000> of <sil=0.000> solving <sil=0.000> the <sil=0.000> problem <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you <sil=0.000> have <sil=0.000> to <sil=0.000> think <sil=0.000> logically <sil=0.000> what <sil=0.000> exactly <sil=0.000> you
need <sil=0.000> to <sil=0.000> do <sil=0.000> and <sil=0.000> what <sil=0.000> exactly <sil=0.000> you <sil=0.000> are <sil=0.000> writing <sil=0.000> what <sil=0.000> is <sil=0.000> the <sil=0.000> flow <sil=0.000> and <sil=0.000> what <sil=0.000> is <sil=0.000> happening <sil=0.000> with
the <sil=0.000> variables <sil=0.000> and <sil=0.000> I always <sil=0.000> suggest <sil=0.000> that <sil=0.000> you <sil=0.000> have <sil=0.000> small <sil=0.000> pictures <sil=0.000> of <sil=0.000> the <sil=0.000> different <sil=0.000> variables
and <sil=0.000> see <sil=0.000> how <sil=0.000> they <sil=0.000> are <sil=0.000> changing <sil=0.000> in <sil=0.000> the <sil=0.000> course <sil=0.000> of <sil=0.000> running <sil=0.000> the <sil=0.000> program <sil=2.000> .PERIOD 
Now <sil=0.000> so <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> seen <sil=0.000> a useful <sil=0.000> commercial <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  called <sil=0.000> toy <sil=0.000> commercial <sil=0.000> problem <sil=0.000> that <sil=0.000> how
I <sil=0.000> can <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> cost <sil=0.000> of <sil=0.000> a total <sil=0.000> sales <sil=0.000> or <sil=0.000> monthly <sil=0.000> sales <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  and <sil=0.000> here <sil=0.000> the <sil=0.000> number <sil=0.000> of <sil=0.000> items
sold <sil=0.000> per <sil=0.000> month <sil=0.000> are <sil=0.000> given <sil=0.000> then <sil=0.000> you <sil=0.000> can <sil=0.000> do <sil=0.000> it <sil=2.000> .PERIOD 
Well <sil=1.000> ,COMMA  next <sil=0.000> let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> a very <sil=0.000> important <sil=0.000> thing <sil=0.000> called <sil=0.000> searching <sil=2.000> .PERIOD  Searching <sil=0.000> is <sil=0.000> a
fundamental <sil=0.000> task <sil=0.000> in <sil=0.000> any <sil=0.000> and <sil=0.000> in <sil=0.000> fact <sil=1.000> ,COMMA  in <sil=0.000> many <sil=0.000> computations <sil=2.000> .PERIOD  In <sil=0.000> many <sil=0.000> computations <sil=0.000> we
need <sil=0.000> to <sil=0.000> search <sil=2.000> .PERIOD  What <sil=0.000> do <sil=0.000> we <sil=0.000> search <sil=0.228> ?QUESTIONMARK  There <sil=0.000> are <sil=0.000> different <sil=0.000> types <sil=0.000> of <sil=0.000> searches <sil=1.000> ,COMMA  but <sil=0.000> we <sil=0.000> will <sil=0.000> be
now <sil=0.000> talking <sil=0.000> about <sil=0.000> the <sil=0.000> simplest <sil=0.000> possible <sil=0.000> search <sil=0.000> that <sil=0.000> is <sil=0.000> we <sil=0.000> are <sil=0.000> trying <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> whether <sil=0.000> a
particular <sil=0.000> element <sil=0.000> is <sil=0.000> there <sil=0.000> in <sil=0.000> an <sil=0.000> array <sil=0.000> right <sil=2.000> .PERIOD 

Say <sil=1.000> ,COMMA  so <sil=0.000> the <sil=0.000> purpose <sil=0.000> is <sil=0.000> to <sil=0.000> check <sil=0.000> if <sil=0.000> a given <sil=0.000> element <sil=0.000> which <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> the <sil=0.000> key <sil=0.000> is <sil=0.000> there <sil=0.000> in
the <sil=0.000> array <sil=0.000> or <sil=0.000> not <sil=2.000> .PERIOD  We <sil=0.000> will <sil=0.000> first <sil=0.000> talk <sil=0.000> about <sil=0.000> the <sil=0.000> array <sil=0.000> is <sil=0.000> not <sil=0.000> arranged <sil=0.000> in <sil=0.000> any <sil=0.000> order <sil=0.000> and <sil=0.000> we
will <sil=0.000> do <sil=0.000> that <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  suppose <sil=0.000> I ask <sil=0.000> the <sil=0.000> question <sil=0.000> that <sil=0.000> is <sil=0.000> there <sil=0.000> any <sil=0.000> even <sil=0.000> number <sil=0.000> in <sil=0.000> the <sil=0.000> set <sil=0.000> of <sil=0.000> numbers <sil=0.000> given <sil=1.000> ,COMMA 
suppose <sil=0.000> there <sil=0.000> are <sil=0.000> some <sil=0.000> numbers <sil=0.000> given <sil=0.000> 5 7 <sil=0.000> 2 9 <sil=0.000> 1 8 <sil=0.000> 3 like <sil=0.000> that <sil=2.000> .PERIOD  I <sil=0.000> want <sil=0.000> to <sil=0.000> see <sil=0.000> and <sil=0.000> suppose
this <sil=0.000> is <sil=0.000> a huge <sil=0.000> this <sil=0.000> is <sil=0.000> a list <sil=0.000> of <sil=0.000> hundred <sil=0.000> numbers <sil=2.000> .PERIOD  I <sil=0.000> want <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> whether <sil=0.000> there <sil=0.000> is <sil=0.000> any
particular <sil=0.000> number <sil=0.000> forget <sil=0.000> about <sil=0.000> even <sil=0.000> number <sil=1.000> ,COMMA  for <sil=0.000> the <sil=0.000> time <sil=0.000> being <sil=0.000> for <sil=0.000> the <sil=0.000> timing <sil=0.000> let <sil=0.000> us

assume <sil=0.000> that <sil=0.000> I want <sil=0.000> to <sil=0.000> see <sil=0.000> whether <sil=0.000> in <sil=0.000> this <sil=0.000> list <sil=0.000> any <sil=0.000> 4 is <sil=0.000> there <sil=1.000> ,COMMA  is <sil=0.000> there <sil=0.000> any <sil=0.000> 4 in <sil=0.000> the <sil=0.000> list <sil=0.000> that <sil=0.000> is
the <sil=0.000> question <sil=0.000> that <sil=0.000> we <sil=0.000> are <sil=0.000> asking <sil=2.000> .PERIOD  The <sil=0.000> answer <sil=0.000> can <sil=0.000> be <sil=0.000> either <sil=0.000> yes <sil=0.000> or <sil=0.000> no <sil=2.000> .PERIOD 
If <sil=0.000> it <sil=0.000> is <sil=0.000> yes <sil=0.000> then <sil=0.000> the <sil=0.000> next <sil=0.000> question <sil=0.000> comes <sil=0.000> where <sil=0.000> in <sil=0.000> the <sil=0.000> list <sil=0.000> is <sil=0.000> it <sil=0.000> there <sil=1.000> ,COMMA  is <sil=0.000> it <sil=0.000> where <sil=0.000> means <sil=0.000> in
which <sil=0.000> position <sil=0.000> it <sil=0.000> is <sil=0.000> there <sil=2.000> .PERIOD  I <sil=0.000> may <sil=0.000> ask <sil=0.000> like <sil=0.000> to <sil=0.000> know <sil=0.000> the <sil=0.000> position <sil=0.000> or <sil=0.000> I may <sil=0.000> not <sil=0.000> like <sil=0.000> to <sil=0.000> know
the <sil=0.000> position <sil=0.000> I would <sil=0.000> be <sil=0.000> satisfied <sil=0.000> to <sil=0.000> know <sil=0.000> whether <sil=0.000> this <sil=0.000> list <sil=0.000> contains <sil=0.000> any <sil=0.000> 4 or <sil=0.000> not <sil=0.000> all <sil=0.000> right <sil=0.354> ;SEMICOLON 
so <sil=0.000> 5 7 <sil=0.000> 2 9 <sil=0.000> 1 8 <sil=0.000> 3 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  again <sil=0.000> 5 7 <sil=0.000> 2 9 <sil=0.000> 1 8 <sil=0.000> 3 and <sil=0.000> my <sil=0.000> key <sil=0.000> is <sil=0.000> 4 because <sil=0.000> I am <sil=0.000> interested <sil=0.000> in <sil=0.000> the <sil=0.000> existence <sil=0.000> of <sil=0.000> 4 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
instead <sil=0.000> of <sil=0.000> writing <sil=0.000> the <sil=0.000> c which <sil=0.000> you <sil=0.000> will <sil=0.000> be <sil=0.000> writing <sil=0.000> I will <sil=0.000> be <sil=0.000> discussing <sil=0.000> how <sil=0.000> to <sil=0.000> approach
this <sil=0.000> problem <sil=0.000> what <sil=0.000> would <sil=0.000> the <sil=0.000> pseudo <sil=0.000> code <sil=0.000> be <sil=0.000> and <sil=0.000> I am <sil=0.000> sure <sil=0.000> in <sil=0.000> the <sil=0.000> assignments <sil=0.000> in <sil=0.000> your
practice <sil=0.000> you <sil=0.000> can <sil=0.000> write <sil=0.000> the <sil=0.000> program <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> know <sil=0.000> I need <sil=0.000> to <sil=0.000> know <sil=0.000> beforehand <sil=0.000> this <sil=0.000> list <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
so <sil=0.000> I need <sil=0.000> to <sil=0.000> know <sil=0.000> a list <sil=0.000> which <sil=0.000> may <sil=0.000> be <sil=0.000> an <sil=0.000> integer <sil=0.000> list <sil=0.000> of <sil=0.000> might <sil=0.000> be <sil=0.000> here <sil=0.000> 7 numbers <sil=1.000> ,COMMA  I <sil=0.000> need
to <sil=0.000> know <sil=0.000> that <sil=0.000> also <sil=0.000> I need <sil=0.000> to <sil=0.000> know <sil=0.000> which <sil=0.000> key <sil=0.000> I am <sil=0.000> searching <sil=0.000> for <sil=2.000> .PERIOD 

Once <sil=0.000> I know <sil=0.000> these <sil=0.000> two <sil=1.000> ,COMMA  I <sil=0.000> know <sil=0.000> 5 7 <sil=0.000> 2 9 <sil=0.000> 1 8 <sil=0.000> 3 is <sil=0.000> my <sil=0.000> list <sil=0.000> and <sil=0.000> I know <sil=0.000> that <sil=0.000> 4 is <sil=0.000> my <sil=0.000> key <sil=0.000> then
how <sil=0.000> should <sil=0.000> I go <sil=0.000> about <sil=0.000> it <sil=2.000> .PERIOD 
I <sil=0.000> have <sil=0.000> got <sil=0.000> 4 in <sil=0.000> mind <sil=2.000> .PERIOD  I <sil=0.000> start <sil=0.000> to <sil=0.000> look <sil=0.000> at <sil=0.000> as <sil=0.000> if <sil=0.000> I am <sil=0.000> looking <sil=0.000> at <sil=0.000> through <sil=0.000> some <sil=0.000> means <sil=0.000> at
different <sil=0.000> positions <sil=0.000> I look <sil=0.000> at <sil=0.000> this <sil=0.000> position <sil=0.000> and <sil=0.000> check <sil=0.000> this <sil=0.000> element <sil=0.000> and <sil=0.000> compare <sil=0.000> this
element <sil=0.000> with <sil=0.000> the <sil=0.000> key <sil=0.000> and <sil=0.000> I ask <sil=0.000> are <sil=0.000> they <sil=0.000> equal <sil=2.000> .PERIOD  If <sil=0.000> the <sil=0.000> answer <sil=0.000> is <sil=0.000> yes <sil=1.000> ,COMMA  then <sil=0.000> obviously <sil=0.000> I can
say <sil=0.000> that <sil=0.000> 4 is <sil=0.000> in <sil=0.000> the <sil=0.000> list <sil=2.000> .PERIOD  But <sil=0.000> as <sil=0.000> you <sil=0.000> can <sil=0.000> see <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> true <sil=1.000> ,COMMA  so <sil=0.000> in <sil=0.000> case <sil=0.000> of <sil=0.000> no <sil=0.000> I will <sil=0.000> shift <sil=0.000> my
focus <sil=0.000> from <sil=0.000> here <sil=0.000> to <sil=0.000> here <sil=0.000> and <sil=0.000> I will <sil=0.000> now <sil=0.000> compare <sil=0.000> with <sil=0.000> 4 this <sil=0.000> element <sil=0.000> 7 <sil=1.000> ,COMMA  are <sil=0.000> they <sil=0.000> equal <sil=1.000> ,COMMA  no
then <sil=0.000> I will <sil=0.000> again <sil=0.000> shift <sil=0.000> the <sil=0.000> focus <sil=0.000> and <sil=0.000> I will <sil=0.000> go <sil=0.000> on <sil=0.000> shift <sil=0.000> the <sil=0.000> focus <sil=0.000> and <sil=0.000> I will <sil=0.000> compare <sil=0.000> with
this <sil=0.000> element <sil=0.000> with <sil=0.000> the <sil=0.000> key <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD  In <sil=0.000> that <sil=0.000> I will <sil=0.000> go <sil=0.000> on <sil=2.000> .PERIOD  How <sil=0.000> long <sil=0.000> shall <sil=0.000> I go <sil=0.000> on <sil=0.000> till <sil=0.000> the <sil=0.000> end
of <sil=0.000> the <sil=0.000> list <sil=2.000> .PERIOD 

If <sil=0.000> suppose <sil=0.000> here <sil=0.000> there <sil=0.000> was <sil=0.000> a 4 <sil=1.000> ,COMMA  instead <sil=0.000> of <sil=0.000> 1 there <sil=0.000> was <sil=0.000> a 4 <sil=0.000> here <sil=1.000> ,COMMA  suppose <sil=0.000> instead <sil=0.000> of <sil=0.000> 1 there
was <sil=0.000> a 4 <sil=0.000> here <sil=2.000> .PERIOD  Then <sil=0.000> when <sil=0.000> my <sil=0.000> focus <sil=0.000> changes <sil=0.000> to <sil=0.000> this <sil=0.000> point <sil=0.000> and <sil=0.000> then <sil=0.000> again <sil=0.000> comes <sil=0.000> to <sil=0.000> this
point <sil=0.000> and <sil=0.000> then <sil=0.000> I find <sil=0.000> that <sil=0.000> this <sil=0.000> element <sil=0.000> is <sil=0.000> matching <sil=0.000> the <sil=0.000> key <sil=0.000> value <sil=1.000> ,COMMA  then <sil=0.000> I can <sil=0.000> exit <sil=0.000> and <sil=0.000> say
yes <sil=1.000> ,COMMA  4 <sil=0.000> is <sil=0.000> there <sil=0.000> in <sil=0.000> the <sil=0.000> list <sil=2.000> .PERIOD  Then <sil=0.000> if <sil=0.000> there <sil=0.000> is <sil=0.000> other <sil=0.000> question <sil=0.000> has <sil=0.000> to <sil=0.000> be <sil=0.000> answered <sil=0.000> that <sil=0.000> 4 is <sil=0.000> there <sil=1.000> ,COMMA 
but <sil=0.000> where <sil=0.000> is <sil=0.000> 4 <sil=1.000> ,COMMA  where <sil=0.000> is <sil=0.000> 4 <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> case <sil=0.000> what <sil=0.000> would <sil=0.000> be <sil=0.000> an <sil=0.000> answer <sil=0.000> be <sil=2.000> .PERIOD  Your <sil=0.000> answer <sil=0.000> would
be <sil=0.000> this <sil=0.000> position <sil=2.000> .PERIOD  And <sil=0.000> what <sil=0.000> is <sil=0.000> this <sil=0.000> position <sil=0.228> ?QUESTIONMARK  This <sil=0.000> position <sil=0.000> is <sil=0.000> nothing <sil=1.000> ,COMMA  but <sil=0.000> the <sil=0.000> current <sil=0.000> index
current <sil=0.000> value <sil=0.000> of <sil=0.000> the <sil=0.000> index <sil=2.000> .PERIOD  Here <sil=0.000> the <sil=0.000> index <sil=0.000> started <sil=0.000> this <sil=0.000> is <sil=0.000> my <sil=0.000> index <sil=0.000> which <sil=0.000> was <sil=0.000> shifting <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  now <sil=0.000> we <sil=0.000> can <sil=0.000> think <sil=0.000> of <sil=0.000> the <sil=0.000> algorithm <sil=0.000> I have <sil=0.000> got <sil=0.000> 5 7 <sil=0.000> 2 9 <sil=0.000> 1 8 <sil=0.000> 3 and <sil=0.000> my <sil=0.000> key <sil=0.000> is <sil=0.000> 4 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> will
be <sil=0.000> doing <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> a loop <sil=0.000> which <sil=0.000> is <sil=0.000> a list <sil=0.000> for <sil=0.000> i equals <sil=0.000> 0 <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  the <sil=0.000> focus <sil=0.000> or <sil=0.000> the
index <sil=0.000> i less <sil=0.000> than <sil=0.000> equal <sil=0.000> to <sil=0.000> 1 2 <sil=0.000> 3 4 <sil=0.000> 5 6 <sil=0.000> 7 6 <sil=1.000> ,COMMA  i <sil=0.000> plus <sil=0.000> plus <sil=1.000> ,COMMA  i <sil=0.000> plus <sil=0.000> plus <sil=2.000> .PERIOD  If <sil=0.000> least <sil=0.000> i <sil=1.000> ,COMMA  that <sil=0.000> means <sil=1.000> ,COMMA  the
ith <sil=0.000> element <sil=0.000> of <sil=0.000> the <sil=0.000> list <sil=0.000> is <sil=0.000> equal <sil=0.000> to <sil=0.000> the <sil=0.000> key <sil=0.000> then <sil=0.000> I can <sil=0.000> say <sil=0.000> found <sil=0.000> assigned <sil=0.000> 1 <sil=2.000> .PERIOD  And <sil=0.000> what <sil=0.000> is
found <sil=0.228> ?QUESTIONMARK  Found <sil=0.000> is <sil=0.000> some <sil=0.000> variable <sil=0.000> which <sil=0.000> I have <sil=0.000> initialized <sil=0.000> at <sil=0.000> this <sil=0.000> point <sil=0.000> initially <sil=0.000> nothing <sil=0.000> is
found <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> found <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  found <sil=0.000> is <sil=0.000> 0 initially <sil=0.000> I have <sil=0.000> not <sil=0.000> found <sil=0.000> the <sil=0.000> key <sil=0.000> here <sil=0.000> I am
comparing <sil=0.000> as <sil=0.000> soon <sil=0.000> as <sil=0.000> I compare <sil=0.000> I put <sil=0.000> found <sil=0.000> equal <sil=0.000> to <sil=0.000> 1 and <sil=0.000> then <sil=0.000> I can <sil=0.000> exit <sil=0.000> or <sil=0.000> this
automatically <sil=0.000> this <sil=0.000> loop <sil=0.000> will <sil=0.000> go <sil=0.000> on <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  if <sil=0.000> I do <sil=0.000> it <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=0.000> what <sil=0.000> is <sil=0.000> the <sil=0.000> problem <sil=0.228> ?QUESTIONMARK  Suppose <sil=0.000> my <sil=0.000> key <sil=0.000> was <sil=1.000> ,COMMA  suppose <sil=0.000> my <sil=0.000> key
was <sil=0.000> 1 then <sil=0.000> it <sil=0.000> goes <sil=0.000> on <sil=0.000> i 0 <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> never <sil=0.000> happening <sil=0.000> found <sil=0.000> is <sil=0.000> still <sil=0.000> 0 <sil=1.000> ,COMMA  it <sil=0.000> goes <sil=0.000> on <sil=0.000> it <sil=0.000> comes <sil=0.000> to
here <sil=0.000> and <sil=0.000> I count <sil=0.000> come <sil=0.000> to <sil=0.000> found <sil=0.000> equal <sil=0.000> to <sil=0.000> 1 and <sil=0.000> then <sil=0.000> I can <sil=0.000> say <sil=0.000> if <sil=0.000> found <sil=0.000> equal <sil=0.000> to <sil=0.000> 1 <sil=1.000> ,COMMA  I <sil=0.000> can
printf <sil=1.000> ,COMMA  printf <sil=0.000> key <sil=0.000> found <sil=0.000> at <sil=0.000> position <sil=0.000> percentage <sil=0.000> d i <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  at <sil=0.000> that <sil=0.000> point <sil=0.000> I can <sil=0.000> also <sil=0.000> print <sil=0.000> that <sil=0.000> it
has <sil=0.000> been <sil=0.000> found <sil=0.000> here <sil=0.000> right <sil=2.000> .PERIOD  In <sil=0.000> the <sil=0.000> worst <sil=0.000> case <sil=0.000> what <sil=0.000> can <sil=0.000> happen <sil=0.228> ?QUESTIONMARK  Found <sil=0.000> will <sil=0.000> remain <sil=0.000> 0 <sil=1.000> ,COMMA 
found <sil=0.000> will <sil=0.000> remain <sil=0.000> 0 and <sil=0.000> I will <sil=0.000> come <sil=0.000> to <sil=0.000> the <sil=0.000> end <sil=0.000> of <sil=0.000> this <sil=0.000> point <sil=0.000> when <sil=0.000> I come <sil=0.000> here <sil=0.000> I can
check <sil=0.000> if <sil=0.000> found <sil=0.000> is <sil=0.000> 0 <sil=1.000> ,COMMA  printf <sil=0.000> key <sil=0.000> not <sil=0.000> found <sil=0.354> ;SEMICOLON  if <sil=0.000> I do <sil=0.000> not <sil=0.000> find <sil=0.000> it <sil=2.000> .PERIOD  There <sil=0.000> can <sil=0.000> be <sil=0.000> different <sil=0.000> flavors
of <sil=0.000> the <sil=0.000> same <sil=0.000> problem <sil=2.000> .PERIOD 

The <sil=0.000> other <sil=0.000> flavor <sil=0.000> could <sil=0.000> be <sil=0.000> that <sil=0.000> suppose <sil=0.000> this <sil=0.000> element <sil=0.000> 1 is <sil=0.000> there <sil=0.000> at <sil=0.000> multiple <sil=0.000> places <sil=0.000> suppose
it <sil=0.000> is <sil=0.000> also <sil=0.000> here <sil=2.000> .PERIOD  Then <sil=0.000> what <sil=0.000> will <sil=0.000> this <sil=0.000> program <sil=0.000> result <sil=0.000> in <sil=0.228> ?QUESTIONMARK  What <sil=0.000> would <sil=0.000> be <sil=0.000> its <sil=0.000> output <sil=0.228> ?QUESTIONMARK  I <sil=0.000> will <sil=0.000> go
on <sil=0.000> checking <sil=0.000> here <sil=0.000> I will <sil=0.000> check <sil=0.000> the <sil=0.000> for <sil=0.000> loop <sil=0.000> is <sil=0.000> extending <sil=0.000> up <sil=0.000> to <sil=0.000> which <sil=0.000> part <sil=0.354> ;SEMICOLON  the <sil=0.000> for <sil=0.000> loop <sil=0.000> is

extending <sil=0.000> up <sil=0.000> to <sil=0.000> this <sil=1.000> ,COMMA  this <sil=0.000> position <sil=0.000> and <sil=0.000> this <sil=0.000> is <sil=0.000> separate <sil=0.000> I should <sil=0.000> not <sil=0.000> have <sil=0.000> I should <sil=0.000> have
written <sil=0.000> it <sil=0.000> on <sil=0.000> the <sil=0.000> on <sil=0.000> this <sil=0.000> side <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> go <sil=0.000> on <sil=0.000> checking <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  key <sil=0.000> is <sil=0.000> found <sil=0.000> at <sil=0.000> position <sil=0.000> number <sil=0.000> 0 1 <sil=0.000> 2 3 <sil=0.000> 4 <sil=1.000> ,COMMA  key <sil=0.000> is <sil=0.000> found <sil=0.000> at
position <sil=0.000> 4 <sil=2.000> .PERIOD  The <sil=0.000> list <sil=0.000> is <sil=0.000> not <sil=0.000> exhausted <sil=0.000> ultimately <sil=0.000> it <sil=0.000> will <sil=0.000> come <sil=0.000> to <sil=0.000> this <sil=0.000> point <sil=0.000> and <sil=0.000> when <sil=0.000> it <sil=0.000> and
again <sil=0.000> it <sil=0.000> will <sil=0.000> say <sil=0.000> the <sil=0.000> key <sil=0.000> is <sil=0.000> found <sil=0.000> at <sil=0.000> position <sil=0.000> 6 <sil=1.000> ,COMMA  twice <sil=0.000> it <sil=0.000> will <sil=0.000> it <sil=0.000> is <sil=0.000> found <sil=0.000> it <sil=0.000> will <sil=0.000> be <sil=0.000> told <sil=0.000> like
that <sil=0.000> keys <sil=0.000> it <sil=0.000> will <sil=0.000> print <sil=0.000> twice <sil=2.000> .PERIOD  If <sil=0.000> at <sil=0.000> the <sil=0.000> end <sil=0.000> it <sil=0.000> comes <sil=0.000> and <sil=0.000> still <sil=0.000> the <sil=0.000> key <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> the
variable <sil=0.000> found <sil=0.000> is <sil=0.000> 0 then <sil=0.000> it <sil=0.000> will <sil=0.000> say <sil=0.000> print <sil=0.000> is <sil=0.000> not <sil=0.000> found <sil=2.000> .PERIOD 

I <sil=0.000> could <sil=0.000> have <sil=0.000> also <sil=0.000> say <sil=0.000> the <sil=0.000> same <sil=0.000> thing <sil=0.000> same <sil=0.000> problem <sil=0.000> I do <sil=1.000> ,COMMA  say <sil=0.000> suppose <sil=0.000> I have <sil=0.000> got <sil=0.000> a list <sil=0.000> 5 7
9 <sil=0.000> 2 1 <sil=0.000> 3 1 <sil=0.000> the <sil=0.000> question <sil=0.000> is <sil=0.000> how <sil=0.000> many <sil=0.000> ones <sil=0.000> are <sil=0.000> there <sil=2.000> .PERIOD  The <sil=0.000> same <sil=0.000> algorithm <sil=0.000> will <sil=0.000> do <sil=1.000> ,COMMA  the <sil=0.000> same
algorithm <sil=0.000> will <sil=0.000> work <sil=0.000> right <sil=2.000> .PERIOD  What <sil=0.000> is <sil=0.000> the <sil=0.000> same <sil=0.000> the <sil=0.000> algorithm <sil=0.228> ?QUESTIONMARK  The <sil=0.000> algorithm <sil=0.000> is <sil=0.000> I start <sil=0.000> from
one <sil=0.000> point <sil=0.000> from <sil=0.000> this <sil=0.000> beginning <sil=0.000> I let <sil=0.000> me <sil=0.000> draw <sil=0.000> it <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=0.000> if <sil=0.000> this <sil=0.000> be <sil=0.000> an <sil=0.000> array <sil=0.000> where <sil=0.000> all <sil=0.000> my
elements <sil=0.000> are <sil=0.000> there <sil=1.000> ,COMMA  5 <sil=0.000> 7 9 <sil=0.000> 2 1 <sil=0.000> 3 1 <sil=0.000> I start <sil=0.000> from <sil=0.000> the <sil=0.000> beginning <sil=0.000> i equals <sil=0.000> 0 and <sil=0.000> for <sil=0.000> every
element <sil=0.000> I compare <sil=0.000> with <sil=0.000> the <sil=0.000> key <sil=0.000> and <sil=0.000> go <sil=0.000> on <sil=0.000> till <sil=0.000> the <sil=0.000> end <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  if <sil=0.000> I want <sil=0.000> to <sil=0.000> do <sil=0.000> this <sil=0.000> what <sil=0.000> is <sil=0.000> the <sil=0.000> additional <sil=0.000> variable <sil=0.000> that <sil=0.000> I will <sil=0.000> require <sil=0.228> ?QUESTIONMARK  I <sil=0.000> will <sil=0.000> require
another <sil=0.000> variable <sil=0.000> count <sil=0.000> which <sil=0.000> is <sil=0.000> initially <sil=0.000> 0 other <sil=0.000> than <sil=0.000> found <sil=0.000> which <sil=0.000> is <sil=0.000> also <sil=0.000> false <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
whenever <sil=0.000> I find <sil=0.000> a 1 <sil=0.000> and <sil=0.000> my <sil=0.000> key <sil=0.000> is <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  whenever <sil=0.000> I find <sil=0.000> a 1 <sil=0.000> I will <sil=0.000> say <sil=0.000> found <sil=0.000> is <sil=0.000> equal <sil=0.000> to
1 <sil=0.000> and <sil=0.000> also <sil=0.000> I will <sil=0.000> do <sil=0.000> count <sil=0.000> plus <sil=0.000> plus <sil=0.000> and <sil=0.000> I will <sil=0.000> continue <sil=2.000> .PERIOD  Here <sil=0.000> I come <sil=0.000> and <sil=0.000> I will <sil=0.000> find <sil=0.000> I will
have <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> count <sil=0.000> to <sil=0.000> be <sil=0.000> 2 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> also <sil=1.000> ,COMMA  so <sil=0.000> I can <sil=0.000> say <sil=0.000> that <sil=0.000> here <sil=0.000> I could <sil=0.000> print <sil=0.000> where

found <sil=0.000> is <sil=0.000> becoming <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> also <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> say <sil=0.000> at <sil=0.000> which <sil=0.000> position <sil=0.000> it <sil=0.000> is <sil=0.000> a found <sil=0.000> and <sil=0.000> how
many <sil=0.000> times <sil=0.000> it <sil=0.000> is <sil=0.000> found <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  it <sil=0.000> can <sil=0.000> another <sil=0.000> flavor <sil=0.000> could <sil=0.000> be <sil=0.000> that <sil=0.000> I have <sil=0.000> got <sil=0.000> this <sil=0.000> say <sil=0.000> this <sil=0.000> array <sil=0.354> ;SEMICOLON  I <sil=0.000> have <sil=0.000> got <sil=0.000> this
array <sil=0.000> and <sil=0.000> some <sil=0.000> array <sil=0.000> 6 3 <sil=0.000> 2 9 <sil=0.000> 1 5 <sil=0.000> and <sil=0.000> whenever <sil=0.000> I have <sil=0.000> been <sil=0.000> given <sil=0.000> a key <sil=0.000> say <sil=0.000> the <sil=0.000> key <sil=0.000> is <sil=0.000> 2 <sil=1.000> ,COMMA 
as <sil=0.000> soon <sil=0.000> as <sil=0.000> I find <sil=0.000> 2 that <sil=0.000> is <sil=0.000> enough <sil=0.000> for <sil=0.000> me <sil=2.000> .PERIOD  I <sil=0.000> just <sil=0.000> want <sil=0.000> to <sil=0.000> know <sil=0.000> whether <sil=0.000> 2 is <sil=0.000> there <sil=0.000> in <sil=0.000> the
list <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> not <sil=0.000> interested <sil=0.000> to <sil=0.000> know <sil=0.000> how <sil=0.000> many <sil=0.000> times <sil=0.000> it <sil=0.000> is <sil=0.000> there <sil=0.000> or <sil=0.000> in <sil=0.000> which <sil=0.000> position <sil=0.000> it <sil=0.000> is <sil=0.000> there
or <sil=0.000> at <sil=0.000> best <sil=0.000> I may <sil=0.000> like <sil=0.000> to <sil=0.000> know <sil=0.000> at <sil=0.000> which <sil=0.000> position <sil=0.000> I you <sil=0.000> found <sil=0.000> it <sil=0.000> first <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> I can <sil=0.000> do <sil=1.000> ,COMMA  I
will <sil=0.000> go <sil=0.000> on <sil=0.000> searching <sil=0.000> like <sil=0.000> this <sil=0.000> and <sil=0.000> whenever <sil=0.000> you <sil=0.000> find <sil=0.000> 2 then <sil=0.000> you <sil=0.000> print <sil=0.000> that <sil=0.000> I have <sil=0.000> found <sil=0.000> 2
here <sil=0.000> and <sil=0.000> exit <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  what <sil=0.000> will <sil=0.000> you <sil=0.000> do <sil=0.228> ?QUESTIONMARK  The <sil=0.000> loop <sil=0.000> will <sil=0.000> be <sil=1.000> ,COMMA  the <sil=0.000> loop <sil=0.000> inside <sil=0.000> the <sil=0.000> loop <sil=0.000> you <sil=0.000> will <sil=0.000> have <sil=0.000> you <sil=0.000> can <sil=0.000> do
it <sil=0.000> like <sil=0.000> this <sil=0.000> that <sil=0.000> if <sil=0.000> a i <sil=0.000> or <sil=0.000> list <sil=0.000> i <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> I was <sil=0.000> writing <sil=0.000> list <sil=0.000> i is <sil=0.000> not <sil=0.000> equal <sil=0.000> to <sil=0.000> key <sil=0.000> all <sil=0.000> right <sil=0.000> for <sil=0.000> you
could <sil=0.000> have <sil=0.000> done <sil=0.000> it <sil=0.000> by <sil=0.000> while <sil=0.000> also <sil=0.000> n minus <sil=0.000> 1 i <sil=0.000> plus <sil=0.000> plus <sil=0.000> you <sil=0.000> go <sil=0.000> on <sil=0.000> doing <sil=0.000> this <sil=2.000> .PERIOD  If <sil=0.000> list <sil=0.000> i is <sil=0.000> not
is <sil=0.000> sorry <sil=0.000> is <sil=0.000> if <sil=0.000> it <sil=0.000> is <sil=0.000> equal <sil=0.000> to <sil=0.000> the <sil=0.000> key <sil=0.000> what <sil=0.000> I have <sil=0.000> done <sil=0.000> is <sil=0.000> equal <sil=0.000> to <sil=0.000> key <sil=0.000> say <sil=0.000> found <sil=0.000> equal <sil=0.000> to <sil=0.000> 1
and <sil=0.000> printf <sil=0.000> the <sil=0.000> position <sil=0.000> and <sil=0.000> exit <sil=0.000> and <sil=0.000> you <sil=0.000> need <sil=0.000> not <sil=0.000> go <sil=0.000> through <sil=0.000> the <sil=0.000> entire <sil=0.000> loop <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  there
are <sil=1.000> ,COMMA  so <sil=0.000> that <sil=0.000> is <sil=0.000> this <sil=0.000> sort <sil=0.000> of <sil=0.000> search <sil=0.000> which <sil=0.000> I am <sil=0.000> doing <sil=0.000> in <sil=0.000> a linear <sil=0.000> way <sil=0.000> from <sil=0.000> one <sil=0.000> side <sil=0.000> to <sil=0.000> the
other <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> linear <sil=0.000> search <sil=2.000> .PERIOD  It <sil=0.000> is <sil=0.000> the <sil=0.000> simple <sil=1.000> ,COMMA  very <sil=0.000> simple <sil=0.000> search <sil=0.000> for <sil=0.000> a particular
element <sil=2.000> .PERIOD  We <sil=0.000> will <sil=0.000> see <sil=0.000> a little <sil=0.000> bit <sil=0.000> more <sil=0.000> on <sil=0.000> this <sil=0.000> in <sil=0.000> the <sil=0.000> next <sil=0.000> lecture <sil=2.000> .PERIOD 

We <sil=0.000> were <sil=0.000> discussing <sil=0.000> about <sil=0.000> strings <sil=0.000> and <sil=0.000> in <sil=0.000> today s <sil=0.000> discussion <sil=1.000> ,COMMA  let <sil=0.000> me <sil=0.000> recapitulate <sil=0.000> what <sil=0.000> we
or <sil=0.000> the <sil=0.000> last <sil=0.000> part <sil=0.000> of <sil=0.000> what <sil=0.000> we <sil=0.000> discussed <sil=0.000> in <sil=0.000> the <sil=0.000> earlier <sil=0.000> lecture <sil=2.000> .PERIOD 

How <sil=0.000> can <sil=0.000> we <sil=0.000> read <sil=0.000> words <sil=0.000> from <sil=0.000> this <sil=0.000> from <sil=0.000> an <sil=0.000> input <sil=0.000> say <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  there <sil=0.000> we <sil=0.000> had <sil=0.000> introduced <sil=1.000> ,COMMA  this
percentage <sil=0.000> is <sil=0.000> format <sil=0.000> with <sil=0.000> that <sil=1.000> ,COMMA  with <sil=0.000> percentage <sil=0.000> is <sil=0.000> if <sil=0.000> we <sil=0.000> read <sil=0.000> a name <sil=1.000> ,COMMA  then <sil=0.000> it <sil=0.000> has <sil=0.000> to <sil=0.000> be
noted <sil=0.000> that <sil=0.000> the <sil=0.000> ampersand <sil=0.000> is <sil=0.000> not <sil=0.000> needed <sil=0.000> in <sil=0.000> this <sil=0.000> case <sil=0.000> right <sil=0.000> the <sil=0.000> ampersand <sil=0.000> is <sil=0.000> not <sil=0.000> needed
when <sil=0.000> I am <sil=0.000> reading <sil=0.000> a string <sil=0.000> when <sil=0.000> I am <sil=0.000> reading <sil=0.000> a string <sil=0.000> I do <sil=0.000> not <sil=0.000> need <sil=0.000> that <sil=0.000> ampersand <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  the <sil=0.000> point <sil=0.000> to <sil=0.000> remember <sil=0.000> is <sil=0.000> that <sil=0.000> whenever <sil=0.000> I am <sil=0.000> reading <sil=0.000> this <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=0.000> the <sil=0.000> string <sil=0.000> will
be <sil=0.000> read <sil=0.000> until <sil=0.000> there <sil=0.000> is <sil=0.000> some <sil=0.000> blank <sil=0.000> white <sil=0.000> space <sil=0.000> this <sil=0.000> is <sil=0.000> also <sil=0.000> called <sil=0.000> as <sil=0.000> white <sil=0.000> space <sil=0.000> or <sil=0.000> a tab
sign <sil=0.000> or <sil=0.000> a carriage <sil=0.000> return <sil=0.000> or <sil=0.000> enter <sil=0.000> is <sil=0.000> pressed <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> I type <sil=0.000> on <sil=0.000> a b <sil=0.000> c and <sil=0.000> then <sil=0.000> I type <sil=0.000> blank <sil=1.000> ,COMMA 
then <sil=0.000> this <sil=0.000> a b <sil=0.000> c will <sil=0.000> be <sil=0.000> taken <sil=0.000> as <sil=0.000> the <sil=0.000> word <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  when <sil=0.000> I perform <sil=0.000> scan <sil=0.000> if <sil=0.000> in <sil=0.000> this <sil=0.000> form <sil=0.000> in <sil=0.000> name
then <sil=0.000> a b <sil=0.000> c will <sil=0.000> go <sil=0.000> in <sil=0.000> the <sil=0.000> name <sil=0.000> alright <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> what <sil=0.000> we <sil=0.000> had <sil=0.000> seen <sil=0.000> last <sil=0.000> time <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> why <sil=0.000> this <sil=0.000> example <sil=0.000> was <sil=0.000> given <sil=0.000> if <sil=0.000> we <sil=0.000> type <sil=0.000> Rupak <sil=0.000> Biswas <sil=0.000> since <sil=0.000> after <sil=0.000> Rupak <sil=1.000> ,COMMA  there
is <sil=0.000> a blank <sil=0.000> we <sil=0.000> will <sil=0.000> stop <sil=0.000> at <sil=0.000> that <sil=0.000> point <sil=0.000> of <sil=0.000> time <sil=2.000> .PERIOD  The <sil=0.000> name <sil=0.000> will <sil=0.000> be <sil=0.000> assigned <sil=0.000> to <sil=0.000> Rupak <sil=0.000> ok
name <sil=0.000> will <sil=0.000> be <sil=0.000> assigned <sil=0.000> to <sil=0.000> the <sil=0.000> string <sil=0.000> Rupak <sil=0.000> name <sil=0.000> will <sil=0.000> be <sil=0.000> assign <sil=0.000> the <sil=0.000> string <sil=0.000> Rupak <sil=2.000> .PERIOD 

On <sil=0.000> the <sil=0.000> other <sil=0.000> hand <sil=0.000> when <sil=0.000> we <sil=0.000> read <sil=0.000> a line <sil=0.000> of <sil=0.000> text <sil=0.000> if <sil=0.000> I suppose <sil=0.000> I want <sil=0.000> to <sil=0.000> read <sil=0.000> say <sil=0.000> this <sil=0.000> Rupak
Biswas <sil=1.000> ,COMMA  I <sil=0.000> want <sil=0.000> to <sil=0.000> read <sil=0.000> this <sil=0.000> blank <sil=0.000> also <sil=0.000> this <sil=0.000> entire <sil=0.000> thing <sil=0.000> the <sil=0.000> entire <sil=0.000> sentence <sil=1.000> ,COMMA  I <sil=0.000> want <sil=0.000> to <sil=0.000> read
a <sil=0.000> quick <sil=0.000> brown <sil=0.000> fox <sil=0.000> I want <sil=0.000> to <sil=0.000> read <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> want <sil=0.000> to <sil=0.000> read <sil=0.000> this <sil=0.000> characters <sil=0.000> as <sil=0.000> well <sil=0.000> as <sil=0.000> this <sil=0.000> blank <sil=0.000> space <sil=0.000> is <sil=0.000> everything <sil=0.000> then <sil=0.000> what <sil=0.000> will
be <sil=0.000> my <sil=0.000> delimiter <sil=0.228> ?QUESTIONMARK  My <sil=0.000> delimiter <sil=0.000> will <sil=0.000> be <sil=0.000> the <sil=0.000> carriage <sil=0.000> return <sil=0.000> the <sil=0.000> return <sil=0.000> carriage <sil=0.000> return <sil=0.000> or
that <sil=0.000> is <sil=0.000> often <sil=0.000> designated <sil=0.000> as <sil=0.000> backslash <sil=0.000> n <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  till <sil=0.000> I get <sil=0.000> a backslash <sil=0.000> n <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> go <sil=0.000> on <sil=0.000> reading
this <sil=0.000> that <sil=0.000> is <sil=0.000> how <sil=0.000> I want <sil=0.000> I can <sil=0.000> read <sil=0.000> a line <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  in <sil=0.000> order <sil=0.000> to <sil=0.000> do <sil=0.000> that <sil=0.000> we <sil=0.000> can <sil=0.000> use <sil=0.000> the <sil=0.000> gate <sil=0.000> care <sil=0.000> function <sil=0.000> for <sil=0.000> the <sil=0.000> purpose <sil=0.000> by <sil=0.000> gate <sil=0.000> care
function <sil=0.000> we <sil=0.000> will <sil=0.000> be <sil=0.000> getting <sil=0.000> the <sil=0.000> characters <sil=0.000> one <sil=0.000> after <sil=0.000> another <sil=1.000> ,COMMA  and <sil=0.000> I will <sil=0.000> go <sil=0.000> on <sil=0.000> getting <sil=0.000> the
functions <sil=0.000> till <sil=0.000> the <sil=0.000> I mean <sil=0.000> I will <sil=0.000> be <sil=0.000> going <sil=0.000> on <sil=0.000> getting <sil=0.000> the <sil=0.000> characters <sil=1.000> ,COMMA  till <sil=0.000> I come <sil=0.000> to <sil=0.000> a
character <sil=0.000> that <sil=0.000> is <sil=0.000> carriage <sil=0.000> return <sil=0.000> designating <sil=0.000> that <sil=0.000> there <sil=0.000> is <sil=0.000> an <sil=0.000> that <sil=0.000> is <sil=0.000> an <sil=0.000> end <sil=0.000> of <sil=0.000> the <sil=0.000> line <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  for <sil=0.000> example <sil=1.000> ,COMMA  here <sil=0.000> a line <sil=0.000> has <sil=0.000> been <sil=0.000> defined <sil=0.000> to <sil=0.000> be <sil=0.000> of <sil=0.000> maximum <sil=0.000> length <sil=0.000> 81 <sil=1.000> ,COMMA  typically <sil=0.000> as <sil=0.000> I
said <sil=0.000> a line <sil=0.000> consist <sil=0.000> of <sil=0.000> 80 <sil=0.000> characters <sil=0.000> and <sil=0.000> you <sil=0.000> must <sil=0.000> be <sil=0.000> understanding <sil=0.000> now <sil=0.000> realizing <sil=0.000> now
that <sil=0.000> why <sil=0.000> I put <sil=0.000> 81 <sil=1.000> ,COMMA  the <sil=0.000> reason <sil=0.000> is <sil=0.000> here <sil=0.000> I need <sil=0.000> a space <sil=0.000> for <sil=0.000> backslash <sil=0.000> 0 <sil=2.000> .PERIOD  And <sil=0.000> I put <sil=0.000> c to <sil=0.000> be <sil=0.000> 0 c
is <sil=0.000> the <sil=0.000> number <sil=0.000> of <sil=0.000> characters <sil=0.000> c is <sil=0.000> here <sil=0.000> designating <sil=0.000> the <sil=0.000> number <sil=0.000> of <sil=0.000> characters <sil=0.000> read <sil=1.000> ,COMMA  all <sil=0.000> right <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  here <sil=0.000> we <sil=0.000> are <sil=0.000> doing <sil=0.000> it <sil=0.000> through <sil=0.000> a do <sil=0.000> while <sil=0.000> statement <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> see <sil=0.000> that <sil=0.000> we <sil=0.000> can <sil=0.000> do <sil=0.000> a we
are <sil=0.000> doing <sil=0.000> it <sil=0.000> through <sil=0.000> a do <sil=0.000> while <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> reading <sil=0.000> one <sil=0.000> character <sil=0.000> here <sil=0.000> say <sil=0.000> x and <sil=0.000> that <sil=0.000> I am
reading <sil=0.000> it <sil=0.000> though <sil=0.000> to <sil=0.000> get <sil=0.000> char <sil=1.000> ,COMMA  and <sil=0.000> that <sil=0.000> character <sil=0.000> that <sil=0.000> has <sil=0.000> been <sil=0.000> read <sil=0.000> is <sil=0.000> coming <sil=0.000> to <sil=0.000> the
variable <sil=0.000> array <sil=0.000> line <sil=0.000> all <sil=0.000> right <sil=0.000> line <sil=0.000> c c <sil=0.000> was <sil=0.000> initially <sil=0.000> 0 <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  here <sil=0.000> I put <sil=0.000> x <sil=1.000> ,COMMA  then <sil=0.000> I go <sil=0.000> up <sil=0.000> then <sil=0.000> character <sil=0.000> I go <sil=0.000> on <sil=0.000> I read <sil=0.000> it <sil=0.000> and <sil=0.000> then <sil=0.000> found <sil=0.000> that <sil=0.000> their
character <sil=0.000> is <sil=0.000> not <sil=0.000> ampersand <sil=2.000> .PERIOD  I <sil=0.000> go <sil=0.000> back <sil=0.000> again <sil=0.000> and <sil=0.000> read <sil=0.000> another <sil=0.000> character <sil=0.000> say <sil=0.000> x y <sil=0.000> increase <sil=0.000> c <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  c <sil=0.000> is <sil=0.000> now <sil=0.000> pointing <sil=0.000> here <sil=1.000> ,COMMA  c <sil=0.000> is <sil=0.000> now <sil=0.000> pointing <sil=0.000> here <sil=0.000> and <sil=0.000> I again <sil=0.000> go <sil=0.000> back <sil=0.000> now <sil=0.000> suppose <sil=0.000> a
blank <sil=0.000> has <sil=0.000> been <sil=0.000> typed <sil=0.000> in <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> come <sil=0.000> here <sil=0.000> get <sil=0.000> char <sil=0.000> is <sil=0.000> blank <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> comes <sil=0.000> here <sil=0.000> and <sil=0.000> then <sil=0.000> c
is <sil=0.000> pointing <sil=0.000> to <sil=0.000> the <sil=0.000> next <sil=0.000> position <sil=0.000> here <sil=1.000> ,COMMA  and <sil=0.000> then <sil=0.000> I go <sil=0.000> again <sil=0.000> here <sil=0.000> and <sil=0.000> suppose <sil=0.000> I type <sil=0.000> in <sil=0.000> p <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
the <sil=0.000> c is <sil=0.000> now <sil=0.000> pointing <sil=0.000> here <sil=1.000> ,COMMA  and <sil=0.000> then <sil=0.000> after <sil=0.000> that <sil=0.000> I read <sil=0.000> the <sil=0.000> character <sil=0.000> and <sil=0.000> the <sil=0.000> character <sil=0.000> was
ampersand <sil=0.000> I mean <sil=0.000> the <sil=0.000> character <sil=0.000> was <sil=0.000> backslash <sil=0.000> n <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  the <sil=0.000> end <sil=0.000> of <sil=0.000> the <sil=0.000> character <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> put <sil=0.000> backslash <sil=0.000> n here <sil=1.000> ,COMMA  whatever <sil=0.000> it <sil=0.000> was <sil=0.000> there <sil=0.000> and <sil=0.000> c is <sil=0.000> pointing <sil=0.000> here <sil=2.000> .PERIOD  Now <sil=0.000> I have <sil=0.000> after
insertion <sil=0.000> of <sil=0.000> backslash <sil=0.000> n <sil=1.000> ,COMMA  I <sil=0.000> come <sil=0.000> and <sil=0.000> find <sil=0.000> here <sil=0.000> that <sil=0.000> well <sil=0.000> what <sil=0.000> I have <sil=0.000> entered <sil=0.000> is <sil=0.000> backslash
n <sil=2.000> .PERIOD  Now <sil=0.000> backslash <sil=0.000> n should <sil=0.000> not <sil=0.000> be <sil=0.000> there <sil=0.000> instead <sil=0.000> of <sil=0.000> that <sil=0.000> we <sil=0.000> should <sil=0.000> have <sil=0.000> backslash <sil=0.000> 0
therefore <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> come <sil=0.000> back <sil=0.000> I will <sil=0.000> decrement <sil=0.000> c by <sil=0.000> ones <sil=0.000> position <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> come <sil=0.000> here <sil=0.000> and
I <sil=0.000> will <sil=0.000> replace <sil=0.000> this <sil=0.000> with <sil=0.000> backslash <sil=0.000> 0 right <sil=0.000> here <sil=0.000> I will <sil=0.000> bring <sil=0.000> in <sil=0.000> backslash <sil=0.000> 0 will <sil=0.000> come <sil=0.000> here <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  the <sil=0.000> pattern <sil=0.000> that <sil=0.000> will <sil=0.000> be <sil=0.000> stored <sil=0.000> do <sil=0.000> will <sil=0.000> be <sil=0.000> x y <sil=0.000> blank <sil=0.000> p backslash <sil=0.000> 0 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> what <sil=0.000> this
thing <sil=0.000> will <sil=0.000> look <sil=0.000> like <sil=0.000> in <sil=0.000> that <sil=0.000> way <sil=0.000> I am <sil=0.000> reading <sil=0.000> a line <sil=0.000> that <sil=0.000> is <sil=0.000> how <sil=0.000> we <sil=0.000> are <sil=0.000> reading <sil=0.000> a line <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
we <sil=0.000> have <sil=0.000> seen <sil=0.000> that <sil=0.000> we <sil=0.000> can <sil=0.000> read <sil=0.000> characters <sil=0.000> as <sil=0.000> a character <sil=0.000> array <sil=2.000> .PERIOD 

Char <sil=0.000> some <sil=0.000> line <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=0.000> line <sil=0.000> 81 <sil=2.000> .PERIOD  Now <sil=0.000> this <sil=0.000> line <sil=0.000> I can <sil=0.000> read <sil=0.000> character <sil=0.000> by <sil=0.000> character <sil=0.000> or <sil=0.000> I
can <sil=0.000> type <sil=0.000> in <sil=0.000> line <sil=0.000> to <sil=0.000> be <sil=0.000> x y <sil=0.000> blank <sil=0.000> p that <sil=0.000> is <sil=0.000> also <sil=0.000> will <sil=0.000> do <sil=0.000> the <sil=0.000> same <sil=0.000> thing <sil=1.000> ,COMMA  otherwise <sil=1.000> ,COMMA  I <sil=0.000> could
have <sil=0.000> copied <sil=0.000> it <sil=0.000> character <sil=0.000> by <sil=0.000> character <sil=0.000> both <sil=0.000> of <sil=0.000> them <sil=0.000> are <sil=0.000> equivalent <sil=1.000> ,COMMA  all <sil=0.000> right <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> we <sil=0.000> have <sil=0.000> read <sil=0.000> the <sil=0.000> character <sil=0.000> until <sil=0.000> the <sil=0.000> char <sil=0.000> return <sil=0.000> or <sil=0.000> backslash <sil=0.000> n is <sil=0.000> encountered
and <sil=0.000> then <sil=0.000> we <sil=0.000> make <sil=0.000> it <sil=0.000> a valid <sil=0.000> string <sil=0.000> by <sil=0.000> replacing <sil=0.000> backslash <sil=0.000> n by <sil=0.000> backslash <sil=0.000> 0 <sil=2.000> .PERIOD 

An <sil=0.000> alternative <sil=0.000> approach <sil=0.000> of <sil=0.000> reading <sil=0.000> a line <sil=0.000> can <sil=0.000> be <sil=0.000> this <sil=0.000> that <sil=0.000> I just <sil=0.000> specify <sil=0.000> the <sil=0.000> format <sil=1.000> ,COMMA  here
till <sil=0.000> now <sil=0.000> what <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=0.000> is <sil=0.000> that <sil=0.000> our <sil=0.000> formats <sil=0.000> could <sil=0.000> be <sil=0.000> percentage <sil=0.000> s percentage <sil=0.000> d

percentage <sil=0.000> f like <sil=0.000> that <sil=2.000> .PERIOD  I <sil=0.000> can <sil=0.000> also <sil=0.000> specify <sil=0.000> my <sil=0.000> format <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=0.000> as <sil=0.000> you <sil=0.000> can <sil=0.000> see <sil=0.000> here <sil=1.000> ,COMMA  what
it <sil=0.000> means <sil=0.000> is <sil=0.000> anything <sil=0.000> I am <sil=0.000> sorry <sil=0.000> what <sil=0.000> happened <sil=0.354> ;SEMICOLON  anything <sil=0.000> that <sil=0.000> is <sil=0.000> a b <sil=0.000> c d <sil=0.000> or <sil=0.000> whatever <sil=0.000> that
this <sil=0.000> entire <sil=0.000> thing <sil=0.000> and <sil=0.000> here <sil=0.000> there <sil=0.000> is <sil=0.000> a blank <sil=1.000> ,COMMA  I <sil=0.000> do <sil=0.000> not <sil=0.000> know <sil=0.000> what <sil=0.000> is <sil=0.000> happening <sil=0.000> here <sil=1.000> ,COMMA  here
you <sil=0.000> can <sil=0.000> see <sil=0.000> there <sil=0.000> is <sil=0.000> a blank <sil=0.000> here <sil=2.000> .PERIOD 
So <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> allowed <sil=0.228> ?QUESTIONMARK  Anything <sil=0.000> including <sil=0.000> bank <sil=0.000> blank <sil=0.000> capital <sil=0.000> A to <sil=0.000> Z
everything <sil=0.000> is <sil=0.000> allowed <sil=0.000> as <sil=0.000> members <sil=0.000> of <sil=0.000> the <sil=0.000> variable <sil=0.000> line <sil=2.000> .PERIOD  Similarly <sil=0.000> here <sil=0.000> the <sil=0.000> specification <sil=0.000> is
that <sil=0.000> it <sil=0.000> can <sil=0.000> be <sil=0.000> char <sil=0.000> at <sil=0.000> this <sil=0.000> is <sil=0.000> a wild <sil=0.000> card <sil=0.000> it <sil=0.000> is <sil=0.000> called <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  we <sil=0.000> can <sil=0.000> put <sil=0.000> in <sil=0.000> anything
preceding <sil=0.000> backslash <sil=0.000> n <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> means <sil=0.000> it <sil=0.000> is <sil=0.000> a wild <sil=0.000> card <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  anything <sil=0.000> can <sil=0.000> come
here <sil=0.000> as <sil=0.000> a character <sil=1.000> ,COMMA  that <sil=0.000> can <sil=0.000> be <sil=0.000> a member <sil=0.000> of <sil=0.000> the <sil=0.000> variable <sil=0.000> line <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> also <sil=0.000> another <sil=0.000> way
of <sil=0.000> specifying <sil=0.000> it <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  these <sil=0.000> are <sil=0.000> specifics <sil=0.000> to <sil=0.000> the <sil=0.000> language <sil=0.000> c of <sil=0.000> course <sil=2.000> .PERIOD 

Now <sil=0.000> it <sil=0.000> is <sil=0.000> easier <sil=0.000> relatively <sil=0.000> simpler <sil=0.000> to <sil=0.000> display <sil=0.000> strings <sil=0.000> on <sil=0.000> the <sil=0.000> screen <sil=0.000> we <sil=0.000> can <sil=0.000> simply <sil=0.000> do <sil=0.000> a
string <sil=1.000> ,COMMA  we <sil=0.000> can <sil=0.000> display <sil=0.000> the <sil=0.000> string <sil=0.000> with <sil=0.000> percentage <sil=0.000> x s <sil=0.000> and <sil=0.000> followed <sil=0.000> by <sil=0.000> the <sil=0.000> string <sil=0.000> name <sil=0.000> that
is <sil=0.000> simpler <sil=0.000> now <sil=0.000> we <sil=0.000> come <sil=0.000> to <sil=0.000> a very <sil=0.000> important <sil=0.000> aspect <sil=0.000> how <sil=0.000> do <sil=0.000> we <sil=0.000> process <sil=0.000> character <sil=0.000> strings <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  for <sil=0.000> that <sil=0.000> we <sil=0.000> have <sil=0.000> got <sil=0.000> several <sil=0.000> c library <sil=0.000> functions <sil=0.000> we <sil=0.000> will <sil=0.000> soon <sil=0.000> come <sil=0.000> to <sil=0.000> functions <sil=0.000> and
we <sil=0.000> have <sil=0.000> already <sil=0.000> seen <sil=0.000> different <sil=0.000> types <sil=0.000> of <sil=0.000> functions <sil=0.000> like <sil=0.000> square <sil=0.000> root <sil=1.000> ,COMMA  maybe <sil=0.000> did <sil=0.000> you <sil=0.000> see <sil=0.000> and
we <sil=0.000> have <sil=0.000> seen <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=0.000> the <sil=0.000> standard <sil=0.000> functions <sil=0.000> like <sil=0.000> scan <sil=0.000> f <sil=1.000> ,COMMA  print <sil=0.000> f all <sil=0.000> those <sil=0.000> things <sil=2.000> .PERIOD 
Similarly <sil=0.000> we <sil=0.000> have <sil=0.000> got <sil=0.000> c libraries <sil=0.000> built <sil=0.000> in <sil=0.000> library <sil=0.000> functions <sil=1.000> ,COMMA  for <sil=0.000> character <sil=0.000> string
manipulation <sil=0.000> how <sil=0.000> are <sil=0.000> they <sil=0.000> looking <sil=0.000> like <sil=0.228> ?QUESTIONMARK  They <sil=0.000> are <sil=0.000> we <sil=0.000> have <sil=0.000> to <sil=0.000> in <sil=0.000> order <sil=0.000> to <sil=0.000> do <sil=0.000> that <sil=2.000> .PERIOD 

Say <sil=0.000> one <sil=0.000> is <sil=0.000> s t <sil=0.000> r c <sil=0.000> p y <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  string <sil=0.000> copy <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  if <sil=0.000> I have <sil=0.000> a string <sil=0.000> here <sil=0.000> say
string <sil=0.000> here <sil=0.000> is <sil=0.000> my <sil=0.000> sorry <sil=0.000> let <sil=0.000> me <sil=0.000> put <sil=0.000> a blank <sil=0.000> here <sil=1.000> ,COMMA  my <sil=0.000> space <sil=0.000> job <sil=2.000> .PERIOD  Suppose <sil=0.000> these <sil=0.000> are <sil=0.000> string <sil=0.000> A
and <sil=0.000> I want <sil=0.000> to <sil=0.000> copy <sil=0.000> it <sil=0.000> to <sil=0.000> another <sil=0.000> string <sil=0.000> B <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  B <sil=0.000> will <sil=0.000> also <sil=0.000> therefore <sil=1.000> ,COMMA  have <sil=0.000> my <sil=0.000> blank <sil=0.000> job <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> that <sil=0.000> can <sil=0.000> be <sil=0.000> done <sil=0.000> by <sil=0.000> string <sil=0.000> copy <sil=0.000> function <sil=0.000> s t <sil=0.000> r c <sil=0.000> p y <sil=0.000> how <sil=0.000> can <sil=0.000> that <sil=0.000> be <sil=0.000> done <sil=0.228> ?QUESTIONMARK  We
also <sil=0.000> have <sil=0.000> a similar <sil=0.000> thing <sil=0.000> like <sil=0.000> string <sil=0.000> length <sil=0.000> s t <sil=0.000> r l <sil=0.000> e n <sil=0.000> which <sil=0.000> means <sil=0.000> that <sil=0.000> I have <sil=0.000> got <sil=0.000> a string
say <sil=0.000> my <sil=0.000> job <sil=0.000> again <sil=1.000> ,COMMA  blank <sil=0.000> job <sil=0.000> and <sil=0.000> automatically <sil=0.000> there <sil=0.000> is <sil=0.000> a backslash <sil=0.000> 0 at <sil=0.000> the <sil=0.000> end <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  when <sil=0.000> I copy <sil=0.000> it <sil=1.000> ,COMMA  then <sil=0.000> this <sil=0.000> will <sil=0.000> also <sil=0.000> be <sil=0.000> with <sil=0.000> s t <sil=0.000> r c <sil=0.000> p y <sil=0.000> we <sil=0.000> will <sil=0.000> have <sil=0.000> my <sil=0.000> blank <sil=0.000> job
backslash <sil=0.000> n will <sil=0.000> come <sil=0.000> here <sil=0.000> sorry <sil=0.000> backslash <sil=0.000> 0 will <sil=0.000> come <sil=0.000> here <sil=1.000> ,COMMA  but <sil=0.000> s t <sil=0.000> r l <sil=0.000> e n <sil=0.000> means <sil=0.000> string
length <sil=0.000> I will <sil=0.000> count <sil=0.000> how <sil=0.000> many <sil=0.000> elements <sil=0.000> are <sil=0.000> there <sil=0.000> in <sil=0.000> the <sil=0.000> string <sil=0.354> ;SEMICOLON  can <sil=0.000> you <sil=0.000> tell <sil=0.000> me <sil=0.000> how <sil=0.000> many
elements <sil=0.000> are <sil=0.000> there <sil=0.000> in <sil=0.000> the <sil=0.000> string <sil=0.228> ?QUESTIONMARK  1 <sil=0.000> 2 3 <sil=0.000> blank <sil=0.000> is <sil=0.000> a valid <sil=0.000> character <sil=0.000> 1 <sil=1.000> ,COMMA  2 <sil=1.000> ,COMMA  3 <sil=0.000> 4 <sil=1.000> ,COMMA  5 <sil=1.000> ,COMMA  6 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the
string <sil=0.000> length <sil=0.000> will <sil=0.000> be <sil=0.000> returned <sil=0.000> that <sil=0.000> will <sil=0.000> returned <sil=0.000> is <sil=0.000> 6 <sil=1.000> ,COMMA  similarly <sil=0.000> we <sil=0.000> have <sil=0.000> another <sil=0.000> function
very <sil=0.000> popular <sil=0.000> function <sil=0.000> string <sil=0.000> comparison <sil=0.000> s t <sil=0.000> r c <sil=0.000> m p <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> two <sil=0.000> strings
my <sil=0.000> job <sil=0.000> and <sil=0.000> here <sil=0.000> my <sil=0.000> job <sil=1.000> ,COMMA  and <sil=0.000> I compared <sil=0.000> them <sil=0.000> if <sil=0.000> sorry <sil=0.000> if <sil=0.000> they <sil=0.000> are <sil=0.000> the <sil=0.000> same <sil=0.000> then <sil=0.000> I will
have <sil=0.000> a one <sil=0.000> ok <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> another <sil=0.000> function <sil=0.000> the <sil=0.000> fourth <sil=0.000> function <sil=0.000> is <sil=0.000> s t <sil=0.000> r c <sil=0.000> a t <sil=0.000> what <sil=0.000> is <sil=0.000> meant <sil=0.000> by
concatenation <sil=0.228> ?QUESTIONMARK  Concatenation <sil=0.000> s t <sil=0.000> r c <sil=0.000> a t <sil=0.000> is <sil=0.000> actually <sil=0.000> s t <sil=0.000> r c <sil=0.000> a t <sil=0.000> means <sil=0.000> string <sil=0.000> concatenation <sil=2.000> .PERIOD 

That <sil=0.000> means <sil=1.000> ,COMMA  if <sil=0.000> I have <sil=0.000> a string <sil=0.000> here <sil=0.000> say <sil=0.000> a b <sil=0.000> c ended <sil=0.000> with <sil=0.000> this <sil=1.000> ,COMMA  and <sil=0.000> there <sil=0.000> is <sil=0.000> another <sil=0.000> string
say <sil=0.000> p q <sil=0.000> r ended <sil=0.000> with <sil=0.000> this <sil=1.000> ,COMMA  when <sil=0.000> I concatenate <sil=0.000> it <sil=0.000> that <sil=0.000> these <sil=0.000> two <sil=0.000> strings <sil=0.000> what <sil=0.000> I get <sil=0.000> is <sil=0.000> a
joining <sil=0.000> of <sil=0.000> these <sil=0.000> two <sil=0.000> strings <sil=0.000> one <sil=0.000> after <sil=0.000> another <sil=2.000> .PERIOD  When <sil=0.000> I say <sil=0.000> that <sil=0.000> string <sil=0.000> b is <sil=0.000> concatenated
with <sil=0.000> a then <sil=0.000> my <sil=0.000> pattern <sil=0.000> will <sil=0.000> be <sil=0.000> a b <sil=0.000> c note <sil=0.000> that <sil=0.000> this <sil=0.000> backslash <sil=0.000> 0 will <sil=0.000> not <sil=0.000> come <sil=0.000> p q <sil=0.000> r and
backslash <sil=0.000> 0 <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> concatenation <sil=0.000> all <sil=0.000> right <sil=0.000> of <sil=0.000> two <sil=0.000> strings <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> being
given <sil=0.000> by <sil=0.000> a function <sil=0.000> s t <sil=0.000> r c <sil=0.000> a t <sil=2.000> .PERIOD 
Now <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  these <sil=0.000> are <sil=0.000> the <sil=0.000> very <sil=0.000> common <sil=0.000> functions <sil=0.000> for <sil=0.000> string <sil=0.000> operations <sil=2.000> .PERIOD  For <sil=0.000> our <sil=0.000> job <sil=0.000> if <sil=0.000> we
need <sil=0.000> some <sil=0.000> other <sil=0.000> functions <sil=0.000> we <sil=0.000> can <sil=0.000> always <sil=0.000> write <sil=0.000> functions <sil=0.000> which <sil=0.000> will <sil=0.000> learn <sil=0.000> in <sil=0.000> a couple <sil=0.000> of
lectures <sil=0.000> from <sil=0.000> now <sil=1.000> ,COMMA  but <sil=0.000> these <sil=0.000> are <sil=0.000> already <sil=0.000> available <sil=0.000> in <sil=0.000> the <sil=0.000> c library <sil=0.000> all <sil=0.000> right <sil=0.000> s t <sil=0.000> d i <sil=0.000> o dot <sil=0.000> h
and <sil=0.000> also <sil=0.000> when <sil=0.000> we <sil=0.000> use <sil=0.000> that <sil=0.000> square <sil=0.000> root <sil=0.000> function  <sil=2.000> .PERIOD 

And <sil=0.000> therefore <sil=1.000> ,COMMA  in <sil=0.000> order <sil=0.000> to <sil=0.000> do <sil=0.000> that <sil=0.000> we <sil=0.000> have <sil=0.000> to <sil=0.000> include <sil=0.000> st <sil=0.000> string <sil=0.000> dot <sil=0.000> h <sil=1.000> ,COMMA  if <sil=0.000> you <sil=0.000> recall <sil=0.000> we <sil=0.000> had
said <sil=0.000> that <sil=0.000> if <sil=0.000> you <sil=0.000> recall <sil=0.000> we <sil=0.000> can <sil=0.000> include <sil=0.000> always <sil=0.000> you <sil=0.000> do <sil=0.000> that <sil=0.000> hash <sil=0.000> include <sil=2.000> .PERIOD 

Earlier <sil=0.000> we <sil=0.000> had <sil=0.000> included <sil=0.000> math <sil=0.000> dot <sil=0.000> h <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  all <sil=0.000> the <sil=0.000> mathematic <sil=0.000> library <sil=0.000> of <sil=0.000> all <sil=0.000> the
mathematical <sil=0.000> functions <sil=0.000> math <sil=0.000> dot <sil=0.000> h when <sil=0.000> we <sil=0.000> use <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  s <sil=0.000> q r <sil=0.000> square <sil=0.000> root <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> this <sil=0.000> is <sil=0.000> a function <sil=0.000> that <sil=0.000> is <sil=0.000> already <sil=0.000> inbuilt <sil=1.000> ,COMMA  inbuilt <sil=0.000> in <sil=0.000> this <sil=0.000> math <sil=0.000> library <sil=0.000> similarly <sil=0.000> for
strings <sil=0.000> if <sil=0.000> I use <sil=0.000> this <sil=0.000> s t <sil=0.000> r c <sil=0.000> p y <sil=1.000> ,COMMA  s <sil=0.000> t r <sil=0.000> c a <sil=0.000> t <sil=1.000> ,COMMA  s <sil=0.000> t r <sil=0.000> c m <sil=1.000> ,COMMA  c <sil=0.000> m p <sil=0.000> compare <sil=1.000> ,COMMA  then <sil=0.000> I have <sil=0.000> to <sil=0.000> include
strings <sil=0.000> dot <sil=0.000> h in <sil=0.000> my <sil=0.000> function <sil=0.000> alright <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> are <sil=0.000> some <sil=0.000> examples <sil=2.000> .PERIOD 

Very <sil=0.000> much <sil=0.000> like <sil=0.000> a string <sil=0.000> assignment <sil=0.000> operator <sil=0.000> string <sil=0.000> copy <sil=0.000> just <sil=0.000> like <sil=0.000> an <sil=0.000> assignment <sil=1.000> ,COMMA  for
example <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> we <sil=0.000> are <sil=0.000> saying <sil=0.000> string <sil=0.000> copy <sil=0.000> string <sil=0.000> 1 string <sil=0.000> 2 <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  both <sil=0.000> string <sil=0.000> 2 will <sil=0.000> be <sil=0.000> copied <sil=0.000> in <sil=0.000> string <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  assigns <sil=0.000> the <sil=0.000> content <sil=0.000> of <sil=0.000> string <sil=0.000> 2 to <sil=0.000> string <sil=0.000> 1
assigns <sil=0.000> the <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> the <sil=0.000> source <sil=0.000> this <sil=0.000> is <sil=0.000> the <sil=0.000> destination <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> copied <sil=0.000> from <sil=0.000> here <sil=0.000> to <sil=0.000> here
say <sil=0.000> string <sil=0.000> copy <sil=0.000> city <sil=0.000> Calcutta <sil=0.000> what <sil=0.000> will <sil=0.000> happen <sil=0.000> here <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> trying <sil=0.000> to <sil=0.000> copy <sil=0.000> city
is <sil=0.000> a string <sil=0.000> that <sil=0.000> is <sil=0.000> already <sil=0.000> defined <sil=0.000> alright <sil=0.000> I have <sil=0.000> defined <sil=0.000> city <sil=0.000> and <sil=0.000> I am <sil=0.000> copying <sil=0.000> this <sil=0.000> string
now <sil=0.000> this <sil=0.000> is <sil=0.000> a string <sil=0.000> constant <sil=1.000> ,COMMA  this <sil=0.000> part <sil=0.000> is <sil=0.000> a string <sil=0.000> constant <sil=0.000> this <sil=0.000> is <sil=0.000> a string <sil=0.000> constant <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  what <sil=0.000> I am <sil=0.000> doing <sil=0.000> is <sil=0.000> I am <sil=0.000> I have <sil=0.000> got <sil=0.000> a variable <sil=0.000> city <sil=1.000> ,COMMA  variable <sil=0.000> of <sil=0.000> type <sil=0.000> string <sil=2.000> .PERIOD 

Now <sil=0.000> this <sil=0.000> how <sil=0.000> did <sil=0.000> you <sil=0.000> define <sil=0.000> it <sil=0.000> to <sil=0.000> be <sil=0.000> a type <sil=0.000> of <sil=0.000> type <sil=0.000> string <sil=0.000> it <sil=0.000> was <sil=0.000> char <sil=0.000> city <sil=0.000> say <sil=0.000> something
like <sil=0.000> this <sil=0.000> char <sil=0.000> city <sil=0.000> 20 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  20 <sil=0.000> characters <sil=0.000> can <sil=0.000> come <sil=0.000> there <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  when <sil=0.000> I write <sil=0.000> city <sil=0.000> s t <sil=0.000> r c <sil=0.000> copy <sil=0.000> city <sil=0.000> to <sil=0.000> Calcutta <sil=0.000> or <sil=0.000> right <sil=0.000> now <sil=0.000> we <sil=0.000> say <sil=0.000> Kolkata <sil=0.000> say <sil=0.000> we
do <sil=0.000> Kolkata <sil=2.000> .PERIOD  Then <sil=0.000> in <sil=0.000> this <sil=0.000> variable <sil=0.000> Kolkata <sil=0.000> will <sil=0.000> be <sil=0.000> loaded <sil=0.000> all <sil=0.000> right <sil=0.000> a followed <sil=0.000> by <sil=0.000> a
backslash <sil=0.000> 0 right <sil=2.000> .PERIOD  On <sil=0.000> the <sil=0.000> other <sil=0.000> hand <sil=0.000> suppose <sil=0.000> city <sil=0.000> is <sil=0.000> here <sil=0.000> and <sil=0.000> suppose <sil=0.000> another <sil=0.000> city
another <sil=0.000> string <sil=0.000> variable <sil=0.000> is <sil=0.000> there <sil=1.000> ,COMMA  which <sil=0.000> is <sil=0.000> maybe <sil=0.000> Mumbai <sil=0.000> and <sil=0.000> I copy <sil=0.000> string <sil=0.000> copy <sil=0.000> city <sil=0.000> my
city <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  what <sil=0.000> will <sil=0.000> happen <sil=0.000> this <sil=0.000> string <sil=1.000> ,COMMA  this <sil=0.000> string <sil=0.000> my <sil=0.000> city <sil=0.000> will <sil=0.000> come <sil=0.000> into <sil=0.000> this
variable <sil=0.000> city <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  this <sil=0.000> Kolkata <sil=0.000> will <sil=0.000> be <sil=0.000> overwritten <sil=0.000> and <sil=0.000> will <sil=0.000> be <sil=0.000> replaced <sil=0.000> by <sil=0.000> Mumbai <sil=2.000> .PERIOD  Now <sil=0.000> Kolkata <sil=0.000> is <sil=0.000> of
length <sil=0.000> 1 2 <sil=0.000> 3 4 <sil=0.000> 5 6 <sil=0.000> 7 and <sil=0.000> Mumbai <sil=0.000> is <sil=0.000> 1 2 <sil=0.000> 3 4 <sil=0.000> 5 6 <sil=0.000> in <sil=0.000> that <sil=0.000> case <sil=0.000> what <sil=0.000> will <sil=0.000> happen <sil=0.228> ?QUESTIONMARK  As <sil=0.000> I copy
this <sil=0.000> whole <sil=0.000> string <sil=0.000> over <sil=0.000> here <sil=0.000> then <sil=0.000> here <sil=0.000> Mumbai <sil=0.000> m will <sil=0.000> come <sil=0.000> u will <sil=0.000> come <sil=0.000> m b <sil=0.000> a i <sil=0.000> and <sil=0.000> this
backslash <sil=0.000> 0 will <sil=0.000> come <sil=0.000> here <sil=0.000> and <sil=0.000> so <sil=1.000> ,COMMA  the <sil=0.000> entire <sil=0.000> string <sil=0.000> will <sil=0.000> be <sil=0.000> kept <sil=0.000> here <sil=0.000> the <sil=0.000> last <sil=0.000> sorry <sil=0.000> up <sil=0.000> to
this <sil=0.000> and <sil=0.000> with <sil=0.000> a backslash <sil=0.000> 0 here <sil=1.000> ,COMMA  and <sil=0.000> the <sil=0.000> remaining <sil=0.000> part <sil=0.000> of <sil=0.000> unused <sil=0.000> part <sil=0.000> of <sil=0.000> Kolkata <sil=0.000> will <sil=0.000> be
lost <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  warning <sil=0.000> there <sil=0.000> is <sil=0.000> an <sil=0.000> warning <sil=0.000> here <sil=0.000> that <sil=0.000> is <sil=0.000> assignment <sil=0.000> operator <sil=0.000> does <sil=0.000> not <sil=0.000> work <sil=0.000> for
string <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> could <sil=0.000> not <sil=0.000> have <sil=0.000> done <sil=0.000> string <sil=0.000> 1 assign <sil=0.000> string <sil=0.000> 2 or <sil=0.000> as <sil=0.000> we <sil=0.000> are <sil=0.000> doing <sil=0.000> here <sil=0.000> city
assigned <sil=1.000> ,COMMA  my <sil=0.000> city <sil=0.000> that <sil=0.000> would <sil=0.000> not <sil=0.000> do <sil=0.000> that <sil=0.000> assignment <sil=0.000> operator <sil=0.000> will <sil=0.000> not <sil=0.000> work <sil=0.000> in <sil=0.000> the <sil=0.000> case <sil=0.000> of
strings <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  city <sil=0.000> assigned <sil=0.000> Calcutta <sil=0.000> is <sil=0.000> invalid <sil=2.000> .PERIOD 

String <sil=0.000> length <sil=0.000> s t <sil=0.000> r l <sil=0.000> e n <sil=0.000> this <sil=0.000> is <sil=0.000> you <sil=0.000> I will <sil=0.000> ask <sil=0.000> you <sil=0.000> when <sil=0.000> we <sil=0.000> teach <sil=0.000> you <sil=0.000> function <sil=1.000> ,COMMA  to <sil=0.000> write <sil=0.000> a
function <sil=0.000> for <sil=0.000> finding <sil=0.000> the <sil=0.000> string <sil=0.000> length <sil=0.000> although <sil=0.000> it <sil=0.000> is <sil=0.000> available <sil=0.000> in <sil=0.000> the <sil=0.000> standard <sil=0.000> c library <sil=2.000> .PERIOD 
Counts <sil=0.000> and <sil=0.000> returns <sil=0.000> the <sil=0.000> number <sil=0.000> of <sil=0.000> characters <sil=0.000> in <sil=0.000> a string <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  len <sil=0.000> suppose <sil=0.000> len <sil=0.000> is <sil=0.000> a variable
of <sil=0.000> type <sil=0.000> integer <sil=1.000> ,COMMA  len <sil=0.000> is <sil=0.000> of <sil=0.000> type <sil=0.000> integer <sil=0.000> len <sil=0.000> is <sil=0.000> of <sil=0.000> type <sil=0.000> integer <sil=0.000> and <sil=0.000> we <sil=0.000> say <sil=0.000> s t <sil=0.000> r l <sil=0.000> e n <sil=0.000> string <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  string <sil=0.000> is <sil=0.000> some <sil=0.000> string <sil=0.000> all <sil=0.000> right <sil=0.000> some <sil=0.000> variable <sil=0.000> name <sil=0.000> s t <sil=0.000> r1e <sil=0.000> n city <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  city <sil=0.000> is <sil=0.000> a variable
and <sil=0.000> whatever <sil=0.000> is <sil=0.000> the <sil=0.000> n suppose <sil=0.000> city <sil=0.000> is <sil=0.000> Mumbai <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> length <sil=0.000> of <sil=0.000> the <sil=0.000> characters
in <sil=0.000> this <sil=0.000> string <sil=0.000> and <sil=0.000> that <sil=0.000> will <sil=0.000> come <sil=0.000> in <sil=0.000> to <sil=0.000> len <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  len <sil=0.000> here <sil=0.000> we <sil=0.000> will <sil=0.000> get <sil=0.000> the <sil=0.000> value <sil=0.000> 6 when <sil=0.000> I do
this <sil=0.000> function <sil=0.000> on <sil=0.000> this <sil=0.000> on <sil=0.000> the <sil=0.000> string <sil=2.000> .PERIOD 

The <sil=0.000> null <sil=0.000> character <sil=0.000> at <sil=0.000> the <sil=0.000> end <sil=0.000> as <sil=0.000> I said <sil=0.000> is <sil=0.000> not <sil=0.000> counted <sil=0.000> because <sil=0.000> that <sil=0.000> tells <sil=0.000> you <sil=0.000> that <sil=0.000> you <sil=0.000> need
not <sil=0.000> count <sil=0.000> any <sil=0.000> further <sil=0.354> ;SEMICOLON  counting <sil=0.000> ends <sil=0.000> with <sil=0.000> the <sil=0.000> first <sil=0.000> null <sil=0.000> character <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  if <sil=0.000> I do <sil=0.000> Calcutta <sil=0.000> if <sil=0.000> I copy <sil=0.000> Calcutta <sil=0.000> the <sil=0.000> string <sil=1.000> ,COMMA  constant <sil=0.000> calculative <sil=0.000> city <sil=0.000> and <sil=0.000> I find <sil=0.000> out
the <sil=0.000> length <sil=0.000> of <sil=0.000> city <sil=0.000> it <sil=0.000> will <sil=0.000> be <sil=0.000> 1 2 <sil=0.000> 3 4 <sil=0.000> 5 6 <sil=0.000> 7 8 <sil=0.000> and <sil=0.000> backslash <sil=0.000> 0 will <sil=0.000> be <sil=0.000> left <sil=0.000> out <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  n <sil=0.000> is
assigned <sil=0.000> 8 writing <sil=0.000> the <sil=0.000> string <sil=0.000> length <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  one <sil=0.000> problem <sil=0.000> that <sil=0.000> can <sil=0.000> be <sil=0.000> given <sil=0.000> to <sil=0.000> you <sil=0.000> that <sil=0.000> I am <sil=0.000> not <sil=0.000> talking <sil=0.000> about <sil=0.000> this <sil=0.000> function <sil=0.000> part
right <sil=0.000> now <sil=2.000> .PERIOD 
Suppose <sil=0.000> I am <sil=0.000> trying <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> string <sil=0.000> length <sil=0.000> of <sil=0.000> a character <sil=0.000> string <sil=0.000> I am <sil=0.000> trying <sil=0.000> to <sil=0.000> find
how <sil=0.000> do <sil=0.000> you <sil=0.000> find <sil=0.000> out <sil=0.000> string <sil=0.000> length <sil=0.000> I mean <sil=0.000> its <sil=0.000> writing <sil=0.000> a program <sil=0.000> that <sil=0.000> is <sil=0.000> finding <sil=0.000> the <sil=0.000> string
length <sil=0.000> you <sil=0.000> need <sil=0.000> not <sil=0.000> bother <sil=0.000> about <sil=0.000> the <sil=0.000> structure <sil=0.000> of <sil=0.000> this <sil=0.000> as <sil=0.000> yet <sil=1.000> ,COMMA  but <sil=0.000> let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> the
algorithm <sil=0.000> purely <sil=0.000> what <sil=0.000> is <sil=0.000> being <sil=0.000> done <sil=0.228> ?QUESTIONMARK  Len <sil=0.000> some <sil=0.000> variable <sil=0.000> has <sil=0.000> been <sil=0.000> put <sil=0.000> to <sil=0.000> 0 and <sil=0.000> then <sil=0.000> while
I <sil=0.000> am <sil=0.000> not <sil=0.000> encountering <sil=0.000> now <sil=0.000> s t <sil=0.000> r is <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> course <sil=1.000> ,COMMA  array <sil=0.000> of <sil=0.000> characters <sil=2.000> .PERIOD  As <sil=0.000> you <sil=0.000> can <sil=0.000> see
its <sil=0.000> an <sil=0.000> idea <sil=0.000> characters <sil=0.000> as <sil=0.000> long <sil=0.000> as <sil=0.000> that <sil=0.000> is <sil=0.000> not <sil=0.000> equal <sil=0.000> to <sil=0.000> backslash <sil=0.000> 0 <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  not <sil=0.000> the <sil=0.000> end
of <sil=0.000> the <sil=0.000> string <sil=0.000> I am <sil=0.000> going <sil=0.000> to <sil=0.000> going <sil=0.000> in <sil=0.000> going <sil=0.000> on <sil=0.000> incrementing <sil=0.000> this <sil=0.000> len <sil=1.000> ,COMMA  len <sil=0.000> was <sil=0.000> 0 len
becomes <sil=0.000> one <sil=0.000> like <sil=0.000> that <sil=0.000> and <sil=0.000> then <sil=0.000> we <sil=0.000> return <sil=0.000> len <sil=0.000> after <sil=0.000> I completed <sil=0.000> then <sil=0.000> I return <sil=0.000> len  <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> provided <sil=0.000> in <sil=0.000> the <sil=0.000> of <sil=0.000> course <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> to <sil=0.000> include <sil=0.000> the <sil=0.000> string <sil=0.000> dot <sil=0.000> h <sil=1.000> ,COMMA  but <sil=0.000> this <sil=0.000> thing
this <sil=0.000> is <sil=0.000> what <sil=0.000> I am <sil=0.000> writing <sil=0.000> if <sil=1.000> ,COMMA  but <sil=0.000> actually <sil=0.000> this <sil=0.000> is <sil=0.000> a already <sil=0.000> available <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> need <sil=0.000> not <sil=0.000> write <sil=0.000> it <sil=1.000> ,COMMA 
I <sil=0.000> need <sil=0.000> to <sil=0.000> simply <sil=0.000> include <sil=0.000> hash <sil=0.000> include <sil=0.000> I call <sil=0.000> it <sil=0.000> hash <sil=0.000> include <sil=0.000> strings <sil=0.000> dot <sil=0.000> h that <sil=0.000> library <sil=2.000> .PERIOD 
There <sil=0.000> similar <sil=0.000> program <sil=0.000> is <sil=0.000> already <sil=0.000> written <sil=0.000> and <sil=0.000> when <sil=0.000> I write <sil=0.000> strlen <sil=0.000> that <sil=0.000> is <sil=0.000> the <sil=0.000> program <sil=0.000> that
is <sil=0.000> activated <sil=2.000> .PERIOD 
String <sil=0.000> compare <sil=0.000> is <sil=0.000> comparing <sil=0.000> two <sil=0.000> strings <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  we <sil=0.000> are <sil=0.000> comparing <sil=0.000> two <sil=0.000> strings <sil=0.000> and <sil=0.000> returns <sil=0.000> 0 if <sil=0.000> they <sil=0.000> are <sil=0.000> identical <sil=0.000> what <sil=0.000> I just <sil=0.000> now <sil=0.000> said
was <sil=0.000> just <sil=0.000> the <sil=0.000> opposite <sil=2.000> .PERIOD  If <sil=0.000> they <sil=0.000> are <sil=0.000> matching <sil=0.000> then <sil=0.000> it <sil=0.000> returns <sil=0.000> 0 and <sil=0.000> if <sil=0.000> they <sil=0.000> do <sil=0.000> not <sil=0.000> match <sil=0.000> a
little <sil=0.000> non <sil=0.000> intuitive <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  keep <sil=0.000> it <sil=0.000> in <sil=0.000> mind <sil=0.000> that <sil=0.000> if <sil=0.000> the <sil=0.000> two <sil=0.000> strings <sil=0.000> match <sil=1.000> ,COMMA  then <sil=0.000> we <sil=0.000> will <sil=0.000> return <sil=0.000> a
0 <sil=0.000> otherwise <sil=0.000> will <sil=0.000> return <sil=0.000> a non-zero <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  example <sil=0.000> is <sil=0.000> here <sil=0.000> if <sil=0.000> I compare <sil=0.000> city <sil=0.000> with <sil=0.000> the <sil=0.000> string <sil=0.000> Delhi <sil=0.000> is <sil=0.000> 0 then <sil=0.000> I do <sil=0.000> something <sil=2.000> .PERIOD  What
does <sil=0.000> it <sil=0.000> mean <sil=0.000> city <sil=0.000> is <sil=0.000> a string <sil=0.000> already <sil=1.000> ,COMMA  suppose <sil=0.000> that <sil=0.000> is <sil=0.000> again <sil=0.000> Chennai <sil=0.000> suppose <sil=0.000> that <sil=0.000> is
Chennai <sil=0.000> and <sil=0.000> I am <sil=0.000> comparing <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  city <sil=0.000> is <sil=0.000> a variable <sil=0.000> which <sil=0.000> has <sil=0.000> got <sil=0.000> this <sil=0.000> value <sil=1.000> ,COMMA  and <sil=0.000> I am
comparing <sil=0.000> with <sil=0.000> Delhi <sil=0.000> of <sil=0.000> course <sil=1.000> ,COMMA  now <sil=0.000> they <sil=0.000> are <sil=0.000> not <sil=0.000> matching <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> not <sil=0.000> it <sil=0.000> will <sil=0.000> return
non <sil=0.000> zero <sil=2.000> .PERIOD  But <sil=0.000> if <sil=0.000> the <sil=0.000> city <sil=0.000> was <sil=0.000> Delhi <sil=0.000> then <sil=0.000> these <sil=0.000> two <sil=0.000> have <sil=0.000> matched <sil=0.000> and <sil=0.000> I would <sil=0.000> have <sil=0.000> got <sil=0.000> a
one <sil=0.000> here <sil=0.000> right <sil=2.000> .PERIOD 
Now <sil=0.354> ;SEMICOLON  obviously <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> also <sil=0.000> just <sil=0.000> think <sil=0.000> and <sil=0.000> decide <sil=0.000> how <sil=0.000> this <sil=0.000> algorithm <sil=0.000> can <sil=0.000> be <sil=0.000> written
that <sil=0.000> is <sil=0.000> 0073o <sil=1.000> ,COMMA  simple <sil=0.000> now <sil=0.000> you <sil=0.000> have <sil=0.000> learnt <sil=0.000> all <sil=0.000> the <sil=0.000> tidbits <sil=0.000> of <sil=0.000> writing <sil=0.000> such <sil=0.000> a program <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  if <sil=0.000> this <sil=0.000> is <sil=0.000> not <sil=0.000> equal <sil=0.000> to <sil=0.000> 0 then <sil=0.000> then <sil=0.000> we <sil=0.000> do <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  similarly <sil=0.000> I can <sil=0.000> do <sil=0.000> city <sil=0.000> 1 city <sil=0.000> 2 now <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  before <sil=0.000> that <sil=0.000> you <sil=0.000> can <sil=0.000> simply <sil=0.000> think <sil=0.000> of <sil=0.000> how <sil=0.000> the <sil=0.000> algorithm <sil=0.000> will <sil=0.000> look <sil=0.000> like <sil=0.000> in <sil=0.000> case <sil=0.000> of <sil=0.000> this
suppose <sil=0.000> I have <sil=0.000> got <sil=0.000> two <sil=0.000> strings <sil=2.000> .PERIOD 

One <sil=0.000> is <sil=0.000> say <sil=0.000> Chennai <sil=0.000> and <sil=0.000> the <sil=0.000> other <sil=0.000> string <sil=0.000> is <sil=0.000> of <sil=0.000> course <sil=1.000> ,COMMA  backslash <sil=0.000> 0 here <sil=0.000> instead <sil=0.000> of <sil=0.000> n there <sil=0.000> is
a <sil=0.000> name <sil=0.000> here <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  how <sil=0.000> will <sil=0.000> you <sil=0.000> do <sil=0.000> that <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  you <sil=0.000> will <sil=0.000> compare <sil=0.000> these <sil=0.000> two <sil=0.000> character <sil=0.000> by <sil=0.000> character <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this
is <sil=0.000> suppose <sil=0.000> city <sil=0.000> 1 and <sil=0.000> this <sil=0.000> is <sil=0.000> city <sil=0.000> 2 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> very <sil=0.000> easily <sil=0.000> compare <sil=0.000> while <sil=0.000> city <sil=0.000> 1 i <sil=0.000> of
course <sil=1.000> ,COMMA  i <sil=0.000> has <sil=0.000> been <sil=0.000> assigned <sil=0.000> to <sil=0.000> 0 here <sil=0.000> is <sil=0.000> same <sil=0.000> as <sil=0.000> city <sil=0.000> 2 i <sil=0.000> what <sil=0.000> shall <sil=0.000> we <sil=0.000> do <sil=0.228> ?QUESTIONMARK  We <sil=0.000> will <sil=0.000> go <sil=0.000> on
incrementing <sil=0.000> I plus <sil=0.000> plus <sil=1.000> ,COMMA  but <sil=0.000> and <sil=0.000> if <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> equal <sil=0.000> we <sil=0.000> will <sil=0.000> come <sil=0.000> out <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  this <sil=0.000> here <sil=0.000> I compare <sil=0.000> here <sil=0.000> I compare <sil=0.000> I come <sil=0.000> here <sil=0.000> and <sil=0.000> here <sil=0.000> I find <sil=0.000> that <sil=0.000> city <sil=0.000> 3 here <sil=1.000> ,COMMA  city <sil=0.000> 1
3 <sil=0.000> and <sil=0.000> city <sil=0.000> 2 3 <sil=0.000> are <sil=0.000> not <sil=0.000> the <sil=0.000> same <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> come <sil=0.000> out <sil=1.000> ,COMMA  but <sil=0.000> what <sil=0.000> happens <sil=0.000> if <sil=0.000> they <sil=0.000> are <sil=0.000> same <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> need <sil=0.000> to <sil=0.000> put <sil=0.000> in <sil=0.000> if <sil=0.000> they <sil=0.000> are <sil=0.000> same <sil=0.000> I how <sil=0.000> long <sil=0.000> shall <sil=0.000> I go <sil=0.000> on <sil=0.000> no <sil=0.000> mismatch <sil=0.000> is <sil=0.000> there
suppose <sil=0.000> this <sil=0.000> is <sil=0.000> also <sil=0.000> n while <sil=0.000> city <sil=0.000> is <sil=0.000> city <sil=0.000> 1 is <sil=0.000> not <sil=0.000> equal <sil=0.000> to <sil=0.000> city <sil=0.000> 2 <sil=1.000> ,COMMA  while <sil=0.000> city <sil=0.000> 1 is <sil=0.000> equal <sil=0.000> to <sil=0.000> city
2 <sil=0.000> do <sil=0.000> I need <sil=0.000> another <sil=0.000> condition <sil=0.000> here <sil=0.000> yes <sil=0.000> and <sil=0.000> city <sil=0.000> i is <sil=0.000> not <sil=0.000> equal <sil=0.000> to <sil=0.000> backslash <sil=0.000> 0 <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  are <sil=0.000> you <sil=0.000> understanding <sil=0.000> this <sil=1.000> ,COMMA  while <sil=0.000> this <sil=0.000> condition <sil=0.000> which <sil=0.000> I have <sil=0.000> already <sil=0.000> written <sil=0.000> there <sil=2.000> .PERIOD 
That <sil=0.000> should <sil=0.000> be <sil=0.000> true <sil=0.000> in <sil=0.000> order <sil=0.000> to <sil=0.000> proceed <sil=0.000> in <sil=0.000> order <sil=0.000> to <sil=0.000> proceed <sil=0.000> further <sil=0.000> for <sil=0.000> further <sil=0.000> checking <sil=1.000> ,COMMA  I
should <sil=0.000> they <sil=0.000> are <sil=0.000> matching <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> should <sil=0.000> proceed <sil=0.000> and <sil=1.000> ,COMMA  but <sil=0.000> and <sil=0.000> also <sil=0.000> the <sil=0.000> fact <sil=0.000> should <sil=0.000> be <sil=0.000> that
none <sil=0.000> of <sil=0.000> these <sil=0.000> two <sil=0.000> cities <sil=0.000> names <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  two <sil=0.000> strings <sil=0.000> have <sil=0.000> reached <sil=0.000> the <sil=0.000> end <sil=0.000> is <sil=0.000> not <sil=0.000> equal <sil=0.000> to <sil=0.000> this <sil=0.000> and <sil=0.000> city <sil=0.000> 2 i <sil=0.000> if <sil=0.000> any <sil=0.000> one <sil=0.000> of <sil=0.000> them <sil=0.000> has <sil=0.000> matched <sil=0.000> has <sil=0.000> reached <sil=0.000> the <sil=0.000> end
then <sil=0.000> my <sil=0.000> while <sil=0.000> condition <sil=0.000> will <sil=0.000> be <sil=0.000> violated <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> not <sil=0.000> continue <sil=0.000> any <sil=0.000> further <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> keep <sil=0.000> a flag <sil=0.000> here <sil=0.000> that <sil=0.000> what <sil=0.000> should <sil=0.000> I say <sil=0.000> match <sil=0.000> is <sil=0.000> one <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> I go <sil=0.000> on <sil=0.000> doing <sil=0.000> this
match <sil=0.000> will <sil=0.000> be <sil=0.000> remaining <sil=0.000> 1 <sil=1.000> ,COMMA  whenever <sil=0.000> I come <sil=0.000> out <sil=0.000> of <sil=0.000> this <sil=0.000> loop <sil=0.000> I will <sil=0.000> make <sil=0.000> match <sil=0.000> 0 that
means <sil=1.000> ,COMMA  it <sil=0.000> has <sil=0.000> there <sil=0.000> has <sil=0.000> been <sil=0.000> a match <sil=0.000> because <sil=0.000> the <sil=0.000> convention <sil=0.000> is <sil=0.000> that <sil=0.000> if <sil=0.000> they <sil=0.000> are <sil=0.000> matching
then <sil=0.000> it <sil=0.000> should <sil=0.000> be <sil=0.000> 0 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you <sil=0.000> please <sil=0.000> also <sil=0.000> try <sil=0.000> to <sil=0.000> write <sil=0.000> this <sil=0.000> function <sil=0.000> right <sil=0.000> this <sil=0.000> program <sil=0.000> right
we <sil=0.000> will <sil=0.000> ask <sil=0.000> you <sil=0.000> to <sil=0.000> make <sil=0.000> it <sil=0.000> a function <sil=0.000> a couple <sil=0.000> of <sil=0.000> lectures <sil=0.000> later <sil=2.000> .PERIOD  I <sil=0.000> hope <sil=0.000> this <sil=0.000> is <sil=0.000> clear <sil=0.000> this
part <sil=0.000> please <sil=0.000> try <sil=0.000> to <sil=0.000> understand <sil=0.000> this <sil=0.000> condition <sil=0.000> try <sil=0.000> to <sil=0.000> understand <sil=0.000> this <sil=0.000> condition <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD 
Next <sil=0.000> we <sil=0.000> have <sil=0.000> got <sil=0.000> the <sil=0.000> last <sil=0.000> one <sil=0.000> that <sil=0.000> is <sil=0.000> a s <sil=0.000> t r <sil=0.000> c a <sil=0.000> t <sil=2.000> .PERIOD  that <sil=0.000> is <sil=0.000> rather <sil=0.000> simple <sil=0.000> you <sil=0.000> will <sil=0.000> also <sil=0.000> be <sil=0.000> able
to <sil=0.000> write <sil=0.000> the <sil=0.000> program <sil=0.000> for <sil=0.000> that <sil=0.000> it <sil=0.000> is <sil=0.000> two <sil=0.000> strings <sil=0.000> are <sil=0.000> just <sil=0.000> being <sil=0.000> kind <sil=0.000> of <sil=0.000> concatenated <sil=1.000> ,COMMA  but <sil=0.000> one
thing <sil=0.000> that <sil=0.000> you <sil=0.000> must <sil=0.000> remember <sil=0.000> appending <sil=0.000> concatenating <sil=0.000> means <sil=0.000> joining <sil=1.000> ,COMMA  while <sil=0.000> appending
means <sil=0.000> at <sil=0.000> adding <sil=0.000> one <sil=0.000> at <sil=0.000> the <sil=0.000> end <sil=0.000> of <sil=0.000> the <sil=0.000> other <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  when <sil=0.000> I write <sil=0.000> this <sil=0.000> a b <sil=0.000> c <sil=1.000> ,COMMA  p <sil=0.000> q r <sil=0.000> then <sil=0.000> p q <sil=0.000> r
has <sil=0.000> been <sil=0.000> appended <sil=0.000> to <sil=0.000> a b <sil=0.000> c  <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  string <sil=0.000> 2 is <sil=0.000> appended <sil=0.000> to <sil=0.000> string <sil=0.000> one <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> joined <sil=0.000> at <sil=0.000> the <sil=0.000> end <sil=0.000> of <sil=0.000> string <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
the <sil=0.000> null <sil=0.000> character <sil=0.000> at <sil=0.000> the <sil=0.000> end <sil=0.000> of <sil=0.000> string <sil=0.000> 1 is <sil=0.000> removed <sil=0.000> and <sil=0.000> string <sil=0.000> 2 is <sil=0.000> joined <sil=0.000> from <sil=0.000> that <sil=0.000> point <sil=2.000> .PERIOD 
(Refer <sil=0.000> Slide <sil=0.000> Time: 32:48)

as <sil=0.000> we <sil=0.000> said <sil=0.000> that <sil=0.000> there <sil=0.000> can <sil=0.000> be <sil=0.000> a b <sil=0.000> c backslash <sil=0.000> 0 and <sil=0.000> then <sil=0.000> when <sil=0.000> I append <sil=0.000> p q <sil=0.000> r to <sil=0.000> that <sil=1.000> ,COMMA  then <sil=0.000> p
q <sil=0.000> r will <sil=0.000> p will <sil=0.000> replace <sil=0.000> this <sil=0.000> and <sil=0.000> backslash <sil=0.000> 0 will <sil=0.000> come <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  ultimately <sil=0.000> we <sil=0.000> will <sil=0.000> have <sil=0.000> a
b <sil=0.000> c <sil=1.000> ,COMMA  p <sil=0.000> q r <sil=0.000> backslash <sil=0.000> 0 all <sil=0.000> right <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  string <sil=0.000> copy <sil=0.000> suppose <sil=0.000> I have <sil=0.000> name <sil=0.000> one <sil=0.000> a string <sil=0.000> assigned <sil=0.000> by <sil=0.000> string <sil=0.000> copy <sil=0.000> Amit <sil=0.354> ;SEMICOLON  A <sil=0.000> m i <sil=0.000> t <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  it <sil=0.000> looks <sil=0.000> like <sil=0.000> this <sil=0.000> a m <sil=0.000> i t <sil=0.000> backslash <sil=0.000> here <sil=0.000> there <sil=0.000> is <sil=0.000> a backslash <sil=0.000> 0 and <sil=0.000> there <sil=0.000> is <sil=0.000> a blank <sil=0.000> here
you <sil=0.000> see <sil=0.000> the <sil=0.000> string <sil=0.000> is <sil=0.000> not <sil=0.000> a m <sil=0.000> i t <sil=0.000> a m <sil=0.000> i t <sil=0.000> blank <sil=0.000> and <sil=0.000> another <sil=0.000> string <sil=0.000> is <sil=0.000> name <sil=0.000> two <sil=0.000> which <sil=0.000> is <sil=0.000> R o
y <sil=1.000> ,COMMA  then <sil=0.000> when <sil=0.000> I append <sil=0.000> them <sil=0.000> concatenate <sil=0.000> them <sil=0.000> there <sil=0.000> it <sil=0.000> will <sil=0.000> be <sil=0.000> a m <sil=0.000> i t <sil=0.000> blank <sil=0.000> this <sil=0.000> blank <sil=0.000> and
then <sil=0.000> R o <sil=0.000> y and <sil=0.000> this <sil=0.000> this <sil=0.000> blank <sil=0.000> has <sil=0.000> been <sil=0.000> replaced <sil=0.000> by <sil=0.000> r <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  r <sil=0.000> has <sil=0.000> gone <sil=0.000> here <sil=0.000> and <sil=0.000> we <sil=0.000> will <sil=0.000> get
this <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> string <sil=0.000> concatenation <sil=0.000> this <sil=0.000> will <sil=0.000> often <sil=0.000> come <sil=0.000> handy <sil=0.000> when <sil=0.000> you <sil=0.000> type <sil=0.000> in <sil=0.000> some
character <sil=0.000> strings <sil=0.000> or <sil=0.000> type <sil=0.000> and <sil=0.000> lines <sil=0.000> or <sil=0.000> compute <sil=0.000> using <sil=0.000> some <sil=0.000> text <sil=0.000> strings <sil=0.000> text <sil=0.000> English
sentence <sil=0.000> has <sil=0.000> been <sil=0.000> given <sil=0.000> and <sil=0.000> you <sil=0.000> are <sil=0.000> trying <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> where <sil=0.000> the <sil=0.000> verb <sil=0.000> is <sil=0.000> and <sil=0.000> all <sil=0.000> those
then <sil=0.000> you <sil=0.000> need <sil=0.000> a lot <sil=0.000> of <sil=0.000> string <sil=0.000> operations <sil=0.000> like <sil=0.000> this <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> an <sil=0.000> example <sil=0.000> here <sil=0.000> we <sil=0.000> are <sil=0.000> reading <sil=0.000> a line <sil=0.000> of <sil=0.000> text <sil=0.000> and <sil=0.000> counting <sil=0.000> the <sil=0.000> number <sil=0.000> of
uppercase <sil=0.000> letters <sil=0.000> how <sil=0.000> many <sil=0.000> uppercase <sil=0.000> letters <sil=0.000> are <sil=0.000> there <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> are <sil=0.000> the <sil=0.000> things <sil=0.000> we <sil=0.000> are
including <sil=0.000> here <sil=0.228> ?QUESTIONMARK  s <sil=0.000> t d <sil=0.000> i o <sil=0.000> dot <sil=0.000> h and <sil=0.000> old <sil=0.000> friend <sil=0.000> is <sil=0.000> here <sil=1.000> ,COMMA  string <sil=0.000> dot <sil=0.000> h is <sil=0.000> also <sil=0.000> there <sil=0.000> then <sil=0.000> look <sil=0.000> at
this <sil=0.000> function <sil=0.000> I have <sil=0.000> defined <sil=0.000> a line <sil=0.000> to <sil=0.000> be <sil=0.000> of <sil=0.000> length <sil=0.000> 81 <sil=0.000> big <sil=0.000> one <sil=0.000> 81 <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> the <sil=0.000> variables <sil=0.000> I and <sil=0.000> current <sil=0.000> count <sil=0.000> is <sil=0.000> equal <sil=0.000> to <sil=0.000> 0 <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> asking <sil=0.000> the <sil=0.000> user <sil=0.000> to
input <sil=0.000> the <sil=0.000> line <sil=0.000> I am <sil=0.000> reading <sil=0.000> the <sil=0.000> line <sil=0.000> using <sil=0.000> this <sil=0.000> format <sil=0.000> which <sil=0.000> we <sil=0.000> just <sil=0.000> discussed <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA 
anything <sil=0.000> can <sil=0.000> come <sil=0.000> here <sil=0.000> I mean <sil=0.000> anything <sil=0.000> can <sil=0.000> come <sil=0.000> here <sil=0.000> like <sil=0.000> a b <sil=0.000> c slash <sil=1.000> ,COMMA  dash <sil=0.000> alright
percentage <sil=0.000> p whatever <sil=0.000> is <sil=0.000> coming <sil=0.000> except <sil=0.000> backslash <sil=0.000> n its <sil=0.000> coming <sil=0.000> here <sil=0.000> and <sil=0.000> then <sil=0.000> I am
finding <sil=0.000> the <sil=0.000> length <sil=0.000> of <sil=0.000> the <sil=0.000> line <sil=2.000> .PERIOD 
Suppose <sil=0.000> the <sil=0.000> line <sil=0.000> that <sil=0.000> was <sil=0.000> actually <sil=0.000> typed <sil=0.000> in <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=0.000> through <sil=0.000> this <sil=0.000> scan <sil=0.000> f is <sil=0.000> say <sil=0.000> apple
blank <sil=0.000> is <sil=0.000> red <sil=2.000> .PERIOD 

All <sil=0.000> right <sil=0.000> and <sil=0.000> then <sil=0.000> there <sil=0.000> is <sil=0.000> backslash <sil=0.000> here <sil=0.000> now <sil=0.000> this <sil=0.000> string <sil=0.000> length <sil=0.000> s t <sil=0.000> r l <sil=0.000> e n <sil=0.000> will <sil=0.000> find <sil=0.000> out <sil=0.000> the
length <sil=0.000> of <sil=0.000> the <sil=0.000> string <sil=0.000> 1 2 <sil=0.000> 3 4 <sil=0.000> 5 6 <sil=0.000> 7 8 <sil=0.000> 9 10 <sil=0.000> 11 <sil=0.000> 12 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  12 <sil=0.000> is <sil=0.000> n is <sil=0.000> becoming <sil=0.000> 12 <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  for <sil=0.000> i equal <sil=0.000> to <sil=0.000> 1 to <sil=0.000> n <sil=1.000> ,COMMA  now <sil=0.000> here <sil=0.000> is <sil=0.000> another <sil=0.000> new <sil=0.000> function <sil=0.000> that <sil=0.000> we <sil=0.000> are <sil=0.000> finding <sil=0.000> is <sil=0.000> upper <sil=0.000> if
the <sil=0.000> character <sil=0.000> is <sil=0.000> upper <sil=0.000> case <sil=0.000> letter <sil=1.000> ,COMMA  is <sil=0.000> upper <sil=0.000> if <sil=0.000> the <sil=0.000> character <sil=0.000> that <sil=0.000> is <sil=0.000> being <sil=0.000> red <sil=0.000> that <sil=0.000> that <sil=0.000> is
being <sil=0.000> passed <sil=0.000> here <sil=0.000> I put <sil=0.000> in <sil=0.000> some <sil=0.000> character <sil=0.000> and <sil=0.000> if <sil=0.000> the <sil=0.000> character <sil=0.000> is <sil=0.000> an <sil=0.000> upper <sil=0.000> case <sil=0.000> letter <sil=0.000> then
I <sil=0.000> will <sil=0.000> count <sil=0.000> that <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  suppose <sil=0.000> here <sil=0.000> I make <sil=0.000> a little <sil=0.000> change <sil=0.000> I say <sil=0.000> this <sil=0.000> is <sil=0.000> I say <sil=0.000> that <sil=0.000> this <sil=0.000> is
capital <sil=0.000> and <sil=0.000> I say <sil=0.000> that <sil=0.000> this <sil=0.000> is <sil=0.000> capital <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> happening <sil=0.000> is <sil=0.000> it <sil=0.000> is <sil=0.000> reading <sil=0.000> character <sil=0.000> by <sil=0.000> character <sil=0.000> from <sil=0.000> here <sil=0.000> I 0 <sil=0.000> onwards <sil=1.000> ,COMMA  and
checking <sil=0.000> whether <sil=0.000> this <sil=0.000> character <sil=0.000> is <sil=0.000> an <sil=0.000> upper <sil=0.000> character <sil=0.000> if <sil=0.000> that <sil=0.000> is <sil=0.000> so <sil=1.000> ,COMMA  count <sil=0.000> is <sil=0.000> becoming <sil=0.000> 1 <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  count <sil=0.000> becomes <sil=0.000> one <sil=0.000> as <sil=0.000> a is <sil=0.000> upper <sil=0.000> case <sil=0.000> letter <sil=1.000> ,COMMA  then <sil=0.000> we <sil=0.000> go <sil=0.000> on <sil=0.000> in <sil=0.000> this <sil=0.000> loop <sil=0.000> i is <sil=0.000> being
incremented <sil=0.000> until <sil=0.000> it <sil=0.000> comes <sil=0.000> to <sil=0.000> 12 <sil=0.000> less <sil=0.000> than <sil=0.000> 12 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> another <sil=0.000> one <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> get <sil=0.000> the
count <sil=0.000> to <sil=0.000> be <sil=0.000> 2 <sil=1.000> ,COMMA  it <sil=0.000> goes <sil=0.000> on <sil=0.000> and <sil=0.000> here <sil=0.000> I will <sil=0.000> get <sil=0.000> another <sil=0.000> one <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  its <sil=0.000> free <sil=0.000> print <sil=0.000> f the <sil=0.000> number <sil=0.000> of
uppercase <sil=0.000> letters <sil=0.000> is <sil=0.000> percentage <sil=0.000> d is <sil=0.000> now <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=2.000> .PERIOD  The <sil=0.000> number <sil=0.000> of <sil=0.000> uppercase <sil=0.000> letters <sil=0.000> in
string <sil=0.000> percentages <sil=0.000> s is <sil=0.000> percentage <sil=0.000> d <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  line <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=0.000> as <sil=0.000> a line <sil=0.000> apple <sil=0.000> is <sil=0.000> red <sil=0.000> the
number <sil=0.000> of <sil=0.000> uppercase <sil=0.000> letters <sil=0.000> in <sil=0.000> apple <sil=0.000> is <sil=0.000> red <sil=0.000> is <sil=0.000> 3 <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  here <sil=0.000> this <sil=0.000> program <sil=0.000> demonstrates <sil=0.000> a couple <sil=0.000> of <sil=0.000> things <sil=2.000> .PERIOD 

One <sil=0.000> is <sil=0.000> first <sil=0.000> of <sil=0.000> all <sil=0.000> this <sil=0.000> is <sil=0.000> a new <sil=0.000> thing <sil=0.000> that <sil=0.000> you <sil=0.000> have <sil=0.000> learned <sil=0.000> is <sil=0.000> upper <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> just <sil=0.000> writing <sil=0.000> it
separately <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> it <sil=0.000> is <sil=0.000> clear <sil=1.000> ,COMMA  but <sil=0.000> in <sil=0.000> actual <sil=0.000> c library <sil=0.000> the <sil=0.000> function <sil=0.000> is <sil=0.000> written <sil=0.000> in <sil=0.000> the <sil=0.000> form
without <sil=0.000> this <sil=0.000> gap <sil=0.000> or <sil=0.000> without <sil=0.000> any <sil=0.000> special <sil=0.000> character <sil=0.000> in <sil=0.000> between <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> the <sil=0.000> first <sil=0.000> thing <sil=0.000> that <sil=0.000> we
have <sil=0.000> learned <sil=2.000> .PERIOD  And <sil=0.000> how <sil=0.000> we <sil=0.000> have <sil=0.000> already <sil=0.000> seen <sil=0.000> it <sil=0.000> is <sil=0.000> an <sil=0.000> application <sil=0.000> of <sil=0.000> what <sil=0.000> we <sil=0.000> learnt <sil=0.000> how
we <sil=0.000> can <sil=0.000> read <sil=0.000> a line <sil=0.000> using <sil=0.000> this <sil=0.000> wildcard <sil=0.000> format <sil=2.000> .PERIOD  And <sil=0.000> then <sil=0.000> we <sil=0.000> found <sil=0.000> out <sil=0.000> what <sil=0.000> is <sil=0.000> the <sil=0.000> length
of <sil=0.000> the <sil=0.000> line <sil=0.000> by <sil=0.000> our <sil=0.000> newly <sil=0.000> learned <sil=0.000> function <sil=0.000> s t <sil=0.000> r l <sil=0.000> e n <sil=0.354> ;SEMICOLON  and <sil=0.000> using <sil=0.000> that <sil=0.000> we <sil=0.000> have <sil=0.000> this <sil=0.000> is <sil=0.000> this
looping <sil=0.000> we <sil=0.000> already <sil=0.000> know <sil=0.000> we <sil=0.000> have <sil=0.000> practiced <sil=0.000> it <sil=0.000> so <sil=0.000> often <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  we <sil=0.000> now <sil=0.000> using <sil=0.000> this <sil=0.000> value <sil=0.000> using <sil=0.000> this <sil=0.000> for <sil=0.000> loop <sil=0.000> for <sil=0.000> so <sil=1.000> ,COMMA  many <sil=0.000> iterations <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  many
repetitions <sil=0.000> that <sil=0.000> is <sil=0.000> determined <sil=0.000> by <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> n will <sil=0.000> check <sil=0.000> the <sil=0.000> entire <sil=0.000> string <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> an
example <sil=0.000> of <sil=0.000> applying <sil=0.000> the <sil=0.000> string <sil=0.000> function <sil=0.000> in <sil=0.000> string <sil=0.000> operations <sil=1.000> ,COMMA  will <sil=0.000> go <sil=0.000> further <sil=0.000> with <sil=0.000> some
more <sil=0.000> examples <sil=0.000> later <sil=2.000> .PERIOD 

We <sil=0.000> have <sil=0.000> looked <sil=0.000> at <sil=0.000> arrays <sil=0.000> and <sil=0.000> their <sil=0.000> utility <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> in <sil=0.000> particular <sil=0.000> looked <sil=0.000> at <sil=0.000> one
dimensional <sil=0.000> array <sil=0.000> and <sil=0.000> today <sil=0.000> we <sil=0.000> will <sil=0.000> introduce <sil=0.000> another <sil=0.000> variety <sil=0.000> of <sil=0.000> array <sil=1.000> ,COMMA  which <sil=0.000> is <sil=0.000> 2-
dimensional <sil=0.000> array <sil=2.000> .PERIOD  In <sil=0.000> fact <sil=1.000> ,COMMA  we <sil=0.000> can <sil=0.000> have <sil=0.000> multi-dimensional <sil=0.000> arrays <sil=0.000> in <sil=0.000> general <sil=0.000> arrays <sil=0.000> can
be <sil=0.354> ;SEMICOLON  we <sil=0.000> can <sil=0.000> have <sil=0.000> in <sil=0.000> n dimensional <sil=0.000> array <sil=2.000> .PERIOD 

For <sil=0.000> a particular <sil=0.000> value <sil=0.000> of <sil=0.000> n equal <sil=0.000> to <sil=0.000> 1 <sil=1.000> ,COMMA  we <sil=0.000> are <sil=0.000> having <sil=0.000> this <sil=0.000> one-dimensional <sil=0.000> array <sil=1.000> ,COMMA  right <sil=0.228> ?QUESTIONMARK 
Where <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> some <sil=0.000> say <sil=0.000> 1 dimensional <sil=0.000> array <sil=0.000> of <sil=0.000> integers <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  for <sil=0.000> n equal <sil=0.000> to <sil=0.000> 2 we <sil=0.000> can
have <sil=0.000> 2 dimensional <sil=0.000> arrays <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  where <sil=0.000> there <sil=0.000> will <sil=0.000> length <sil=0.000> and <sil=0.000> there <sil=0.000> will <sil=0.000> be <sil=0.000> a
breadth <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> array <sil=0.000> can <sil=0.000> be <sil=0.000> considered <sil=0.000> of <sil=0.000> consisting <sil=0.000> of <sil=0.000> a number <sil=0.000> of <sil=0.000> 1
dimensional <sil=0.000> arrays <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  as <sil=0.000> I am <sil=0.000> showing <sil=0.000> in <sil=0.000> this <sil=0.000> diagram <sil=0.000> I have <sil=0.000> got <sil=0.000> 2 dimensions
on <sil=0.000> this <sil=0.000> dimension <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> 4 rows <sil=0.000> on <sil=0.000> and <sil=0.000> on <sil=0.000> this <sil=0.000> dimension <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> sorry <sil=1.000> ,COMMA  this <sil=0.000> let <sil=0.000> me
draw <sil=0.000> it <sil=0.000> a fresh <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  on <sil=0.000> this <sil=0.000> side <sil=0.000> I have <sil=0.000> got <sil=0.000> 4 rows <sil=0.000> and <sil=1.000> ,COMMA  on <sil=0.000> this <sil=0.000> side <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> 1 2 <sil=0.000> 3 4 <sil=0.000> 5 6 <sil=0.000> positions <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
these <sil=0.000> are <sil=0.000> called <sil=0.000> columns <sil=0.000> and <sil=0.000> these <sil=0.000> are <sil=0.000> called <sil=0.000> rows <sil=1.000> ,COMMA  right <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  here <sil=0.000> I have <sil=0.000> got <sil=0.000> 2
dimensions <sil=0.000> one <sil=0.000> is <sil=0.000> the <sil=0.000> length <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> 6 or <sil=0.000> 6 columns <sil=0.000> and <sil=0.000> the <sil=0.000> breadth <sil=0.000> which <sil=0.000> is <sil=0.000> 4 rows
since <sil=1.000> ,COMMA  these <sil=0.000> 2 dimensions <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> a 2-dimensional <sil=0.000> array <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  a <sil=0.000> 2-dimensional <sil=0.000> array <sil=0.000> like <sil=0.000> this <sil=0.000> can <sil=0.000> be <sil=0.000> considered <sil=0.000> to <sil=0.000> be <sil=0.000> consisting <sil=0.000> of <sil=0.000> see <sil=0.000> in <sil=0.000> this <sil=0.000> case <sil=0.000> 4
1 <sil=0.000> dimensional <sil=0.000> arrays <sil=0.000> arrange <sil=0.000> one <sil=0.000> after <sil=0.000> another <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> one <sil=0.000> array <sil=1.000> ,COMMA  which <sil=0.000> we <sil=0.000> learnt <sil=0.000> till
now <sil=0.000> this <sil=0.000> is <sil=0.000> another <sil=0.000> array <sil=0.000> this <sil=0.000> part <sil=0.000> is <sil=0.000> another <sil=0.000> array <sil=0.000> this <sil=0.000> part <sil=0.000> is <sil=0.000> another <sil=0.000> array <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> have
got <sil=0.000> 4 different <sil=0.000> arrays <sil=0.000> 1 2 <sil=0.000> 3 4 <sil=1.000> ,COMMA  4 <sil=0.000> different <sil=0.000> arrays <sil=0.000> arranged <sil=0.000> one <sil=0.000> after <sil=0.000> another <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> have <sil=0.000> for <sil=0.000> n equal <sil=0.000> to <sil=0.000> 2 <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> rows <sil=0.000> and <sil=0.000> columns <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> get <sil=0.000> 2 dimensional
arrays <sil=2.000> .PERIOD  Similarly <sil=1.000> ,COMMA  for <sil=0.000> n equal <sil=0.000> to <sil=0.000> 3 we <sil=0.000> can <sil=0.000> have <sil=0.000> 3 dimensional <sil=0.000> arrays <sil=1.000> ,COMMA  like <sil=0.000> so <sil=0.000> I have <sil=0.000> got
one <sil=0.000> 2 dimensional <sil=0.000> arrays <sil=0.000> like <sil=0.000> this <sil=1.000> ,COMMA  and <sil=0.000> we <sil=0.000> can <sil=0.000> think <sil=0.000> of <sil=0.000> another <sil=0.000> 2 dimensional <sil=0.000> array <sil=0.000> line
here <sil=1.000> ,COMMA  another <sil=0.000> 2 dimensional <sil=0.000> array <sil=0.000> line <sil=0.000> here <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> way <sil=0.000> I can <sil=0.000> have <sil=0.000> an <sil=0.000> arrangement <sil=0.000> of <sil=0.000> say
may <sil=0.000> be <sil=0.000> 3 or <sil=0.000> 4 <sil=1.000> ,COMMA  2 <sil=0.000> dimensional <sil=0.000> arrays <sil=0.000> one <sil=0.000> after <sil=0.000> another <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> also <sil=0.000> an <sil=0.000> arrangement <sil=0.000> each <sil=0.000> of
these <sil=0.000> may <sil=0.000> be <sil=0.000> 4 rows <sil=0.000> and <sil=0.000> 6 columns <sil=1.000> ,COMMA  sorry <sil=0.000> may <sil=0.000> be <sil=0.000> like <sil=0.000> this <sil=0.000> 4 rows <sil=0.000> and <sil=0.000> 6 columns <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  this <sil=0.000> row <sil=0.000> this <sil=0.000> 3-dimensional <sil=0.000> array <sil=0.000> will <sil=0.000> be <sil=0.000> 4 rows <sil=0.000> 6 columns <sil=0.000> and <sil=0.000> 4 such <sil=1.000> ,COMMA  2 <sil=0.000> dimensional
arrays <sil=0.000> this <sil=0.000> is <sil=0.000> one <sil=0.000> 2-dimensional <sil=0.000> array <sil=0.000> this <sil=0.000> another <sil=0.000> 2-dimensional <sil=0.000> array <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> and <sil=0.000> this <sil=0.000> one
2-dimensional <sil=0.000> array <sil=0.000> and <sil=0.000> we <sil=0.000> have <sil=0.000> got <sil=0.000> 4 such <sil=0.000> 2-dimensional <sil=0.000> arrays <sil=0.000> arranged <sil=0.000> one <sil=0.000> after
another <sil=1.000> ,COMMA  right <sil=0.228> ?QUESTIONMARK  If <sil=0.000> I had <sil=0.000> a one <sil=0.000> more <sil=0.000> here <sil=1.000> ,COMMA  if <sil=0.000> I had <sil=0.000> one <sil=0.000> more <sil=0.000> here <sil=1.000> ,COMMA  same <sil=0.000> array <sil=0.000> then <sil=0.000> this
would <sil=0.000> be <sil=0.000> changed <sil=0.000> to <sil=0.000> 5 <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> way <sil=0.000> I can <sil=0.000> extend <sil=0.000> my <sil=0.000> concept <sil=0.000> of <sil=0.000> arranging <sil=0.000> data <sil=0.000> as <sil=0.000> we <sil=0.000> had

done <sil=0.000> for <sil=0.000> 1 dimensional <sil=0.000> array <sil=1.000> ,COMMA  we <sil=0.000> are <sil=0.000> extending <sil=0.000> it <sil=0.000> to <sil=0.000> 2 dimensions <sil=0.000> 3 dimensions <sil=0.000> in <sil=0.000> that
way <sil=1.000> ,COMMA  it <sil=0.000> be <sil=0.000> difficult <sil=0.000> to <sil=0.000> concept <sil=0.000> I mean <sil=0.000> show <sil=0.000> it <sil=0.000> on <sil=0.000> the <sil=0.000> this <sil=0.000> screen <sil=0.000> we <sil=0.000> can <sil=0.000> go <sil=0.000> up <sil=0.000> to <sil=0.000> n <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  n <sil=0.000> dimensional <sil=0.000> arrays <sil=1.000> ,COMMA  which <sil=0.000> will <sil=0.000> have <sil=0.000> different <sil=0.000> dimensions <sil=0.000> all <sil=0.000> together <sil=1.000> ,COMMA  but <sil=0.000> today <sil=0.000> we
will <sil=0.000> be <sil=0.000> just <sil=0.000> discussing <sil=0.000> about <sil=0.000> 2 dimensional <sil=0.000> arrays <sil=0.000> and <sil=0.000> the <sil=0.000> thing <sil=0.000> is <sil=0.000> quite <sil=0.000> general <sil=0.000> and <sil=0.000> can
be <sil=0.000> extended <sil=0.000> to <sil=0.000> other <sil=0.000> dimensional <sil=0.000> arrays <sil=0.000> also
So <sil=1.000> ,COMMA  we <sil=0.000> are <sil=0.000> now <sil=1.000> ,COMMA  talking <sil=0.000> about <sil=0.000> 2 dimensional <sil=0.000> arrays <sil=0.000> you <sil=0.000> can <sil=0.000> see <sil=0.000> the <sil=0.000> most <sil=0.000> common
example <sil=0.000> of <sil=0.000> 2-dimensional <sil=0.000> array <sil=0.000> is <sil=0.000> a table <sil=0.000> means <sil=0.000> an <sil=0.000> arrangement <sil=0.000> of <sil=0.000> data <sil=0.000> just <sil=0.000> like <sil=0.000> this <sil=2.000> .PERIOD 
This <sil=0.000> is <sil=0.000> list <sil=0.000> arrangement <sil=0.000> of <sil=0.000> information <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> a table <sil=1.000> ,COMMA  often <sil=0.000> we <sil=0.000> see <sil=0.000> table <sil=0.000> in <sil=0.000> other
forms <sil=0.000> also <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> have <sil=0.000> a table <sil=0.000> of <sil=0.000> something <sil=0.000> like <sil=0.000> this <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  the <sil=0.000> first <sil=0.000> here <sil=0.000> I put <sil=0.000> name <sil=0.000> of <sil=0.000> the <sil=0.000> boy <sil=1.000> ,COMMA  name <sil=0.000> of <sil=0.000> a student <sil=0.000> then <sil=0.000> I store <sil=0.000> age <sil=0.000> of <sil=0.000> a student <sil=1.000> ,COMMA 
school <sil=0.000> to <sil=0.000> which <sil=0.000> the <sil=0.000> student <sil=0.000> goes <sil=0.000> and <sil=0.000> address <sil=0.000> of <sil=0.000> the <sil=0.000> student <sil=0.000> may <sil=0.000> be <sil=1.000> ,COMMA  and <sil=0.000> I have <sil=0.000> got <sil=0.000> such
scope <sil=0.000> of <sil=0.000> keeping <sil=0.000> it <sil=0.000> for <sil=0.000> say <sil=0.000> 4 students <sil=0.000> one <sil=0.000> student <sil=0.000> number <sil=0.000> 1 <sil=1.000> ,COMMA  student <sil=0.000> number <sil=0.000> 2 <sil=1.000> ,COMMA  student
number <sil=0.000> 3 <sil=1.000> ,COMMA  student <sil=0.000> number <sil=0.000> of <sil=0.000> 4 and <sil=0.000> I go <sil=0.000> on <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> this <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> a table <sil=0.000> because <sil=1.000> ,COMMA  I
am <sil=0.000> organising <sil=0.000> them <sil=0.000> in <sil=0.000> a organised <sil=0.000> in <sil=0.000> a tabular <sil=0.000> form <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> a table <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> we <sil=0.000> were <sil=0.000> looking <sil=0.000> at <sil=0.000> now <sil=1.000> ,COMMA  is <sil=0.000> another <sil=0.000> table <sil=0.000> where <sil=0.000> here <sil=0.000> I am
showing <sil=0.000> that <sil=1.000> ,COMMA  there <sil=0.000> are <sil=0.000> 4 students <sil=0.000> student <sil=0.000> 1 <sil=1.000> ,COMMA  student <sil=0.000> 2 <sil=1.000> ,COMMA  student <sil=0.000> 3 <sil=1.000> ,COMMA  student <sil=0.000> 4 for <sil=0.000> each <sil=0.000> of <sil=0.000> the
students <sil=0.000> I have <sil=0.000> got <sil=0.000> some <sil=0.000> marks <sil=0.000> in <sil=0.000> the <sil=0.000> different <sil=0.000> subjects <sil=1.000> ,COMMA  subject <sil=0.000> 1 <sil=1.000> ,COMMA  subject <sil=0.000> 2 <sil=1.000> ,COMMA  subject <sil=0.000> 3 <sil=1.000> ,COMMA 
subject <sil=0.000> 4 and <sil=0.000> subject <sil=0.000> 5 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> consider <sil=0.000> that <sil=0.000> all <sil=0.000> the <sil=0.000> marks <sil=0.000> of <sil=0.000> student <sil=0.000> 1 in <sil=0.000> the <sil=0.000> different

subjects <sil=0.000> are <sil=0.000> stored <sil=0.000> in <sil=0.000> a row <sil=1.000> ,COMMA  this <sil=0.000> row <sil=0.000> for <sil=0.000> the <sil=0.000> first <sil=0.000> student <sil=0.000> similarly <sil=1.000> ,COMMA  this <sil=0.000> row <sil=0.000> for <sil=0.000> the <sil=0.000> 2nd
student <sil=1.000> ,COMMA  right <sil=0.228> ?QUESTIONMARK  Similarly <sil=1.000> ,COMMA  this <sil=0.000> row <sil=0.000> for <sil=0.000> the <sil=0.000> 3rd <sil=0.000> student <sil=0.000> and <sil=0.000> this <sil=0.000> row <sil=0.000> for <sil=0.000> the <sil=0.000> 4th <sil=0.000> student <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  each <sil=0.000> row <sil=0.000> wise <sil=0.000> I get <sil=0.000> the <sil=0.000> information <sil=0.000> of <sil=0.000> all <sil=0.000> students <sil=0.000> and <sil=0.000> column <sil=0.000> wise <sil=0.000> if <sil=0.000> I look <sil=0.000> in <sil=0.000> this
direction <sil=1.000> ,COMMA  what <sil=0.000> do <sil=0.000> I get <sil=0.000> in <sil=0.000> subject <sil=0.000> 1 what <sil=0.000> are <sil=0.000> the <sil=0.000> different <sil=0.000> marks <sil=0.228> ?QUESTIONMARK  And <sil=0.000> who <sil=0.000> have <sil=0.000> got
what <sil=0.000> marks <sil=0.228> ?QUESTIONMARK  And <sil=0.000> most <sil=0.000> interesting <sil=0.000> part <sil=0.000> is <sil=0.000> the <sil=0.000> intersection <sil=0.000> say <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  this <sil=0.000> element
of <sil=0.000> the <sil=0.000> array <sil=0.000> what <sil=0.000> will <sil=0.000> this <sil=0.000> element <sil=0.000> tell <sil=0.000> me <sil=1.000> ,COMMA  this <sil=0.000> element <sil=0.000> has <sil=0.000> is <sil=0.000> identified <sil=0.000> by <sil=0.000> it <sil=0.000> is <sil=0.000> row <sil=0.000> and
column <sil=1.000> ,COMMA  which <sil=0.000> row <sil=0.000> it <sil=0.000> is <sil=0.000> in <sil=0.000> and <sil=0.000> which <sil=0.000> column <sil=0.000> it <sil=0.000> is <sil=0.000> in <sil=1.000> ,COMMA  this <sil=0.000> element <sil=0.000> is <sil=0.000> 75 <sil=0.000> when <sil=0.000> what <sil=0.000> is <sil=0.000> the
meaning <sil=0.000> of <sil=0.000> this <sil=0.000> 75 <sil=0.000> is <sil=0.000> the <sil=0.000> student <sil=0.000> 2s <sil=0.000> sub <sil=0.000> marks <sil=0.000> of <sil=0.000> subject <sil=0.000> 2 <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> in <sil=0.000> whatever <sil=0.000> we <sil=0.000> tell <sil=0.000> you
can <sil=0.000> tell <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> the <sil=0.000> subject <sil=0.000> to <sil=0.000> marks <sil=0.000> of <sil=0.000> student <sil=0.000> 2 <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> the <sil=0.000> subject <sil=0.000> 3 marks <sil=0.000> of <sil=0.000> student <sil=0.000> 3 <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> way <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> represent <sil=0.000> any <sil=0.000> of <sil=0.000> these <sil=0.000> as <sil=0.000> identified <sil=0.000> by <sil=0.000> some <sil=0.000> row <sil=1.000> ,COMMA  name <sil=0.000> row
number <sil=0.000> and <sil=0.000> column <sil=0.000> number <sil=0.000> recall <sil=0.000> that <sil=1.000> ,COMMA  in <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> 1 dimensional <sil=0.000> array <sil=2.000> .PERIOD 

When <sil=0.000> we <sil=0.000> are <sil=0.000> talking <sil=0.000> of <sil=0.000> one <sil=0.000> dimensional <sil=0.000> array <sil=0.000> there <sil=0.000> we <sil=0.000> had <sil=0.000> indices <sil=0.000> index <sil=1.000> ,COMMA  right <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  that
index <sil=0.000> was <sil=0.000> telling <sil=0.000> us <sil=0.000> say <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  there <sil=0.000> are <sil=0.000> suppose <sil=0.000> these <sil=0.000> are <sil=0.000> marks <sil=0.000> again <sil=0.000> out <sil=0.000> of <sil=0.000> 10
alright <sil=1.000> ,COMMA  and <sil=0.000> I wanted <sil=0.000> to <sil=0.000> know <sil=0.000> what <sil=0.000> is <sil=0.000> the <sil=0.000> marks <sil=0.000> in <sil=0.000> subject <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> i value <sil=0.000> i equal <sil=0.000> to <sil=0.000> 0
was <sil=0.000> pointing <sil=0.000> me <sil=0.000> to <sil=0.000> this <sil=1.000> ,COMMA  suppose <sil=0.000> this <sil=0.000> is <sil=0.000> marks <sil=0.000> i value <sil=0.000> was <sil=0.000> showing <sil=0.000> this <sil=1.000> ,COMMA  if <sil=0.000> I take <sil=0.000> the <sil=0.000> i
value <sil=0.000> 1 <sil=1.000> ,COMMA  then <sil=0.000> I get <sil=0.000> the <sil=0.000> marks <sil=0.000> of <sil=0.000> this <sil=0.000> subject <sil=0.000> like <sil=0.000> that <sil=0.000> now <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> case <sil=0.000> in <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> 1 if <sil=0.000> I
wanted <sil=0.000> to <sil=0.000> have <sil=0.000> this <sil=0.000> element <sil=1.000> ,COMMA  that <sil=0.000> was <sil=0.000> identified <sil=0.000> by <sil=0.000> i value <sil=0.000> equal <sil=0.000> to <sil=0.000> 0 1 <sil=0.000> 2 3 <sil=0.000> 4 <sil=1.000> ,COMMA  but <sil=0.000> in <sil=0.000> the
case <sil=0.000> of <sil=0.000> a 2 <sil=0.000> dimensional <sil=0.000> array <sil=0.000> just <sil=0.000> as <sil=0.000> we <sil=0.000> are <sil=0.000> seeing <sil=0.000> here <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> be <sil=0.000> getting <sil=0.000> to <sil=0.000> a particular

element <sil=0.000> again <sil=0.000> in <sil=0.000> the <sil=0.000> same <sil=0.000> way <sil=0.000> with <sil=0.000> index <sil=1.000> ,COMMA  but <sil=0.000> here <sil=0.000> say <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  this <sil=0.000> element <sil=0.000> this
element <sil=0.000> here <sil=2.000> .PERIOD 
How <sil=0.000> do <sil=0.000> I identify <sil=0.000> this <sil=0.000> element <sil=0.228> ?QUESTIONMARK  This <sil=0.000> element <sil=0.000> will <sil=0.000> be <sil=0.000> identified <sil=0.000> by <sil=0.000> this <sil=0.000> row <sil=0.000> and <sil=0.000> this
column <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  my <sil=0.000> index <sil=0.000> while <sil=0.000> this <sil=0.000> was <sil=0.000> for <sil=0.000> one <sil=0.000> dimensional <sil=0.000> array <sil=0.000> the <sil=0.000> index <sil=0.000> was <sil=0.000> i <sil=1.000> ,COMMA  in <sil=0.000> this
case <sil=0.000> the <sil=0.000> index <sil=0.000> will <sil=0.000> be <sil=0.000> i and <sil=0.000> j <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  any <sil=0.000> pair <sil=0.000> i j <sil=0.000> pair <sil=0.000> will <sil=0.000> identify <sil=0.000> which <sil=0.000> row <sil=0.000> and <sil=0.000> which
column <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> particular <sil=0.000> element <sil=0.000> is <sil=0.000> determined <sil=0.000> by <sil=0.000> the <sil=0.000> i value <sil=0.000> again <sil=0.000> just <sil=0.000> because <sil=1.000> ,COMMA  it <sil=0.000> is
see <sil=0.000> I am <sil=0.000> saying <sil=0.000> that <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> starting <sil=0.000> from <sil=0.000> 0 1 <sil=0.000> 2 and <sil=0.000> here <sil=0.000> 0 1 <sil=0.000> 2 3 <sil=0.000> 4 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  say <sil=0.000> this <sil=0.000> element <sil=0.000> can
be <sil=0.000> identified <sil=0.000> by <sil=0.000> i is <sil=0.000> equal <sil=0.000> to <sil=0.000> 1 1 <sil=1.000> ,COMMA  right <sil=0.228> ?QUESTIONMARK  For <sil=0.000> example <sil=1.000> ,COMMA  this <sil=0.000> element <sil=0.000> this <sil=0.000> element <sil=0.000> is
identified <sil=0.000> by <sil=0.000> sorry <sil=1.000> ,COMMA  index <sil=0.000> value <sil=0.000> i j <sil=0.000> I am <sil=0.000> sorry <sil=0.000> here <sil=1.000> ,COMMA  the <sil=0.000> index <sil=0.000> is <sil=0.000> 1 1 <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  the <sil=0.000> i j <sil=0.000> pair <sil=0.000> a pair <sil=0.000> is <sil=0.000> 1 1 <sil=0.000> for <sil=0.000> this <sil=0.000> i should <sil=0.000> be <sil=0.000> 1 and <sil=0.000> j should <sil=0.000> be <sil=0.000> 3 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> pair <sil=0.000> is
identified <sil=0.000> by <sil=0.000> 1 <sil=1.000> ,COMMA  3 <sil=0.000> whenever <sil=0.000> I get <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  suppose <sil=0.000> here <sil=0.000> this <sil=0.000> array <sil=0.000> was <sil=0.000> marks <sil=1.000> ,COMMA  similarly <sil=0.000> I will
have <sil=0.000> an <sil=0.000> a name <sil=0.000> for <sil=0.000> this <sil=0.000> 2-dimensional <sil=0.000> array <sil=0.000> and <sil=0.000> I can <sil=0.000> access <sil=0.000> any <sil=0.000> element <sil=0.000> by <sil=0.000> this <sil=0.000> indices <sil=1.000> ,COMMA 
but <sil=0.000> in <sil=0.000> this <sil=0.000> case <sil=0.000> since <sil=0.000> it <sil=0.000> is <sil=0.000> a 2-dimensional <sil=0.000> array <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> 2 pointers <sil=0.000> 2 parts <sil=0.000> of <sil=0.000> this <sil=0.000> row
part <sil=0.000> and <sil=0.000> the <sil=0.000> column <sil=0.000> part <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> you <sil=0.000> can <sil=0.000> see <sil=0.000> that <sil=1.000> ,COMMA  the <sil=0.000> subjects <sil=0.000> are <sil=0.000> organised <sil=0.000> in <sil=0.000> this <sil=0.000> way
subject <sil=0.000> marks <sil=0.000> are <sil=0.000> organised <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=0.000> and <sil=0.000> we <sil=0.000> can <sil=0.000> access <sil=0.000> any <sil=0.000> of <sil=0.000> this <sil=0.000> elements <sil=0.000> using <sil=0.000> the
proper <sil=0.000> indexes <sil=0.000> student <sil=0.000> number <sil=0.000> and <sil=0.000> the <sil=0.000> subject <sil=0.000> number <sil=2.000> .PERIOD 

In <sil=0.000> the <sil=0.000> table <sil=0.000> that <sil=0.000> was <sil=0.000> shown <sil=0.000> here <sil=1.000> ,COMMA  a <sil=0.000> showing <sil=0.000> how <sil=0.000> many <sil=0.000> elements <sil=0.000> 1 2 <sil=0.000> 3 4 <sil=0.000> 5 into <sil=0.000> 420
elements <sil=1.000> ,COMMA  right <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  the <sil=0.000> table <sil=0.000> contains <sil=0.000> 20 <sil=0.000> values <sil=0.000> 5 in <sil=0.000> each <sil=0.000> line <sil=0.000> and <sil=0.000> it <sil=0.000> can <sil=0.000> be <sil=0.000> arranged
organises <sil=0.000> as <sil=0.000> a matrix <sil=0.000> 2-dimensional <sil=0.000> matrix <sil=0.000> consisting <sil=0.000> of <sil=0.000> 4 rows <sil=0.000> and <sil=0.000> 5 columns <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  C <sil=0.000> allows <sil=0.000> us <sil=0.000> to <sil=0.000> define <sil=0.000> such <sil=0.000> tables <sil=0.000> by <sil=0.000> using <sil=0.000> 2-dimensional <sil=0.000> array <sil=0.000> what <sil=0.000> does <sil=0.000> it <sil=0.000> mean <sil=1.000> ,COMMA 
the <sil=0.000> general <sil=0.000> form <sil=0.000> is <sil=0.000> like <sil=0.000> this <sil=0.000> type <sil=1.000> ,COMMA  array <sil=0.000> name <sil=1.000> ,COMMA  row <sil=0.000> size <sil=1.000> ,COMMA  column <sil=0.000> size <sil=2.000> .PERIOD  Always <sil=0.000> you
compare <sil=0.000> with <sil=0.000> what <sil=0.000> we <sil=0.000> learned <sil=0.000> for <sil=0.000> 1 dimensional <sil=0.000> array <sil=0.000> is <sil=0.000> just <sil=0.000> an <sil=0.000> extension <sil=0.000> of <sil=0.000> that <sil=1.000> ,COMMA  for
example <sil=1.000> ,COMMA  marks <sil=0.000> 4 5 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  in <sil=0.000> this <sil=0.000> case <sil=0.000> which <sil=0.000> we <sil=0.000> saw <sil=0.000> just <sil=0.000> now <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> an <sil=0.000> array <sil=0.000> with <sil=0.000> and <sil=0.000> let <sil=0.000> us
call <sil=0.000> this <sil=0.000> say <sil=1.000> ,COMMA  the <sil=0.000> name <sil=0.000> of <sil=0.000> this <sil=0.000> array <sil=0.000> is <sil=0.000> it <sil=0.000> also <sil=0.000> marks <sil=2.000> .PERIOD 

And <sil=0.000> marks <sil=0.000> has <sil=0.000> got <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> me <sil=0.000> write <sil=0.000> here <sil=1.000> ,COMMA  because <sil=0.000> it <sil=0.000> is <sil=0.000> marks <sil=0.000> and <sil=0.000> it <sil=0.000> has <sil=0.000> got <sil=0.000> 4 rows <sil=0.000> and <sil=0.000> it
has <sil=0.000> got <sil=0.000> 5 columns <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> how <sil=0.000> I can <sil=0.000> describe <sil=0.000> this <sil=0.000> array <sil=1.000> ,COMMA  and <sil=0.000> then <sil=0.000> we <sil=0.000> can <sil=0.000> go <sil=0.000> on <sil=0.000> filling

up <sil=0.000> the <sil=0.000> values <sil=0.000> of <sil=0.000> this <sil=0.000> array <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  array <sil=0.000> name <sil=1.000> ,COMMA  row <sil=0.000> size <sil=0.000> and <sil=0.000> column <sil=0.000> size <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  for <sil=0.000> example <sil=1.000> ,COMMA 
int <sil=0.000> marks <sil=1.000> ,COMMA  similarly <sil=0.000> I can <sil=0.000> have <sil=0.000> cells <sil=0.000> of <sil=0.000> 25 <sil=0.000> items <sil=0.000> over <sil=0.000> 12 <sil=0.000> marks <sil=0.000> may <sil=0.000> be <sil=0.000> say <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> have
something <sil=0.000> like <sil=1.000> ,COMMA  so <sil=0.000> let <sil=0.000> us <sil=0.000> try <sil=0.000> to <sil=0.000> see <sil=0.000> what <sil=0.000> this <sil=0.000> possibly <sil=0.000> can <sil=0.000> mean <sil=0.000> is <sil=0.000> that <sil=0.000> suppose <sil=0.000> I have <sil=0.000> got
a <sil=0.000> table <sil=0.000> where <sil=1.000> ,COMMA  there <sil=0.000> are <sil=0.000> 12 <sil=0.000> rows <sil=0.000> alright <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> have <sil=0.000> 12 <sil=0.000> rows <sil=0.000> here <sil=0.000> and <sil=0.000> there <sil=0.000> will <sil=0.000> be <sil=0.000> 25
columns <sil=0.000> here <sil=0.000> alright <sil=1.000> ,COMMA  there <sil=0.000> will <sil=0.000> be <sil=0.000> 300 <sil=0.000> items <sil=0.000> so <sil=0.000> I am <sil=0.000> not <sil=0.000> showing <sil=0.000> that <sil=2.000> .PERIOD 
But <sil=0.000> say <sil=0.000> each <sil=0.000> of <sil=0.000> these <sil=0.000> rows <sil=0.000> may <sil=0.000> mean <sil=0.000> say <sil=0.000> this <sil=0.000> is <sil=0.000> January <sil=0.000> row <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> a February <sil=0.000> row <sil=1.000> ,COMMA  this
is <sil=0.000> a march <sil=0.000> row <sil=0.000> etc <sil=1.000> ,COMMA  and <sil=0.000> suppose <sil=0.000> here <sil=0.000> there <sil=0.000> are <sil=0.000> different <sil=0.000> items <sil=0.000> or <sil=0.000> shop <sil=0.000> has <sil=0.000> got <sil=0.000> different
items <sil=0.000> and <sil=0.000> in <sil=0.000> that <sil=0.000> way <sil=0.000> it <sil=0.000> has <sil=0.000> got <sil=0.000> 25 <sil=0.000> different <sil=0.000> items <sil=0.000> and <sil=0.000> here <sil=2.000> .PERIOD  We <sil=0.000> write <sil=0.000> how <sil=0.000> many <sil=0.000> units <sil=0.000> of
a <sil=0.000> particular <sil=0.000> this <sil=0.000> row <sil=0.000> is <sil=0.000> shirts <sil=0.000> alright <sil=1.000> ,COMMA  this <sil=0.000> one <sil=0.000> says <sil=0.000> that <sil=1.000> ,COMMA  in <sil=0.000> the <sil=0.000> month <sil=0.000> of <sil=0.000> February <sil=0.000> how
many <sil=0.000> shirts <sil=0.000> have <sil=0.000> been <sil=0.000> sold <sil=0.000> and <sil=0.000> may <sil=0.000> be <sil=0.000> this <sil=0.000> says <sil=0.000> in <sil=0.000> the <sil=0.000> month <sil=0.000> of <sil=0.000> say <sil=0.000> this <sil=0.000> is <sil=0.000> pen <sil=0.000> in <sil=0.000> the
month <sil=0.000> of <sil=0.000> January <sil=0.000> or <sil=0.000> in <sil=0.000> the <sil=0.000> month <sil=0.000> of <sil=0.000> January <sil=0.000> how <sil=0.000> many <sil=0.000> pens <sil=0.000> have <sil=0.000> been <sil=0.000> sold <sil=0.228> ?QUESTIONMARK 
So <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> way <sil=0.000> this <sil=0.000> entire <sil=0.000> matrix <sil=0.000> or <sil=0.000> this <sil=0.000> array <sil=0.000> can <sil=0.000> be <sil=0.000> named <sil=0.000> as <sil=0.000> the <sil=0.000> arrays <sil=0.000> cells <sil=1.000> ,COMMA  which
will <sil=0.000> have <sil=0.000> 12 <sil=0.000> rows <sil=0.000> and <sil=0.000> 25 <sil=0.000> columns <sil=1.000> ,COMMA  similarly <sil=0.000> and <sil=0.000> another <sil=0.000> very <sil=0.000> important <sil=0.000> thing <sil=0.000> to <sil=0.000> note <sil=0.000> is
this <sil=0.000> type <sil=1.000> ,COMMA  this <sil=0.000> type <sil=0.000> that <sil=0.000> we <sil=0.000> declared <sil=0.000> also <sil=0.000> in <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> 1 dimensional <sil=0.000> array <sil=0.000> is <sil=0.000> also
applicable <sil=0.000> here <sil=1.000> ,COMMA  because <sil=0.000> each <sil=0.000> of <sil=0.000> these <sil=0.000> elements <sil=0.000> in <sil=0.000> this <sil=0.000> array <sil=0.000> will <sil=0.000> be <sil=0.000> of <sil=0.000> the <sil=0.000> same <sil=0.000> type <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
here <sil=0.000> cells <sil=0.000> I am <sil=0.000> saying <sil=0.000> and <sil=0.000> I have <sil=0.000> said <sil=0.000> cells <sil=0.000> is <sil=0.000> float <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  the <sil=0.000> way <sil=0.000> I wrote <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> correct <sil=0.000> I should <sil=0.000> write <sil=0.000> it <sil=0.000> as <sil=0.000> say <sil=1.000> ,COMMA  how <sil=0.000> many <sil=0.000> elements <sil=0.000> are
there <sil=0.228> ?QUESTIONMARK  What <sil=0.000> it <sil=0.000> can <sil=0.000> be <sil=0.000> that <sil=0.000> in <sil=0.000> the <sil=0.000> month <sil=0.000> of <sil=0.000> January <sil=0.228> ?QUESTIONMARK  What <sil=0.000> is <sil=0.000> the <sil=0.000> worth <sil=0.000> of <sil=0.000> not <sil=0.000> how <sil=0.000> many
shirts <sil=0.000> were <sil=0.000> sold <sil=0.228> ?QUESTIONMARK  But <sil=1.000> ,COMMA  shirts <sil=0.000> worth <sil=0.000> how <sil=0.000> many <sil=0.000> rupees <sil=0.000> were <sil=0.000> sold <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> can <sil=0.000> be <sil=0.000> here <sil=0.000> 100 <sil=2.000> .PERIOD <sil=0.000> 5
say <sil=0.000> because <sil=1.000> ,COMMA  each <sil=0.000> of <sil=0.000> these <sil=0.000> elements <sil=0.000> have <sil=0.000> floating <sil=0.000> point <sil=0.000> numbers <sil=1.000> ,COMMA  alright <sil=0.228> ?QUESTIONMARK  Similarly <sil=1.000> ,COMMA 
matrix <sil=0.000> can <sil=0.000> be <sil=0.000> a 100 <sil=0.000> by <sil=0.000> 100 <sil=0.000> matrix <sil=0.000> where <sil=1.000> ,COMMA  each <sil=0.000> of <sil=0.000> the <sil=0.000> elements <sil=0.000> will <sil=0.000> there <sil=0.000> double
precision <sil=0.000> number <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> got <sil=0.000> 2 places <sil=1.000> ,COMMA  2 <sil=0.000> dimensions <sil=0.000> that <sil=0.000> we <sil=0.000> are <sil=0.000> specifying <sil=0.000> here <sil=2.000> .PERIOD 

Unlike <sil=0.000> what <sil=0.000> we <sil=0.000> did <sil=0.000> in <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> a 1-dimensional <sil=0.000> array <sil=0.000> where <sil=1.000> ,COMMA  we <sil=0.000> did <sil=0.000> something <sil=0.000> like <sil=0.000> int
marks <sil=0.000> say <sil=0.000> 5 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  int <sil=0.000> marks <sil=0.000> 5 is <sil=0.000> a 1-dimensional <sil=0.000> array <sil=0.000> with <sil=0.000> 5 elements <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> say <sil=0.000> that
these <sil=0.000> are <sil=0.000> with <sil=0.000> 5 columns <sil=0.000> of <sil=0.000> this <sil=0.000> 1-dimensional <sil=0.000> array <sil=1.000> ,COMMA  which <sil=0.000> is <sil=0.000> 1 row <sil=0.000> had <sil=0.000> there <sil=0.000> been <sil=0.000> more
rows <sil=0.000> like <sil=0.000> this <sil=1.000> ,COMMA  then <sil=0.000> immediately <sil=0.000> I have <sil=0.000> to <sil=0.000> identify <sil=0.000> which <sil=0.000> row <sil=0.000> and <sil=0.000> which <sil=0.000> column <sil=0.000> and <sil=0.000> if
there <sil=0.000> be <sil=0.000> 2 such <sil=0.000> rows <sil=1.000> ,COMMA  then <sil=0.000> this <sil=0.000> array <sil=0.000> should <sil=0.000> be <sil=0.000> described <sil=0.000> as <sil=0.000> int <sil=0.000> marks <sil=0.000> say <sil=0.000> here <sil=1.000> ,COMMA  2 <sil=0.000> 5
because <sil=1.000> ,COMMA  they <sil=0.000> are <sil=0.000> rows <sil=2.000> .PERIOD 

Similar <sil=0.000> to <sil=0.000> that <sil=0.000> of <sil=0.000> 1 dimensional <sil=0.000> array <sil=1.000> ,COMMA  but <sil=0.000> we <sil=0.000> use <sil=0.000> 2 indices <sil=1.000> ,COMMA  indices <sil=0.000> is <sil=0.000> the <sil=0.000> plural <sil=0.000> of <sil=0.000> index
indices <sil=1.000> ,COMMA  right <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  the <sil=0.000> first <sil=0.000> one <sil=0.000> indicates <sil=0.000> the <sil=0.000> row <sil=0.000> and <sil=0.000> the <sil=0.000> second <sil=0.000> one <sil=0.000> indicates <sil=0.000> the <sil=0.000> column
both <sil=0.000> the <sil=0.000> indices <sil=0.000> should <sil=0.000> be <sil=0.000> expressions <sil=0.000> which <sil=1.000> ,COMMA  evaluate <sil=0.000> to <sil=0.000> integer <sil=0.000> values <sil=0.000> and <sil=0.000> that <sil=0.000> was <sil=0.000> the
case <sil=0.000> for <sil=0.000> 1 dimensional <sil=0.000> arrays <sil=0.000> also <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> I have <sil=0.000> something <sil=0.000> like <sil=0.000> marks <sil=0.000> 2 5 <sil=0.000> these <sil=0.000> integer <sil=1.000> ,COMMA 
these <sil=0.000> values <sil=0.000> must <sil=0.000> be <sil=0.000> integers <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> write <sil=0.000> expressions <sil=0.000> we <sil=0.000> will <sil=0.000> show <sil=0.000> there <sil=0.000> later <sil=1.000> ,COMMA  but <sil=0.000> those
expressions <sil=0.000> must <sil=0.000> evaluate <sil=0.000> to <sil=0.000> integer <sil=0.000> values <sil=1.000> ,COMMA  alright <sil=0.228> ?QUESTIONMARK 

Examples <sil=0.000> are <sil=0.000> x m <sil=0.000> n 0 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  whatever <sil=0.000> m value <sil=0.000> is <sil=0.000> m has <sil=0.000> to <sil=0.000> be <sil=0.000> an <sil=0.000> integer <sil=1.000> ,COMMA  suppose <sil=0.000> m here <sil=0.000> is
2 <sil=0.000> and <sil=0.000> n is <sil=0.000> 1 <sil=1.000> ,COMMA  then <sil=0.000> in <sil=0.000> this <sil=0.000> array <sil=0.000> whose <sil=0.000> name <sil=0.000> is <sil=0.000> x we <sil=0.000> have <sil=0.000> got <sil=0.000> a number <sil=0.000> of <sil=0.000> rows <sil=0.000> and <sil=0.000> a
number <sil=0.000> of <sil=0.000> columns <sil=1.000> ,COMMA  which <sil=0.000> element <sil=0.000> am <sil=0.000> I referring <sil=0.000> to <sil=0.000> here <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> referring <sil=0.000> to <sil=0.000> row <sil=0.000> to <sil=0.000> 0 1 <sil=0.000> 2
3 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> referring <sil=0.000> to <sil=0.000> this <sil=0.000> row <sil=0.000> and <sil=0.000> which <sil=0.000> column <sil=0.000> I am <sil=0.000> referring <sil=0.000> to <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> was <sil=0.000> 0 1 <sil=0.000> 2
3 <sil=0.000> 4 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> referring <sil=0.000> to <sil=0.000> this <sil=0.000> column <sil=0.000> therefore <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> actually <sil=0.000> pointing <sil=0.000> at <sil=0.000> this <sil=0.000> particular
element <sil=1.000> ,COMMA  alright <sil=0.228> ?QUESTIONMARK  This <sil=0.000> particular <sil=0.000> element <sil=2.000> .PERIOD 

Similarly <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> do <sil=0.000> operations <sil=0.000> like <sil=0.000> this <sil=0.000> what <sil=0.000> does <sil=0.000> this <sil=0.000> mean <sil=0.000> let <sil=0.000> us <sil=0.000> try <sil=0.000> to <sil=0.000> understands <sil=0.000> this
means <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> I am <sil=0.000> referring <sil=0.000> to <sil=0.000> 3 different <sil=0.000> 2-dimensional <sil=0.000> arrays <sil=0.000> one <sil=0.000> is <sil=0.000> a <sil=1.000> ,COMMA  which <sil=0.000> has <sil=0.000> got
some <sil=0.000> rows <sil=0.000> and <sil=0.000> columns <sil=0.000> and <sil=0.000> these <sil=0.000> another <sil=0.000> array <sil=0.000> this <sil=0.000> is <sil=0.000> a this <sil=0.000> is <sil=0.000> b and <sil=0.000> I have <sil=0.000> got <sil=0.000> another
array <sil=0.000> c <sil=2.000> .PERIOD  <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> taking <sil=0.000> what <sil=0.000> is <sil=0.000> being <sil=0.000> done <sil=0.000> here <sil=1.000> ,COMMA  this <sil=0.000> means <sil=0.000> c i <sil=0.000> k <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> c is <sil=0.000> being <sil=0.000> designated
by <sil=0.000> an <sil=0.000> index <sil=0.000> i <sil=1.000> ,COMMA  another <sil=0.000> index <sil=0.000> k this <sil=0.000> one <sil=0.000> is <sil=0.000> being <sil=0.000> done <sil=0.000> by <sil=0.000> referred <sil=0.000> by <sil=0.000> i and <sil=0.000> some <sil=0.000> j this <sil=0.000> 1 by
j <sil=0.000> and <sil=0.000> k what <sil=0.000> is <sil=0.000> being <sil=0.000> done <sil=0.000> here <sil=1.000> ,COMMA  that <sil=0.000> for <sil=0.000> different <sil=0.000> values <sil=0.000> of <sil=0.000> i j <sil=0.000> and <sil=0.000> k <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> selecting <sil=0.000> this
has <sil=0.000> got <sil=0.000> a special <sil=0.000> application <sil=1.000> ,COMMA  but <sil=0.000> I am <sil=0.000> not <sil=0.000> going <sil=0.000> to <sil=0.000> that <sil=0.000> I am <sil=0.000> looking <sil=0.000> at <sil=0.000> taking <sil=0.000> at <sil=0.000> the
taking <sil=0.000> a particular <sil=0.000> value <sil=0.000> from <sil=0.000> here <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> c i <sil=0.000> and <sil=0.000> c k <sil=0.000> k is <sil=0.000> pointing <sil=0.000> here <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  this <sil=0.000> one <sil=0.000> I am <sil=0.000> taking <sil=0.000> and <sil=0.000> adding <sil=0.000> that <sil=1.000> ,COMMA  with <sil=0.000> the <sil=0.000> product <sil=0.000> of <sil=0.000> a i <sil=0.000> and <sil=0.000> j <sil=1.000> ,COMMA  j <sil=0.000> might <sil=0.000> be <sil=0.000> pointing
somewhere <sil=0.000> here <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> taking <sil=0.000> this <sil=0.000> element <sil=0.000> and <sil=0.000> I am <sil=0.000> taking <sil=0.000> may <sil=0.000> be <sil=0.000> b j <sil=0.000> for <sil=0.000> b array <sil=0.000> j row <sil=0.000> I
am <sil=0.000> sorry <sil=1.000> ,COMMA  j <sil=0.000> row <sil=0.000> j should <sil=0.000> be <sil=0.000> here <sil=1.000> ,COMMA  j <sil=0.000> row <sil=0.000> and <sil=0.000> k column <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> taking <sil=0.000> another <sil=0.000> element
from <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> taking <sil=0.000> this <sil=0.000> element <sil=0.000> multiplied <sil=0.000> by <sil=0.000> this <sil=0.000> element <sil=0.000> here <sil=1.000> ,COMMA  and <sil=0.000> adding <sil=0.000> that
with <sil=0.000> this <sil=0.000> element <sil=0.000> that <sil=0.000> is <sil=0.000> taken <sil=0.000> from <sil=0.000> c <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> what <sil=0.000> I am <sil=0.000> doing <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> simple <sil=0.000> example <sil=1.000> ,COMMA 
but <sil=0.000> this <sil=0.000> has <sil=0.000> got <sil=0.000> for <sil=0.000> mode <sil=0.000> implication <sil=0.000> you <sil=0.000> will <sil=0.000> realise <sil=0.000> that <sil=0.000> soon <sil=2.000> .PERIOD 

Here <sil=0.000> you <sil=0.000> see <sil=1.000> ,COMMA  what <sil=0.000> we <sil=0.000> have <sil=0.000> done <sil=0.000> here <sil=0.000> why <sil=0.000> is <sil=0.000> this <sil=0.000> example <sil=0.000> shown <sil=0.000> here <sil=1.000> ,COMMA  you <sil=0.000> see <sil=0.000> we <sil=0.000> are
specifying <sil=0.000> the <sil=0.000> index <sil=0.000> in <sil=0.000> the <sil=0.000> form <sil=0.000> of <sil=0.000> an <sil=0.000> expression <sil=1.000> ,COMMA  suppose <sil=0.000> j was <sil=0.000> 2 and <sil=0.000> here <sil=1.000> ,COMMA  which <sil=0.000> one <sil=0.000> I
am <sil=0.000> referring <sil=0.000> to <sil=0.000> a j <sil=0.000> into <sil=0.000> 2 so <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  a <sil=0.000> 6 followed <sil=0.000> by <sil=0.000> whatever <sil=0.000> value <sil=0.000> of <sil=0.000> k was <sil=0.000> might
be <sil=0.000> 6 2 <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> referring <sil=0.000> to <sil=0.000> the <sil=0.000> element <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=0.000> a <sil=1.000> ,COMMA  a <sil=0.000> is <sil=0.000> an <sil=0.000> array <sil=0.000> whose <sil=0.000> 7th
row <sil=0.000> and <sil=0.000> 3rd <sil=0.000> column <sil=0.000> element <sil=0.000> is <sil=0.000> being <sil=0.000> taken <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  if <sil=0.000> this <sil=0.000> be <sil=0.000> like <sil=0.000> this <sil=0.000> I am <sil=0.000> taking <sil=0.000> this <sil=0.000> 7th <sil=0.000> row <sil=0.000> element <sil=0.000> and <sil=0.000> 2nd <sil=0.000> or <sil=0.000> 3rd <sil=0.000> column <sil=0.000> element <sil=1.000> ,COMMA  I
am <sil=0.000> taking <sil=0.000> that <sil=0.000> value <sil=0.000> and <sil=0.000> finding <sil=0.000> this <sil=0.000> square <sil=0.000> root <sil=0.000> of <sil=0.000> that <sil=1.000> ,COMMA  and <sil=0.000> that <sil=0.000> is <sil=0.000> again <sil=0.000> being <sil=0.000> put <sil=0.000> to <sil=0.000> the
corresponding <sil=0.000> value <sil=0.000> of <sil=0.000> that <sil=1.000> ,COMMA  is <sil=0.000> coming <sil=0.000> to <sil=0.000> some <sil=0.000> other <sil=0.000> variable <sil=0.000> name <sil=0.000> actually <sil=0.000> this <sil=0.000> should
be <sil=0.000> since <sil=1.000> ,COMMA  this <sil=0.000> an <sil=0.000> array <sil=0.000> this <sil=0.000> should <sil=0.000> have <sil=0.000> been <sil=0.000> kept <sil=0.000> as <sil=0.000> some <sil=0.000> other <sil=0.000> variable <sil=0.000> in <sil=0.000> b <sil=1.000> ,COMMA  alright <sil=0.228> ?QUESTIONMARK 

So <sil=1.000> ,COMMA  how <sil=0.000> is <sil=0.000> 2 dimensional <sil=0.000> arrays <sil=0.000> stored <sil=0.000> in <sil=0.000> memory <sil=0.000> we <sil=0.000> know <sil=0.000> that <sil=1.000> ,COMMA  a <sil=0.000> 1-dimensional <sil=0.000> array
is <sil=0.000> stored <sil=0.000> in <sil=0.000> a memory <sil=0.000> row <sil=0.000> I mean <sil=0.000> in <sil=0.000> the <sil=0.000> contiguous <sil=0.000> memory <sil=0.000> locations <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  just <sil=0.000> for <sil=0.000> the <sil=0.000> sake <sil=0.000> of <sil=0.000> recalling <sil=0.000> if <sil=0.000> we <sil=0.000> had <sil=1.000> ,COMMA  if <sil=0.000> I have <sil=0.000> a 1 <sil=0.000> dimensional <sil=0.000> array <sil=0.000> say <sil=0.000> 3 5 <sil=0.000> 4 7 <sil=1.000> ,COMMA 
they <sil=0.000> were <sil=0.000> being <sil=0.000> mapped <sil=0.000> to <sil=0.000> the <sil=0.000> memory <sil=0.000> actual <sil=0.000> memory <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> the <sil=0.000> memory <sil=0.000> location <sil=0.000> the
different <sil=0.000> memory <sil=0.000> locations <sil=0.000> and <sil=0.000> I am <sil=0.000> storing <sil=0.000> them <sil=0.000> here <sil=1.000> ,COMMA  3 <sil=0.000> 5 4 <sil=0.000> 7 in <sil=0.000> contiguous <sil=0.000> locations <sil=1.000> ,COMMA 
but <sil=0.000> what <sil=0.000> happens <sil=0.000> to <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> 2 dimensional <sil=0.000> array <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  if <sil=0.000> I have <sil=0.000> the <sil=0.000> array <sil=0.000> that <sil=0.000> I
am <sil=0.000> drawing <sil=0.000> here <sil=1.000> ,COMMA  with <sil=0.000> 3 rows <sil=0.000> and <sil=0.000> 2 columns <sil=1.000> ,COMMA  alright <sil=0.228> ?QUESTIONMARK 

So <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> the <sil=0.000> dimension <sil=0.000> of <sil=0.000> this <sil=0.000> array <sil=0.000> a <sil=1.000> ,COMMA  a <sil=0.000> is <sil=0.000> 3 2 <sil=0.000> 3 rows <sil=0.000> and <sil=0.000> 2 columns <sil=0.000> now <sil=1.000> ,COMMA  suppose <sil=0.000> it
is <sil=0.000> 1 7 <sil=0.000> 5 3 <sil=0.000> 2 0 <sil=0.000> say <sil=0.000> those <sil=0.000> are <sil=0.000> the <sil=0.000> values <sil=0.000> in <sil=0.000> that <sil=1.000> ,COMMA  case <sil=0.000> if <sil=0.000> I stored <sil=0.000> it <sil=0.000> in <sil=0.000> the <sil=0.000> memory <sil=0.000> I can <sil=0.000> stored
it <sil=0.000> now <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> drawing <sil=0.000> how <sil=0.000> it <sil=0.000> can <sil=0.000> be <sil=0.000> stored <sil=0.000> in <sil=0.000> the <sil=0.000> memory <sil=0.000> I need <sil=0.000> 1 2 <sil=0.000> 3 4 <sil=0.000> 5 6 <sil=0.000> locations <sil=0.000> in
the <sil=0.000> memory <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> have <sil=0.000> 6 locations <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> store <sil=0.000> them <sil=0.000> 1 5 <sil=0.000> 2 7 <sil=0.000> 3 0 <sil=0.000> or <sil=0.000> I can <sil=0.000> store
them <sil=0.000> as <sil=0.000> 1 7 <sil=0.000> 5 3 <sil=0.000> 2 0 <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> a difference <sil=0.000> between <sil=0.000> these <sil=0.000> 2 storages <sil=0.000> this <sil=0.000> one <sil=0.000> is <sil=0.000> I am
storing <sil=0.000> them <sil=0.000> column <sil=0.000> wise <sil=0.000> and <sil=1.000> ,COMMA  in <sil=0.000> this <sil=0.000> case <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> storing <sil=0.000> them <sil=0.000> row <sil=0.000> wise <sil=0.000> row <sil=0.000> after <sil=0.000> row <sil=1.000> ,COMMA 
right <sil=0.228> ?QUESTIONMARK 
In <sil=0.000> c the <sil=0.000> compiler <sil=0.000> stores <sil=0.000> the <sil=0.000> arrays <sil=0.000> row <sil=0.000> wise <sil=1.000> ,COMMA  which <sil=0.000> is <sil=0.000> often <sil=0.000> known <sil=0.000> as <sil=0.000> in <sil=0.000> the <sil=0.000> row <sil=0.000> major
form <sil=0.000> and <sil=0.000> this <sil=0.000> is <sil=0.000> the <sil=0.000> column <sil=0.000> major <sil=0.000> form <sil=1.000> ,COMMA  but <sil=0.000> in <sil=0.000> c we <sil=0.000> are <sil=0.000> doing <sil=0.000> it <sil=0.000> in <sil=0.000> row <sil=0.000> major <sil=0.000> form <sil=0.000> there
is <sil=0.000> a specific <sil=0.000> significance <sil=0.000> of <sil=0.000> this <sil=2.000> .PERIOD  Because <sil=1.000> ,COMMA  whenever <sil=0.000> I want <sil=0.000> to <sil=0.000> access <sil=0.000> an <sil=0.000> element <sil=0.000> say <sil=0.000> a
array <sil=1.000> ,COMMA  I <sil=0.000> want <sil=0.000> to <sil=0.000> find <sil=0.000> the <sil=0.000> particular <sil=0.000> element <sil=0.000> say <sil=0.000> 2 3 <sil=1.000> ,COMMA  which <sil=0.000> element <sil=0.000> shall <sil=0.000> I find <sil=0.000> out <sil=0.000> here
for <sil=0.000> example <sil=1.000> ,COMMA  here <sil=0.000> let <sil=0.000> us <sil=0.000> take <sil=0.000> this <sil=0.000> case <sil=0.000> and <sil=0.000> let <sil=0.000> me <sil=0.000> try <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> element <sil=0.000> say <sil=0.000> A this <sil=0.000> is
A <sil=0.000> capital <sil=0.000> A I <sil=0.000> want <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> element <sil=0.000> 2 1 <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> actually <sil=0.000> trying <sil=0.000> to <sil=0.000> find <sil=0.000> out
the <sil=0.000> row <sil=0.000> number <sil=0.000> 2 and <sil=0.000> element <sil=0.000> number <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> trying <sil=0.000> to <sil=0.000> find <sil=0.000> this <sil=0.000> one <sil=0.000> out <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA 
where <sil=0.000> will <sil=0.000> it <sil=0.000> be <sil=0.000> if <sil=0.000> I do <sil=0.000> not <sil=0.000> know <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  say <sil=0.000> this <sil=0.000> is <sil=0.000> accidentally <sil=0.000> I came <sil=0.000> coming <sil=0.000> to <sil=0.000> the <sil=0.000> same
let <sil=0.000> us <sil=0.000> say <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> make <sil=0.000> this <sil=0.000> 1 1 <sil=0.000> 1 <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  which <sil=0.000> one <sil=0.000> row <sil=0.000> 1 column <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am
actually <sil=0.000> trying <sil=0.000> to <sil=0.000> find <sil=0.000> this <sil=0.000> element <sil=0.000> 3 <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> this <sil=0.000> element <sil=1.000> ,COMMA  where <sil=0.000> is <sil=0.000> it <sil=0.000> stored <sil=0.000> you <sil=0.000> can <sil=0.000> see <sil=0.000> that <sil=0.000> 3 has <sil=0.000> been
stored <sil=0.000> here <sil=0.000> if <sil=0.000> I store <sil=0.000> in <sil=0.000> the <sil=0.000> column <sil=0.000> major <sil=0.000> form <sil=1.000> ,COMMA  but <sil=0.000> if <sil=0.000> I store <sil=0.000> in <sil=0.000> the <sil=0.000> row <sil=0.000> major <sil=0.000> form <sil=0.000> it <sil=0.000> is

here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  whenever <sil=0.000> I am <sil=0.000> trying <sil=0.000> to <sil=0.000> find <sil=0.000> this <sil=0.000> element <sil=0.000> out <sil=0.000> of <sil=0.000> this <sil=0.000> memory <sil=0.000> representation <sil=0.000> I
will <sil=0.000> actually <sil=0.000> have <sil=0.000> to <sil=0.000> fetch <sil=0.000> it <sil=0.000> from <sil=0.000> the <sil=0.000> memory <sil=1.000> ,COMMA  right <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  therefore <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> the
address <sil=0.000> of <sil=0.000> this <sil=0.000> and <sil=0.000> for <sil=0.000> that <sil=1.000> ,COMMA  I <sil=0.000> need <sil=0.000> to <sil=0.000> know <sil=0.000> where <sil=0.000> it <sil=0.000> is <sil=0.000> stored <sil=0.000> row <sil=0.000> wise <sil=0.000> or <sil=0.000> column <sil=0.000> wise
since <sil=1.000> ,COMMA  I <sil=0.000> know <sil=0.000> it <sil=0.000> is <sil=0.000> row <sil=0.000> wise <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  how <sil=0.000> should <sil=0.000> I go <sil=0.000> about <sil=0.000> it <sil=0.000> since <sil=1.000> ,COMMA  there <sil=0.000> are <sil=0.000> 2 columns <sil=1.000> ,COMMA  so <sil=0.000> for <sil=0.000> the <sil=0.000> first <sil=0.000> row <sil=0.000> I will <sil=0.000> say
that <sil=1.000> ,COMMA  if <sil=0.000> this <sil=0.000> been <sil=0.000> my <sil=0.000> starting <sil=0.000> address <sil=0.000> 1000 <sil=0.000> in <sil=0.000> the <sil=0.000> first <sil=0.000> row <sil=0.000> we <sil=0.000> will <sil=0.000> take <sil=0.000> 1000 <sil=0.000> and <sil=0.000> 1000
this <sil=0.000> is <sil=0.000> starting <sil=0.000> from <sil=0.000> 1002 <sil=1.000> ,COMMA  alright <sil=0.228> ?QUESTIONMARK  This <sil=0.000> is <sil=0.000> the <sil=0.000> first <sil=0.000> row <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> the <sil=0.000> second <sil=0.000> row <sil=1.000> ,COMMA  and <sil=0.000> this
means <sil=0.000> the <sil=0.000> second-row <sil=0.000> part <sil=0.000> and <sil=0.000> second <sil=0.000> rows <sil=0.000> this <sil=0.000> is <sil=0.000> one <sil=0.000> what <sil=0.000> is <sil=0.000> this <sil=0.000> element <sil=0.000> 5 <sil=1.000> ,COMMA  this <sil=0.000> is
second <sil=0.000> row <sil=0.000> and <sil=0.000> 0th <sil=0.000> element <sil=0.000> and <sil=0.000> this <sil=0.000> one <sil=0.000> is <sil=0.000> second <sil=0.000> row <sil=0.000> and <sil=0.000> then <sil=0.000> the <sil=0.000> next <sil=0.000> element <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> 1 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  using <sil=0.000> knowing <sil=0.000> that <sil=1.000> ,COMMA  whether <sil=0.000> it <sil=0.000> is <sil=0.000> stored <sil=0.000> in <sil=0.000> the <sil=0.000> row <sil=0.000> major <sil=0.000> form <sil=0.000> or <sil=0.000> column
major <sil=0.000> form <sil=0.000> is <sil=0.000> very <sil=0.000> essential <sil=0.000> in <sil=0.000> order <sil=0.000> that <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> the <sil=0.000> element <sil=0.000> in <sil=0.000> a 2-
dimensional <sil=0.000> array <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> continue <sil=0.000> this <sil=0.000> further <sil=0.000> more <sil=0.000> explanations <sil=0.000> are <sil=0.000> required <sil=0.000> about
this <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  we <sil=0.000> were <sil=0.000> discussing <sil=0.000> that <sil=0.000> how <sil=0.000> a 2 <sil=0.000> dimensional <sil=0.000> array <sil=0.000> is <sil=0.000> stored <sil=0.000> in <sil=0.000> the <sil=0.000> memory <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> already <sil=0.000> said <sil=0.000> that <sil=0.000> that <sil=0.000> is <sil=0.000> and <sil=0.000> 2 dimensional <sil=0.000> array <sil=0.000> is <sil=0.000> stored <sil=0.000> in <sil=0.000> a row <sil=0.000> wise
form <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> a particular <sil=0.000> element <sil=0.000> in <sil=0.000> the <sil=0.000> memory <sil=1.000> ,COMMA  right <sil=2.000> .PERIOD 

If <sil=0.000> we <sil=0.000> have <sil=0.000> a 2 <sil=0.000> dimensional <sil=0.000> array <sil=0.000> and <sil=0.000> the <sil=0.000> row <sil=0.000> and <sil=0.000> the <sil=0.000> column <sil=0.000> is <sil=0.000> specified <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
say <sil=0.000> here <sil=0.000> there <sil=0.000> are <sil=0.000> 1 2 <sil=0.000> 3 4 <sil=0.000> 5 rows <sil=0.000> and <sil=0.000> 3 columns <sil=0.000> say <sil=0.000> a particular <sil=0.000> element <sil=0.000> here <sil=0.000> has <sil=0.000> got <sil=0.000> the
address <sil=0.000> say <sil=0.000> the <sil=0.000> name <sil=0.000> of <sil=0.000> this <sil=0.000> array <sil=0.000> is <sil=0.000> A this <sil=0.000> particular <sil=0.000> element <sil=0.000> has <sil=0.000> got <sil=0.000> the <sil=0.000> address <sil=0.000> A 0 <sil=0.000> 1
2 <sil=1.000> ,COMMA  A <sil=0.000> 2 3 <sil=1.000> ,COMMA  A <sil=0.000> 2 0 <sil=0.000> 1 2 <sil=1.000> ,COMMA  A <sil=0.000> 2 2 <sil=0.000> right <sil=0.000> this <sil=0.000> element <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> stored <sil=0.000> how <sil=0.000> it <sil=0.000> is <sil=0.000> stored <sil=0.000> this <sil=0.000> stored <sil=0.000> in
this <sil=0.000> consecutive <sil=0.000> way <sil=0.000> first <sil=0.000> this <sil=0.000> one <sil=0.000> is <sil=0.000> stored <sil=0.000> then <sil=0.000> this <sil=0.000> one <sil=0.000> is <sil=0.000> stored <sil=1.000> ,COMMA  then <sil=0.000> this <sil=0.000> one <sil=0.000> is <sil=0.000> stored
row <sil=0.000> wise <sil=0.000> right <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  if <sil=0.000> in <sil=0.000> my <sil=0.000> each <sil=0.000> of <sil=0.000> them <sil=0.000> have <sil=0.000> got <sil=0.000> a memory <sil=0.000> location <sil=1.000> ,COMMA  so <sil=0.000> if <sil=0.000> the <sil=0.000> location <sil=0.000> of <sil=0.000> this <sil=0.000> is <sil=0.000> 1000
and <sil=0.000> if <sil=0.000> it <sil=0.000> be <sil=0.000> an <sil=0.000> integer <sil=0.000> array <sil=0.000> then <sil=0.000> this <sil=0.000> location <sil=0.000> will <sil=0.000> be <sil=0.000> 1002 <sil=1.000> ,COMMA  this <sil=0.000> location <sil=0.000> will <sil=0.000> be <sil=0.000> 1004 <sil=1.000> ,COMMA 
this <sil=0.000> location <sil=0.000> will <sil=0.000> be <sil=0.000> 1006 <sil=1.000> ,COMMA  1008 <sil=1.000> ,COMMA  1010 <sil=1.000> ,COMMA  right <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> way <sil=0.000> it <sil=0.000> will <sil=0.000> go <sil=0.000> on <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  a <sil=0.000> little <sil=0.000> thought
will <sil=0.000> tell <sil=0.000> you <sil=0.000> that <sil=0.000> if <sil=0.000> the <sil=0.000> starting <sil=0.000> address <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> will <sil=0.000> be <sil=0.000> the <sil=0.000> starting <sil=0.000> address <sil=0.228> ?QUESTIONMARK  What <sil=0.000> will
be <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> this <sil=0.228> ?QUESTIONMARK  It <sil=0.000> will <sil=0.000> be <sil=0.000> 1000 <sil=0.000> plus <sil=0.000> how <sil=0.000> many <sil=0.000> columns <sil=0.000> have <sil=0.000> to <sil=0.000> come <sil=0.000> for <sil=0.000> each
column <sil=0.000> shift <sil=0.000> for <sil=0.000> each <sil=0.000> column <sil=2.000> .PERIOD  What <sil=0.000> will <sil=0.000> be <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> this <sil=0.228> ?QUESTIONMARK  1010 <sil=1.000> ,COMMA  1012 <sil=1.000> ,COMMA  1014 <sil=1.000> ,COMMA  1016 <sil=1.000> ,COMMA 
right <sil=1.000> ,COMMA  actually <sil=0.000> this <sil=0.000> should <sil=0.000> be <sil=0.000> in <sil=0.000> the <sil=0.000> location <sil=0.000> 1016 <sil=0.000> of <sil=0.000> the <sil=0.000> memory <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  we <sil=0.000> start <sil=0.000> with <sil=0.000> 1000 <sil=0.000> and <sil=0.000> then <sil=0.000> since <sil=0.000> each <sil=0.000> of <sil=0.000> the <sil=0.000> elements <sil=0.000> each <sil=0.000> of <sil=0.000> the <sil=0.000> elements <sil=0.000> are
taking <sil=0.000> 2 bytes <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> have <sil=0.000> to <sil=0.000> go <sil=0.000> for <sil=0.000> each <sil=0.000> shift <sil=0.000> 2 bytes <sil=0.000> and <sil=0.000> how <sil=0.000> many <sil=0.000> such <sil=0.000> shifts <sil=2.000> .PERIOD 
What <sil=0.000> is <sil=0.000> the <sil=0.000> distance <sil=0.000> from <sil=0.000> here <sil=0.000> to <sil=0.000> here <sil=0.000> element <sil=0.000> wise <sil=0.228> ?QUESTIONMARK  We <sil=0.000> have <sil=0.000> got <sil=0.000> 8 such <sil=0.000> positions <sil=0.000> right
and <sil=0.000> so <sil=0.000> with <sil=0.000> that <sil=0.000> I can <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> this <sil=0.000> x <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> this <sil=0.000> was <sil=0.000> x and <sil=0.000> this <sil=0.000> was <sil=0.000> element
was <sil=0.000> k then <sil=0.000> what <sil=0.000> would <sil=0.000> be <sil=0.000> my <sil=0.000> address <sil=0.354> ;SEMICOLON  k <sil=0.000> into <sil=0.000> the <sil=0.000> offset <sil=0.000> is <sil=0.000> so <sil=0.000> many <sil=0.000> columns <sil=0.000> 2 3 <sil=1.000> ,COMMA  2
columns <sil=0.000> sorry <sil=0.000> 2 means <sil=0.000> 3 columns <sil=0.000> per <sil=0.000> row <sil=0.000> and <sil=0.000> 3 such <sil=0.000> rows <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> 6 rows <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  in

general <sil=0.000> we <sil=0.000> can <sil=0.000> say <sil=0.000> that <sil=0.000> if <sil=0.000> x be <sil=0.000> the <sil=0.000> starting <sil=0.000> address <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=0.000> in <sil=0.000> the <sil=0.000> memory <sil=0.000> and <sil=0.000> c be
the <sil=0.000> number <sil=0.000> of <sil=0.000> columns <sil=0.000> and <sil=0.000> k be <sil=0.000> the <sil=0.000> number <sil=0.000> of <sil=0.000> bytes <sil=0.000> allocated <sil=0.000> then <sil=0.000> the <sil=0.000> address <sil=0.000> will <sil=0.000> be <sil=0.000> x
plus <sil=0.000> i into <sil=0.000> c plus <sil=0.000> j c <sil=0.000> is <sil=0.000> the <sil=0.000> column <sil=0.000> number <sil=0.000> plus <sil=0.000> j <sil=2.000> .PERIOD  How <sil=0.000> many <sil=0.000> columns <sil=0.000> are <sil=0.000> there <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  if <sil=0.000> I
go <sil=0.000> back <sil=0.000> to <sil=0.000> this <sil=0.000> if <sil=0.000> I go <sil=0.000> back <sil=0.000> to <sil=0.000> this <sil=0.000> I can <sil=0.000> say <sil=0.000> the <sil=0.000> how <sil=0.000> many <sil=0.000> columns <sil=0.000> c is <sil=0.000> each <sil=0.000> it <sil=0.000> has <sil=0.000> got <sil=0.000> 3
columns <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  k <sil=0.000> into <sil=0.000> 3 plus <sil=0.000> sorry <sil=0.000> 3 into <sil=0.000> k plus <sil=0.000> j right <sil=0.000> 3 into <sil=0.000> k means <sil=0.000> 2 plus <sil=0.000> j <sil=1.000> ,COMMA  j <sil=0.000> was <sil=0.000> 2 <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  that <sil=0.000> will <sil=0.000> be <sil=0.000> my <sil=0.000> result <sil=0.000> 1000 <sil=0.000> plus <sil=0.000> 6 plus <sil=0.000> two <sil=0.000> 8 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> will <sil=0.000> be <sil=0.000> the <sil=0.000> location <sil=0.000> that <sil=0.000> I will
be <sil=0.000> finding <sil=0.000> out <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> that <sil=0.000> is <sil=0.000> the <sil=0.000> formulation <sil=0.354> ;SEMICOLON  x <sil=0.000> plus <sil=0.000> I into <sil=0.000> c plus <sil=0.000> j times <sil=0.000> k <sil=1.000> ,COMMA  k <sil=0.000> is <sil=0.000> number
of <sil=0.000> bytes <sil=0.000> allocated <sil=0.000> per <sil=0.000> element <sil=0.000> plus <sil=0.000> please <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> rows <sil=0.000> are <sil=0.000> the <sil=0.000> matrix <sil=0.000> is
actually <sil=0.000> stored <sil=0.000> as <sil=0.000> a 0 <sil=0.000> 0 <sil=1.000> ,COMMA  a <sil=0.000> 0 1 <sil=1.000> ,COMMA  a <sil=0.000> 0 2 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> entire <sil=0.000> thing <sil=0.000> is <sil=0.000> a 0 <sil=0.000> 3 <sil=1.000> ,COMMA  so <sil=0.000> 1 2 <sil=0.000> 3 4 <sil=0.000> so <sil=0.000> there <sil=0.000> 4
columns <sil=0.000> in <sil=0.000> one <sil=0.000> row <sil=2.000> .PERIOD  Then <sil=1.000> ,COMMA  the <sil=0.000> second <sil=0.000> row <sil=0.000> a 1 <sil=1.000> ,COMMA  a <sil=0.000> 1 column <sil=0.000> 0 <sil=1.000> ,COMMA  a <sil=0.000> 1 column <sil=0.000> 1 <sil=1.000> ,COMMA  a <sil=0.000> 1 column <sil=0.000> 2 <sil=1.000> ,COMMA 
a <sil=0.000> 1 column <sil=0.000> 3 <sil=1.000> ,COMMA  then <sil=1.000> ,COMMA  I <sil=0.000> proceed <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> the <sil=0.000> arrangement <sil=0.000> of <sil=0.000> 3 rows <sil=0.000> and <sil=0.000> each
row <sil=0.000> having <sil=0.000> 4 columns <sil=0.000> and <sil=0.000> using <sil=0.000> this <sil=0.000> formula <sil=0.000> which <sil=0.000> is <sil=0.000> intuitive <sil=0.000> we <sil=0.000> can <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> exact
location <sil=0.000> of <sil=0.000> a particular <sil=0.000> element <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  this <sil=0.000> part <sil=0.000> is <sil=0.000> row <sil=0.000> 1 this <sil=0.000> part <sil=0.000> is <sil=0.000> sorry <sil=0.000> this <sil=0.000> part <sil=0.000> is <sil=0.000> row <sil=0.000> 0 <sil=1.000> ,COMMA  this <sil=0.000> part <sil=0.000> is <sil=0.000> row <sil=0.000> 1 <sil=1.000> ,COMMA  this <sil=0.000> part <sil=0.000> is <sil=0.000> row
2 <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> see <sil=0.000> that <sil=0.000> this <sil=0.000> is <sil=0.000> row <sil=0.000> 1 column <sil=0.000> 0 <sil=1.000> ,COMMA  row <sil=0.000> 1 column <sil=0.000> 1 <sil=1.000> ,COMMA  row <sil=0.000> 1 column <sil=0.000> 2 so <sil=0.000> and <sil=0.000> so
forth <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  given <sil=0.000> so <sil=0.000> that <sil=0.000> is <sil=0.000> how <sil=0.000> it <sil=0.000> is <sil=0.000> stored <sil=0.000> and <sil=0.000> how <sil=0.000> we <sil=0.000> can <sil=0.000> find <sil=0.000> out <sil=0.000> what <sil=0.000> the <sil=0.000> address <sil=0.000> is <sil=1.000> ,COMMA  but
how <sil=0.000> do <sil=0.000> we <sil=0.000> read <sil=0.000> a particular <sil=0.000> array <sil=0.000> elements <sil=0.000> into <sil=0.000> a 2 <sil=0.000> dimensional <sil=0.000> array <sil=2.000> .PERIOD  We <sil=0.000> have <sil=0.000> seen <sil=0.000> that
I <sil=0.000> can <sil=0.000> read <sil=0.000> one <sil=0.000> dimensional <sil=0.000> array <sil=0.000> the <sil=0.000> elements <sil=0.000> of <sil=0.000> a 1 <sil=0.000> dimensional <sil=0.000> array <sil=0.000> into <sil=0.000> the <sil=0.000> array <sil=0.000> by

repeatedly <sil=0.000> getting <sil=0.000> the <sil=0.000> character <sil=0.000> from <sil=0.000> the <sil=0.000> user <sil=0.000> and <sil=0.000> storing <sil=0.000> it <sil=0.000> in <sil=0.000> the <sil=0.000> proper <sil=0.000> indexes <sil=0.000> and
proper <sil=0.000> positions <sil=0.000> by <sil=0.000> varying <sil=0.000> the <sil=0.000> index <sil=0.000> right <sil=2.000> .PERIOD  Here <sil=0.000> also <sil=0.000> we <sil=0.000> will <sil=0.000> be <sil=0.000> reading <sil=0.000> one <sil=0.000> element <sil=0.000> at
a <sil=0.000> time <sil=0.000> and <sil=0.000> we <sil=0.000> will <sil=0.000> store <sil=0.000> them <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  my <sil=0.000> array <sil=0.000> is <sil=0.000> say <sil=0.000> the <sil=0.000> array <sil=0.000> that <sil=0.000> I am <sil=0.000> storing <sil=0.000> is <sil=0.000> a i <sil=0.000> j
having <sil=0.000> some <sil=0.000> rows <sil=0.000> and <sil=0.000> columns <sil=0.000> and <sil=0.000> i is <sil=0.000> the <sil=0.000> row <sil=0.000> index <sil=0.000> and <sil=0.000> j is <sil=0.000> the <sil=0.000> column <sil=0.000> index <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
initially <sil=0.000> in <sil=0.000> this <sil=0.000> for <sil=0.000> loop <sil=0.000> look <sil=0.000> here <sil=1.000> ,COMMA  there <sil=0.000> are <sil=0.000> there <sil=0.000> is <sil=0.000> a nested <sil=0.000> for <sil=0.000> loop <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  first <sil=0.000> I am
keeping <sil=0.000> the <sil=0.000> i fixed <sil=0.000> for <sil=0.000> i equal <sil=0.000> to <sil=0.000> 0 <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  I <sil=0.000> come <sil=0.000> here <sil=0.000> inside <sil=0.000> this <sil=1.000> ,COMMA  inside <sil=0.000> this <sil=0.000> there <sil=0.000> is <sil=0.000> a
nesting <sil=0.000> of <sil=0.000> for <sil=0.000> loop <sil=0.000> say <sil=0.000> I have <sil=0.000> got <sil=0.000> 4 columns <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  for <sil=0.000> j is <sil=0.000> equal <sil=0.000> to <sil=0.000> 0 to <sil=0.000> j less <sil=0.000> than <sil=0.000> 4 <sil=0.228> ?QUESTIONMARK  What
do <sil=0.000> I do <sil=0.228> ?QUESTIONMARK  I <sil=0.000> scanf <sil=0.000> and <sil=0.000> a i <sil=0.000> j now <sil=0.000> each <sil=0.000> element <sil=0.000> here <sil=0.000> each <sil=0.000> element <sil=0.000> here <sil=0.000> is <sil=0.000> identified <sil=0.000> by <sil=0.000> the
row <sil=0.000> number <sil=0.000> and <sil=0.000> column <sil=0.000> number <sil=0.000> and <sil=0.000> so <sil=0.000> this <sil=0.000> one <sil=0.000> is <sil=0.000> and <sil=0.000> a 11 <sil=1.000> ,COMMA  this <sil=0.000> one <sil=0.000> is <sil=0.000> and <sil=0.000> a 13 <sil=0.000> in <sil=0.000> that
way <sil=0.000> we <sil=0.000> do <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  now <sil=0.000> for <sil=0.000> j is <sil=0.000> equal <sil=0.000> to <sil=0.000> 0 I <sil=0.000> read <sil=0.000> the <sil=0.000> particular <sil=0.000> value <sil=0.000> and <sil=0.000> store <sil=0.000> it <sil=0.000> here <sil=0.000> suppose <sil=0.000> it <sil=0.000> is <sil=0.000> 5 next
what <sil=0.000> is <sil=0.000> done <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> still <sil=0.000> inside <sil=0.000> this <sil=0.000> loop <sil=0.000> i increment <sil=0.000> j <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  j <sil=0.000> comes <sil=0.000> here <sil=0.000> note <sil=0.000> that <sil=0.000> i is <sil=0.000> fixed
still <sil=0.000> how <sil=0.000> long <sil=0.000> will <sil=0.000> a i <sil=0.000> remain <sil=0.000> fixed <sil=0.000> as <sil=0.000> long <sil=0.000> as <sil=0.000> I am <sil=0.000> inside <sil=0.000> this <sil=0.000> inner <sil=0.000> loop <sil=0.000> and <sil=0.000> how <sil=0.000> long
shall <sil=0.000> I be <sil=0.000> inside <sil=0.000> this <sil=0.000> inner <sil=0.000> loop <sil=0.000> till <sil=0.000> j reaches <sil=0.000> the <sil=0.000> end <sil=0.000> of <sil=0.000> the <sil=0.000> number <sil=0.000> of <sil=0.000> columns <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  next <sil=0.000> I
read <sil=0.000> the <sil=0.000> other <sil=0.000> value <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> 2 <sil=1.000> ,COMMA  next <sil=0.000> I read <sil=0.000> the <sil=0.000> other <sil=0.000> value <sil=0.000> it <sil=0.000> is <sil=0.000> 7 <sil=1.000> ,COMMA  next <sil=0.000> I read <sil=0.000> another
value <sil=0.000> may <sil=0.000> be <sil=0.000> it <sil=0.000> 0 <sil=1.000> ,COMMA  then <sil=0.000> it <sil=0.000> comes <sil=0.000> to <sil=0.000> 4 comes <sil=0.000> to <sil=0.000> the <sil=0.000> end <sil=0.000> of <sil=0.000> the <sil=0.000> row <sil=0.000> because <sil=0.000> all <sil=0.000> the <sil=0.000> columns
have <sil=0.000> been <sil=0.000> filled <sil=0.000> up <sil=0.000> then <sil=0.000> I come <sil=0.000> out <sil=0.000> of <sil=0.000> this <sil=0.000> loop <sil=0.000> and <sil=0.000> again <sil=0.000> go <sil=0.000> inside <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  i <sil=0.000> is <sil=0.000> now
incremented <sil=1.000> ,COMMA  i <sil=0.000> is <sil=0.000> now <sil=0.000> incremented <sil=0.000> to <sil=0.000> this <sil=0.000> one <sil=0.000> and <sil=0.000> I again <sil=0.000> do <sil=0.000> the <sil=0.000> same <sil=0.000> thing <sil=0.000> inside <sil=0.000> this
loop <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> inside <sil=0.000> this <sil=0.000> loop <sil=0.000> is <sil=0.000> filling <sil=0.000> up <sil=0.000> a row <sil=0.000> and <sil=0.000> this <sil=0.000> one <sil=0.000> is <sil=0.000> filling <sil=0.000> up <sil=0.000> all <sil=0.000> the <sil=0.000> rows <sil=2.000> .PERIOD 

Please <sil=0.000> take <sil=0.000> a little <sil=0.000> time <sil=0.000> to <sil=0.000> understand <sil=0.000> this <sil=2.000> .PERIOD  This <sil=0.000> loop <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> once <sil=0.000> again <sil=0.000> explaining <sil=0.000> this
loop <sil=0.000> is <sil=0.000> filling <sil=0.000> up <sil=0.000> one <sil=0.000> row <sil=0.000> keeping <sil=0.000> i fixed <sil=1.000> ,COMMA  i <sil=0.000> is <sil=0.000> fixed <sil=0.000> and <sil=0.000> in <sil=0.000> a loop <sil=0.000> I am <sil=0.000> filling <sil=0.000> up <sil=0.000> the
values <sil=0.000> here <sil=1.000> ,COMMA  here <sil=1.000> ,COMMA  here <sil=1.000> ,COMMA  here <sil=0.000> and <sil=0.000> then <sil=0.000> I increment <sil=0.000> this <sil=0.000> one <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> part <sil=0.000> for <sil=0.000> filling <sil=0.000> up <sil=0.000> all
the <sil=0.000> rows <sil=0.000> one <sil=0.000> by <sil=0.000> one <sil=1.000> ,COMMA  I <sil=0.000> come <sil=0.000> here <sil=0.000> again <sil=0.000> and <sil=0.000> again <sil=0.000> fill <sil=0.000> this <sil=0.000> up <sil=0.000> then <sil=0.000> I increment <sil=0.000> i and <sil=0.000> again
fill <sil=0.000> this <sil=0.000> up <sil=0.000> again <sil=0.000> I increment <sil=0.000> this <sil=0.000> i <sil=1.000> ,COMMA  come <sil=0.000> here <sil=0.000> and <sil=0.000> fill <sil=0.000> this <sil=0.000> up <sil=0.000> all <sil=0.000> right <sil=0.000> that <sil=0.000> is <sil=0.000> how <sil=0.000> we <sil=0.000> read
the <sil=0.000> elements <sil=0.000> of <sil=0.000> an <sil=0.000> array <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> being <sil=0.000> what <sil=0.000> is <sil=0.000> being <sil=0.000> shown <sil=0.000> here <sil=2.000> .PERIOD 

The <sil=0.000> ampersand <sil=0.000> is <sil=0.000> necessary <sil=0.000> here <sil=0.000> just <sil=0.000> as <sil=0.000> in <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> an <sil=0.000> array <sil=0.000> it <sil=0.000> was <sil=0.000> necessary <sil=0.000> it <sil=0.000> is
necessary <sil=0.000> here <sil=0.000> as <sil=0.000> well <sil=2.000> .PERIOD  The <sil=0.000> elements <sil=0.000> can <sil=0.000> be <sil=0.000> entered <sil=0.000> all <sil=0.000> in <sil=0.000> one <sil=0.000> line <sil=0.000> or <sil=0.000> in <sil=0.000> different <sil=0.000> lines <sil=0.000> it
really <sil=0.000> does <sil=0.000> not <sil=0.000> matter <sil=0.000> whether <sil=0.000> you <sil=0.000> pet <sil=0.000> type <sil=0.000> 5 <sil=1.000> ,COMMA  blank <sil=0.000> 6 <sil=1.000> ,COMMA  blank <sil=0.000> 7 <sil=1.000> ,COMMA  blank <sil=0.000> 8 or <sil=0.000> you <sil=0.000> type <sil=0.000> 5
enter <sil=0.000> 6 enter <sil=0.000> like <sil=0.000> that <sil=0.000> that <sil=0.000> really <sil=0.000> does <sil=0.000> not <sil=0.000> matter <sil=0.000> because <sil=0.000> we <sil=0.000> already <sil=0.000> know <sil=0.000> that <sil=0.000> every
element <sil=0.000> will <sil=0.000> be <sil=0.000> stored <sil=0.000> in <sil=0.000> a row <sil=0.000> wise <sil=0.000> fashion <sil=2.000> .PERIOD 

How <sil=0.000> to <sil=0.000> print <sil=0.000> the <sil=0.000> elements <sil=0.000> of <sil=0.000> an <sil=0.000> array <sil=0.228> ?QUESTIONMARK  Again <sil=1.000> ,COMMA  suppose <sil=0.000> I have <sil=0.000> got <sil=0.000> an <sil=0.000> array <sil=1.000> ,COMMA  suppose <sil=0.000> I
have <sil=0.000> got <sil=0.000> an <sil=0.000> array <sil=0.000> suppose <sil=0.000> I have <sil=0.000> got <sil=0.000> a 2 <sil=0.000> dimensional <sil=0.000> array <sil=0.000> and <sil=0.000> I will <sil=0.000> have <sil=0.000> to <sil=0.000> print <sil=0.000> the
elements <sil=0.000> I cannot <sil=0.000> just <sil=0.000> print <sil=0.000> the <sil=0.000> array <sil=0.000> in <sil=0.000> one <sil=0.000> shot <sil=0.000> I cannot <sil=0.000> do <sil=0.000> that <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  again <sil=0.000> here <sil=0.000> I will <sil=0.000> be
fixed <sil=0.000> and <sil=0.000> then <sil=0.000> I will <sil=0.000> print <sil=0.000> say <sil=0.000> this <sil=0.000> is <sil=0.000> a 0 <sil=0.000> 1 2 <sil=0.000> 3 0 <sil=0.000> 1 2 <sil=0.000> 3 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  first <sil=0.000> a 00 <sil=0.000> will <sil=0.000> be <sil=0.000> printed
whatever <sil=0.000> was <sil=0.000> the <sil=0.000> value <sil=0.000> here <sil=0.000> I am <sil=0.000> printing <sil=0.000> it <sil=0.000> here <sil=1.000> ,COMMA  then <sil=0.000> j will <sil=0.000> be <sil=0.000> incremented <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> next
one <sil=0.000> that <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=0.000> will <sil=0.000> be <sil=0.000> a 01 <sil=1.000> ,COMMA  next <sil=0.000> j will <sil=0.000> be <sil=0.000> incremented <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> a 02 <sil=1.000> ,COMMA  a <sil=0.000> 03
so <sil=0.000> and <sil=0.000> so <sil=0.000> forth <sil=0.000> and <sil=0.000> then <sil=0.000> I will <sil=0.000> be <sil=0.000> incremented <sil=0.000> again <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> next
printing <sil=0.000> will <sil=0.000> be <sil=0.000> a 1 <sil=0.000> and <sil=0.000> j will <sil=0.000> be <sil=0.000> reinitialised <sil=0.000> to <sil=0.000> 0 1 <sil=1.000> ,COMMA  a <sil=0.000> 10 <sil=1.000> ,COMMA  a <sil=0.000> 11 <sil=0.000> and <sil=0.000> like <sil=0.000> that <sil=0.000> it <sil=0.000> will <sil=0.000> be
printed <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  the <sil=0.000> elements <sil=0.000> are <sil=0.000> since <sil=0.000> it <sil=0.000> is <sil=0.000> a back <sil=0.000> slash <sil=0.000> n you <sil=0.000> can <sil=0.000> see <sil=0.000> the <sil=0.000> elements <sil=0.000> have <sil=0.000> printed
one <sil=0.000> per <sil=0.000> line <sil=0.000> because <sil=0.000> every <sil=0.000> time <sil=0.000> I am <sil=0.000> printing <sil=0.000> I am <sil=0.000> giving <sil=0.000> a back <sil=0.000> slash <sil=0.000> n <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  although
the <sil=0.354> ;SEMICOLON  my <sil=0.000> array <sil=0.000> could <sil=0.000> be <sil=0.000> 1 2 <sil=0.000> 3 5 <sil=0.000> 4 6 <sil=0.000> 7 9 <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=0.000> as <sil=0.000> 1 2 <sil=0.000> 3 5 <sil=0.000> 4 6 <sil=0.000> 7 9 <sil=0.000> because <sil=0.000> at
every <sil=0.000> point <sil=0.000> I have <sil=0.000> given <sil=0.000> a back <sil=0.000> slash <sil=0.000> n <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  here <sil=0.000> what <sil=0.000> are <sil=0.000> we <sil=0.000> doing <sil=0.000> here <sil=0.228> ?QUESTIONMARK  In <sil=0.000> this <sil=0.000> case <sil=0.000> the <sil=0.000> elements <sil=0.000> will <sil=0.000> all <sil=0.000> be <sil=0.000> printed <sil=0.000> in <sil=0.000> the
same <sil=0.000> line <sil=0.000> because <sil=0.000> I have <sil=0.000> not <sil=0.000> put <sil=0.000> the <sil=0.000> back <sil=0.000> slash <sil=0.000> n <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=0.000> all <sil=0.000> the <sil=0.000> elements
say <sil=0.000> sorry <sil=0.000> all <sil=0.000> the <sil=0.000> elements <sil=0.000> say <sil=0.000> 1 2 <sil=0.000> 3 4 <sil=0.000> 5 6 <sil=0.000> 7 8 <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=0.000> if <sil=0.000> that <sil=0.000> was <sil=0.000> the

matrix <sil=0.000> then <sil=0.000> this <sil=0.000> part <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=0.000> in <sil=0.000> one <sil=0.000> line <sil=0.000> and <sil=0.000> then <sil=0.000> I go <sil=0.000> up <sil=0.000> there <sil=0.000> is <sil=0.000> no <sil=0.000> back <sil=0.000> slash <sil=0.000> n
this <sil=0.000> one <sil=0.000> will <sil=0.000> be <sil=0.000> followed <sil=0.000> and <sil=0.000> the <sil=0.000> entire <sil=0.000> thing <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=0.000> in <sil=0.000> one <sil=0.000> line <sil=1.000> ,COMMA  1 <sil=0.000> 2 3 <sil=0.000> 4 5 <sil=0.000> 6 7 <sil=0.000> 8 <sil=2.000> .PERIOD 

But <sil=0.000> if <sil=0.000> I had <sil=0.000> done <sil=0.000> this <sil=0.000> that <sil=0.000> first <sil=0.000> I had <sil=0.000> this <sil=0.000> again <sil=0.000> 1 2 <sil=0.000> 3 4 <sil=0.000> 5 6 <sil=0.000> 7 8 <sil=0.000> and <sil=0.000> I want <sil=0.000> it <sil=0.000> to <sil=0.000> be <sil=0.000> printed
in <sil=0.000> this <sil=0.000> way <sil=0.000> because <sil=0.000> here <sil=0.000> I have <sil=0.000> not <sil=0.000> given <sil=0.000> any <sil=0.000> back <sil=0.000> slash <sil=0.000> n it <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=0.000> one <sil=0.000> two <sil=0.000> 3 4
and <sil=0.000> as <sil=0.000> it <sil=0.000> comes <sil=0.000> out <sil=0.000> of <sil=0.000> this <sil=0.000> loop <sil=0.000> it <sil=0.000> goes <sil=0.000> here <sil=0.000> and <sil=0.000> comes <sil=0.000> to <sil=0.000> the <sil=0.000> next <sil=0.000> row <sil=0.000> first <sil=0.000> thing <sil=0.000> that <sil=0.000> it
does <sil=0.000> is <sil=0.000> printf <sil=0.000> back <sil=0.000> slash <sil=0.000> n <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> control <sil=0.000> will <sil=0.000> come <sil=0.000> here <sil=0.000> and <sil=0.000> then <sil=0.000> 5 6 <sil=0.000> 7 8 <sil=0.000> will <sil=0.000> be <sil=0.000> printed
therefore <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> a better <sil=0.000> way <sil=0.000> of <sil=0.000> printing <sil=0.000> a 2 <sil=0.000> dimensional <sil=0.000> array <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> it <sil=0.000> looks <sil=0.000> like <sil=0.000> a 2
dimensional <sil=0.000> array <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  that <sil=0.000> this <sil=0.000> will <sil=0.000> make <sil=0.000> the <sil=0.000> elements <sil=0.000> now <sil=0.000> the <sil=0.000> question <sil=0.000> is <sil=0.000> you <sil=0.000> just <sil=0.000> think <sil=0.000> how <sil=0.000> can <sil=0.000> we <sil=0.000> print
two <sil=0.000> matrices <sil=0.000> side <sil=0.000> by <sil=0.000> side <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  suppose <sil=0.000> there <sil=0.000> is <sil=0.000> one <sil=0.000> matrix <sil=0.000> 1 2 <sil=0.000> 3 4 <sil=0.000> another <sil=0.000> is <sil=0.000> character
matrix <sil=0.000> a b <sil=0.000> c d <sil=0.000> how <sil=0.000> can <sil=0.000> you <sil=0.000> print <sil=0.000> them <sil=0.000> side <sil=0.000> by <sil=0.000> side <sil=0.000> what <sil=0.000> should <sil=0.000> we <sil=0.000> do <sil=0.228> ?QUESTIONMARK  Can <sil=0.000> you <sil=0.000> think <sil=0.000> of
that <sil=0.228> ?QUESTIONMARK  I <sil=0.000> mean <sil=0.000> if <sil=0.000> I say <sil=0.000> I have <sil=0.000> got <sil=0.000> two <sil=0.000> matrices <sil=0.000> one <sil=0.000> is <sil=0.000> 1 2 <sil=0.000> 3 4 <sil=0.000> 5 6 <sil=0.000> 7 8 <sil=2.000> .PERIOD  Another <sil=0.000> matrix <sil=0.000> is <sil=0.000> say
a <sil=0.000> b c <sil=0.000> d <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> they <sil=0.000> have <sil=0.000> different <sil=0.000> dimensions <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  first <sil=0.000> of <sil=0.000> all <sil=1.000> ,COMMA  first <sil=0.000> of <sil=0.000> all <sil=0.000> how <sil=0.000> can <sil=0.000> you <sil=0.000> represent <sil=0.000> such <sil=0.000> a metrics <sil=0.228> ?QUESTIONMARK  Say <sil=0.000> this <sil=0.000> matrix <sil=0.000> how <sil=0.000> will
you <sil=0.000> declare <sil=0.000> that <sil=0.000> simple <sil=0.000> this <sil=0.000> will <sil=0.000> be <sil=0.000> a character <sil=0.000> matrix <sil=0.000> character <sil=0.000> let <sil=0.000> us <sil=0.000> call <sil=0.000> the <sil=0.000> this <sil=0.000> matrix
let <sil=0.000> it <sil=0.000> be <sil=0.000> M <sil=1.000> ,COMMA  M <sil=0.000> is <sil=0.000> 2 by <sil=0.000> 2 <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  each <sil=0.000> elements <sil=0.000> of <sil=0.000> this <sil=0.000> matrix <sil=0.000> will <sil=0.000> be <sil=0.000> a character <sil=2.000> .PERIOD  And
this <sil=0.000> is <sil=0.000> int <sil=1.000> ,COMMA  let <sil=0.000> it <sil=0.000> be <sil=0.000> N <sil=1.000> ,COMMA  2 <sil=0.000> by <sil=0.000> 4 <sil=1.000> ,COMMA  right <sil=2.000> .PERIOD  These <sil=0.000> are <sil=0.000> the <sil=0.000> two <sil=0.000> matrices <sil=0.000> now <sil=0.000> you <sil=0.000> can <sil=0.000> think <sil=0.000> of <sil=0.000> how
you <sil=0.000> can <sil=0.000> print <sil=0.000> two <sil=0.000> matrices <sil=0.000> side <sil=0.000> by <sil=0.000> side <sil=2.000> .PERIOD  If <sil=0.000> I do <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=0.000> by <sil=0.000> this <sil=0.000> row <sil=0.000> by <sil=0.000> this <sil=0.000> I will <sil=0.000> first
print <sil=0.000> 1 2 <sil=0.000> 3 4 <sil=0.000> and <sil=0.000> then <sil=0.000> what <sil=0.000> should <sil=0.000> I do <sil=0.228> ?QUESTIONMARK  I <sil=0.000> should <sil=0.000> go <sil=0.000> to <sil=0.000> here <sil=0.000> I should <sil=0.000> again <sil=0.000> for <sil=0.000> j is <sil=0.000> equal
to <sil=0.000> j to <sil=0.000> M call <sil=0.000> might <sil=0.000> be <sil=0.000> j plus <sil=0.000> plus <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> be <sil=0.000> doing <sil=0.000> I will <sil=0.000> be <sil=0.000> printing <sil=0.000> M i <sil=0.000> j <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> will
come <sil=0.000> immediately <sil=0.000> side <sil=0.000> by <sil=0.000> side <sil=0.000> if <sil=0.000> necessary <sil=0.000> I could <sil=0.000> have <sil=0.000> given <sil=0.000> another <sil=0.000> blank <sil=0.000> in <sil=0.000> between
and <sil=0.000> I could <sil=0.000> have <sil=0.000> printed <sil=0.000> this <sil=0.000> as <sil=0.000> a complete <sil=0.000> row <sil=0.000> next <sil=0.000> I go <sil=0.000> up <sil=0.000> and <sil=0.000> print <sil=0.000> this <sil=0.000> and <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I
suggest <sil=0.000> that <sil=0.000> you <sil=0.000> try <sil=0.000> to <sil=0.000> write <sil=0.000> this <sil=0.000> program <sil=0.000> and <sil=0.000> run <sil=0.000> it <sil=0.000> and <sil=0.000> see <sil=0.000> whether <sil=0.000> you <sil=0.000> get <sil=0.000> a nice
output <sil=0.000> or <sil=0.000> not <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  we <sil=0.000> come <sil=0.000> to <sil=0.000> a very <sil=0.000> well <sil=0.000> known <sil=0.000> problem <sil=0.000> that <sil=0.000> we <sil=0.000> often <sil=0.000> encounter <sil=0.000> matrix <sil=0.000> addition <sil=2.000> .PERIOD  I
am <sil=0.000> going <sil=0.000> to <sil=0.000> add <sil=0.000> two <sil=0.000> matrices <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> a very <sil=0.000> simple <sil=0.000> problem <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  all <sil=0.000> of <sil=0.000> you <sil=0.000> know <sil=0.000> how
this <sil=0.000> can <sil=0.000> be <sil=0.000> done <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> a matrix <sil=0.000> of <sil=0.000> the <sil=0.000> same <sil=0.000> size <sil=0.000> two <sil=0.000> matrices <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> 1 2 <sil=0.000> 3 4 <sil=0.000> 7 6 <sil=0.000> 9 2 <sil=0.000> and <sil=0.000> there <sil=0.000> is
another <sil=0.000> matrix <sil=0.000> 10 <sil=0.000> 12 <sil=0.000> 15 <sil=0.000> 13 <sil=0.000> 7 14 <sil=0.000> 3 0 <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  I <sil=0.000> want <sil=0.000> to <sil=0.000> add <sil=0.000> them <sil=0.000> and <sil=0.000> have <sil=0.000> another <sil=0.000> matrix <sil=2.000> .PERIOD 
First <sil=0.000> of <sil=0.000> all <sil=0.000> this <sil=0.000> is <sil=0.000> a matrix <sil=0.000> of <sil=0.000> 2 rows <sil=0.000> and <sil=0.000> 4 columns <sil=0.000> 2 rows <sil=0.000> and <sil=0.000> 4 columns <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> can
say <sil=0.000> that <sil=0.000> this <sil=0.000> A is <sil=0.000> a 2 <sil=0.000> by <sil=0.000> 4 matrix <sil=0.000> and <sil=0.000> this <sil=0.000> one <sil=0.000> B is <sil=0.000> also <sil=0.000> a 2 <sil=0.000> by <sil=0.000> 4 matrix <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  the <sil=0.000> sum <sil=0.000> I

will <sil=0.000> store <sil=0.000> in <sil=0.000> another <sil=0.000> matrix <sil=0.000> whose <sil=0.000> dimension <sil=0.000> will <sil=0.000> also <sil=0.000> be <sil=0.000> two <sil=0.000> by <sil=0.000> 4 has <sil=0.000> to <sil=0.000> be <sil=2.000> .PERIOD  And <sil=0.000> how <sil=0.000> is
matrix <sil=0.000> addition <sil=0.000> done <sil=0.228> ?QUESTIONMARK  I <sil=0.000> will <sil=0.000> first <sil=0.000> take <sil=0.000> this <sil=0.000> element <sil=2.000> .PERIOD 
What <sil=0.000> is <sil=0.000> this <sil=0.000> element <sil=0.228> ?QUESTIONMARK  I <sil=0.000> am <sil=0.000> saying <sil=0.000> this <sil=0.000> element <sil=0.000> what <sil=0.000> is <sil=0.000> this <sil=0.000> element <sil=2.000> .PERIOD  This <sil=0.000> element <sil=0.000> means
a <sil=0.000> particular <sil=0.000> i j <sil=0.000> value <sil=0.000> 0 0 <sil=0.000> element <sil=0.000> i 0 <sil=0.000> j 0 <sil=0.000> from <sil=0.000> these <sil=0.000> array <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> take <sil=0.000> this <sil=0.000> element <sil=0.000> 1 and
then <sil=0.000> take <sil=0.000> b i <sil=0.000> j of <sil=0.000> the <sil=0.000> same <sil=0.000> i j <sil=0.000> value <sil=0.000> 0 0 <sil=0.000> 1 add <sil=0.000> them <sil=0.000> together <sil=0.000> 1 plus <sil=0.000> 10 <sil=0.000> I get <sil=0.000> 11 <sil=1.000> ,COMMA  I <sil=0.000> put <sil=0.000> that
11 <sil=0.000> in <sil=0.000> the <sil=0.000> i j <sil=0.000> value <sil=0.000> remaining <sil=0.000> same <sil=0.000> 0 0 <sil=0.000> of <sil=0.000> the <sil=0.000> c matrix <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> it <sil=0.000> is <sil=0.000> 11 <sil=2.000> .PERIOD 
Next <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> increasing <sil=0.000> the <sil=0.000> index <sil=0.000> i here <sil=0.000> j remains <sil=0.000> sorry <sil=0.000> I am <sil=0.000> incrementing <sil=0.000> whatever <sil=0.000> I do <sil=0.000> I
keep <sil=0.000> the <sil=0.000> I fixed <sil=0.000> and <sil=0.000> increment <sil=0.000> the <sil=0.000> j <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  i <sil=0.000> is <sil=0.000> 1 <sil=1.000> ,COMMA  j <sil=0.000> is <sil=0.000> 1 is <sil=0.000> 0 <sil=1.000> ,COMMA  j <sil=0.000> is <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  with <sil=0.000> that <sil=0.000> I take <sil=0.000> this
value <sil=0.000> 2 and <sil=0.000> take <sil=0.000> this <sil=0.000> value <sil=0.000> with <sil=0.000> a same <sil=0.000> i and <sil=0.000> j value <sil=1.000> ,COMMA  i <sil=0.000> is <sil=0.000> 0 and <sil=0.000> j is <sil=0.000> 1 add <sil=0.000> them <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is
4teen <sil=0.000> and <sil=0.000> I store <sil=0.000> this <sil=0.000> value <sil=0.000> here <sil=0.000> in <sil=0.000> that <sil=0.000> way <sil=0.000> I go <sil=0.000> on <sil=0.000> for <sil=0.000> this <sil=0.000> entire <sil=0.000> matrix <sil=0.000> that <sil=0.000> is <sil=0.000> how <sil=0.000> I do
the <sil=0.000> matrix <sil=0.000> addition <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> see <sil=0.000> how <sil=0.000> the <sil=0.000> code <sil=0.000> looks <sil=0.000> like <sil=0.000> for <sil=0.000> this <sil=0.000> and <sil=0.000> let <sil=0.000> us <sil=0.000> try <sil=0.000> to
understand <sil=0.000> the <sil=0.000> code <sil=0.000> this <sil=0.000> much <sil=0.000> is <sil=0.000> include <sil=0.000> s t <sil=0.000> d i <sil=0.000> o dot <sil=0.000> h then <sil=0.000> my <sil=0.000> main <sil=0.000> program <sil=0.000> is
continuing <sil=2.000> .PERIOD  What <sil=0.000> is <sil=0.000> being <sil=0.000> done <sil=0.228> ?QUESTIONMARK 
Here <sil=0.000> I am <sil=0.000> trying <sil=0.000> to <sil=0.000> add <sil=0.000> 2 <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> writing <sil=0.000> the <sil=0.000> program <sil=0.000> for <sil=0.000> adding <sil=0.000> 2 matrices <sil=0.000> of <sil=0.000> size <sil=0.000> 100 <sil=0.000> by
100 <sil=0.000> let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=0.000> 100 <sil=0.000> by <sil=0.000> 100 <sil=1.000> ,COMMA  a <sil=0.000> matrix <sil=0.000> of <sil=0.000> size <sil=0.000> 100 <sil=0.000> rows <sil=0.000> and <sil=0.000> 100 <sil=0.000> columns <sil=1.000> ,COMMA  b <sil=0.000> of <sil=0.000> 100
rows <sil=0.000> and <sil=0.000> 100 <sil=0.000> columns <sil=0.000> and <sil=0.000> c of <sil=0.000> 100 <sil=0.000> rows <sil=0.000> and <sil=0.000> 100 <sil=0.000> columns <sil=2.000> .PERIOD  And <sil=0.000> I have <sil=0.000> got <sil=0.000> other <sil=0.000> integer
values <sil=0.000> p q <sil=0.000> m n <sil=2.000> .PERIOD  I <sil=0.000> am <sil=0.000> reading <sil=0.000> the <sil=0.000> matrices <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> reading <sil=0.000> sorry <sil=0.000> I am <sil=0.000> reading <sil=0.000> m and <sil=0.000> n
alright <sil=0.000> two <sil=0.000> values <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> m and <sil=0.000> n <sil=0.228> ?QUESTIONMARK  m <sil=0.000> and <sil=0.000> n although <sil=0.000> I have <sil=0.000> here <sil=0.000> recall <sil=0.000> the
difference <sil=0.000> between <sil=0.000> I mention <sil=0.000> about <sil=0.000> the <sil=0.000> size <sil=0.000> and <sil=0.000> the <sil=0.000> dimension <sil=0.000> is <sil=0.000> the <sil=0.000> maximum <sil=0.000> size <sil=0.000> the
maximum <sil=0.000> size <sil=0.000> that <sil=0.000> it <sil=0.000> can <sil=0.000> have <sil=0.000> 100 <sil=0.000> and <sil=0.000> 100 <sil=0.000> are <sil=0.000> the <sil=0.000> maximum <sil=0.000> sizes <sil=0.000> of <sil=0.000> the <sil=0.000> a matrix <sil=0.000> and <sil=0.000> b
matrix <sil=1.000> ,COMMA  but <sil=0.000> actually <sil=0.000> I can <sil=0.000> have <sil=0.000> I may <sil=0.000> not <sil=0.000> need <sil=0.000> so <sil=0.000> many <sil=0.000> locations <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> I can <sil=0.000> do <sil=0.228> ?QUESTIONMARK 

I <sil=0.000> have <sil=0.000> got <sil=0.000> a has <sil=0.000> got <sil=0.000> so <sil=0.000> much <sil=0.000> size <sil=1.000> ,COMMA  but <sil=0.000> actually <sil=0.000> I am <sil=0.000> filling <sil=0.000> up <sil=0.000> only <sil=0.000> these <sil=0.000> say <sil=0.000> this <sil=0.000> much <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> my <sil=0.000> m <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> sorry <sil=0.000> this <sil=0.000> is <sil=0.000> my <sil=0.000> m and <sil=0.000> this <sil=0.000> is <sil=0.000> my <sil=0.000> n ok <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  my <sil=0.000> actual <sil=0.000> matrix <sil=0.000> is <sil=0.000> small <sil=0.000> dimension <sil=0.000> is <sil=0.000> a largest <sil=0.000> size <sil=0.000> that <sil=0.000> I can <sil=0.000> accommodate <sil=0.000> all
right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> need <sil=0.000> that <sil=0.000> actual <sil=0.000> value <sil=0.000> m and <sil=0.000> n and <sil=0.000> then <sil=0.000> for <sil=0.000> p is <sil=0.000> an <sil=0.000> index <sil=0.000> p equals <sil=0.000> to <sil=0.000> 0 less
than <sil=0.000> m p <sil=0.000> plus <sil=0.000> plus <sil=0.000> q <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> reading <sil=0.000> the <sil=0.000> matrix <sil=0.000> a <sil=1.000> ,COMMA  and <sil=0.000> here <sil=0.000> you <sil=0.000> see <sil=0.000> I am <sil=0.000> not <sil=0.000> using <sil=0.000> the
conventional <sil=0.000> i j <sil=0.000> indices <sil=0.000> I am <sil=0.000> saying <sil=0.000> p is <sil=0.000> keeping <sil=0.000> account <sil=0.000> of <sil=0.000> my <sil=0.000> row <sil=0.000> and <sil=0.000> q is <sil=0.000> keeping
account <sil=0.000> of <sil=0.000> my <sil=0.000> column <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  for <sil=0.000> p 0 <sil=0.000> to <sil=0.000> m and <sil=0.000> q 0 <sil=0.000> to <sil=0.000> n I <sil=0.000> am <sil=0.000> filling <sil=0.000> up <sil=0.000> the <sil=0.000> a matrix <sil=1.000> ,COMMA  then <sil=0.000> I
come <sil=0.000> here <sil=0.000> fill <sil=0.000> up <sil=0.000> this <sil=0.000> matrix <sil=0.000> out <sil=0.000> of <sil=0.000> this <sil=0.000> outer <sil=0.000> loop <sil=2.000> .PERIOD 
This <sil=0.000> inner <sil=0.000> loop <sil=1.000> ,COMMA  with <sil=0.000> this <sil=0.000> inner <sil=0.000> loop <sil=0.000> what <sil=0.000> am <sil=0.000> I doing <sil=0.000> I am <sil=0.000> filling <sil=0.000> out <sil=0.000> particular <sil=0.000> row <sil=0.000> and
the <sil=0.000> outer <sil=0.000> loop <sil=0.000> I am <sil=0.000> going <sil=0.000> to <sil=0.000> the <sil=0.000> next <sil=0.000> column <sil=1.000> ,COMMA  repeatedly <sil=0.000> I am <sil=0.000> saying <sil=0.000> that <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  in <sil=0.000> this <sil=0.000> way
I <sil=0.000> read <sil=0.000> matrix <sil=0.000> a here <sil=1.000> ,COMMA  here <sil=0.000> I read <sil=0.000> matrix <sil=0.000> b then <sil=0.000> I am <sil=0.000> doing <sil=0.000> the <sil=0.000> addition <sil=0.000> here <sil=2.000> .PERIOD  Again <sil=0.000> my <sil=0.000> the
dimensions <sil=0.000> of <sil=0.000> the <sil=0.000> two <sil=0.000> matrices <sil=0.000> will <sil=0.000> be <sil=0.000> the <sil=0.000> same <sil=0.000> when <sil=0.000> I add <sil=0.000> and <sil=0.000> the <sil=0.000> result <sil=0.000> matrix <sil=0.000> will
also <sil=0.000> be <sil=0.000> the <sil=0.000> same <sil=0.000> according <sil=0.000> to <sil=0.000> matrix <sil=0.000> algebra <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> I am <sil=0.000> adding <sil=0.000> two <sil=0.000> matrices <sil=0.000> they <sil=0.000> will
result <sil=0.000> in <sil=0.000> the <sil=0.000> same <sil=0.000> dimension <sil=0.000> matrix <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  again <sil=0.000> for <sil=0.000> p equal <sil=0.000> to <sil=0.000> 0 to <sil=0.000> m and <sil=0.000> q equal <sil=0.000> to <sil=0.000> 0 to <sil=0.000> m
I <sil=0.000> take <sil=0.000> c p <sil=0.000> q <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> taken <sil=0.000> two <sil=0.000> matrices <sil=2.000> .PERIOD 

And <sil=0.000> now <sil=0.000> I am <sil=0.000> generating <sil=0.000> c matrix <sil=0.000> where <sil=0.000> this <sil=0.000> value <sil=0.000> this <sil=0.000> particular <sil=0.000> element <sil=0.000> is <sil=0.000> being
computed <sil=0.000> by <sil=0.000> the <sil=0.000> corresponding <sil=0.000> element <sil=0.000> from <sil=0.000> a and <sil=0.000> the <sil=0.000> corresponding <sil=0.000> element <sil=0.000> from <sil=0.000> b
being <sil=0.000> added <sil=0.000> I am <sil=0.000> filling <sil=0.000> it <sil=0.000> up <sil=0.000> and <sil=0.000> this <sil=0.000> is <sil=0.000> going <sil=0.000> on <sil=0.000> in <sil=0.000> a loop <sil=0.000> all <sil=0.000> right <sil=0.000> and <sil=0.000> so <sil=0.000> I fill <sil=0.000> this
entire <sil=0.000> thing <sil=0.000> up <sil=2.000> .PERIOD  What <sil=0.000> is <sil=0.000> a last <sil=0.000> for <sil=0.000> loop <sil=0.228> ?QUESTIONMARK  This <sil=0.000> last <sil=0.000> for <sil=0.000> loop <sil=0.000> is <sil=0.000> nothing <sil=1.000> ,COMMA  but <sil=0.000> printing <sil=0.000> the
same <sil=0.000> array <sil=1.000> ,COMMA  printing <sil=0.000> the <sil=0.000> array <sil=0.000> in <sil=0.000> the <sil=0.000> proper <sil=0.000> way <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  here <sil=0.000> you <sil=0.000> please <sil=0.000> note <sil=0.000> that <sil=0.000> it <sil=0.000> is <sil=0.000> back <sil=0.000> slash <sil=0.000> n <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> come <sil=0.000> nicely <sil=0.000> after <sil=0.000> one <sil=0.000> row
there <sil=0.000> will <sil=0.000> be <sil=0.000> a we <sil=0.000> will <sil=0.000> go <sil=0.000> to <sil=0.000> the <sil=0.000> new <sil=0.000> line <sil=0.000> and <sil=0.000> we <sil=0.000> will <sil=0.000> print <sil=0.000> it <sil=0.000> this <sil=0.000> way <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> a matrix
addition <sil=0.000> which <sil=0.000> is <sil=0.000> a very <sil=0.000> useful <sil=0.000> very <sil=0.000> common <sil=0.000> and <sil=0.000> simple <sil=0.000> application <sil=0.000> of <sil=0.000> our <sil=0.000> knowledge <sil=0.000> of
two <sil=0.000> dimensional <sil=0.000> array <sil=0.000> to <sil=0.000> start <sil=0.000> with <sil=2.000> .PERIOD 
We <sil=0.000> will <sil=0.000> other <sil=0.000> applications <sil=0.000> of <sil=0.000> this <sil=0.000> to <sil=0.000> in <sil=0.000> a future <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  the <sil=0.000> other <sil=0.000> thing <sil=0.000> that <sil=0.000> will <sil=0.000> be
discussing <sil=0.000> in <sil=0.000> the <sil=0.000> consequence <sil=0.000> lectures <sil=0.000> are <sil=0.000> next <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> now <sil=0.000> have <sil=0.000> got <sil=0.000> an <sil=0.000> idea <sil=0.000> of <sil=0.000> 1
dimensional <sil=0.000> array <sil=0.000> and <sil=0.000> we <sil=0.000> have <sil=0.000> got <sil=0.000> an <sil=0.000> idea <sil=0.000> of <sil=0.000> 2 dimensional <sil=0.000> array <sil=2.000> .PERIOD  We <sil=0.000> have <sil=0.000> also <sil=0.000> seen
strings <sil=0.000> and <sil=0.000> character <sil=0.000> arrays <sil=2.000> .PERIOD  Next <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> move <sil=0.000> to <sil=0.000> functions <sil=0.000> in <sil=0.000> the <sil=0.000> next <sil=0.000> lecture <sil=2.000> .PERIOD  We
have <sil=0.000> already <sil=0.000> mentioned <sil=0.000> about <sil=0.000> the <sil=0.000> term <sil=0.000> functions <sil=0.000> while <sil=0.000> moving <sil=0.000> and <sil=0.000> in <sil=0.000> the <sil=0.000> course <sil=0.000> of <sil=0.000> other
discussion <sil=1.000> ,COMMA  and <sil=0.000> we <sil=0.000> have <sil=0.000> already <sil=0.000> seen <sil=0.000> one <sil=0.000> particular <sil=0.000> function <sil=0.000> that <sil=0.000> is <sil=0.000> main <sil=0.000> function <sil=0.000> that <sil=0.000> is
always <sil=0.000> there <sil=0.000> is <sil=0.000> a main <sil=0.000> body <sil=0.000> of <sil=0.000> any <sil=0.000> C program <sil=0.000> and <sil=0.000> we <sil=0.000> have <sil=0.000> also <sil=0.000> seen <sil=0.000> some <sil=0.000> library
functions <sil=2.000> .PERIOD  But <sil=0.000> next <sil=0.000> lecture <sil=0.000> onwards <sil=0.000> we <sil=0.000> will <sil=0.000> look <sil=0.000> at <sil=0.000> user <sil=0.000> defined <sil=0.000> functions <sil=2.000> .PERIOD 
We <sil=0.000> have <sil=0.000> seen <sil=0.000> some <sil=0.000> stored <sil=0.000> functions <sil=0.000> in <sil=0.000> the <sil=0.000> earlier <sil=0.000> lecture <sil=0.000> like <sil=0.000> string <sil=0.000> copy <sil=1.000> ,COMMA  string <sil=0.000> length <sil=1.000> ,COMMA 
finding <sil=0.000> string <sil=0.000> length <sil=1.000> ,COMMA  similarly <sil=0.000> a user <sil=0.000> can <sil=0.000> himself <sil=0.000> or <sil=0.000> herself <sil=0.000> write <sil=0.000> a particular <sil=0.000> function <sil=0.000> of

his <sil=0.000> or <sil=0.000> her <sil=0.000> own <sil=0.000> need <sil=2.000> .PERIOD  We <sil=0.000> will <sil=0.000> have <sil=0.000> to <sil=0.000> see <sil=0.000> why <sil=0.000> we <sil=0.000> need <sil=0.000> to <sil=0.000> write <sil=0.000> functions <sil=0.000> and <sil=0.000> how <sil=0.000> a
function <sil=0.000> can <sil=0.000> be <sil=0.000> written <sil=0.000> from <sil=0.000> the <sil=0.000> next <sil=0.000> lecture <sil=0.000> onwards <sil=2.000> .PERIOD 
Thank <sil=0.000> you <sil=2.000> .PERIOD 

In <sil=0.000> the <sil=0.000> earlier <sil=0.000> lectures <sil=1.000> ,COMMA  we <sil=0.000> had <sil=0.000> discussed <sil=0.000> about <sil=0.000> one <sil=0.000> dimensional <sil=0.000> array <sil=0.000> as <sil=0.000> well <sil=0.000> as <sil=0.000> 2
dimensional <sil=0.000> array <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> seen <sil=0.000> how <sil=0.000> one <sil=0.000> dimensional <sil=0.000> array <sil=0.000> can <sil=0.000> be <sil=0.000> stored <sil=1.000> ,COMMA  read <sil=0.000> and
printed <sil=0.000> and <sil=0.000> as <sil=0.000> well <sil=0.000> as <sil=0.000> we <sil=0.000> saw <sil=0.000> how <sil=0.000> a linear <sil=0.000> search <sil=0.000> can <sil=0.000> be <sil=0.000> applied <sil=0.000> over <sil=0.000> one <sil=0.000> dimensional
array <sil=2.000> .PERIOD 
Similarly <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=0.000> for <sil=0.000> 2 dimensional <sil=0.000> arrays <sil=0.000> how <sil=0.000> it <sil=0.000> can <sil=0.000> be <sil=0.000> read <sil=1.000> ,COMMA  it <sil=0.000> can <sil=0.000> be <sil=0.000> stored <sil=1.000> ,COMMA  it <sil=0.000> is
stored <sil=0.000> in <sil=0.000> row <sil=0.000> major <sil=0.000> form <sil=0.000> and <sil=0.000> how <sil=0.000> it <sil=0.000> can <sil=0.000> be <sil=0.000> printed <sil=2.000> .PERIOD  Now <sil=0.000> today <sil=0.000> we <sil=0.000> will <sil=0.000> start <sil=0.000> discussing
on <sil=0.000> a very <sil=0.000> important <sil=0.000> and <sil=0.000> vital <sil=0.000> component <sil=0.000> of <sil=0.000> programming <sil=0.000> and <sil=0.000> also (Refer <sil=0.000> Time: 01:06)
of <sil=0.000> the <sil=0.000> C language <sil=0.000> that <sil=0.000> is <sil=0.000> functions <sil=2.000> .PERIOD  The <sil=0.000> concept <sil=0.000> of <sil=0.000> functions <sil=0.000> is <sil=0.000> very <sil=0.000> general <sil=0.000> and <sil=0.000> we <sil=0.000> will
have <sil=0.000> to <sil=0.000> first <sil=0.000> look <sil=0.000> at <sil=0.000> it <sil=0.000> from <sil=0.000> the <sil=0.000> general <sil=0.000> angle <sil=0.000> why <sil=0.000> it <sil=0.000> is <sil=0.000> required <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> a function <sil=0.228> ?QUESTIONMARK 
And <sil=0.000> then <sil=0.000> we <sil=0.000> can <sil=0.000> look <sil=0.000> at <sil=0.000> some <sil=0.000> of <sil=0.000> the <sil=0.000> details <sil=0.000> of <sil=0.000> this <sil=0.000> the <sil=0.000> implementation <sil=0.000> of <sil=0.000> this <sil=0.000> concept <sil=0.000> in
the <sil=0.000> C language <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  first <sil=0.000> let <sil=0.000> us <sil=0.000> start <sil=0.000> with <sil=0.000> functions <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> we <sil=0.000> will <sil=0.000> start <sil=0.000> to <sil=0.000> visualise <sil=0.000> a task <sil=2.000> .PERIOD 

Suppose <sil=0.000> I have <sil=0.000> got <sil=0.000> a big <sil=0.000> task <sil=0.000> alright <sil=0.000> which <sil=0.000> I have <sil=0.000> to <sil=0.000> implement <sil=0.000> by <sil=0.000> programming <sil=2.000> .PERIOD  Now
any <sil=0.000> task <sil=0.000> this <sil=0.000> is <sil=0.000> one <sil=0.000> task <sil=0.000> this <sil=0.000> task <sil=0.000> may <sil=0.000> be <sil=0.000> too <sil=0.000> complicated <sil=2.000> .PERIOD  And <sil=0.000> for <sil=0.000> any <sil=0.000> human
programmer <sil=0.000> or <sil=0.000> any <sil=0.000> human <sil=0.000> being <sil=0.000> to <sil=0.000> solve <sil=0.000> this <sil=0.000> task <sil=0.000> from <sil=0.000> the <sil=0.000> beginning <sil=0.000> till <sil=0.000> end <sil=0.000> in <sil=0.000> one <sil=0.000> shot
may <sil=0.000> be <sil=0.000> difficult <sil=2.000> .PERIOD  Often <sil=0.000> what <sil=0.000> we <sil=0.000> do <sil=0.000> we <sil=0.000> break <sil=0.000> up <sil=0.000> this <sil=0.000> task <sil=0.000> into <sil=0.000> a set <sil=0.000> of <sil=0.000> smaller <sil=0.000> sub <sil=0.000> tasks <sil=1.000> ,COMMA 
different <sil=0.000> sub <sil=0.000> tasks <sil=0.228> ?QUESTIONMARK  And <sil=0.000> each <sil=0.000> of <sil=0.000> this <sil=0.000> sub <sil=0.000> tasks <sil=0.000> are <sil=0.000> smaller <sil=0.000> enough <sil=1.000> ,COMMA  small <sil=0.000> enough <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that
we <sil=0.000> can <sil=0.000> manage <sil=0.000> it <sil=0.000> better <sil=0.000> each <sil=0.000> of <sil=0.000> these <sil=0.000> are <sil=0.000> possibly <sil=0.000> better <sil=0.000> managed <sil=1.000> ,COMMA  alright <sil=2.000> .PERIOD 
We <sil=0.000> can <sil=0.000> say <sil=0.000> if <sil=0.000> you <sil=0.000> think <sil=0.000> of <sil=0.000> a program <sil=0.000> segment <sil=0.000> a part <sil=0.000> of <sil=0.000> a program <sil=2.000> .PERIOD  If <sil=0.000> the <sil=0.000> task <sil=0.000> is <sil=0.000> broken
big <sil=0.000> task <sil=0.000> is <sil=0.000> broken <sil=0.000> down <sil=0.000> into <sil=0.000> a small <sil=0.000> task <sil=0.000> a number <sil=0.000> of <sil=0.000> small <sil=0.000> tasks <sil=1.000> ,COMMA  then <sil=0.000> it <sil=0.000> is <sil=0.000> easier <sil=0.000> to
write <sil=0.000> the <sil=0.000> program <sil=0.000> for <sil=0.000> each <sil=0.000> of <sil=0.000> these <sil=0.000> smaller <sil=0.000> tasks <sil=2.000> .PERIOD  And <sil=0.000> each <sil=0.000> of <sil=0.000> these <sil=0.000> tasks <sil=0.000> can <sil=0.000> be
independently <sil=0.000> tested <sil=0.000> for <sil=0.000> it <sil=0.000> is <sil=0.000> correctness <sil=1.000> ,COMMA  whether <sil=0.000> it <sil=0.000> is <sil=0.000> working <sil=0.000> properly <sil=0.000> or <sil=0.000> not <sil=0.000> each <sil=0.000> of
these <sil=0.000> can <sil=0.000> be <sil=0.000> separately <sil=0.000> tested <sil=2.000> .PERIOD 
And <sil=0.000> then <sil=0.000> if <sil=0.000> all <sil=0.000> these <sil=0.000> are <sil=0.000> connected <sil=0.000> together <sil=0.000> if <sil=0.000> all <sil=0.000> these <sil=0.000> are <sil=0.000> connected <sil=0.000> together <sil=0.000> one <sil=0.000> after
another <sil=0.000> and <sil=0.000> then <sil=0.000> I can <sil=0.000> ultimately <sil=0.000> get <sil=0.000> this <sil=0.000> enter <sil=0.000> task <sil=0.000> done <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  instead <sil=0.000> of <sil=0.000> addressing <sil=0.000> the
whole <sil=0.000> task <sil=0.000> into <sil=0.000> execute <sil=0.000> the <sil=0.000> whole <sil=0.000> task <sil=1.000> ,COMMA  or <sil=0.000> implement <sil=0.000> the <sil=0.000> whole <sil=0.000> task <sil=1.000> ,COMMA  as <sil=0.000> a single <sil=0.000> task <sil=0.000> it <sil=0.000> is
often <sil=0.000> advisable <sil=0.000> to <sil=0.000> break <sil=0.000> it <sil=0.000> down <sil=0.000> into <sil=0.000> a number <sil=0.000> of <sil=0.000> subtasks <sil=2.000> .PERIOD 
Now <sil=0.000> let <sil=0.000> us <sil=0.000> talk <sil=0.000> about <sil=0.000> programming <sil=1.000> ,COMMA  now <sil=0.000> if <sil=0.000> we <sil=0.000> want <sil=0.000> to <sil=0.000> know <sil=0.000> what <sil=0.000> is <sil=0.000> a when <sil=0.000> we <sil=0.000> say <sil=0.000> the
term <sil=0.000> function <sil=1.000> ,COMMA  if <sil=0.000> we <sil=0.000> take <sil=0.000> the <sil=0.000> English <sil=0.000> meaning <sil=0.000> of <sil=0.000> that <sil=0.000> function <sil=0.000> is <sil=0.000> means <sil=0.000> doing <sil=0.000> something <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> a also <sil=0.000> a task <sil=0.000> therefore <sil=1.000> ,COMMA  this <sil=0.000> entire <sil=0.000> function <sil=0.000> can <sil=0.000> be <sil=0.000> broken <sil=0.000> down <sil=0.000> into <sil=0.000> smaller
functions <sil=0.000> and <sil=0.000> each <sil=0.000> of <sil=0.000> this <sil=0.000> functions <sil=0.000> can <sil=0.000> be <sil=0.000> implemented <sil=0.000> independently <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  the <sil=0.000> advantage <sil=0.000> that <sil=0.000> we <sil=0.000> get <sil=0.000> by <sil=0.000> this <sil=0.000> means <sil=0.000> is <sil=0.000> that <sil=0.000> we <sil=0.000> can <sil=0.000> divide <sil=0.000> the <sil=0.000> problem <sil=0.000> into
smaller <sil=0.000> parts <sil=0.000> and <sil=0.000> thereby <sil=0.000> we <sil=0.000> can <sil=0.000> conquer <sil=0.000> the <sil=0.000> small <sil=1.000> ,COMMA  we <sil=0.000> can <sil=0.000> conquer <sil=0.000> the <sil=0.000> smaller <sil=0.000> sub
segments <sil=0.000> and <sil=0.000> in <sil=0.000> the <sil=0.000> process <sil=1.000> ,COMMA  we <sil=0.000> in <sil=0.000> the <sil=0.000> process <sil=0.000> we <sil=0.000> achieve <sil=0.000> the <sil=0.000> complete <sil=0.000> task <sil=0.000> that <sil=0.000> is <sil=0.000> the
first <sil=0.000> thing <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  by <sil=0.000> this <sil=0.000> it <sil=0.000> is <sil=0.000> easier <sil=0.000> to <sil=0.000> implement <sil=0.000> and <sil=0.000> also <sil=0.000> easier <sil=0.000> to <sil=0.000> test <sil=0.000> or <sil=0.000> verify <sil=2.000> .PERIOD 
We <sil=0.000> can <sil=0.000> check <sil=0.000> whether <sil=0.000> each <sil=0.000> of <sil=0.000> these <sil=0.000> components <sil=0.000> are <sil=0.000> working <sil=0.000> correctly <sil=0.000> or <sil=0.000> not <sil=2.000> .PERIOD  Now
when <sil=0.000> we <sil=0.000> find <sil=0.000> that <sil=0.000> all <sil=0.000> the <sil=0.000> components <sil=0.000> are <sil=0.000> working <sil=0.000> correctly <sil=0.000> and <sil=0.000> if <sil=0.000> they <sil=0.000> are <sil=0.000> connected
together <sil=0.000> correctly <sil=1.000> ,COMMA  then <sil=0.000> we <sil=0.000> will <sil=0.000> have <sil=0.000> the <sil=0.000> entire <sil=0.000> problem <sil=0.000> solved <sil=0.000> correctly <sil=0.000> that <sil=0.000> is <sil=0.000> the <sil=0.000> first
advantage <sil=0.000> of <sil=0.000> writing <sil=0.000> a complex <sil=0.000> program <sil=0.000> broken <sil=0.000> down <sil=0.000> into <sil=0.000> smaller <sil=0.000> functions <sil=2.000> .PERIOD 
Now <sil=0.000> the <sil=0.000> other <sil=0.000> advantage <sil=0.000> is <sil=0.000> suppose <sil=0.000> I had <sil=0.000> 2 implement <sil=0.000> one <sil=0.000> task <sil=2.000> .PERIOD 

And <sil=0.000> in <sil=0.000> order <sil=0.000> to <sil=0.000> implement <sil=0.000> this <sil=0.000> big <sil=0.000> task <sil=1.000> ,COMMA  I <sil=0.000> had <sil=0.000> to <sil=0.000> write <sil=0.000> a number <sil=0.000> of <sil=0.000> functions <sil=0.000> smaller
functions <sil=2.000> .PERIOD  Say <sil=0.000> 3 smaller <sil=0.000> functions <sil=0.000> together <sil=0.000> implement <sil=0.000> this <sil=0.000> big <sil=0.000> function <sil=0.000> alright <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> us
call <sil=0.000> them <sil=0.000> f 1 <sil=0.000> function <sil=0.000> 1 <sil=1.000> ,COMMA  f <sil=0.000> 2 for <sil=0.000> function <sil=0.000> 2 and <sil=0.000> f 3 <sil=0.000> for <sil=0.000> function <sil=0.000> 3 <sil=2.000> .PERIOD 
Now <sil=0.000> suppose <sil=0.000> I have <sil=0.000> now <sil=0.000> this <sil=0.000> problem <sil=0.000> has <sil=0.000> been <sil=0.000> solved <sil=0.000> by <sil=0.000> solving <sil=0.000> each <sil=0.000> of <sil=0.000> these <sil=0.000> 3
functions <sil=1.000> ,COMMA  each <sil=0.000> of <sil=0.000> these <sil=0.000> 3 functions <sil=0.000> have <sil=0.000> been <sil=0.000> written <sil=0.000> and <sil=0.000> tested <sil=0.000> and <sil=0.000> consequently <sil=0.000> they
have <sil=0.000> been <sil=0.000> connected <sil=0.000> together <sil=0.000> and <sil=0.000> we <sil=0.000> have <sil=0.000> got <sil=0.000> the <sil=0.000> complete <sil=0.000> function <sil=2.000> .PERIOD  Now <sil=0.000> suppose
another <sil=0.000> friend <sil=0.000> of <sil=0.000> yours <sil=0.000> wants <sil=0.000> to <sil=0.000> write <sil=0.000> another <sil=0.000> task <sil=0.000> solve <sil=0.000> another <sil=0.000> task <sil=0.000> say <sil=0.000> this <sil=0.000> was <sil=0.000> this
was <sil=0.000> also <sil=0.000> a task <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> also <sil=0.000> a function <sil=0.000> I am <sil=0.000> writing <sil=0.000> that <sil=0.000> as <sil=0.000> capital <sil=0.000> F 1 <sil=0.000> and <sil=0.000> there <sil=0.000> is <sil=0.000> another <sil=0.000> friend <sil=0.000> of
yours <sil=0.000> who <sil=0.000> is <sil=0.000> trying <sil=0.000> to <sil=0.000> complete <sil=1.000> ,COMMA  another <sil=0.000> task <sil=0.000> which <sil=0.000> we <sil=0.000> are <sil=0.000> naming <sil=0.000> as <sil=0.000> F 2 <sil=2.000> .PERIOD  Now <sil=0.000> in <sil=0.000> order
to <sil=0.000> develop <sil=0.000> F 2 <sil=1.000> ,COMMA  he <sil=0.000> finds <sil=0.000> that <sil=0.000> I have <sil=0.000> to <sil=0.000> solve <sil=0.000> some <sil=0.000> problems <sil=0.000> some <sil=0.000> sub <sil=0.000> problems <sil=1.000> ,COMMA  which
are <sil=0.000> solved <sil=0.000> by <sil=0.000> f 1 <sil=0.000> and <sil=0.000> another <sil=0.000> sub <sil=0.000> problem <sil=0.000> which <sil=0.000> is <sil=0.000> solved <sil=0.000> by <sil=0.000> f 3 <sil=1.000> ,COMMA  might <sil=0.000> be <sil=0.000> that <sil=0.000> this <sil=0.000> sub
problem <sil=0.000> requires <sil=0.000> f 1 <sil=1.000> ,COMMA  f <sil=0.000> 3 and <sil=0.000> say <sil=0.000> another <sil=0.000> function <sil=0.000> which <sil=0.000> was <sil=0.000> not <sil=0.000> written <sil=0.000> by <sil=0.000> anybody <sil=0.000> till
now <sil=0.000> f 4 <sil=2.000> .PERIOD 
Now <sil=0.354> ;SEMICOLON  obviously <sil=1.000> ,COMMA  since <sil=0.000> f 1 <sil=0.000> has <sil=0.000> been <sil=0.000> written <sil=0.000> and <sil=0.000> tested <sil=0.000> he <sil=0.000> the <sil=0.000> writer <sil=0.000> of <sil=0.000> f 2 <sil=0.000> did <sil=0.000> not <sil=0.000> write <sil=0.000> f 1
again <sil=1.000> ,COMMA  because <sil=0.000> that <sil=0.000> f 1 <sil=0.000> this <sil=0.000> f 1 <sil=0.000> can <sil=0.000> be <sil=0.000> used <sil=0.000> for <sil=0.000> this <sil=0.000> purpose <sil=0.000> similarly <sil=0.000> this <sil=0.000> f 3 <sil=0.000> can <sil=0.000> be <sil=0.000> used
for <sil=0.000> this <sil=0.000> purpose <sil=1.000> ,COMMA  and <sil=0.000> only <sil=0.000> effort <sil=0.000> that <sil=0.000> he <sil=0.000> has <sil=0.000> to <sil=0.000> spend <sil=0.000> is <sil=0.000> to <sil=0.000> write <sil=0.000> f 4 <sil=2.000> .PERIOD  Thus <sil=0.000> the <sil=0.000> functions
which <sil=0.000> are <sil=0.000> written <sil=0.000> already <sil=0.000> right <sil=0.000> can <sil=0.000> be <sil=0.000> reused <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> reusability <sil=0.000> is <sil=0.000> another <sil=0.000> very <sil=0.000> important <sil=0.000> advantage <sil=0.000> of <sil=0.000> writing <sil=0.000> functions <sil=2.000> .PERIOD  Now <sil=0.000> we
have <sil=0.000> said <sil=0.000> that <sil=0.000> in <sil=0.000> order <sil=0.000> to <sil=0.000> solve <sil=0.000> F 1 <sil=0.000> or <sil=0.000> F 2 <sil=0.000> we <sil=0.000> have <sil=0.000> to <sil=0.000> write <sil=0.000> we <sil=0.000> will <sil=0.000> have <sil=0.000> to <sil=0.000> independently
write <sil=0.000> and <sil=0.000> test <sil=0.000> smallest <sil=0.000> functions <sil=0.000> and <sil=0.000> connect <sil=0.000> them <sil=0.000> together <sil=2.000> .PERIOD  What <sil=0.000> do <sil=0.000> I mean <sil=0.000> by
connecting <sil=0.000> them <sil=0.000> together <sil=0.000> let <sil=0.000> us <sil=0.000> try <sil=0.000> to <sil=0.000> understand <sil=0.000> that <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  say <sil=0.000> we <sil=0.000> have <sil=0.000> a function <sil=0.000> that <sil=0.000> is <sil=0.000> to <sil=0.000> be <sil=0.000> done <sil=0.000> developed <sil=0.000> and <sil=0.000> we <sil=0.000> find <sil=0.000> that <sil=0.000> this <sil=0.000> part <sil=0.000> has <sil=0.000> to
be <sil=0.000> this <sil=0.000> part <sil=0.354> ;SEMICOLON  this <sil=0.000> task <sil=0.000> has <sil=0.000> to <sil=0.000> be <sil=0.000> solved <sil=0.000> by <sil=0.000> some <sil=0.000> function <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> write <sil=0.000> a function <sil=0.000> here <sil=0.000> for
this <sil=0.000> part <sil=0.354> ;SEMICOLON  let <sil=0.000> me <sil=0.000> do <sil=0.000> it <sil=0.000> again <sil=2.000> .PERIOD 

This <sil=0.000> is <sil=0.000> my <sil=0.000> whole <sil=0.000> problem <sil=0.000> that <sil=0.000> I have <sil=0.000> to <sil=0.000> solve <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> solving <sil=0.000> some <sil=0.000> things <sil=0.000> here <sil=0.000> some
steps <sil=0.000> I am <sil=0.000> solving <sil=2.000> .PERIOD  And <sil=0.000> then <sil=0.000> I find <sil=0.000> here <sil=0.000> there <sil=0.000> is <sil=0.000> something <sil=0.000> that <sil=0.000> has <sil=0.000> to <sil=0.000> be <sil=0.000> done <sil=0.000> which <sil=0.000> is
not <sil=0.000> very <sil=0.000> easy <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  for <sil=0.000> that <sil=0.000> I came <sil=0.000> at <sil=0.000> this <sil=0.000> point <sil=0.000> and <sil=0.000> for <sil=0.000> this <sil=0.000> I need <sil=0.000> to <sil=0.000> write <sil=0.000> a function <sil=0.000> or
might <sil=0.000> be <sil=0.000> there <sil=0.000> is <sil=0.000> a function <sil=0.000> already <sil=0.000> existing <sil=0.000> in <sil=0.000> my <sil=0.000> library <sil=1.000> ,COMMA  which <sil=0.000> has <sil=0.000> been <sil=0.000> writ
ten <sil=0.000> by <sil=0.000> somebody <sil=0.000> else <sil=1.000> ,COMMA  which <sil=0.000> I can <sil=0.000> reuse <sil=2.000> .PERIOD 
Now <sil=0.000> in <sil=0.000> that <sil=0.000> case <sil=0.000> and <sil=0.000> also <sil=0.000> say <sil=0.000> here <sil=0.000> after <sil=0.000> doing <sil=0.000> that <sil=0.000> here <sil=0.000> I can <sil=0.000> do <sil=0.000> a couple <sil=0.000> of <sil=0.000> simpler <sil=0.000> tasks
and <sil=0.000> then <sil=0.000> here <sil=0.000> I come <sil=0.000> to <sil=0.000> another <sil=0.000> point <sil=1.000> ,COMMA  which <sil=0.000> requires <sil=0.000> it <sil=0.000> to <sil=0.000> be <sil=0.000> independently <sil=0.000> solved <sil=0.000> and
written <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> need <sil=0.000> a function <sil=0.000> for <sil=0.000> that <sil=0.000> and <sil=0.000> then <sil=0.000> after <sil=0.000> that <sil=0.000> I will <sil=0.000> do <sil=0.000> some <sil=0.000> more <sil=0.000> simple
things <sil=0.000> and <sil=0.000> my <sil=0.000> task <sil=0.000> will <sil=0.000> be <sil=0.000> over <sil=0.000> say <sil=0.000> this <sil=0.000> is <sil=0.000> a situation <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  when <sil=0.000> I come <sil=0.000> here <sil=0.000> I will <sil=0.000> have <sil=0.000> to <sil=0.000> I means <sil=0.000> this <sil=0.000> program <sil=1.000> ,COMMA  which <sil=0.000> is <sil=0.000> a main <sil=0.000> tasks <sil=0.000> main
task <sil=0.000> that <sil=0.000> I have <sil=0.000> to <sil=0.000> solve <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  since <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=0.000> the <sil=0.000> name <sil=0.000> main <sil=0.000> in <sil=0.000> our <sil=0.000> description <sil=0.000> for <sil=0.000> C
earlier <sil=1.000> ,COMMA  let <sil=0.000> me <sil=0.000> also <sil=0.000> name <sil=0.000> this <sil=0.000> to <sil=0.000> be <sil=0.000> main <sil=0.000> and <sil=0.000> I am <sil=0.000> just <sil=0.000> for <sil=0.000> nothing <sil=0.000> I am <sil=0.000> just <sil=0.000> putting <sil=0.000> some
parenthesis <sil=0.000> here <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  main <sil=0.000> is <sil=0.000> a main <sil=0.000> task <sil=0.000> that <sil=0.000> I have <sil=0.000> to <sil=0.000> do <sil=0.000> and <sil=0.000> at <sil=0.000> this <sil=0.000> point <sil=0.000> I am <sil=0.000> doing <sil=0.000> something s <sil=0.000> and
here <sil=0.000> I need <sil=0.000> the <sil=0.000> help <sil=0.000> of <sil=0.000> this <sil=1.000> ,COMMA  now <sil=0.000> remember <sil=2.000> .PERIOD  That <sil=0.000> this <sil=0.000> function <sil=0.000> whose <sil=0.000> name <sil=0.000> is <sil=0.000> say <sil=0.000> f f <sil=0.000> 1
that <sil=0.000> can <sil=0.000> be <sil=0.000> used <sil=0.000> by <sil=0.000> my <sil=0.000> main <sil=0.000> function <sil=0.000> or <sil=0.000> somebody <sil=0.000> else <sil=0.000> main <sil=0.000> function <sil=0.000> also <sil=2.000> .PERIOD  Therefore <sil=1.000> ,COMMA 
when <sil=0.000> I need <sil=0.000> this <sil=0.000> to <sil=0.000> be <sil=0.000> executed <sil=0.000> with <sil=0.000> my <sil=0.000> data <sil=1.000> ,COMMA  then <sil=0.000> I must <sil=0.000> whatever <sil=0.000> data <sil=0.000> I have <sil=0.000> prepared
here <sil=0.000> that <sil=0.000> some <sil=0.000> of <sil=0.000> that <sil=0.000> I will <sil=0.000> have <sil=0.000> to <sil=0.000> pass <sil=0.000> on <sil=0.000> to <sil=0.000> this <sil=0.000> here <sil=2.000> .PERIOD 
And <sil=0.000> this <sil=0.000> will <sil=0.000> solve <sil=0.000> this <sil=0.000> subtask <sil=0.000> and <sil=0.000> then <sil=0.000> I will <sil=0.000> have <sil=0.000> to <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  a <sil=0.000> this <sil=0.000> must <sil=0.000> give <sil=0.000> back
whatever <sil=0.000> it <sil=0.000> computed <sil=0.000> to <sil=0.000> the <sil=0.000> main <sil=0.000> task <sil=0.000> and <sil=0.000> the <sil=0.000> main <sil=0.000> task <sil=0.000> will <sil=0.000> continued <sil=0.000> doing <sil=0.000> simple
things <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you <sil=0.000> see <sil=0.000> that <sil=0.000> there <sil=0.000> are <sil=0.000> 2 links <sil=0.354> ;SEMICOLON  one <sil=0.000> is <sil=0.000> going <sil=0.000> in <sil=0.000> the <sil=0.000> function <sil=1.000> ,COMMA  another <sil=0.000> is
coming <sil=0.000> out <sil=0.000> or <sil=0.000> some <sil=0.000> data <sil=0.000> that <sil=0.000> is <sil=0.000> being <sil=0.000> returned <sil=0.000> by <sil=0.000> this <sil=0.000> function <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> being <sil=0.000> returned <sil=0.000> by
this <sil=0.000> function <sil=2.000> .PERIOD  Then <sil=0.000> I carry <sil=0.000> out <sil=0.000> some <sil=0.000> tasks <sil=0.000> simpler <sil=0.000> tasks <sil=0.000> here <sil=0.000> and <sil=0.000> at <sil=0.000> this <sil=0.000> point <sil=0.000> I find <sil=0.000> now <sil=0.000> I
need <sil=0.000> help <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  some <sil=0.000> part <sil=0.000> of <sil=0.000> the <sil=0.000> data <sil=0.000> from <sil=0.000> here <sil=0.000> will <sil=0.000> be <sil=0.000> used <sil=0.000> by <sil=0.000> the <sil=0.000> function <sil=0.000> f 2 <sil=0.000> and <sil=0.000> that <sil=0.000> has <sil=0.000> to <sil=0.000> come
to <sil=0.000> f 2 <sil=0.000> here <sil=0.000> and <sil=0.000> f 2 <sil=0.000> will <sil=0.000> carry <sil=0.000> out <sil=0.000> the <sil=0.000> task <sil=0.000> and <sil=0.000> will <sil=0.000> return <sil=0.000> to <sil=0.000> the <sil=0.000> point <sil=0.000> here <sil=2.000> .PERIOD  Now <sil=0.000> about <sil=0.000> this
return <sil=0.000> you <sil=0.000> should <sil=0.000> observe <sil=0.000> one <sil=0.000> thing <sil=1.000> ,COMMA  that <sil=0.000> the <sil=0.000> function <sil=0.000> was <sil=0.000> called <sil=0.000> from <sil=0.000> this <sil=0.000> point <sil=1.000> ,COMMA  we <sil=0.000> call
this <sil=0.000> thing <sil=0.000> to <sil=0.000> be <sil=0.000> a function <sil=0.000> call <sil=0.000> function <sil=0.000> call <sil=0.000> with <sil=0.000> some <sil=0.000> data <sil=0.000> being <sil=0.000> passed <sil=0.000> on <sil=0.000> to <sil=0.000> this <sil=2.000> .PERIOD  And
function <sil=0.000> calls <sil=0.000> or <sil=0.000> function <sil=0.000> invocation <sil=0.000> and <sil=0.000> after <sil=0.000> invocation <sil=0.000> this <sil=0.000> function <sil=0.000> works <sil=0.000> and <sil=0.000> it
returns <sil=0.000> where <sil=0.000> does <sil=0.000> it <sil=0.000> return <sil=0.228> ?QUESTIONMARK 

It <sil=0.000> returns <sil=0.000> to <sil=0.000> the <sil=0.000> point <sil=0.000> in <sil=0.000> the <sil=0.000> main <sil=0.000> task <sil=0.000> just <sil=0.000> after <sil=0.000> the <sil=0.000> point <sil=0.000> from <sil=0.000> where <sil=0.000> it <sil=0.000> was <sil=0.000> called <sil=2.000> .PERIOD  It <sil=0.000> was
called <sil=0.000> from <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> comes <sil=0.000> here <sil=0.000> and <sil=0.000> then <sil=0.000> returns <sil=0.000> to <sil=0.000> the <sil=0.000> next <sil=0.000> point <sil=0.000> just <sil=0.000> after <sil=0.000> the <sil=0.000> after
this <sil=0.000> call <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> a calling <sil=0.000> point <sil=0.000> and <sil=0.000> this <sil=0.000> a return <sil=0.000> point <sil=2.000> .PERIOD 
Similarly <sil=0.000> for <sil=0.000> here <sil=0.000> you <sil=0.000> see <sil=0.000> that <sil=0.000> it <sil=0.000> is <sil=0.000> executing <sil=0.000> and <sil=0.000> at <sil=0.000> this <sil=0.000> point <sil=0.000> it <sil=0.000> is <sil=0.000> being <sil=0.000> called <sil=2.000> .PERIOD  And <sil=0.000> after
execution <sil=0.000> the <sil=0.000> control <sil=0.000> is <sil=0.000> returned <sil=0.000> into <sil=0.000> the <sil=0.000> immediately <sil=0.000> after <sil=0.000> the <sil=0.000> point <sil=0.000> from <sil=0.000> where <sil=0.000> it <sil=0.000> was
called <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> one <sil=0.000> important <sil=0.000> thing <sil=0.000> to <sil=0.000> understand <sil=0.000> the <sil=0.000> other <sil=0.000> important <sil=0.000> thing <sil=0.000> is <sil=0.000> that <sil=0.000> let <sil=0.000> me <sil=0.000> draw
it <sil=0.000> again <sil=0.000> here <sil=2.000> .PERIOD  I <sil=0.000> have <sil=0.000> got <sil=0.000> my <sil=0.000> main <sil=0.000> task <sil=0.000> and <sil=0.000> this <sil=0.000> is <sil=0.000> my <sil=0.000> main <sil=0.000> and <sil=0.000> here <sil=0.000> is <sil=0.000> another <sil=0.000> main <sil=0.000> task <sil=1.000> ,COMMA 
some <sil=0.000> other <sil=0.000> main <sil=0.000> task <sil=0.000> not <sil=0.000> written <sil=0.000> by <sil=0.000> me <sil=1.000> ,COMMA  but <sil=0.000> somebody <sil=0.000> else <sil=0.000> this <sil=0.000> is <sil=0.000> of <sil=0.000> mister <sil=0.000> A and <sil=0.000> this <sil=0.000> is
of <sil=0.000> mister <sil=0.000> B for <sil=0.000> mister <sil=0.000> B there <sil=0.000> is <sil=0.000> he <sil=0.000> has <sil=0.000> written <sil=0.000> another <sil=0.000> main <sil=2.000> .PERIOD 
Now <sil=0.000> mister <sil=0.000> A or <sil=0.000> mister <sil=0.000> B both <sil=0.000> will <sil=0.000> require <sil=0.000> this <sil=0.000> function <sil=0.000> f <sil=2.000> .PERIOD  Now <sil=0.000> the <sil=0.000> task <sil=0.000> the <sil=0.000> purpose <sil=0.000> of
what <sil=0.000> this <sil=0.000> task <sil=0.000> does <sil=0.000> is <sil=0.000> same <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  this <sil=0.000> task <sil=0.000> is <sil=0.000> computes <sil=0.000> the <sil=0.000> average <sil=0.000> of <sil=0.000> some
numbers <sil=1.000> ,COMMA  10 <sil=0.000> numbers <sil=1.000> ,COMMA  5 <sil=0.000> numbers <sil=0.000> whatever <sil=0.000> it <sil=0.000> is <sil=0.000> or <sil=0.000> may <sil=0.000> be <sil=0.000> floating <sil=0.000> point <sil=0.000> numbers <sil=1.000> ,COMMA 
integer <sil=0.000> numbers <sil=1.000> ,COMMA  whatever <sil=0.000> it <sil=0.000> is <sil=0.000> it <sil=0.000> computes <sil=0.000> the <sil=0.000> average <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  let <sil=0.000> me <sil=0.000> let <sil=0.000> me <sil=0.000> quickly <sil=0.000> rename <sil=0.000> it <sil=0.000> not <sil=0.000> keeping <sil=0.000> it <sil=0.000> wage <sil=0.000> any <sil=0.000> longer <sil=0.000> let <sil=0.000> me <sil=0.000> call <sil=0.000> it <sil=1.000> ,COMMA  average
or <sil=0.000> for <sil=0.000> a specific <sil=0.000> purpose <sil=1.000> ,COMMA  I <sil=0.000> want <sil=0.000> to <sil=0.000> write <sil=0.000> it <sil=0.000> inside <sil=0.000> the <sil=0.000> reason <sil=0.000> will <sil=0.000> be <sil=0.000> clear <sil=0.000> immediately
this <sil=0.000> computes <sil=0.000> the <sil=0.000> average <sil=2.000> .PERIOD 

Now <sil=0.000> mister <sil=0.000> a wants <sil=0.000> to <sil=0.000> use <sil=0.000> this <sil=0.000> average <sil=0.000> function <sil=0.000> for <sil=0.000> some <sil=0.000> data <sil=0.000> for <sil=0.000> 3 data <sil=0.000> he <sil=0.000> wants <sil=0.000> to
compute <sil=0.000> the <sil=0.000> average <sil=0.000> of <sil=0.000> 3 integers <sil=1.000> ,COMMA  suppose <sil=0.000> this <sil=0.000> one <sil=0.000> this <sil=0.000> one <sil=0.000> computes <sil=0.000> the <sil=0.000> average <sil=0.000> of <sil=0.000> 3
integers <sil=1.000> ,COMMA  but <sil=0.000> the <sil=0.000> integers <sil=0.000> can <sil=0.000> vary <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> also <sil=0.000> wants <sil=0.000> to <sil=0.000> find <sil=0.000> the <sil=0.000> average <sil=0.000> of <sil=0.000> 3
integers <sil=0.000> to <sil=0.000> make <sil=0.000> it <sil=0.000> simple <sil=2.000> .PERIOD 
But <sil=0.000> the <sil=0.000> in <sil=0.000> numbers <sil=0.000> for <sil=0.000> which <sil=0.000> A wants <sil=0.000> to <sil=0.000> compute <sil=0.000> the <sil=0.000> averages <sil=0.000> different <sil=0.000> from <sil=0.000> the
numbers <sil=0.000> that <sil=0.000> B will <sil=0.000> compute <sil=0.000> the <sil=0.000> average <sil=0.000> for <sil=1.000> ,COMMA  but <sil=0.000> this <sil=0.000> a v <sil=0.000> g is <sil=0.000> common <sil=0.000> to <sil=0.000> both <sil=0.000> therefore <sil=1.000> ,COMMA 
suppose <sil=0.000> the <sil=0.000> numbers <sil=0.000> that <sil=0.000> some <sil=0.000> integers <sil=0.000> say <sil=0.000> are <sil=0.000> a b <sil=0.000> and <sil=0.000> c and <sil=0.000> here <sil=0.000> this <sil=0.000> person <sil=0.000> wants <sil=0.000> to
find <sil=0.000> the <sil=0.000> average <sil=0.000> of <sil=0.000> 3 integers <sil=0.000> which <sil=0.000> are <sil=0.000> p q <sil=0.000> and <sil=0.000> r 3 <sil=0.000> variable <sil=0.000> names <sil=2.000> .PERIOD 
Now <sil=0.000> this <sil=0.000> average <sil=0.000> cannot <sil=0.000> remember <sil=0.000> p q <sil=0.000> r or <sil=0.000> a b <sil=0.000> c it <sil=0.000> will <sil=0.000> simply <sil=0.000> just <sil=0.000> like <sil=0.000> think <sil=0.000> of <sil=0.000> a box
with <sil=0.000> 3 pipes <sil=0.000> coming <sil=0.000> in <sil=0.000> and <sil=0.000> data <sil=0.000> will <sil=0.000> come <sil=0.000> in <sil=0.000> through <sil=0.000> there <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  he <sil=0.000> just <sil=0.000> names <sil=0.000> this
average <sil=0.000> for <sil=0.000> he <sil=0.000> names <sil=0.000> these <sil=0.000> pipes <sil=0.000> as <sil=0.000> x this <sil=0.000> is <sil=0.000> y and <sil=0.000> this <sil=0.000> is <sil=0.000> z <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  when <sil=0.000> this <sil=0.000> function <sil=0.000> main
wants <sil=0.000> to <sil=0.000> compute <sil=0.000> the <sil=0.000> average <sil=0.000> of <sil=0.000> a b <sil=0.000> c he <sil=0.000> must <sil=0.000> send <sil=0.000> a through <sil=0.000> the <sil=0.000> pipe <sil=0.000> x b <sil=0.000> through <sil=0.000> the
pipe <sil=0.000> y and <sil=0.000> c through <sil=0.000> the <sil=0.000> pipe <sil=0.000> z and <sil=0.000> you <sil=0.000> will <sil=0.000> get <sil=0.000> the <sil=0.000> average <sil=0.000> computed <sil=1.000> ,COMMA  and <sil=0.000> the <sil=0.000> average
will <sil=0.000> be <sil=0.000> returned <sil=0.000> from <sil=0.000> the <sil=0.000> point <sil=0.000> where <sil=0.000> it <sil=0.000> was <sil=0.000> called <sil=0.000> from <sil=0.000> this <sil=0.000> point <sil=0.000> immediately <sil=0.000> after <sil=0.000> that
it <sil=0.000> will <sil=0.000> go <sil=0.000> back <sil=0.000> clear <sil=2.000> .PERIOD 
Now <sil=0.000> when <sil=0.000> let <sil=0.000> me <sil=0.000> change <sil=0.000> the <sil=0.000> colour <sil=1.000> ,COMMA  now <sil=0.000> when <sil=0.000> the <sil=0.000> function <sil=0.000> main <sil=0.000> B <sil=0.354> ;SEMICOLON  B <sil=0.000> wants <sil=0.000> to <sil=0.000> compute
the <sil=0.000> average <sil=0.000> he <sil=0.000> wants <sil=0.000> to <sil=0.000> compute <sil=0.000> the <sil=0.000> average <sil=0.000> of <sil=0.000> p q <sil=0.000> r <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  p <sil=0.000> will <sil=0.000> be <sil=0.000> sent <sil=0.000> to <sil=0.000> the <sil=0.000> pipe <sil=0.000> x <sil=1.000> ,COMMA  q
will <sil=0.000> be <sil=0.000> sent <sil=0.000> to <sil=0.000> the <sil=0.000> pipe <sil=0.000> y <sil=1.000> ,COMMA  and <sil=0.000> r will <sil=0.000> be <sil=0.000> sent <sil=0.000> to <sil=0.000> the <sil=0.000> pipe <sil=0.000> z <sil=2.000> .PERIOD  And <sil=0.000> the <sil=0.000> average <sil=0.000> will <sil=0.000> be
computed <sil=0.000> suppose <sil=0.000> it <sil=0.000> was <sil=0.000> called <sil=0.000> from <sil=0.000> this <sil=0.000> point <sil=1.000> ,COMMA  from <sil=0.000> this <sil=0.000> point <sil=1.000> ,COMMA  this <sil=0.000> average <sil=0.000> was <sil=0.000> called <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  then <sil=0.000> it <sil=0.000> will <sil=0.000> return <sil=0.000> the <sil=0.000> to <sil=0.000> this <sil=0.000> point <sil=0.000> with <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> the <sil=0.000> average <sil=0.000> with <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> the
average <sil=0.000> whatever <sil=0.000> is <sil=0.000> computed <sil=0.000> here <sil=2.000> .PERIOD 
Therefore <sil=1.000> ,COMMA  so <sil=0.000> if <sil=0.000> this <sil=0.000> is <sil=0.000> clear <sil=0.000> then <sil=0.000> let <sil=0.000> us <sil=0.000> come <sil=0.000> to <sil=0.000> 2 more <sil=0.000> terms <sil=2.000> .PERIOD 

They <sil=0.000> are <sil=0.000> that <sil=0.000> this <sil=0.000> function <sil=0.000> main <sil=0.000> A <sil=1.000> ,COMMA  A <sil=0.000> is <sil=0.000> main <sil=0.000> was <sil=0.000> sending <sil=0.000> a <sil=1.000> ,COMMA  b <sil=1.000> ,COMMA  c <sil=0.000> to <sil=0.000> the <sil=0.000> function <sil=0.000> as
parameters <sil=0.000> we <sil=0.000> call <sil=0.000> it <sil=0.000> as <sil=0.000> parameters <sil=2.000> .PERIOD  And <sil=0.000> this <sil=0.000> function <sil=0.000> which <sil=0.000> is <sil=0.000> our <sil=0.000> average <sil=0.000> function <sil=0.000> is
not <sil=0.000> biased <sil=0.000> to <sil=0.000> a <sil=1.000> ,COMMA  it <sil=0.000> has <sil=0.000> got <sil=0.000> it <sil=0.000> knows <sil=0.000> that <sil=0.000> it <sil=0.000> needs <sil=0.000> 3 inputs <sil=0.000> and <sil=0.000> there <sil=0.000> are <sil=0.000> 3 input <sil=0.000> pipes <sil=1.000> ,COMMA  3
input <sil=0.000> positions <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  these <sil=0.000> x y <sil=0.000> z are <sil=0.000> arguments <sil=0.000> this <sil=0.000> we <sil=0.000> call <sil=0.000> as <sil=0.000> arguments <sil=0.000> alright <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  this <sil=0.000> average
when <sil=0.000> it <sil=0.000> is <sil=0.000> written <sil=0.000> it <sil=0.000> has <sil=0.000> got <sil=0.000> 3 input <sil=0.000> pipes <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> can <sil=0.000> write <sil=0.000> simply <sil=0.000> like <sil=0.000> this <sil=0.000> function
name <sil=0.000> average <sil=0.000> with <sil=0.000> 3 parameter <sil=0.000> arguments <sil=0.000> x y <sil=0.000> and <sil=0.000> z <sil=2.000> .PERIOD  Now <sil=0.000> who <sil=0.000> ever <sil=0.000> calls <sil=0.000> it <sil=0.000> we <sil=0.000> will <sil=0.000> have
to <sil=0.000> establish <sil=0.000> the <sil=0.000> mapping <sil=1.000> ,COMMA  between <sil=0.000> the <sil=0.000> parameters <sil=0.000> that <sil=0.000> it <sil=0.000> wants <sil=0.000> to <sil=0.000> pass <sil=0.000> the <sil=0.000> parameters <sil=0.000> it
wants <sil=0.000> to <sil=0.000> pass <sil=0.000> to <sil=0.000> the <sil=0.000> through <sil=0.000> the <sil=0.000> arguments <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  the <sil=0.000> connection <sil=0.000> that <sil=0.000> we <sil=0.000> had <sil=0.000> shown <sil=0.000> in <sil=0.000> the <sil=0.000> earlier <sil=0.000> diagram <sil=0.000> which <sil=0.000> was <sil=0.000> where <sil=0.000> both <sil=0.000> the
programs <sil=1.000> ,COMMA  were <sil=0.000> both <sil=0.000> the <sil=0.000> programs <sil=0.000> are <sil=0.000> accessing <sil=0.000> it <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  each <sil=0.000> of <sil=0.000> these <sil=0.000> parameters <sil=0.000> should
the <sil=0.000> parameters <sil=0.000> should <sil=0.000> be <sil=0.000> matching <sil=0.000> with <sil=0.000> this <sil=0.000> arguments <sil=2.000> .PERIOD  Let <sil=0.000> us <sil=0.000> come <sil=0.000> to <sil=0.000> this <sil=0.000> once <sil=0.000> again
say <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> main <sil=0.000> of <sil=0.000> A and <sil=0.000> here <sil=0.000> is <sil=0.000> main <sil=0.000> of <sil=0.000> B <sil=1.000> ,COMMA  I <sil=0.000> repeat <sil=0.000> what <sil=0.000> I was <sil=0.000> saying <sil=0.000> till <sil=0.000> now <sil=0.000> and <sil=0.000> this
has <sil=0.000> got <sil=0.000> p q <sil=0.000> r now <sil=1.000> ,COMMA  you <sil=0.000> must <sil=0.000> be <sil=0.000> must <sil=0.000> have <sil=0.000> realised <sil=0.000> now <sil=1.000> ,COMMA  what <sil=0.000> are <sil=0.000> these <sil=0.000> p q <sil=0.000> r <sil=0.228> ?QUESTIONMARK  When <sil=0.000> I use
this <sil=0.000> function <sil=0.000> average <sil=1.000> ,COMMA  which <sil=0.000> has <sil=0.000> got <sil=0.000> 3 arguments <sil=0.000> x y <sil=0.000> z which <sil=0.000> are <sil=0.000> nothing <sil=1.000> ,COMMA  but <sil=0.000> 3 pipes
which <sil=0.000> are <sil=0.000> arguments <sil=0.000> and <sil=0.000> when <sil=0.000> I call <sil=0.000> from <sil=0.000> some <sil=0.000> point <sil=1.000> ,COMMA  when <sil=0.000> I call <sil=0.000> this <sil=0.000> function <sil=0.000> average
then <sil=0.000> I have <sil=0.000> to <sil=0.000> pass <sil=0.000> these <sil=0.000> parameters <sil=0.000> p q <sil=0.000> r to <sil=0.000> these <sil=0.000> arguments <sil=0.000> x y <sil=0.000> z <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  p <sil=0.000> will <sil=0.000> go <sil=0.000> to <sil=0.000> x q <sil=0.000> will <sil=0.000> go <sil=0.000> to <sil=0.000> y and <sil=0.000> z r <sil=0.000> will <sil=0.000> go <sil=0.000> to <sil=0.000> z <sil=1.000> ,COMMA  on <sil=0.000> the <sil=0.000> other <sil=0.000> hand <sil=0.000> when <sil=0.000> a is <sil=0.000> calling
when <sil=0.000> a is <sil=0.000> calling <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> happening <sil=1.000> ,COMMA  when <sil=0.000> a is <sil=0.000> calling <sil=0.000> then <sil=0.000> a had <sil=0.000> the <sil=0.000> a b <sil=0.000> c to <sil=0.000> be <sil=0.000> passed
on <sil=0.000> to <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  a <sil=0.000> goes <sil=0.000> to <sil=0.000> x <sil=1.000> ,COMMA  b <sil=0.000> goes <sil=0.000> to <sil=0.000> y and <sil=0.000> c goes <sil=0.000> to <sil=0.000> z <sil=2.000> .PERIOD  Now <sil=0.000> since <sil=0.000> now <sil=0.000> if <sil=0.000> you <sil=0.000> just <sil=0.000> think
these <sil=0.000> are <sil=0.000> 3 pipes <sil=1.000> ,COMMA  now <sil=0.000> the <sil=0.000> pipes <sil=0.000> are <sil=0.000> every <sil=0.000> pipe <sil=0.000> has <sil=0.000> got <sil=0.000> a width <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  if <sil=0.000> I want <sil=0.000> to <sil=0.000> fit <sil=0.000> smaller <sil=0.000> pipe <sil=0.000> into <sil=0.000> a bigger <sil=0.000> pipe <sil=0.000> that <sil=0.000> would <sil=0.000> not <sil=0.000> fit <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> width <sil=0.000> of
diameter <sil=0.000> of <sil=0.000> both <sil=0.000> the <sil=0.000> pipes <sil=0.000> must <sil=0.000> fit <sil=0.000> together <sil=1.000> ,COMMA  what <sil=0.000> do <sil=0.000> I mean <sil=0.000> by <sil=0.000> that <sil=1.000> ,COMMA  what <sil=0.000> I mean <sil=0.000> by <sil=0.000> that
is <sil=0.000> that <sil=0.000> whatever <sil=0.000> arguments <sil=0.000> are <sil=0.000> whatever <sil=0.000> are <sil=0.000> the <sil=0.000> types <sil=0.000> of <sil=0.000> the <sil=0.000> arguments <sil=0.000> that <sil=0.000> must <sil=0.000> match
the <sil=0.000> types <sil=0.000> of <sil=0.000> the <sil=0.000> parameters <sil=0.000> or <sil=0.000> in <sil=0.000> other <sil=0.000> words <sil=0.000> the <sil=0.000> types <sil=0.000> of <sil=0.000> the <sil=0.000> parameters <sil=0.000> also <sil=0.000> must <sil=0.000> match
the <sil=0.000> types <sil=0.000> of <sil=0.000> the <sil=0.000> arguments <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> the <sil=0.000> pipes <sil=0.000> fit <sil=0.000> there <sil=0.000> should <sil=0.000> not <sil=0.000> be <sil=0.000> any <sil=0.000> mismatch <sil=0.000> over
there <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> take <sil=0.000> little <sil=0.000> more <sil=0.000> deeper <sil=0.000> look <sil=0.000> here <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  suppose <sil=0.000> I have <sil=0.000> got <sil=0.000> a main <sil=0.000> function <sil=0.000> here <sil=0.000> I am <sil=0.000> not <sil=0.000> so <sil=0.000> much <sil=0.000> bothered <sil=0.000> about <sil=0.000> the <sil=0.000> same
types <sil=0.000> now <sil=0.000> and <sil=0.000> the <sil=0.000> main <sil=0.000> function <sil=0.000> is <sil=0.000> running <sil=0.000> and <sil=0.000> here <sil=0.000> I want <sil=0.000> to <sil=0.000> say <sil=0.000> result <sil=0.000> is <sil=0.000> average <sil=0.000> of <sil=0.000> a b
c <sil=0.000> and <sil=0.000> etcetera <sil=1.000> ,COMMA  etcetera <sil=1.000> ,COMMA  etcetera <sil=1.000> ,COMMA  etcetera <sil=0.000> and <sil=0.000> we <sil=0.000> end <sil=0.000> here <sil=2.000> .PERIOD  And <sil=0.000> let <sil=0.000> us <sil=0.000> assume <sil=0.000> that <sil=0.000> here <sil=0.000> I
have <sil=0.000> declared <sil=0.000> int <sil=0.000> a <sil=1.000> ,COMMA  b <sil=1.000> ,COMMA  c <sil=0.000> both <sil=0.000> of <sil=0.000> them <sil=0.000> are <sil=0.000> integers <sil=2.000> .PERIOD  Now <sil=0.000> we <sil=0.000> have <sil=0.000> got <sil=0.000> the <sil=0.000> function <sil=0.000> which
is <sil=0.000> average <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  this <sil=0.000> average <sil=0.000> of <sil=0.000> 3 integers <sil=0.000> can <sil=0.000> be <sil=0.000> a float <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> just <sil=0.000> write <sil=0.000> I will <sil=0.000> explain <sil=0.000> it <sil=0.000> a little <sil=0.000> later
float <sil=0.000> average <sil=0.000> x <sil=1.000> ,COMMA  y <sil=1.000> ,COMMA  z <sil=0.000> and <sil=0.000> I can <sil=0.000> say <sil=0.000> int <sil=0.000> x <sil=1.000> ,COMMA  y <sil=1.000> ,COMMA  z <sil=0.000> and <sil=0.000> whatever <sil=0.000> I am <sil=0.000> computing <sil=0.000> average <sil=0.000> here
and <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  thus <sil=0.000> this <sil=0.000> is <sil=0.000> simple <sil=0.000> you <sil=0.000> can <sil=0.000> have <sil=0.000> int <sil=0.000> sum <sil=0.000> and <sil=0.000> sum <sil=0.000> equals <sil=0.000> x plus <sil=0.000> y plus <sil=0.000> z <sil=1.000> ,COMMA  and
average <sil=0.000> is <sil=0.000> equal <sil=0.000> to <sil=0.000> x plus <sil=0.000> y plus <sil=0.000> z by <sil=0.000> 3 <sil=2.000> .PERIOD  Then <sil=0.000> I write <sil=0.000> returned <sil=1.000> ,COMMA  why <sil=0.000> do <sil=0.000> I write <sil=0.000> returned <sil=0.000> I
will <sil=0.000> come <sil=0.000> to <sil=0.000> that <sil=2.000> .PERIOD 
Now <sil=0.000> look <sil=0.000> at <sil=0.000> the <sil=0.000> 2 things <sil=0.000> a I <sil=0.000> will <sil=0.000> talk <sil=0.000> about <sil=0.000> this <sil=0.000> part <sil=0.000> a little <sil=0.000> later <sil=2.000> .PERIOD  Here <sil=0.000> I am <sil=0.000> I have
declared <sil=0.000> a b <sil=0.000> c to <sil=0.000> be <sil=0.000> integers <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  in <sil=0.000> the <sil=0.000> memory <sil=0.000> for <sil=0.000> a b <sil=0.000> and <sil=0.000> c 2 <sil=0.000> bytes <sil=0.000> or <sil=0.000> 4 bytes <sil=0.000> as <sil=0.000> the
system <sil=0.000> may <sil=0.000> demand <sil=0.000> that <sil=0.000> type <sil=0.000> of <sil=0.000> that <sil=0.000> much <sil=0.000> memory <sil=0.000> has <sil=0.000> been <sil=0.000> given <sil=2.000> .PERIOD  Now <sil=0.000> when <sil=0.000> I write
here <sil=0.000> a v <sil=0.000> g <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> invoking <sil=0.000> or <sil=0.000> calling <sil=0.000> this <sil=0.000> function <sil=0.000> a v <sil=0.000> g <sil=2.000> .PERIOD  And <sil=0.000> I am <sil=0.000> passing <sil=0.000> on
a <sil=0.000> v g <sil=0.000> requires <sil=0.000> 3 parameters <sil=0.000> x <sil=1.000> ,COMMA  y <sil=1.000> ,COMMA  z <sil=0.000> and <sil=0.000> x <sil=1.000> ,COMMA  y <sil=1.000> ,COMMA  z <sil=0.000> are <sil=0.000> all <sil=0.000> integers <sil=2.000> .PERIOD  And <sil=0.000> I could <sil=0.000> have <sil=0.000> written
there <sil=0.000> is <sil=0.000> another <sil=0.000> way <sil=0.000> of <sil=0.000> writing <sil=0.000> it <sil=0.000> that <sil=0.000> I could <sil=0.000> have <sil=0.000> written <sil=0.000> here <sil=0.000> int <sil=0.000> x int <sil=0.000> y int <sil=0.000> z that <sil=0.000> is <sil=0.000> also
possible <sil=1.000> ,COMMA  but <sil=0.000> later <sil=0.000> we <sil=0.000> will <sil=0.000> see <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  a <sil=1.000> ,COMMA  b <sil=1.000> ,COMMA  c <sil=0.000> there <sil=0.000> is <sil=0.000> a correspondence <sil=0.000> between <sil=0.000> a <sil=1.000> ,COMMA  b <sil=0.000> and <sil=0.000> c with <sil=0.000> x <sil=1.000> ,COMMA  y <sil=0.000> and <sil=0.000> z <sil=2.000> .PERIOD  And <sil=0.000> they <sil=0.000> are
matching <sil=0.000> in <sil=0.000> the <sil=0.000> type <sil=0.000> then <sil=0.000> this <sil=0.000> computation <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> come <sil=0.000> here <sil=0.000> then <sil=0.000> follow <sil=0.000> my <sil=0.000> blue <sil=0.000> line
this <sil=0.000> is <sil=0.000> being <sil=0.000> computed <sil=0.000> and <sil=0.000> ultimately <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> average <sil=0.000> is <sil=0.000> computed <sil=2.000> .PERIOD 
Look <sil=0.000> that <sil=0.000> the <sil=0.000> value <sil=0.000> is <sil=0.000> being <sil=0.000> computed <sil=0.000> in <sil=0.000> a v <sil=0.000> g which <sil=0.000> is <sil=0.000> also <sil=0.000> the <sil=0.000> name <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  in <sil=0.000> a way <sil=0.000> you <sil=0.000> can <sil=0.000> say <sil=0.000> that <sil=0.000> the <sil=0.000> name <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=0.000> is <sil=0.000> just <sil=0.000> like <sil=0.000> a variable <sil=0.000> that <sil=0.000> is
holding <sil=0.000> the <sil=0.000> value <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> holding <sil=0.000> the <sil=0.000> value <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> average <sil=0.000> any <sil=0.000> variable <sil=0.000> that <sil=0.000> is <sil=0.000> holding <sil=0.000> a
value <sil=0.000> must <sil=0.000> have <sil=0.000> a type <sil=0.000> that <sil=0.000> is <sil=0.000> why <sil=0.000> since <sil=0.000> average <sil=0.000> of <sil=0.000> 3 integers <sil=0.000> can <sil=0.000> be <sil=0.000> a float <sil=0.000> therefore <sil=1.000> ,COMMA 
we <sil=0.000> have <sil=0.000> to <sil=0.000> assign <sil=0.000> a type <sil=0.000> to <sil=0.000> the <sil=0.000> name <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=2.000> .PERIOD 
Designating <sil=0.000> what <sil=0.000> type <sil=0.000> of <sil=0.000> value <sil=0.000> it <sil=0.000> is <sil=0.000> returning <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> we <sil=0.000> can <sil=0.000> see <sil=0.000> that <sil=0.000> it <sil=0.000> will <sil=0.000> compute
average <sil=0.000> and <sil=0.000> then <sil=0.000> there <sil=0.000> is <sil=0.000> a statement <sil=0.000> new <sil=0.000> statement <sil=0.000> that <sil=0.000> you <sil=0.000> are <sil=0.000> encountering <sil=0.000> here <sil=0.000> is
returned <sil=1.000> ,COMMA  where <sil=0.000> is <sil=0.000> it <sil=0.000> returning <sil=0.000> it <sil=0.000> is <sil=0.000> returning <sil=0.000> to <sil=0.000> the <sil=0.000> point <sil=0.000> from <sil=0.000> where <sil=0.000> it <sil=0.000> is <sil=0.000> called <sil=0.000> at <sil=0.000> is <sil=0.000> this
point <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  the <sil=0.000> average <sil=1.000> ,COMMA  suppose <sil=0.000> if <sil=0.000> the <sil=0.000> values <sil=0.000> are <sil=0.000> 1 2 <sil=0.000> and <sil=0.000> 3 then <sil=0.000> the <sil=0.000> average <sil=0.000> is <sil=0.000> 2 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  then <sil=0.000> 2 goes
to <sil=0.000> this <sil=0.000> a v <sil=0.000> g and <sil=0.000> that <sil=0.000> a v <sil=0.000> g is <sil=0.000> being <sil=0.000> transferred <sil=0.000> to <sil=0.000> result <sil=2.000> .PERIOD  Now <sil=0.000> if <sil=0.000> I do <sil=0.000> print <sil=0.000> result <sil=0.000> here <sil=0.000> 2
will <sil=0.000> be <sil=0.000> printed <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> to <sil=0.000> give <sil=0.000> you <sil=0.000> an <sil=0.000> idea <sil=0.000> of <sil=0.000> what <sil=0.000> is <sil=0.000> meant <sil=0.000> by <sil=0.000> in <sil=0.000> calling <sil=0.000> a function
invoking <sil=0.000> a function <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> meant <sil=0.000> by <sil=0.000> returning <sil=0.000> from <sil=0.000> a function <sil=1.000> ,COMMA  and <sil=0.000> what <sil=0.000> are <sil=0.000> parameters
and <sil=0.000> arguments <sil=2.000> .PERIOD 
We <sil=0.000> will <sil=0.000> see <sil=0.000> more <sil=0.000> of <sil=0.000> this <sil=0.000> in <sil=0.000> the <sil=0.000> subsequent <sil=0.000> lectures <sil=1.000> ,COMMA  but <sil=0.000> you <sil=0.000> should <sil=0.000> also <sil=0.000> understand <sil=0.000> why
we <sil=0.000> do <sil=0.000> this <sil=0.000> reasons <sil=0.000> at <sil=0.000> 2 fold <sil=0.000> as <sil=0.000> I said <sil=0.000> one <sil=0.000> is <sil=0.000> to <sil=0.000> divide <sil=0.000> or <sil=0.000> break <sil=0.000> down <sil=0.000> a complex <sil=0.000> problem
into <sil=0.000> manageable <sil=0.000> sub <sil=0.000> problems <sil=1.000> ,COMMA  and <sil=0.000> the <sil=0.000> second <sil=0.000> and <sil=0.000> test <sil=0.000> them <sil=0.000> independently <sil=1.000> ,COMMA  and <sil=0.000> the
other <sil=0.000> issue <sil=0.000> is <sil=0.000> other <sil=0.000> advantage <sil=0.000> big <sil=0.000> advantage <sil=0.000> is <sil=0.000> that <sil=0.000> once <sil=0.000> we <sil=0.000> make <sil=0.000> a thing <sil=0.000> a function <sil=1.000> ,COMMA 
which <sil=0.000> is <sil=0.000> tested <sil=0.000> we <sil=0.000> can <sil=0.000> keep <sil=0.000> it <sil=0.000> for <sil=0.000> being <sil=0.000> reused <sil=0.000> that <sil=0.000> is <sil=0.000> a very <sil=0.000> very <sil=0.000> important <sil=0.000> thing <sil=2.000> .PERIOD 
And <sil=0.000> this <sil=0.000> concept <sil=0.000> is <sil=0.000> general <sil=0.000> over <sil=0.000> different <sil=0.000> languages <sil=0.000> like <sil=0.354> ;SEMICOLON  we <sil=0.000> have <sil=0.000> got <sil=0.000> class <sil=0.000> etcetera
which <sil=0.000> we <sil=0.000> can <sil=0.000> reuse <sil=0.000> a number <sil=0.000> of <sil=0.000> times <sil=2.000> .PERIOD  And <sil=0.000> this <sil=0.000> is <sil=0.000> this <sil=0.000> idea <sil=0.000> the <sil=0.000> implementations <sil=0.000> are
varying <sil=0.000> from <sil=0.000> language <sil=0.000> to <sil=0.000> language <sil=1.000> ,COMMA  but <sil=0.000> the <sil=0.000> concept <sil=0.000> is <sil=0.000> common <sil=0.000> and <sil=0.000> is <sil=0.000> used <sil=0.000> in <sil=0.000> different
languages <sil=2.000> .PERIOD 
Thank <sil=0.000> you <sil=0.000> and <sil=0.000> we <sil=0.000> will <sil=0.000> continue <sil=0.000> with <sil=0.000> functions <sil=0.000> in <sil=0.000> the <sil=0.000> subsequent <sil=0.000> lectures <sil=2.000> .PERIOD 

We <sil=0.000> have <sil=0.000> seen <sil=0.000> what <sil=0.000> a function <sil=0.000> is <sil=1.000> ,COMMA  and <sil=0.000> why <sil=0.000> a function <sil=0.000> is <sil=0.000> required <sil=1.000> ,COMMA  what <sil=0.000> are <sil=0.000> the <sil=0.000> advantages
of <sil=0.000> using <sil=0.000> a function <sil=0.228> ?QUESTIONMARK  We <sil=0.000> have <sil=0.000> also <sil=0.000> seen <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> a parameter <sil=0.000> and <sil=0.000> what <sil=0.000> is <sil=0.000> an <sil=0.000> argument <sil=1.000> ,COMMA 
and <sil=0.000> the <sil=0.000> types <sil=0.000> of <sil=0.000> the <sil=0.000> parameters <sil=0.000> in <sil=0.000> the <sil=0.000> argument <sil=0.000> must <sil=0.000> match <sil=2.000> .PERIOD  Otherwise <sil=1.000> ,COMMA  the <sil=0.000> system <sil=0.000> will
of <sil=0.000> course <sil=1.000> ,COMMA  give <sil=0.000> you <sil=0.000> error <sil=0.000> and <sil=0.000> the <sil=0.000> reason <sil=0.000> is <sil=0.000> because <sil=0.000> there <sil=0.000> will <sil=0.000> be <sil=0.000> type <sil=0.000> mismatch <sil=0.000> and <sil=0.000> the
data <sil=0.000> will <sil=0.000> not <sil=0.000> be <sil=0.000> passed <sil=0.000> properly <sil=0.000> ok <sil=2.000> .PERIOD  Because <sil=0.000> this <sil=0.000> is <sil=0.000> essentially <sil=0.000> a parameter <sil=0.000> is <sil=0.000> being
assigned <sil=0.000> to <sil=0.000> an <sil=0.000> argument <sil=0.000> ok <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  in <sil=0.000> this <sil=0.000> lecture <sil=0.000> we <sil=0.000> will <sil=0.000> look <sil=0.000> at <sil=0.000> some <sil=0.000> more <sil=0.000> detail
nuisance <sil=1.000> ,COMMA  detailed <sil=0.000> points <sil=0.000> of <sil=0.000> function <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  to <sil=0.000> start <sil=0.000> with <sil=0.000> let <sil=0.000> us <sil=0.000> revise <sil=0.000> what <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=2.000> .PERIOD 

A <sil=0.000> function <sil=0.354> ;SEMICOLON  what <sil=0.000> is <sil=0.000> a function <sil=0.228> ?QUESTIONMARK  A <sil=0.000> function <sil=0.000> is <sil=0.000> a self-contained <sil=0.000> program <sil=0.000> segment <sil=2.000> .PERIOD  This
very <sil=0.000> important <sil=0.354> ;SEMICOLON  this <sil=0.000> not <sil=0.000> the <sil=0.000> whole <sil=0.000> program <sil=1.000> ,COMMA  but <sil=0.000> it <sil=0.000> is <sil=0.000> self-contained <sil=1.000> ,COMMA  and <sil=0.000> it <sil=0.000> is <sil=0.000> a program
segment <sil=0.354> ;SEMICOLON  part <sil=0.000> of <sil=0.000> a program <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> a main <sil=0.000> task <sil=0.000> and <sil=0.000> a part <sil=0.000> of <sil=0.000> that <sil=0.000> being <sil=0.000> executed <sil=0.000> is <sil=0.000> being
implemented <sil=0.000> by <sil=0.000> this <sil=0.000> function <sil=1.000> ,COMMA  and <sil=0.000> this <sil=0.000> self-contained <sil=0.000> because <sil=0.000> this <sil=0.000> can <sil=0.000> be <sil=0.000> independently
tested <sil=0.000> giving <sil=0.000> data <sil=0.000> and <sil=0.000> finding <sil=0.000> out <sil=1.000> ,COMMA  whether <sil=0.000> the <sil=0.000> task <sil=0.000> for <sil=0.000> which <sil=0.000> it <sil=0.000> has <sil=0.000> been <sil=0.000> designed <sil=0.000> is
actually <sil=0.000> being <sil=0.000> fulfilled <sil=0.000> or <sil=0.000> not <sil=0.000> ok <sil=2.000> .PERIOD  It <sil=0.000> carries <sil=0.000> out <sil=0.000> some <sil=0.000> specific <sil=0.000> and <sil=0.000> well-defined <sil=0.000> task <sil=2.000> .PERIOD  Now
that <sil=0.000> is <sil=0.000> the <sil=0.000> general <sil=0.000> concept <sil=0.000> of <sil=0.000> a function <sil=1.000> ,COMMA  now <sil=0.000> in <sil=0.000> C <sil=1.000> ,COMMA  any <sil=0.000> C program <sil=0.000> can <sil=0.000> consist <sil=0.000> of <sil=0.000> one <sil=0.000> or

more <sil=0.000> functions <sil=2.000> .PERIOD  At <sil=0.000> least <sil=0.000> one <sil=0.000> should <sil=0.000> be <sil=0.000> there <sil=0.000> why <sil=1.000> ,COMMA  because <sil=0.000> we <sil=0.000> need <sil=0.000> always <sil=0.000> the <sil=0.000> main <sil=0.000> right
we <sil=0.000> have <sil=0.000> seen <sil=0.000> that <sil=0.000> we <sil=0.000> need <sil=0.000> main <sil=2.000> .PERIOD 

Any <sil=0.000> C function <sil=0.000> must <sil=0.000> have <sil=0.000> a main <sil=2.000> .PERIOD  And <sil=0.000> main <sil=0.000> is <sil=0.000> nothing <sil=0.000> but <sil=0.000> a function <sil=2.000> .PERIOD  And <sil=0.000> why <sil=0.000> did <sil=0.000> we
put <sil=0.000> here <sil=0.000> this <sil=0.000> empty <sil=0.000> bracket <sil=0.354> ;SEMICOLON  because <sil=0.000> the <sil=0.000> structure <sil=0.000> of <sil=0.000> a function <sil=0.000> is <sil=0.000> always <sil=0.000> a function <sil=0.000> name
and <sil=0.000> a place <sil=0.000> for <sil=0.000> the <sil=0.000> arguments <sil=0.000> right <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> say <sil=0.000> that <sil=0.000> well <sil=1.000> ,COMMA  when <sil=0.000> we <sil=0.000> are <sil=0.000> starting <sil=0.000> a main <sil=0.000> function <sil=0.000> we <sil=0.000> are <sil=0.000> writing <sil=0.000> a main
function <sil=0.000> that <sil=0.000> we <sil=0.000> will <sil=0.000> do <sil=0.000> the <sil=0.000> task <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> not <sil=0.000> taking <sil=0.000> data <sil=0.000> from <sil=0.000> anywhere <sil=0.000> outside <sil=2.000> .PERIOD  Therefore <sil=1.000> ,COMMA 
why <sil=0.000> there <sil=0.000> is <sil=0.000> no <sil=0.000> argument <sil=2.000> .PERIOD  Yes <sil=1.000> ,COMMA  you <sil=0.000> are <sil=0.000> right <sil=2.000> .PERIOD  There <sil=0.000> is <sil=0.000> no <sil=0.000> argument <sil=0.000> that <sil=0.000> is <sil=0.000> why <sil=0.000> we <sil=0.000> put <sil=0.000> 2
braces <sil=0.000> and <sil=0.000> there <sil=0.000> is <sil=0.000> an <sil=0.000> empty <sil=0.000> space <sil=0.000> here <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> empty <sil=1.000> ,COMMA  right <sil=0.228> ?QUESTIONMARK  But <sil=0.000> still <sil=0.000> it <sil=0.000> looks <sil=0.000> like <sil=0.000> a
function <sil=2.000> .PERIOD  Moreover <sil=1.000> ,COMMA  in <sil=0.000> the <sil=0.000> earlier <sil=0.000> lecture <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> seen <sil=0.000> that <sil=0.000> the <sil=0.000> result <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=0.000> is
returned <sil=0.000> in <sil=0.000> it <sil=0.000> is <sil=0.000> name <sil=2.000> .PERIOD  And <sil=0.000> since <sil=0.000> this <sil=0.000> is <sil=0.000> a with <sil=0.000> like <sil=0.000> a variable <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> have <sil=0.000> a type <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
some <sil=0.000> type <sil=0.000> like <sil=0.000> for <sil=0.000> average <sil=0.000> we <sil=0.000> found <sil=0.000> float <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> main <sil=0.000> can <sil=0.000> also <sil=0.000> have <sil=0.000> a type <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> see <sil=0.000> later <sil=0.000> that <sil=0.000> this <sil=0.000> main <sil=0.000> can <sil=0.000> have <sil=0.000> a type <sil=2.000> .PERIOD 
We <sil=0.000> will <sil=0.000> have <sil=0.000> a set <sil=0.000> of <sil=0.000> empty <sil=0.000> arguments <sil=0.000> and <sil=0.000> the <sil=0.000> body <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=1.000> ,COMMA  and <sil=0.000> there <sil=0.000> can <sil=0.000> be
some <sil=0.000> there <sil=0.000> can <sil=0.000> be <sil=0.000> type <sil=2.000> .PERIOD  Say <sil=1.000> ,COMMA  sometimes <sil=0.000> a type <sil=0.000> can <sil=0.000> be <sil=0.000> int <sil=2.000> .PERIOD  If <sil=0.000> this <sil=0.000> main <sil=0.000> function <sil=0.354> ;SEMICOLON  that
means <sil=1.000> ,COMMA  this <sil=0.000> main <sil=0.000> function <sil=0.000> will <sil=0.000> return <sil=0.000> and <sil=0.000> integer <sil=0.000> and <sil=0.000> when <sil=0.000> we <sil=0.000> say <sil=0.000> that <sil=0.000> it <sil=0.000> does <sil=0.000> not <sil=0.000> return
anything <sil=1.000> ,COMMA  we <sil=0.000> can <sil=0.000> say <sil=0.000> also <sil=0.000> that <sil=0.000> this <sil=0.000> function <sil=0.000> is <sil=0.000> of <sil=0.000> type <sil=0.000> void <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  it <sil=0.000> does <sil=0.000> not <sil=0.000> return
any <sil=0.000> value <sil=0.000> ok <sil=1.000> ,COMMA  void <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> see <sil=0.000> this <sil=0.000> later <sil=1.000> ,COMMA  but <sil=0.000> this <sil=0.000> is <sil=0.000> the <sil=0.000> reason <sil=0.000> why <sil=0.000> we <sil=0.000> say <sil=0.000> that <sil=0.000> every
C <sil=0.000> program <sil=0.000> must <sil=0.000> consist <sil=0.000> of <sil=0.000> one <sil=0.000> or <sil=0.000> more <sil=0.000> than <sil=0.000> one <sil=0.000> function <sil=2.000> .PERIOD  One <sil=0.000> of <sil=0.000> these <sil=0.000> functions <sil=0.000> must
be <sil=0.000> called <sil=0.000> the <sil=0.000> main <sil=0.354> ;SEMICOLON  and <sil=0.000> the <sil=0.000> execution <sil=0.000> of <sil=0.000> the <sil=0.000> program <sil=0.000> always <sil=0.000> begins <sil=0.000> by <sil=0.000> carrying <sil=0.000> out <sil=0.000> the
instructions <sil=0.000> in <sil=0.000> main <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> the <sil=0.000> entry <sil=0.000> points <sil=0.000> any <sil=0.000> program <sil=2.000> .PERIOD  I <sil=0.000> mean <sil=1.000> ,COMMA  I <sil=0.000> cannot <sil=0.000> say <sil=0.000> that <sil=0.000> main
will <sil=0.000> be <sil=0.000> somewhere <sil=0.000> in <sil=0.000> the <sil=0.000> middle <sil=0.000> no <sil=2.000> .PERIOD 

When <sil=0.000> I start <sil=1.000> ,COMMA  when <sil=0.000> I start <sil=1.000> ,COMMA  it <sil=0.000> must <sil=0.000> the <sil=0.000> gateway <sil=0.000> is <sil=0.000> the <sil=0.000> main <sil=2.000> .PERIOD  And <sil=0.000> then <sil=0.000> from <sil=0.000> within <sil=0.000> main <sil=1.000> ,COMMA  I
can <sil=0.000> go <sil=0.000> out <sil=0.000> and <sil=0.000> use <sil=0.000> some <sil=0.000> function <sil=0.000> f 1 <sil=1.000> ,COMMA  and <sil=0.000> from <sil=0.000> f 1 <sil=0.000> I can <sil=0.000> go <sil=0.000> out <sil=0.000> to <sil=0.000> another <sil=0.000> function <sil=0.000> f 2 <sil=1.000> ,COMMA 
another <sil=0.000> function <sil=0.000> sorry <sil=1.000> ,COMMA  another <sil=0.000> function <sil=0.000> f 2 <sil=0.000> like <sil=0.000> that <sil=2.000> .PERIOD 
But <sil=0.000> the <sil=0.000> gateway <sil=0.000> the <sil=0.000> entry <sil=0.000> should <sil=0.000> be <sil=0.000> main <sil=0.354> ;SEMICOLON  and <sil=0.000> ultimately <sil=0.000> the <sil=0.000> exit <sil=0.000> say <sil=0.000> f 2 <sil=0.000> will <sil=0.000> return <sil=0.000> here <sil=1.000> ,COMMA 
then <sil=0.000> f 1 <sil=0.000> will <sil=0.000> return <sil=0.000> here <sil=2.000> .PERIOD  Ultimately <sil=0.000> the <sil=0.000> exit <sil=0.000> will <sil=0.000> also <sil=0.000> be <sil=0.000> through <sil=0.000> main <sil=1.000> ,COMMA  alright <sil=0.228> ?QUESTIONMARK  A
function <sil=0.000> will <sil=0.000> carry <sil=0.000> out <sil=0.000> it <sil=0.000> is <sil=0.000> intended <sil=0.000> task <sil=1.000> ,COMMA  whenever <sil=0.000> it <sil=0.000> is <sil=0.000> called <sil=0.000> or <sil=0.000> invoked <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> have
encountered <sil=0.000> with <sil=0.000> this <sil=0.000> term <sil=0.000> called <sil=0.000> or <sil=0.000> invoked <sil=0.000> right <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  in <sil=0.000> general <sil=1.000> ,COMMA  a <sil=0.000> function <sil=0.000> will <sil=0.000> process <sil=0.000> information <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> passed <sil=0.000> to <sil=0.000> it <sil=1.000> ,COMMA  from <sil=0.000> the <sil=0.000> calling
portion <sil=0.000> of <sil=0.000> the <sil=0.000> program <sil=2.000> .PERIOD  From <sil=1.000> ,COMMA  where <sil=0.000> it <sil=0.000> has <sil=0.000> from <sil=0.000> where <sil=0.000> it <sil=0.000> has <sil=0.000> been <sil=0.000> called <sil=0.000> or <sil=0.000> invoked <sil=2.000> .PERIOD 
And <sil=0.000> then <sil=1.000> ,COMMA  the <sil=0.000> function <sil=0.000> will <sil=0.000> take <sil=0.000> the <sil=0.000> data <sil=0.354> ;SEMICOLON  that <sil=0.000> is <sil=1.000> ,COMMA  if <sil=0.000> some <sil=0.000> data <sil=0.000> is <sil=0.000> to <sil=0.000> be <sil=0.000> passed <sil=1.000> ,COMMA  then <sil=0.000> it <sil=0.000> will
be <sil=0.000> passed <sil=0.000> to <sil=0.000> it <sil=0.000> from <sil=0.000> the <sil=0.000> calling <sil=0.000> part <sil=2.000> .PERIOD  And <sil=0.000> it <sil=0.000> will <sil=0.000> return <sil=0.000> a single <sil=0.000> value <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> are <sil=0.000> these
points <sil=0.228> ?QUESTIONMARK  Information <sil=0.000> is <sil=0.000> passed <sil=0.000> via <sil=0.000> special <sil=0.000> identifiers <sil=1.000> ,COMMA  called <sil=0.000> arguments <sil=0.000> and <sil=0.000> parameters <sil=2.000> .PERIOD 
And <sil=0.000> the <sil=0.000> value <sil=0.000> that <sil=0.000> is <sil=0.000> returned <sil=0.000> is <sil=0.000> returned <sil=0.000> by <sil=0.000> the <sil=0.000> return <sil=0.000> statement <sil=2.000> .PERIOD  Some <sil=0.000> functions <sil=0.000> do <sil=0.000> not
return <sil=0.000> anything <sil=2.000> .PERIOD  For <sil=0.000> example <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> say <sil=0.000> this <sil=2.000> .PERIOD  Say <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> writing <sil=0.000> a function <sil=1.000> ,COMMA  say <sil=0.000> my
function <sil=2.000> .PERIOD 

It <sil=0.000> is <sil=0.000> maybe <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> not <sil=0.000> taking <sil=0.000> any <sil=0.000> parameters <sil=2.000> .PERIOD  Because <sil=0.000> in <sil=0.000> the <sil=0.000> body <sil=0.000> it <sil=0.000> is <sil=0.000> simply <sil=0.000> nothing
doing <sil=0.000> nothing <sil=0.000> just <sil=0.000> printing <sil=0.000> printf <sil=1.000> ,COMMA  hello <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> also <sil=0.000> valid <sil=0.000> function <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  in <sil=0.000> this <sil=0.000> case <sil=0.000> the
main <sil=0.000> function <sil=1.000> ,COMMA  where <sil=0.000> it <sil=0.000> was <sil=0.000> it <sil=0.000> was <sil=0.000> just <sil=0.000> here <sil=0.000> and <sil=0.000> it <sil=0.000> just <sil=0.000> called <sil=0.000> my <sil=0.000> function <sil=0.000> here <sil=0.000> with
nothing <sil=0.000> this <sil=0.000> also <sil=0.000> possible <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  my <sil=0.000> function <sil=0.000> it <sil=0.000> goes <sil=0.000> there <sil=0.000> and <sil=0.000> does <sil=0.000> not <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> do <sil=0.000> not <sil=0.000> need
to <sil=0.000> give <sil=0.000> any <sil=0.000> return <sil=1.000> ,COMMA  but <sil=0.000> if <sil=0.000> I give <sil=0.000> a return <sil=0.000> that <sil=0.000> is <sil=0.000> also <sil=0.000> fine <sil=0.000> it <sil=0.000> does <sil=0.000> not <sil=0.000> return <sil=0.000> anything <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
this <sil=0.000> of <sil=0.000> type <sil=0.000> void <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> returning <sil=0.000> anything <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  but <sil=0.000> the <sil=0.000> control <sil=0.000> in <sil=0.000> any <sil=0.000> case <sil=0.000> it <sil=0.000> does <sil=0.000> not
return <sil=0.000> any <sil=0.000> value <sil=1.000> ,COMMA  but <sil=0.000> the <sil=0.000> control <sil=0.000> will <sil=0.000> come <sil=0.000> back <sil=0.000> here <sil=0.000> and <sil=0.000> from <sil=0.000> here <sil=0.000> it <sil=0.000> will <sil=0.000> be <sil=0.000> executed <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  there <sil=0.000> may <sil=0.000> be <sil=0.000> some <sil=0.000> functions <sil=1.000> ,COMMA  which <sil=0.000> do <sil=0.000> not <sil=0.000> return <sil=0.000> any <sil=0.000> value <sil=0.000> like <sil=0.000> it <sil=0.000> just <sil=0.000> printing <sil=0.000> some
data <sil=0.000> ok <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> possible <sil=0.000> for <sil=0.000> example <sil=0.354> ;SEMICOLON  I <sil=0.000> can <sil=0.000> make <sil=0.000> it <sil=0.000> even <sil=0.000> more <sil=0.000> realistic <sil=2.000> .PERIOD 

Say <sil=0.000> here <sil=0.000> main <sil=0.000> is <sil=0.000> here <sil=1.000> ,COMMA  and <sil=0.000> there <sil=0.000> is <sil=0.000> int <sil=0.000> A 5 <sil=1.000> ,COMMA  int <sil=0.000> B 6 <sil=1.000> ,COMMA  alright <sil=0.228> ?QUESTIONMARK  And <sil=0.000> here <sil=1.000> ,COMMA  I <sil=0.000> call <sil=0.000> average <sil=0.000> a
comma <sil=0.000> b <sil=1.000> ,COMMA  right <sil=2.000> .PERIOD  And <sil=0.000> here <sil=0.000> I write <sil=0.000> average <sil=0.000> int <sil=0.000> x <sil=1.000> ,COMMA  int <sil=0.000> y <sil=2.000> .PERIOD  And <sil=0.000> here <sil=0.000> I just <sil=0.000> compute <sil=0.000> average <sil=0.000> is
equal <sil=0.000> to <sil=0.000> x plus <sil=0.000> y by <sil=0.000> 2 <sil=2.000> .PERIOD  Printf <sil=0.000> a v <sil=0.000> g equals <sil=0.000> back <sil=0.000> slash <sil=1.000> ,COMMA  a <sil=0.000> v g <sil=0.000> equals <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> sorry <sil=1.000> ,COMMA  percentage
f <sil=0.000> back <sil=0.000> slash <sil=0.000> n comma <sil=0.000> a v <sil=0.000> g <sil=2.000> .PERIOD  That <sil=0.000> you <sil=0.000> understand <sil=2.000> .PERIOD  And <sil=0.000> I can <sil=0.000> write <sil=0.000> return <sil=0.000> or <sil=0.000> I may <sil=0.000> not
write <sil=0.000> return <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> will <sil=0.000> happen <sil=0.228> ?QUESTIONMARK  This <sil=0.000> will <sil=0.000> come <sil=0.000> here <sil=0.000> 5 and <sil=0.000> 6 <sil=1.000> ,COMMA  5 <sil=0.000> will <sil=0.000> be <sil=0.000> passed <sil=0.000> on <sil=0.000> here
x <sil=0.000> will <sil=0.000> be <sil=0.000> 5 y <sil=0.000> will <sil=0.000> be <sil=0.000> 6 <sil=2.000> .PERIOD  The <sil=0.000> value <sil=0.000> will <sil=0.000> be <sil=0.000> 5 <sil=2.000> .PERIOD <sil=0.000> 5 that <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=0.000> here <sil=2.000> .PERIOD  But <sil=0.000> I have <sil=0.000> to <sil=0.000> give
a <sil=0.000> type <sil=0.000> to <sil=0.000> this <sil=0.000> average <sil=1.000> ,COMMA  because <sil=0.000> here <sil=0.000> the <sil=0.000> average <sil=0.000> type <sil=0.000> is <sil=0.000> not <sil=0.000> defined <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> to <sil=0.000> say <sil=0.000> this
will <sil=0.000> be <sil=0.000> float <sil=0.000> average <sil=2.000> .PERIOD  Because <sil=0.000> there <sil=0.000> is <sil=0.000> some <sil=0.000> value <sil=1.000> ,COMMA  some <sil=0.000> type <sil=0.000> to <sil=0.000> this <sil=0.000> value <sil=0.000> some <sil=0.000> type <sil=0.000> to
this <sil=0.000> variable <sil=2.000> .PERIOD  Which <sil=0.000> will <sil=0.000> hold <sil=0.000> the <sil=0.000> value <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  this <sil=0.000> also <sil=0.000> possible <sil=0.000> here <sil=0.000> you <sil=0.000> can <sil=0.000> see <sil=0.000> that <sil=1.000> ,COMMA  I <sil=0.000> do
not <sil=0.000> need <sil=0.000> to <sil=0.000> write <sil=0.000> a return <sil=1.000> ,COMMA  but <sil=0.000> there <sil=0.000> is <sil=0.000> no <sil=0.000> harm <sil=1.000> ,COMMA  if <sil=0.000> I write <sil=0.000> just <sil=0.000> simply <sil=0.000> return <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> the
good <sil=0.000> practice <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  my <sil=0.000> return <sil=0.000> my <sil=0.000> control <sil=0.000> will <sil=0.000> come <sil=0.000> back <sil=0.000> here <sil=2.000> .PERIOD  And <sil=0.000> that <sil=0.000> is <sil=0.000> the <sil=0.000> last
statement <sil=0.000> that <sil=0.000> will <sil=0.000> be <sil=0.000> the <sil=0.000> end <sil=0.000> ok <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> move <sil=0.000> forward <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  some <sil=0.000> function <sil=0.000> may <sil=0.000> not
return <sil=0.000> anything <sil=0.000> the <sil=0.000> return <sil=0.000> type <sil=0.000> is <sil=0.000> specified <sil=0.000> as <sil=0.000> void <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> an <sil=0.000> example <sil=0.000> of <sil=0.000> factorial <sil=2.000> .PERIOD  We <sil=0.000> start <sil=0.000> with <sil=0.000> so <sil=1.000> ,COMMA  here <sil=0.000> first <sil=0.000> I have <sil=0.000> written <sil=0.000> the <sil=0.000> function
here <sil=1.000> ,COMMA  and <sil=0.000> then <sil=0.000> I have <sil=0.000> written <sil=0.000> the <sil=0.000> main <sil=2.000> .PERIOD 
But <sil=0.000> however <sil=1.000> ,COMMA  in <sil=0.000> whatever <sil=0.000> way <sil=0.000> we <sil=0.000> write <sil=1.000> ,COMMA  the <sil=0.000> main <sil=0.000> the <sil=0.000> program <sil=0.000> while <sil=0.000> execution <sil=0.000> we <sil=0.000> will
enter <sil=0.000> the <sil=0.000> main <sil=0.000> first <sil=1.000> ,COMMA  alright <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  so <sil=0.000> the <sil=0.000> execution <sil=0.000> will <sil=0.000> be <sil=0.000> something <sil=0.000> like <sil=0.000> this <sil=0.000> that <sil=0.000> will
enter <sil=0.000> from <sil=0.000> here <sil=0.000> main <sil=2.000> .PERIOD  It <sil=0.000> takes <sil=0.000> the <sil=0.000> variable <sil=0.000> n <sil=1.000> ,COMMA  which <sil=0.000> is <sil=0.000> an <sil=0.000> integer <sil=0.354> ;SEMICOLON  then <sil=0.000> n1 <sil=0.000> to <sil=0.000> less <sil=0.000> than <sil=0.000> 10
n <sil=0.000> plus <sil=1.000> ,COMMA  printf <sil=0.000> percentage <sil=0.000> d ok <sil=1.000> ,COMMA  and <sil=0.000> n and <sil=0.000> then <sil=0.000> factorial <sil=0.000> alright <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  factorial <sil=0.000> a now <sil=0.000> when
this <sil=0.000> factorial <sil=0.000> n is <sil=0.000> encountered <sil=1.000> ,COMMA  then <sil=0.000> we <sil=0.000> the <sil=0.354> ;SEMICOLON  this <sil=0.000> function <sil=0.000> is <sil=0.000> called <sil=2.000> .PERIOD  This <sil=0.000> function <sil=0.000> what <sil=0.000> is
doing <sil=0.228> ?QUESTIONMARK  It <sil=0.000> has <sil=0.000> got <sil=0.000> int <sil=0.000> m <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  m <sil=0.000> is <sil=0.000> the <sil=0.000> argument <sil=1.000> ,COMMA  and <sil=0.000> is <sil=0.000> being <sil=0.000> called <sil=0.000> with <sil=0.000> a parameter <sil=0.000> n <sil=0.354> ;SEMICOLON 
which <sil=0.000> has <sil=0.000> been <sil=0.000> which <sil=0.000> is <sil=0.000> being <sil=0.000> taken <sil=0.354> ;SEMICOLON  first <sil=0.000> 1 then <sil=0.000> 2 then <sil=0.000> 3 <sil=2.000> .PERIOD  Like <sil=0.000> that <sil=0.000> till <sil=0.000> it <sil=0.000> is <sil=0.000> 10 <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> taking <sil=0.000> it <sil=0.000> n <sil=1.000> ,COMMA  and <sil=0.000> then <sil=0.000> here <sil=0.000> let <sil=0.000> us <sil=0.000> see <sil=1.000> ,COMMA  what <sil=0.000> we <sil=0.000> are <sil=0.000> doing <sil=0.000> int <sil=0.000> i <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  this <sil=0.000> i this
variable <sil=0.000> i and <sil=0.000> this <sil=0.000> variable <sil=0.000> temp <sil=2.000> .PERIOD  These <sil=0.000> 2 variables <sil=0.000> are <sil=0.000> purely <sil=0.000> internal <sil=0.000> variables <sil=0.354> ;SEMICOLON  that
means <sil=1.000> ,COMMA  this <sil=0.000> variables <sil=0.000> are <sil=0.000> internal <sil=0.000> to <sil=0.000> the <sil=0.000> body <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=2.000> .PERIOD  Now <sil=0.000> each <sil=0.000> of <sil=0.000> the <sil=0.000> functions
has <sil=0.000> got <sil=0.000> a life <sil=1.000> ,COMMA  each <sil=0.000> has <sil=0.000> a life <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  factorial <sil=0.000> as <sil=0.000> long <sil=0.000> as <sil=0.000> factorial <sil=0.000> is <sil=0.000> running <sil=0.000> factorial <sil=0.000> is
live <sil=1.000> ,COMMA  and <sil=0.000> when <sil=0.000> factorial <sil=0.000> is <sil=0.000> live <sil=1.000> ,COMMA  whatever <sil=0.000> variables <sil=0.000> are <sil=0.000> defined <sil=0.000> within <sil=0.000> factorial <sil=1.000> ,COMMA  they <sil=0.000> are
live <sil=2.000> .PERIOD  As <sil=0.000> soon <sil=0.000> as <sil=0.000> we <sil=0.000> exit <sil=0.000> from <sil=0.000> factorial <sil=1.000> ,COMMA  that <sil=0.000> function <sil=0.000> is <sil=0.000> dead <sil=2.000> .PERIOD  And <sil=0.000> the <sil=0.000> variables
associated <sil=0.000> solely <sil=0.000> I repeat <sil=2.000> .PERIOD  The <sil=0.000> variables <sil=0.000> associated <sil=0.000> solely <sil=0.000> with <sil=0.000> the <sil=0.000> function <sil=0.000> also <sil=0.000> dies <sil=0.000> with
the <sil=0.000> death <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> see <sil=0.000> here <sil=0.000> i and <sil=0.000> temp <sil=2.000> .PERIOD  Then <sil=0.000> for <sil=0.000> i equal <sil=0.000> to <sil=0.000> one <sil=0.000> to <sil=0.000> m
temp <sil=0.000> equals <sil=0.000> temp <sil=0.000> times <sil=0.000> i <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  1 <sil=0.000> times <sil=1.000> ,COMMA  2 <sil=0.000> times <sil=1.000> ,COMMA  3 <sil=0.000> times <sil=0.000> 4 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> what <sil=0.000> is <sil=0.000> being <sil=0.000> computed <sil=1.000> ,COMMA  1 <sil=0.000> times <sil=0.000> 2 times <sil=0.000> 3 times <sil=0.000> 4 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  like <sil=0.000> that <sil=0.000> whatever <sil=0.000> is <sil=0.000> the
value <sil=0.000> of <sil=0.000> m that <sil=0.000> is <sil=0.000> being <sil=0.000> up <sil=0.000> to <sil=0.000> that <sil=0.000> we <sil=0.000> are <sil=0.000> computing <sil=0.000> a factorial <sil=1.000> ,COMMA  alright <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  if <sil=0.000> I call <sil=0.000> it <sil=1.000> ,COMMA 
now <sil=0.000> here <sil=0.000> I have <sil=0.000> called <sil=0.000> it <sil=0.000> with <sil=0.000> n the <sil=0.000> value <sil=0.000> of <sil=0.000> n <sil=1.000> ,COMMA  alright <sil=0.228> ?QUESTIONMARK  With <sil=0.000> a value <sil=0.000> of <sil=0.000> n <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> calling <sil=0.000> it <sil=1.000> ,COMMA 
and <sil=0.000> I am <sil=0.000> getting <sil=0.000> the <sil=0.000> factorial <sil=2.000> .PERIOD  And <sil=0.000> the <sil=0.000> temp <sil=0.000> is <sil=0.000> being <sil=0.000> returned <sil=1.000> ,COMMA  where <sil=0.000> it <sil=0.000> is <sil=0.000> being <sil=0.000> returned <sil=1.000> ,COMMA 
this <sil=0.000> temp <sil=0.000> is <sil=0.000> being <sil=0.000> returned <sil=0.000> to <sil=0.000> factorial <sil=0.000> temp <sil=0.000> is <sil=0.000> being <sil=0.000> returned <sil=0.000> to <sil=0.000> factorial <sil=1.000> ,COMMA  and <sil=0.000> that <sil=0.000> is
being <sil=0.000> printed <sil=0.000> through <sil=0.000> this <sil=0.000> percentage <sil=0.000> d <sil=1.000> ,COMMA  alright <sil=0.228> ?QUESTIONMARK 
So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> being <sil=0.000> printed <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  return <sil=0.000> temp <sil=1.000> ,COMMA  because <sil=0.000> why <sil=0.000> it <sil=0.000> is <sil=0.000> different <sil=0.228> ?QUESTIONMARK  Here <sil=0.000> I did <sil=0.000> not <sil=0.000> write
return <sil=1.000> ,COMMA  because <sil=0.000> I have <sil=0.000> named <sil=0.000> it <sil=0.000> as <sil=0.000> factorial <sil=1.000> ,COMMA  and <sil=0.000> I have <sil=0.000> written <sil=0.000> temp <sil=0.000> then <sil=0.000> temp <sil=0.000> is <sil=0.000> going
to <sil=0.000> this <sil=0.000> value <sil=0.000> factorial <sil=2.000> .PERIOD  If <sil=0.000> I had <sil=0.000> not <sil=0.000> done <sil=0.000> return <sil=0.000> then <sil=0.000> ultimately <sil=0.354> ;SEMICOLON  because <sil=0.000> here <sil=0.000> I am <sil=0.000> keeping
the <sil=0.000> result <sil=0.000> in <sil=0.000> temp <sil=0.354> ;SEMICOLON  not <sil=0.000> in <sil=0.000> factorial <sil=0.000> has <sil=0.000> not <sil=0.000> been <sil=0.000> used <sil=0.000> as <sil=0.000> any <sil=0.000> variable <sil=0.000> inside <sil=0.000> the <sil=0.000> function <sil=2.000> .PERIOD 
Now <sil=0.000> when <sil=0.000> I go <sil=0.000> there <sil=1.000> ,COMMA  and <sil=0.000> suppose <sil=0.000> if <sil=0.000> I had <sil=0.000> use <sil=0.000> some <sil=0.000> other <sil=0.000> temp <sil=0.000> here <sil=1.000> ,COMMA  this <sil=0.000> temp <sil=0.000> and <sil=0.000> this
temp <sil=0.000> would <sil=0.000> have <sil=0.000> been <sil=0.000> different <sil=2.000> .PERIOD  We <sil=0.000> will <sil=0.000> come <sil=0.000> to <sil=0.000> this <sil=0.000> later <sil=1.000> ,COMMA  but <sil=0.000> this <sil=0.000> just <sil=0.000> an <sil=0.000> example <sil=0.000> of <sil=0.000> a
function <sil=0.000> being <sil=0.000> invoked <sil=2.000> .PERIOD 

We <sil=0.000> just <sil=0.000> recapitulating <sil=1.000> ,COMMA  why <sil=0.000> we <sil=0.000> need <sil=0.000> functions <sil=0.228> ?QUESTIONMARK  This <sil=0.000> term <sil=0.000> may <sil=0.000> be <sil=0.000> new <sil=0.000> to <sil=0.000> you <sil=2.000> .PERIOD  It <sil=0.000> is
modularising <sil=0.000> a program <sil=1.000> ,COMMA  is <sil=0.000> breaking <sil=0.000> down <sil=0.000> a program <sil=0.000> into <sil=0.000> small <sil=0.000> parts <sil=2.000> .PERIOD  Each <sil=0.000> part
independent <sil=0.000> part <sil=0.000> is <sil=0.000> called <sil=0.000> a module <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> why <sil=0.000> breaking <sil=0.000> down <sil=0.000> a big <sil=0.000> program <sil=0.000> into
smaller <sil=0.000> parts <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> modularisation <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> modularising <sil=0.000> a program <sil=2.000> .PERIOD  All <sil=0.000> variables
declared <sil=0.000> inside <sil=0.000> function <sil=0.000> are <sil=0.000> local <sil=0.000> variables <sil=2.000> .PERIOD  Very <sil=1.000> ,COMMA  very <sil=0.000> important <sil=2.000> .PERIOD  Which <sil=0.000> are <sil=0.000> declared
inside <sil=0.000> functions <sil=0.000> are <sil=0.000> local <sil=0.000> variables <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  they <sil=0.000> are <sil=0.000> known <sil=0.000> only <sil=0.000> as <sil=0.000> long <sil=0.000> as <sil=0.000> the

function <sil=0.000> is <sil=0.000> remaining <sil=0.000> running <sil=2.000> .PERIOD  As <sil=0.000> soon <sil=0.000> as <sil=0.000> the <sil=0.000> function <sil=0.000> completes <sil=0.000> it <sil=0.000> is <sil=0.000> execution <sil=2.000> .PERIOD  They
also <sil=0.000> seize <sil=0.000> to <sil=0.000> exist <sil=2.000> .PERIOD  Therefore <sil=1.000> ,COMMA  a <sil=0.000> value <sil=0.000> variable <sil=0.000> I for <sil=0.000> example <sil=1.000> ,COMMA  can <sil=0.000> be <sil=0.000> used <sil=0.000> as <sil=0.000> an <sil=0.000> internal
variable <sil=0.000> of <sil=0.000> a function <sil=1.000> ,COMMA  and <sil=0.000> can <sil=0.000> also <sil=0.000> be <sil=0.000> used <sil=0.000> in <sil=0.000> a some <sil=0.000> other <sil=0.000> function <sil=0.000> or <sil=0.000> in <sil=0.000> the <sil=0.000> main
function <sil=2.000> .PERIOD  They <sil=0.000> will <sil=0.000> actually <sil=0.000> physically <sil=0.000> be <sil=0.000> mapped <sil=0.000> to <sil=0.000> different <sil=0.000> memory <sil=0.000> locations <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> also <sil=0.000> seen <sil=0.000> what <sil=0.000> parameters <sil=0.000> are <sil=2.000> .PERIOD  The <sil=0.000> parameters <sil=0.000> are <sil=0.000> communicate
information <sil=0.000> between <sil=0.000> functions <sil=1.000> ,COMMA  parameter <sil=0.000> and <sil=0.000> argument <sil=0.000> ok <sil=2.000> .PERIOD  They <sil=0.000> also <sil=0.000> become <sil=0.000> local
variables <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  parameter <sil=0.000> arguments <sil=0.000> are <sil=0.000> local <sil=0.000> variables <sil=0.000> the <sil=0.000> parameters <sil=0.000> means <sil=1.000> ,COMMA  the
arguments <sil=0.000> are <sil=0.000> also <sil=0.000> local <sil=0.000> variables <sil=2.000> .PERIOD  The <sil=0.000> benefits <sil=0.000> are <sil=0.000> divide <sil=0.000> and <sil=0.000> conquer <sil=0.000> we <sil=0.000> know <sil=0.000> we <sil=1.000> ,COMMA  we
has <sil=0.000> we <sil=0.000> have <sil=0.000> devoted <sil=0.000> one <sil=0.000> completely <sil=0.000> lecture <sil=0.000> on <sil=0.000> that <sil=0.354> ;SEMICOLON  manageable <sil=0.000> program <sil=0.000> development <sil=2.000> .PERIOD 
Software <sil=0.000> reusability <sil=0.354> ;SEMICOLON  all <sil=0.000> existing <sil=0.000> functions <sil=0.000> can <sil=0.000> use <sil=0.000> can <sil=0.000> be <sil=0.000> used <sil=0.000> as <sil=0.000> building <sil=0.000> blocks <sil=0.000> for
new <sil=0.000> programs <sil=1.000> ,COMMA  and <sil=0.000> this <sil=0.000> is <sil=0.000> another <sil=0.000> thing <sil=0.000> that <sil=0.000> you <sil=0.000> may <sil=0.000> realise <sil=0.000> later <sil=1.000> ,COMMA  that <sil=0.000> inside <sil=0.000> a function <sil=1.000> ,COMMA 
how <sil=0.000> I am <sil=0.000> implementing <sil=0.000> or <sil=0.000> how <sil=0.000> somebody <sil=0.000> has <sil=0.000> implemented <sil=1.000> ,COMMA  it <sil=0.000> may <sil=0.000> be <sil=0.000> very <sil=0.000> complicated <sil=1.000> ,COMMA 
and <sil=0.000> I need <sil=0.000> not <sil=0.000> bother <sil=0.000> about <sil=0.000> that <sil=2.000> .PERIOD 
I <sil=0.000> know <sil=0.000> what <sil=0.000> it <sil=0.000> asks <sil=0.000> for <sil=1.000> ,COMMA  what <sil=0.000> variables <sil=0.000> have <sil=0.000> to <sil=0.000> be <sil=0.000> put <sil=0.000> in <sil=0.000> through <sil=0.000> this <sil=0.000> and <sil=0.000> what <sil=0.000> output <sil=0.000> I
will <sil=0.000> get <sil=0.000> out <sil=0.000> of <sil=0.000> it <sil=0.228> ?QUESTIONMARK  Therefore <sil=1.000> ,COMMA  whatever <sil=0.000> is <sil=0.000> there <sil=0.000> inside <sil=0.000> is <sil=0.000> abstracted <sil=0.000> out <sil=0.000> from <sil=0.000> it <sil=0.000> is <sil=0.000> hidden
from <sil=0.000> it <sil=2.000> .PERIOD  The <sil=0.000> internal <sil=0.000> details <sil=0.000> are <sil=0.000> not <sil=0.000> needed <sil=0.354> ;SEMICOLON  that <sil=0.000> is <sil=1.000> ,COMMA  another <sil=0.000> big <sil=0.000> advantage <sil=0.000> of <sil=0.000> using
functions <sil=2.000> .PERIOD  And <sil=0.000> of <sil=0.000> course <sil=1.000> ,COMMA  avoid <sil=0.000> code <sil=0.000> repetition <sil=0.354> ;SEMICOLON  something <sil=0.000> which <sil=0.000> somebody <sil=0.000> has <sil=0.000> written <sil=2.000> .PERIOD 
Or <sil=0.000> say <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  in <sil=0.000> a main <sil=0.000> program <sil=2.000> .PERIOD  Let <sil=0.000> us <sil=0.000> take <sil=0.000> another <sil=0.000> example <sil=0.000> to <sil=0.000> understand <sil=2.000> .PERIOD 

This <sil=0.000> better <sil=0.000> say <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> a program <sil=1.000> ,COMMA  in <sil=0.000> which <sil=0.000> I am <sil=0.000> doing <sil=0.000> some <sil=0.000> computations <sil=2.000> .PERIOD  Say <sil=1.000> ,COMMA 
computing <sil=0.000> the <sil=0.000> standard <sil=0.000> deviation <sil=0.000> here <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> computing <sil=0.000> the <sil=0.000> standard <sil=0.000> deviation <sil=0.000> here <sil=1.000> ,COMMA  and
may <sil=0.000> be <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  at <sil=0.000> both <sil=0.000> these <sil=0.000> places <sil=0.000> I write <sil=0.000> this <sil=1.000> ,COMMA  write <sil=0.000> this <sil=1.000> ,COMMA  but <sil=0.000> that <sil=0.000> is <sil=0.000> not <sil=0.000> needed <sil=2.000> .PERIOD 

If <sil=0.000> I have <sil=0.000> a function <sil=0.000> for <sil=0.000> computing <sil=0.000> standard <sil=0.000> deviation <sil=0.000> then <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> my <sil=0.000> main <sil=0.000> program <sil=0.000> and
there <sil=0.000> is <sil=0.000> one <sil=0.000> function <sil=0.000> for <sil=0.000> standard <sil=0.000> deviation <sil=0.000> here <sil=2.000> .PERIOD  And <sil=0.000> from <sil=0.000> this <sil=0.000> point <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> simply <sil=0.000> call
this <sil=0.000> get <sil=0.000> the <sil=0.000> value <sil=0.000> again <sil=0.000> continue <sil=1.000> ,COMMA  from <sil=0.000> wherever <sil=0.000> I need <sil=0.000> I can <sil=0.000> again <sil=0.000> call <sil=0.000> this <sil=1.000> ,COMMA  and <sil=0.000> I can <sil=0.000> get
the <sil=0.000> value <sil=1.000> ,COMMA  and <sil=0.000> in <sil=0.000> that <sil=0.000> way <sil=1.000> ,COMMA  I <sil=0.000> save <sil=0.000> in <sil=0.000> the <sil=0.000> number <sil=0.000> of <sil=0.000> lines <sil=0.000> of <sil=0.000> code <sil=0.000> that <sil=0.000> I write <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is
known <sil=0.000> as <sil=0.000> avoiding <sil=0.000> code <sil=0.000> repetition <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  defining <sil=0.000> a function <sil=0.354> ;SEMICOLON  how <sil=0.000> do <sil=0.000> you <sil=0.228> ?QUESTIONMARK  Now <sil=0.000> we <sil=0.000> are <sil=0.000> till <sil=0.000> now <sil=0.000> I was <sil=0.000> trying <sil=0.000> to <sil=0.000> explain <sil=0.000> you
somethings <sil=1.000> ,COMMA  now <sil=0.000> we <sil=0.000> are <sil=0.000> looking <sil=0.000> at <sil=0.000> the <sil=0.000> syntactic <sil=0.000> details <sil=0.000> of <sil=0.000> a C <sil=0.000> function <sil=2.000> .PERIOD  Now <sil=0.000> that <sil=0.000> can
vary <sil=0.000> from <sil=0.000> language <sil=0.000> to <sil=0.000> language <sil=1.000> ,COMMA  but <sil=0.000> more <sil=0.000> or <sil=0.000> less <sil=0.000> the <sil=0.000> ideas <sil=0.000> are <sil=0.000> same <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  a <sil=0.000> function
definition <sil=0.000> has <sil=0.000> got <sil=0.000> 2 parts <sil=2.000> .PERIOD  The <sil=0.000> first <sil=0.000> line <sil=1.000> ,COMMA  first <sil=0.000> line <sil=0.000> and <sil=0.000> the <sil=0.000> sorry <sil=1.000> ,COMMA  the <sil=0.000> first <sil=0.000> line <sil=0.000> and <sil=0.000> the <sil=0.000> what
is <sil=0.000> happening <sil=0.000> here <sil=0.228> ?QUESTIONMARK  First <sil=0.000> line <sil=0.000> and <sil=0.000> the <sil=0.000> body <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=0.000> ok <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> the <sil=0.000> first <sil=0.000> line
typically <sil=0.228> ?QUESTIONMARK  What <sil=0.000> can <sil=0.000> we <sil=0.000> have <sil=0.000> in <sil=0.000> the <sil=0.000> first <sil=0.000> line <sil=0.228> ?QUESTIONMARK  First <sil=0.000> line <sil=0.000> we <sil=0.000> have <sil=0.000> got <sil=0.000> the <sil=0.000> function <sil=0.000> name <sil=2.000> .PERIOD  I
do <sil=0.000> not <sil=0.000> know <sil=0.000> why <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> coming <sil=2.000> .PERIOD  In <sil=0.000> the <sil=0.000> first <sil=0.000> line <sil=0.000> we <sil=0.000> have <sil=0.000> got <sil=0.000> the <sil=0.000> function <sil=0.000> name <sil=1.000> ,COMMA  and
the <sil=0.000> parameter <sil=0.000> list <sil=2.000> .PERIOD  I <sil=0.000> call <sil=0.000> it <sil=0.000> argument <sil=0.000> list <sil=1.000> ,COMMA  but <sil=0.000> whatever <sil=0.000> you <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  a <sil=0.000> function <sil=0.000> has <sil=0.000> got <sil=0.000> the <sil=0.000> first <sil=0.000> line <sil=2.000> .PERIOD  And <sil=0.000> we <sil=0.000> can <sil=0.000> see <sil=0.354> ;SEMICOLON  what <sil=0.000> the <sil=0.000> first <sil=0.000> line <sil=0.000> is <sil=0.228> ?QUESTIONMARK  The <sil=0.000> first <sil=0.000> line
will <sil=0.000> contain <sil=0.000> the <sil=0.000> function <sil=0.000> name <sil=1.000> ,COMMA  and <sil=0.000> a return <sil=0.000> value <sil=0.000> type <sil=1.000> ,COMMA  what <sil=0.000> type <sil=0.000> of <sil=0.000> value <sil=0.000> is <sil=0.000> being
returned <sil=2.000> .PERIOD  Followed <sil=0.000> by <sil=0.000> this <sil=0.000> is <sil=0.000> the <sil=0.000> body <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=2.000> .PERIOD  The <sil=0.000> second <sil=0.000> part <sil=0.000> is <sil=0.000> the <sil=0.000> body <sil=0.000> of <sil=0.000> the
function <sil=2.000> .PERIOD  Where <sil=0.000> there <sil=0.000> are <sil=0.000> declarations <sil=0.000> and <sil=0.000> statements <sil=2.000> .PERIOD  Some <sil=0.000> internal <sil=0.000> values <sil=0.000> can <sil=0.000> be
declared <sil=0.000> internal <sil=0.000> variables <sil=0.000> can <sil=0.000> be <sil=0.000> declared <sil=0.000> here <sil=2.000> .PERIOD  And <sil=0.000> the <sil=0.000> other <sil=0.000> statements <sil=0.000> are <sil=0.000> also <sil=0.000> here <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  so <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.354> ;SEMICOLON  so <sil=1.000> ,COMMA  this <sil=0.000> one <sil=0.000> I actually <sil=0.000> I am <sil=0.000> calling <sil=0.000> them <sil=0.000> argument <sil=2.000> .PERIOD  Some <sil=0.000> people <sil=0.000> also
call <sil=0.000> both <sil=0.000> of <sil=0.000> them <sil=0.000> to <sil=0.000> be <sil=0.000> parameters <sil=0.000> ok <sil=2.000> .PERIOD 

Now <sil=0.000> so <sil=1.000> ,COMMA  the <sil=0.000> first <sil=0.000> line <sil=0.000> contains <sil=0.000> the <sil=0.000> return <sil=0.000> value <sil=0.000> type <sil=2.000> .PERIOD  The <sil=0.000> function <sil=0.000> name <sil=0.000> and <sil=0.000> optionally <sil=0.000> a
set <sil=0.000> of <sil=0.000> comma <sil=0.000> separated <sil=0.000> arguments <sil=0.000> enclosed <sil=0.000> in <sil=0.000> parentheses <sil=2.000> .PERIOD  Like <sil=1.000> ,COMMA  say <sil=0.000> here <sil=0.000> I am <sil=0.000> defining
a <sil=0.000> function <sil=0.000> called <sil=0.000> gcd <sil=1.000> ,COMMA  greatest <sil=0.000> common <sil=0.000> deviser <sil=2.000> .PERIOD  It <sil=0.000> has <sil=0.000> got <sil=0.000> a type <sil=0.000> int <sil=1.000> ,COMMA  and <sil=0.000> has <sil=0.000> got <sil=0.000> 2
arguments <sil=2.000> .PERIOD  One <sil=0.000> is <sil=0.000> A and <sil=0.000> one <sil=0.000> is <sil=0.000> B <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> written <sil=0.000> the <sil=0.000> types <sil=0.000> of <sil=0.000> them <sil=0.000> in <sil=0.000> this <sil=0.000> parentheses
itself <sil=0.000> int <sil=0.000> A <sil=1.000> ,COMMA  comma <sil=0.000> int <sil=0.000> B they <sil=0.000> are <sil=0.000> comma <sil=0.000> separated <sil=2.000> .PERIOD 
The <sil=0.000> argument <sil=0.000> is <sil=0.000> possible <sil=0.000> that <sil=0.000> I can <sil=0.000> declare <sil=0.000> the <sil=0.000> arguments <sil=0.000> also <sil=0.000> on <sil=0.000> the <sil=0.000> next <sil=0.000> line <sil=2.000> .PERIOD  For
example <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> say <sil=0.000> instead <sil=0.000> of <sil=0.000> writing <sil=0.000> it <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> write <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=0.000> int <sil=0.000> gcd <sil=0.000> A
comma <sil=0.000> B and <sil=0.000> in <sil=0.000> the <sil=0.000> next <sil=0.000> line <sil=0.000> before <sil=0.000> the <sil=0.000> body <sil=1.000> ,COMMA  before <sil=0.000> the <sil=0.000> before <sil=0.000> the <sil=0.000> bracket <sil=1.000> ,COMMA  probably <sil=0.000> in
earlier <sil=0.000> example <sil=0.000> I did <sil=0.000> a mistake <sil=1.000> ,COMMA  I <sil=0.000> had <sil=0.000> put <sil=0.000> the <sil=0.000> bracket <sil=0.000> inside <sil=0.000> the <sil=0.000> bracket <sil=2.000> .PERIOD  It <sil=0.000> should <sil=0.000> not <sil=0.000> be
inside <sil=0.000> the <sil=0.000> bracket <sil=2.000> .PERIOD  Immediately <sil=0.000> after <sil=0.000> that <sil=0.000> it <sil=0.000> you <sil=0.000> can <sil=0.000> write <sil=0.000> int <sil=0.000> A comma <sil=0.000> B <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA 
you <sil=0.000> are <sil=0.000> declaring <sil=0.000> that <sil=0.000> these <sil=0.000> are <sil=0.000> A and <sil=0.000> B <sil=2.000> .PERIOD  Either <sil=0.000> inside <sil=0.000> or <sil=0.000> immediately <sil=0.000> after <sil=0.000> that <sil=1.000> ,COMMA  both <sil=0.000> of
them <sil=0.000> are <sil=0.000> fine <sil=2.000> .PERIOD  Now <sil=0.000> these <sil=0.000> are <sil=0.000> called <sil=0.000> the <sil=0.000> formal <sil=0.000> arguments <sil=0.000> or <sil=0.000> some <sil=0.000> people <sil=0.000> also <sil=0.000> call <sil=0.000> it
formal <sil=0.000> parameters <sil=2.000> .PERIOD 

Now <sil=0.000> what <sil=0.000> is <sil=0.000> the <sil=0.000> body <sil=0.000> of <sil=0.000> a function <sil=0.228> ?QUESTIONMARK  The <sil=0.000> body <sil=0.000> of <sil=0.000> a function <sil=0.000> is <sil=0.000> actually <sil=0.000> a compound
statement <sil=2.000> .PERIOD  I <sil=0.000> will <sil=0.000> just <sil=0.000> take <sil=0.000> just <sil=0.000> as <sil=0.000> I had <sil=0.000> statements <sil=0.000> like <sil=0.000> for <sil=0.000> loop <sil=0.000> ok <sil=1.000> ,COMMA  or <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> take <sil=0.000> or
say <sil=0.000> while <sil=0.000> loop <sil=0.000> or <sil=0.000> if <sil=0.000> conditions <sil=1.000> ,COMMA  where <sil=0.000> I write <sil=0.000> if <sil=0.000> some <sil=0.000> condition <sil=0.000> then <sil=0.000> some <sil=0.000> statement <sil=1.000> ,COMMA  else
some <sil=0.000> statement <sil=0.000> like <sil=0.000> that <sil=2.000> .PERIOD  So <sil=0.000> now <sil=1.000> ,COMMA  this <sil=0.000> whole <sil=0.000> thing <sil=0.000> is <sil=0.000> a compound <sil=0.000> statement <sil=2.000> .PERIOD  Similarly <sil=1.000> ,COMMA 
here <sil=0.000> the <sil=0.000> entire <sil=0.000> body <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=0.000> can <sil=0.000> be <sil=0.000> assumed <sil=0.000> to <sil=0.000> be <sil=0.000> a complete <sil=0.000> compound <sil=0.000> say
statement <sil=0.354> ;SEMICOLON  where <sil=0.000> we <sil=0.000> are <sil=0.000> passing <sil=0.000> on <sil=0.000> to <sil=0.000> arguments <sil=0.000> and <sil=0.000> is <sil=0.000> giving <sil=0.000> us <sil=0.000> some <sil=0.000> value <sil=2.000> .PERIOD  Let <sil=0.000> us
look <sil=0.000> at <sil=0.000> what <sil=0.000> is <sil=0.000> being <sil=0.000> done <sil=0.000> here <sil=2.000> .PERIOD  In <sil=0.000> gcd <sil=0.000> int <sil=0.000> A <sil=1.000> ,COMMA  int <sil=0.000> B <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  from <sil=0.000> the <sil=0.000> calling <sil=0.000> function <sil=0.000> must <sil=0.000> be
I <sil=0.000> am <sil=0.000> supplying <sil=0.000> some <sil=0.000> values <sil=0.000> p and <sil=0.000> q <sil=1.000> ,COMMA  may <sil=0.000> be <sil=0.000> 2 integers <sil=0.000> of <sil=0.000> type <sil=0.000> integers <sil=1.000> ,COMMA  which <sil=0.000> are
mapping <sil=0.000> to <sil=0.000> this <sil=0.000> p and <sil=0.000> q A <sil=0.000> and <sil=0.000> B <sil=2.000> .PERIOD 

Now <sil=0.000> here <sil=0.000> you <sil=0.000> know <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=0.000> this <sil=0.000> algorithm <sil=0.000> earlier <sil=2.000> .PERIOD  We <sil=0.000> take <sil=0.000> a variable <sil=0.000> temp <sil=2.000> .PERIOD  Now
that <sil=0.000> is <sil=0.000> now <sil=0.000> the <sil=0.000> body <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=0.000> is <sil=0.000> defined <sil=0.000> by <sil=0.000> these <sil=0.000> braces <sil=2.000> .PERIOD  Temp <sil=1.000> ,COMMA  while <sil=0.000> B is <sil=0.000> not
divided <sil=0.000> by <sil=0.000> A <sil=1.000> ,COMMA  as <sil=0.000> long <sil=0.000> as <sil=0.000> that <sil=0.000> does <sil=0.000> not <sil=0.000> happen <sil=2.000> .PERIOD  We <sil=0.000> take <sil=0.000> we <sil=0.000> divide <sil=0.000> B by <sil=0.000> A and <sil=0.000> take <sil=0.000> the
remainder <sil=1.000> ,COMMA  and <sil=0.000> then <sil=0.000> go <sil=0.000> on <sil=0.000> that <sil=0.000> classical <sil=0.000> way <sil=0.000> of <sil=0.000> finding <sil=0.000> the <sil=0.000> gcd <sil=1.000> ,COMMA  you <sil=0.000> find <sil=0.000> the <sil=0.000> reminder
and <sil=0.000> make <sil=0.000> the <sil=0.000> remainder <sil=0.000> the <sil=0.000> deviser <sil=1.000> ,COMMA  right <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> exactly <sil=0.000> what <sil=0.000> we <sil=0.000> are <sil=0.000> doing <sil=0.000> in <sil=0.000> a
loop <sil=2.000> .PERIOD 
Ultimately <sil=0.000> the <sil=0.000> final <sil=0.000> deviser <sil=0.000> which <sil=0.000> divides <sil=0.000> and <sil=0.000> gives <sil=0.000> us <sil=0.000> A 0 <sil=1.000> ,COMMA  that <sil=0.000> will <sil=0.000> be <sil=0.000> the <sil=0.000> when <sil=0.000> it <sil=0.000> that
will <sil=0.000> be <sil=0.000> the <sil=0.000> gcd <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> gcd <sil=0.000> now <sil=0.354> ;SEMICOLON  that <sil=0.000> gcd <sil=0.000> is <sil=0.000> coming <sil=0.000> in <sil=0.000> this <sil=0.000> A <sil=2.000> .PERIOD  Therefore <sil=1.000> ,COMMA  I <sil=0.000> cannot <sil=0.000> here
just <sil=0.000> write <sil=0.000> simply <sil=0.000> return <sil=2.000> .PERIOD  I <sil=0.000> have <sil=0.000> to <sil=0.000> say <sil=0.000> that <sil=0.000> return <sil=0.000> A <sil=2.000> .PERIOD  And <sil=0.000> may <sil=0.000> be <sil=0.000> from <sil=0.000> the <sil=0.000> main <sil=0.000> function <sil=0.000> I
had <sil=0.000> something <sil=0.000> like <sil=0.000> say <sil=0.000> hcf <sil=0.000> is <sil=0.000> equal <sil=0.000> to <sil=0.000> gcd <sil=0.000> p comma <sil=0.000> q <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  this <sil=0.000> a is <sil=0.000> being <sil=0.000> returned <sil=0.000> to
this <sil=0.000> gcd <sil=2.000> .PERIOD  And <sil=0.000> because <sil=0.000> this <sil=0.000> g c <sil=0.000> because <sil=0.000> it <sil=0.000> was <sil=0.000> a gcd <sil=0.000> function <sil=1.000> ,COMMA  this <sil=0.000> was <sil=0.000> called <sil=0.000> and <sil=0.000> that <sil=0.000> is
why <sil=0.000> it <sil=0.000> is <sil=0.000> going <sil=0.000> to <sil=0.000> a is <sil=0.000> coming <sil=0.000> to <sil=0.000> the <sil=0.000> here <sil=1.000> ,COMMA  and <sil=0.000> then <sil=0.000> by <sil=0.000> this <sil=0.000> assignment <sil=0.000> statement <sil=0.000> that <sil=0.000> is
going <sil=0.000> to <sil=0.000> hcf <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> how <sil=0.000> the <sil=0.000> function <sil=0.000> is <sil=0.000> being <sil=0.000> connected <sil=0.000> ok <sil=2.000> .PERIOD  We <sil=0.000> also <sil=0.000> see <sil=0.000> what <sil=0.000> is <sil=0.000> the
body <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=0.228> ?QUESTIONMARK 

So <sil=1.000> ,COMMA  when <sil=0.000> a function <sil=0.000> is <sil=0.000> called <sil=0.000> from <sil=0.000> some <sil=0.000> other <sil=0.000> function <sil=2.000> .PERIOD  The <sil=0.000> corresponding <sil=0.000> arguments <sil=0.000> in
the <sil=0.000> function <sil=0.000> are <sil=0.000> called <sil=0.000> actual <sil=0.000> arguments <sil=0.000> or <sil=0.000> actual <sil=0.000> parameters <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=0.000> what <sil=0.000> I am
calling <sil=0.000> parameter <sil=1.000> ,COMMA  some <sil=0.000> people <sil=0.000> call <sil=0.000> them <sil=0.000> actual <sil=0.000> parameters <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  just <sil=0.000> in <sil=0.000> the <sil=0.000> earlier
example <sil=0.000> p q <sil=0.000> were <sil=0.000> actual <sil=0.000> parameters <sil=2.000> .PERIOD  And <sil=0.000> what <sil=0.000> was <sil=0.000> there <sil=0.000> a b <sil=0.000> or <sil=0.000> x y <sil=1.000> ,COMMA  whatever <sil=0.000> was <sil=0.000> there
is <sil=0.000> a b <sil=0.000> are <sil=0.000> the <sil=0.000> are <sil=0.000> the <sil=0.000> formal <sil=0.000> parameters <sil=0.000> or <sil=0.000> formal <sil=0.000> arguments <sil=2.000> .PERIOD  Now <sil=0.000> as <sil=0.000> we <sil=0.000> had <sil=0.000> said <sil=1.000> ,COMMA  the
formal <sil=0.000> and <sil=0.000> the <sil=0.000> actual <sil=0.000> arguments <sil=0.000> must <sil=0.000> match <sil=0.000> in <sil=0.000> their <sil=0.000> data <sil=0.000> types <sil=2.000> .PERIOD  The <sil=0.000> identifiers <sil=0.000> used <sil=0.000> as
formal <sil=0.000> arguments <sil=0.000> are <sil=0.000> local <sil=2.000> .PERIOD  Not <sil=0.000> recognised <sil=0.000> outside <sil=0.000> the <sil=0.000> function <sil=2.000> .PERIOD  The <sil=0.000> names <sil=0.000> of <sil=0.000> formal
and <sil=0.000> actual <sil=0.000> arguments <sil=0.000> may <sil=0.000> differ <sil=0.000> as <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=0.000> here <sil=1.000> ,COMMA  they <sil=0.000> are <sil=0.000> differing <sil=0.000> my <sil=0.000> actual
arguments <sil=0.000> were <sil=0.000> p q <sil=2.000> .PERIOD 

And <sil=0.000> here <sil=0.000> it <sil=0.000> is <sil=0.000> A and <sil=0.000> B of <sil=0.000> course <sil=1.000> ,COMMA  they <sil=0.000> are <sil=0.000> differing <sil=2.000> .PERIOD  Now <sil=0.000> this <sil=0.000> A and <sil=0.000> B <sil=1.000> ,COMMA  whatever <sil=0.000> it <sil=0.000> is
here <sil=1.000> ,COMMA  this <sil=0.000> A and <sil=0.000> B will <sil=0.000> not <sil=0.000> be <sil=0.000> reflected <sil=0.000> anywhere <sil=0.000> outside <sil=0.000> this <sil=0.000> function <sil=2.000> .PERIOD  Suppose <sil=1.000> ,COMMA  here
there <sil=0.000> is <sil=0.000> a main <sil=1.000> ,COMMA  the <sil=0.000> main <sil=0.000> will <sil=0.000> not <sil=0.000> get <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> A and <sil=0.000> B <sil=1.000> ,COMMA  this <sil=0.000> completely <sil=0.000> local <sil=0.000> here <sil=0.000> and
as <sil=0.000> soon <sil=0.000> as <sil=0.000> it <sil=0.000> is <sil=0.000> ends <sil=0.000> the <sil=0.000> A and <sil=0.000> B vanishes <sil=1.000> ,COMMA  A <sil=0.000> and <sil=0.000> B will <sil=0.000> no <sil=0.000> longer <sil=0.000> B available <sil=0.000> to <sil=0.000> you <sil=2.000> .PERIOD 
Same <sil=0.000> is <sil=0.000> true <sil=0.000> for <sil=0.000> temp <sil=0.000> because <sil=0.000> temp <sil=0.000> has <sil=0.000> been <sil=0.000> defined <sil=0.000> internally <sil=0.000> within <sil=0.000> this <sil=0.000> function
alright <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> a very <sil=0.000> key <sil=0.000> thing <sil=0.000> that <sil=0.000> you <sil=0.000> must <sil=0.000> understand <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  so <sil=1.000> ,COMMA  when <sil=0.000> a function <sil=0.000> is <sil=0.000> called <sil=0.000> from <sil=0.000> some <sil=0.000> other <sil=0.000> function <sil=1.000> ,COMMA  the <sil=0.000> arguments <sil=0.000> are <sil=0.000> passed
points <sil=0.000> to <sil=0.000> note <sil=0.000> that <sil=0.000> the <sil=0.000> names <sil=0.000> and <sil=0.000> of <sil=0.000> the <sil=0.000> formal <sil=0.000> and <sil=0.000> actual <sil=0.000> arguments <sil=0.000> may <sil=0.000> differ <sil=0.000> right <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> I will <sil=0.000> conclude <sil=0.000> with <sil=0.000> this <sil=0.000> lecture <sil=0.000> I will <sil=0.000> conclude <sil=0.000> with <sil=0.000> this <sil=0.000> example <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> we
are <sil=0.000> computing <sil=0.000> the <sil=0.000> gcd <sil=0.000> of <sil=0.000> 4 numbers <sil=2.000> .PERIOD  In <sil=0.000> the <sil=0.000> main <sil=0.000> function <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> got <sil=0.000> n1 <sil=1.000> ,COMMA  n <sil=0.000> 2 <sil=1.000> ,COMMA  n <sil=0.000> 3 <sil=1.000> ,COMMA  n <sil=0.000> 4 <sil=1.000> ,COMMA 
4 <sil=0.000> values <sil=0.000> have <sil=0.000> been <sil=0.000> read <sil=0.000> here <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> see <sil=0.000> that <sil=0.000> they <sil=0.000> are <sil=0.000> being <sil=0.000> read <sil=0.000> as <sil=0.000> and <sil=0.000> n1 <sil=0.000> and <sil=0.000> n 2 <sil=0.000> and
n <sil=0.000> 3 and <sil=0.000> n 4 <sil=2.000> .PERIOD  They <sil=0.000> are <sil=0.000> been <sil=0.000> read <sil=2.000> .PERIOD  Now <sil=0.000> the <sil=0.000> result <sil=0.000> is <sil=0.354> ;SEMICOLON  now <sil=0.000> gcd <sil=0.000> of <sil=0.000> n1 <sil=1.000> ,COMMA  n <sil=0.000> 2 gcd <sil=0.000> of <sil=0.000> n 3 <sil=1.000> ,COMMA  n <sil=0.000> 4 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
there <sil=0.000> is <sil=0.000> one <sil=0.000> function <sil=0.000> gcd <sil=0.354> ;SEMICOLON  which <sil=0.000> takes <sil=0.000> int <sil=0.000> A int <sil=0.000> B <sil=1.000> ,COMMA  right <sil=0.000> that <sil=0.000> is <sil=0.000> what <sil=0.000> we <sil=0.000> saw <sil=2.000> .PERIOD  Now <sil=0.000> first <sil=1.000> ,COMMA 
when <sil=0.000> within <sil=0.000> this <sil=0.000> parentheses <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> first <sil=0.000> compute <sil=0.000> this <sil=0.000> gcd <sil=0.000> n1 <sil=0.000> and <sil=0.000> n 2 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  a <sil=0.000> will <sil=0.000> have
n1 <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> n1 <sil=1.000> ,COMMA  b <sil=0.000> will <sil=0.000> have <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> n 2 <sil=1.000> ,COMMA  and <sil=0.000> the <sil=0.000> function <sil=0.000> will <sil=0.000> return <sil=0.000> something <sil=1.000> ,COMMA 
return <sil=0.000> A as <sil=0.000> we <sil=0.000> saw <sil=0.000> in <sil=0.000> the <sil=0.000> last <sil=0.000> example <sil=1.000> ,COMMA  return <sil=0.000> A <sil=2.000> .PERIOD  And <sil=0.000> so <sil=1.000> ,COMMA  the <sil=0.000> body <sil=0.000> of <sil=0.000> the <sil=0.000> function
ultimately <sil=0.000> ends <sil=0.000> with <sil=0.000> return <sil=0.000> a <sil=2.000> .PERIOD  And <sil=0.000> that <sil=0.000> a will <sil=0.000> come <sil=0.000> here <sil=0.000> suppose <sil=0.000> that <sil=0.000> value <sil=0.000> was <sil=0.000> 3 say <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  3 <sil=0.000> comes <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> do <sil=0.000> I have <sil=0.000> now <sil=0.228> ?QUESTIONMARK  I <sil=0.000> have <sil=0.000> got <sil=0.000> gcd <sil=0.000> of <sil=0.000> 3 comma <sil=0.000> gcd <sil=0.000> of <sil=0.000> n 3 <sil=1.000> ,COMMA  n <sil=0.000> 4 <sil=2.000> .PERIOD  So
now <sil=1.000> ,COMMA  this <sil=0.000> same <sil=0.000> function <sil=0.000> will <sil=0.000> be <sil=0.000> called <sil=0.000> with <sil=0.000> a having <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> n 3 <sil=0.000> and <sil=0.000> b having <sil=0.000> the
value <sil=0.000> of <sil=0.000> n 4 <sil=2.000> .PERIOD  And <sil=0.000> suppose <sil=0.000> I compute <sil=0.000> them <sil=1.000> ,COMMA  and <sil=0.000> I find <sil=0.000> ultimately <sil=0.000> that <sil=0.000> the <sil=0.000> gcd <sil=0.000> is <sil=0.000> 5 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the
5 <sil=0.000> will <sil=0.000> come <sil=0.000> here <sil=2.000> .PERIOD 
Then <sil=0.000> what <sil=0.000> happens <sil=0.000> to <sil=0.000> this <sil=0.228> ?QUESTIONMARK  Then <sil=0.000> we <sil=0.000> will <sil=0.000> compute <sil=0.000> again <sil=0.000> called <sil=0.000> gcd <sil=0.000> with <sil=0.000> 3 and <sil=0.000> 5 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
again <sil=0.000> here <sil=0.000> now <sil=0.000> a will <sil=0.000> have <sil=0.000> 3 <sil=1.000> ,COMMA  and <sil=0.000> b will <sil=0.000> have <sil=0.000> 5 and <sil=0.000> the <sil=0.000> return <sil=0.000> of <sil=0.000> course <sil=1.000> ,COMMA  a <sil=0.000> 3 and <sil=0.000> 5 will <sil=0.000> be
a <sil=0.000> the <sil=0.000> result <sil=0.000> the <sil=0.000> hcf <sil=0.000> of <sil=0.000> 3 and <sil=0.000> 5 is <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  return <sil=0.000> a that <sil=0.000> will <sil=0.000> come <sil=0.000> here <sil=1.000> ,COMMA  and <sil=0.000> the <sil=0.000> result <sil=0.000> will <sil=0.000> be
one <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> how <sil=0.000> the <sil=0.000> gcd <sil=0.000> is <sil=0.000> computed <sil=0.000> in <sil=0.000> cascading <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=0.000> calls <sil=2.000> .PERIOD  The <sil=0.000> same
function <sil=0.000> you <sil=0.000> see <sil=0.000> is <sil=0.000> being <sil=0.000> called <sil=0.000> time <sil=0.000> and <sil=0.000> again <sil=0.000> repeatedly <sil=0.000> from <sil=0.000> this <sil=0.000> single <sil=0.000> statement <sil=0.000> in
the <sil=0.000> main <sil=0.000> function <sil=2.000> .PERIOD  We <sil=0.000> will <sil=0.000> continue <sil=0.000> looking <sil=0.000> at <sil=0.000> functions <sil=0.000> more <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  in <sil=0.000> the <sil=0.000> earlier <sil=0.000> lecture <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> seen <sil=0.000> how <sil=0.000> a function <sil=0.000> can <sil=0.000> be <sil=0.000> invoked <sil=1.000> ,COMMA  and <sil=0.000> it <sil=0.000> returns <sil=0.000> the
values <sil=2.000> .PERIOD  As <sil=0.000> we <sil=0.000> had <sil=0.000> mentioned <sil=0.000> that <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> the <sil=0.000> case <sil=0.000> that <sil=0.000> always <sil=0.000> a function <sil=0.000> will <sil=0.000> return <sil=0.000> a
value <sil=0.000> here <sil=0.000> is <sil=0.000> an <sil=0.000> example <sil=2.000> .PERIOD 

You <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=0.000> function <sil=0.000> div <sil=0.000> 7 which <sil=0.000> says <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  the <sil=0.000> purpose <sil=0.000> of <sil=0.000> this <sil=0.000> function <sil=0.000> is <sil=0.000> to
find <sil=0.000> out <sil=0.000> whether <sil=0.000> a particular <sil=0.000> number <sil=0.000> that <sil=0.000> is <sil=0.000> passed <sil=0.000> on <sil=0.000> to <sil=0.000> it <sil=0.000> as <sil=0.000> a parameter <sil=1.000> ,COMMA  and <sil=0.000> parameter
whether <sil=0.000> that <sil=0.000> is <sil=0.000> divisible <sil=0.000> by <sil=0.000> 7 or <sil=0.000> not <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> program <sil=0.000> the <sil=0.000> code <sil=0.000> is <sil=0.000> very <sil=0.000> simple <sil=0.000> what <sil=0.000> should
we <sil=0.000> do <sil=0.228> ?QUESTIONMARK  If <sil=0.000> n is <sil=0.000> divisible <sil=0.000> by <sil=0.000> 7 <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  if <sil=0.000> n modulus <sil=0.000> 7 is <sil=0.000> equal <sil=0.000> to <sil=0.000> 0 <sil=1.000> ,COMMA  then <sil=0.000> we <sil=0.000> say <sil=0.000> printf
n <sil=0.000> is <sil=0.000> divisible <sil=0.000> by <sil=0.000> 7 otherwise <sil=0.000> we <sil=0.000> print <sil=0.000> n is <sil=0.000> not <sil=0.000> divisible <sil=0.000> by <sil=0.000> 7 <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  in <sil=0.000> this <sil=0.000> case <sil=0.000> we <sil=0.000> are <sil=0.000> just <sil=0.000> printing <sil=0.000> from <sil=0.000> here <sil=0.000> straight <sil=0.000> the <sil=0.000> print <sil=0.000> out <sil=0.000> is <sil=0.000> coming <sil=0.000> printing
is <sil=0.000> coming <sil=0.000> out <sil=0.000> from <sil=0.000> here <sil=2.000> .PERIOD  The <sil=0.000> main <sil=0.000> function <sil=0.000> is <sil=0.000> only <sil=0.000> passing <sil=0.000> on <sil=0.000> the <sil=0.000> value <sil=0.000> reading
scanning <sil=0.000> reading <sil=0.000> some <sil=0.000> value <sil=0.000> of <sil=0.000> n and <sil=0.000> passing <sil=0.000> on <sil=0.000> that <sil=0.000> value <sil=0.000> of <sil=0.000> n here <sil=0.000> or <sil=0.000> may <sil=0.000> be <sil=0.000> here <sil=0.000> it <sil=0.000> is
n <sil=0.000> is <sil=0.000> the <sil=0.000> argument <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  might <sil=0.000> be <sil=0.000> the <sil=0.000> main <sil=0.000> program <sil=0.000> is <sil=0.000> reading <sil=0.000> a value <sil=0.000> num <sil=1.000> ,COMMA  and <sil=0.000> passing
that <sil=0.000> value <sil=0.000> num <sil=0.000> here <sil=2.000> .PERIOD  Now <sil=0.000> this <sil=0.000> num <sil=0.000> is <sil=0.000> also <sil=0.000> of <sil=0.000> type <sil=0.000> integer <sil=0.000> and <sil=0.000> the <sil=0.000> rest <sil=0.000> of <sil=0.000> the <sil=0.000> things <sil=0.000> are
being <sil=0.000> done <sil=0.000> by <sil=0.000> the <sil=0.000> function <sil=2.000> .PERIOD  It <sil=0.000> is <sil=0.000> testing <sil=0.000> whether <sil=0.000> it <sil=0.000> is <sil=0.000> divisible <sil=0.000> by <sil=0.000> 7 <sil=1.000> ,COMMA  if <sil=0.000> it <sil=0.000> is <sil=0.000> divisible <sil=0.000> by <sil=0.000> 7 <sil=1.000> ,COMMA 

it <sil=0.000> is <sil=0.000> printing <sil=0.000> like <sil=0.000> that <sil=0.000> otherwise <sil=0.000> its <sil=0.000> printing <sil=0.000> the <sil=0.000> other <sil=0.000> message <sil=2.000> .PERIOD  Now <sil=0.000> in <sil=0.000> this <sil=0.000> case <sil=0.000> putting
this <sil=0.000> return <sil=0.000> is <sil=0.000> optional <sil=1.000> ,COMMA  because <sil=0.000> even <sil=0.000> if <sil=0.000> I did <sil=0.000> not <sil=0.000> put <sil=0.000> the <sil=0.000> put <sil=0.000> the <sil=0.000> return <sil=0.000> when <sil=0.000> I would <sil=0.000> have
met <sil=0.000> these <sil=0.000> parentheses <sil=0.000> that <sil=0.000> is <sil=0.000> n bracket <sil=0.000> it <sil=0.000> would <sil=0.000> automatically <sil=0.000> return <sil=0.000> to <sil=0.000> the <sil=0.000> calling <sil=0.000> point <sil=2.000> .PERIOD 
However <sil=0.000> there <sil=0.000> is <sil=0.000> no <sil=0.000> harm <sil=0.000> if <sil=0.000> I put <sil=0.000> the <sil=0.000> return <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  returning <sil=0.000> control <sil=0.354> ;SEMICOLON  we <sil=0.000> have <sil=0.000> seen <sil=0.000> that <sil=0.000> how <sil=0.000> the <sil=0.000> thing <sil=0.000> is <sil=0.000> invoked <sil=0.000> by <sil=0.000> parameter <sil=0.000> passing <sil=2.000> .PERIOD 
Now <sil=0.000> returning <sil=0.000> control <sil=0.000> if <sil=0.000> nothing <sil=0.000> is <sil=0.000> returned <sil=0.000> then <sil=0.000> you <sil=0.000> can <sil=0.000> simply <sil=0.000> write <sil=0.000> return <sil=0.000> semicolon
or <sil=0.000> we <sil=0.000> can <sil=0.000> skip <sil=0.000> that <sil=0.000> and <sil=0.000> until <sil=0.000> it <sil=0.000> comes <sil=0.000> to <sil=0.000> the <sil=0.000> right <sil=0.000> brace <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> last <sil=0.000> right <sil=0.000> brace <sil=0.000> that <sil=0.000> is
automatically <sil=0.000> taken <sil=0.000> as <sil=0.000> the <sil=0.000> return <sil=2.000> .PERIOD  But <sil=0.000> if <sil=0.000> something <sil=0.000> is <sil=0.000> to <sil=0.000> be <sil=0.000> returned <sil=0.000> if <sil=0.000> something <sil=0.000> is <sil=0.000> to <sil=0.000> be
returned <sil=0.000> then <sil=0.000> we <sil=0.000> must <sil=0.000> put <sil=0.000> the <sil=0.000> return <sil=0.000> statement <sil=0.000> with <sil=0.000> say <sil=0.000> may <sil=0.000> be <sil=0.000> return <sil=0.000> A times <sil=0.000> B some
expression <sil=0.000> or <sil=0.000> it <sil=0.000> could <sil=0.000> be <sil=0.000> return <sil=0.000> C or <sil=0.000> it <sil=0.000> could <sil=0.000> be <sil=0.000> something <sil=0.000> like <sil=0.000> return <sil=0.000> 0 or <sil=0.000> return <sil=0.000> 1
whatever <sil=0.000> we <sil=0.000> have <sil=0.000> to <sil=0.000> do <sil=0.000> something <sil=1.000> ,COMMA  some <sil=0.000> expression <sil=0.000> and <sil=0.000> expression <sil=0.000> automatically <sil=0.000> in <sil=0.000> I
mean <sil=0.000> you <sil=0.000> know <sil=0.000> we <sil=0.000> will <sil=0.000> also <sil=0.000> capture <sil=0.000> the <sil=0.000> constants <sil=0.000> so <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=0.000> example <sil=0.000> here <sil=0.000> you <sil=0.000> see <sil=0.000> the <sil=0.000> layout <sil=0.000> is <sil=0.000> also <sil=0.000> important <sil=0.000> here <sil=0.000> we <sil=0.000> are
first <sil=0.000> writing <sil=0.000> the <sil=0.000> function <sil=0.000> this <sil=0.000> is <sil=0.000> the <sil=0.000> function <sil=0.000> the <sil=0.000> function <sil=0.000> declaration <sil=0.000> is <sil=0.000> coming <sil=0.000> first
square <sil=0.000> of <sil=0.000> x square <sil=0.000> of <sil=0.000> an <sil=0.000> integer <sil=0.000> x and <sil=0.000> square <sil=0.000> of <sil=0.000> an <sil=0.000> integer <sil=0.000> x will <sil=0.000> also <sil=0.000> be <sil=0.000> an <sil=0.000> integer
therefore <sil=1.000> ,COMMA  the <sil=0.000> type <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=0.000> is <sil=0.000> int <sil=0.000> as <sil=0.000> you <sil=0.000> can <sil=0.000> see <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> this <sil=0.000> whole <sil=0.000> thing <sil=0.000> is
the <sil=0.000> function <sil=0.000> declaration <sil=1.000> ,COMMA  then <sil=0.000> starts <sil=0.000> the <sil=0.000> body <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> the <sil=0.000> function
declaration <sil=0.000> consists <sil=0.000> of <sil=0.000> the <sil=0.000> name <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=1.000> ,COMMA  and <sil=0.000> the <sil=0.000> parameter <sil=0.000> that <sil=0.000> is <sil=0.000> x of <sil=0.000> type
integer <sil=0.000> and <sil=0.000> this <sil=0.000> int <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> a return <sil=0.000> data <sil=0.000> type <sil=0.000> what <sil=0.000> the <sil=0.000> type <sil=0.000> of <sil=0.000> the <sil=0.000> data <sil=0.000> type <sil=0.000> that <sil=0.000> will <sil=0.000> be
returned <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  these <sil=0.000> 3 together <sil=0.000> make <sil=0.000> the <sil=0.000> function <sil=0.000> declaration <sil=2.000> .PERIOD 
Next <sil=0.000> we <sil=0.000> are <sil=0.000> coming <sil=0.000> to <sil=0.000> the <sil=0.000> body <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=0.000> int <sil=0.000> y what <sil=0.000> is <sil=0.000> that <sil=0.000> that <sil=0.000> is <sil=0.000> a temporary
variable <sil=0.000> temporary <sil=0.000> variable <sil=0.000> why <sil=0.000> I am <sil=0.000> calling <sil=0.000> it <sil=0.000> temporary <sil=0.228> ?QUESTIONMARK  Because <sil=0.000> it <sil=0.000> lives <sil=0.000> as <sil=0.000> long <sil=0.000> as
this <sil=0.000> function <sil=0.000> is <sil=0.000> active <sil=1.000> ,COMMA  as <sil=0.000> soon <sil=0.000> as <sil=0.000> the <sil=0.000> function <sil=0.000> is <sil=0.000> function <sil=0.000> ends <sil=0.000> the <sil=0.000> role <sil=0.000> the <sil=0.000> definition <sil=0.000> of
this <sil=0.000> y is <sil=0.000> also <sil=0.000> lost <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> you <sil=0.000> see <sil=0.000> we <sil=0.000> will <sil=0.000> come <sil=0.000> to <sil=0.000> that <sil=0.000> later <sil=0.000> that <sil=0.000> here <sil=0.000> you <sil=0.000> see <sil=0.000> that <sil=0.000> this <sil=0.000> is
an <sil=0.000> internal <sil=0.000> variable <sil=1.000> ,COMMA  here <sil=0.000> I am <sil=0.000> computing <sil=0.000> the <sil=0.000> square <sil=0.000> y assigned <sil=0.000> x times <sil=0.000> x <sil=1.000> ,COMMA  and <sil=0.000> I am
returning <sil=0.000> y <sil=2.000> .PERIOD  I <sil=0.000> am <sil=0.000> returning <sil=0.000> y and <sil=0.000> after <sil=0.000> returned <sil=0.000> that <sil=0.000> y vanishes <sil=0.000> y where <sil=0.000> is <sil=0.000> y returning <sil=0.000> to <sil=0.228> ?QUESTIONMARK 
Wherever <sil=0.000> they <sil=0.000> square <sil=0.000> has <sil=0.000> been <sil=0.000> called <sil=0.000> now <sil=0.000> here <sil=0.000> you <sil=0.000> see <sil=0.000> here <sil=0.000> is <sil=0.000> a sum <sil=0.000> of <sil=0.000> square <sil=0.000> the <sil=0.000> what
is <sil=0.000> main <sil=0.000> doing <sil=0.000> now <sil=0.000> let <sil=0.000> us <sil=0.000> come <sil=0.000> to <sil=0.000> main <sil=2.000> .PERIOD  Main <sil=0.000> has <sil=0.000> got <sil=0.000> some <sil=0.000> variables <sil=0.000> a b <sil=0.000> and <sil=0.000> sum <sil=0.000> of
square <sil=0.000> is <sil=0.000> another <sil=0.000> variable <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  printf <sil=0.000> give <sil=0.000> a and <sil=0.000> b I <sil=0.000> am <sil=0.000> reading <sil=0.000> a and <sil=0.000> b <sil=2.000> .PERIOD  Now <sil=0.000> I am <sil=0.000> calling
this <sil=0.000> function <sil=0.000> twice <sil=0.000> first <sil=0.000> with <sil=0.000> the <sil=0.000> parameter <sil=0.000> a next <sil=0.000> with <sil=0.000> the <sil=0.000> parameter <sil=0.000> b and <sil=0.000> a and <sil=0.000> b how <sil=0.000> I
mean <sil=0.000> in <sil=0.000> sequence <sil=0.000> goes <sil=0.000> to <sil=0.000> this <sil=0.000> argument <sil=0.000> x and <sil=0.000> the <sil=0.000> square <sil=0.000> of <sil=0.000> a is <sil=0.000> computed <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  return <sil=0.000> y
will <sil=0.000> return <sil=0.000> first <sil=0.000> here <sil=0.000> a square <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> get <sil=0.000> a square <sil=0.000> here <sil=0.000> then <sil=0.000> this <sil=0.000> is <sil=0.000> called <sil=0.000> and <sil=0.000> y is

returned <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> get <sil=0.000> b square <sil=0.000> and <sil=0.000> then <sil=0.000> these <sil=0.000> 2 are <sil=0.000> added <sil=0.000> and <sil=0.000> we <sil=0.000> get <sil=0.000> sum <sil=0.000> of <sil=0.000> square
alright <sil=0.000> and <sil=0.000> then <sil=0.000> we <sil=0.000> are <sil=0.000> printing <sil=0.000> the <sil=0.000> sum <sil=0.000> of <sil=0.000> square <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you <sil=0.000> need <sil=0.000> to <sil=0.000> you <sil=0.000> can <sil=0.000> also <sil=0.000> try <sil=0.000> to <sil=0.000> see
what <sil=0.000> is <sil=0.000> a flow <sil=0.000> of <sil=0.000> data <sil=0.000> in <sil=0.000> such <sil=0.000> cases <sil=0.000> alright <sil=0.000> let <sil=0.000> us <sil=0.000> move <sil=0.000> ahead <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  these <sil=0.000> are <sil=0.000> the <sil=0.000> parameters <sil=0.000> passed <sil=0.000> and <sil=0.000> here <sil=0.000> are <sil=0.000> the <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> the <sil=0.000> argument <sil=0.000> you <sil=0.000> can <sil=0.000> see
that <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  invoking <sil=0.000> a function <sil=0.000> call <sil=0.000> here <sil=0.000> the <sil=0.000> same <sil=0.000> thing <sil=0.000> what <sil=0.000> is <sil=0.000> happening <sil=0.000> when <sil=0.000> a the <sil=0.000> thing
that <sil=0.000> I just <sil=0.000> now <sil=0.000> explained <sil=2.000> .PERIOD 

When <sil=0.000> I am <sil=0.000> saying <sil=0.000> now <sil=0.000> let <sil=0.000> us <sil=0.000> see <sil=0.000> what <sil=0.000> happens <sil=0.000> to <sil=0.000> the <sil=0.000> variables <sil=0.000> assume <sil=0.000> that <sil=0.000> the <sil=0.000> value <sil=0.000> of
a <sil=0.000> that <sil=0.000> has <sil=0.000> been <sil=0.000> read <sil=0.000> here <sil=0.000> is <sil=0.000> 10 <sil=0.000> alright <sil=0.000> then <sil=0.000> square <sil=0.000> of <sil=0.000> a means <sil=0.000> square <sil=0.000> of <sil=0.000> 10 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  10goes <sil=0.000> to
x <sil=1.000> ,COMMA  right <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  a <sil=0.000> is <sil=0.000> 10 <sil=0.000> here <sil=0.000> that <sil=0.000> goes <sil=0.000> to <sil=0.000> x <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  x <sil=0.000> becomes <sil=0.000> 10 <sil=1.000> ,COMMA  now <sil=0.000> we <sil=0.000> compute <sil=0.000> y which <sil=0.000> is <sil=0.000> 10 <sil=0.000> times
10 <sil=0.000> I am <sil=0.000> getting <sil=0.000> y <sil=2.000> .PERIOD  Y <sil=0.000> is <sil=0.000> becoming <sil=0.000> hundred <sil=0.000> right <sil=0.000> now <sil=0.000> this <sil=0.000> hundred <sil=0.000> is <sil=0.000> coming <sil=0.000> here <sil=0.000> actually
this <sil=0.000> arrow <sil=0.000> is <sil=0.000> a little <sil=0.000> wrong <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> actually <sil=0.000> coming <sil=0.000> to <sil=0.000> this <sil=0.000> point <sil=0.000> clear <sil=0.000> next
suppose <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> case <sil=1.000> ,COMMA  similarly <sil=0.000> it <sil=0.000> will <sil=0.000> be <sil=0.000> for <sil=0.000> b <sil=1.000> ,COMMA  if <sil=0.000> b was <sil=0.000> some <sil=0.000> value <sil=0.000> that <sil=0.000> is <sil=0.000> the <sil=0.000> how <sil=0.000> then <sil=0.000> x
suppose <sil=0.000> b was <sil=0.000> 7 then <sil=0.000> x will <sil=0.000> get <sil=0.000> 7 and <sil=0.000> then <sil=0.000> y will <sil=0.000> be <sil=0.000> 49 <sil=1.000> ,COMMA  and <sil=0.000> 49 <sil=0.000> will <sil=0.000> come <sil=0.000> to <sil=0.000> that <sil=0.000> square
of <sil=0.000> b <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  100 <sil=0.000> plus <sil=0.000> 49 <sil=0.000> will <sil=0.000> now <sil=0.000> be <sil=0.000> added <sil=0.000> and <sil=0.000> will <sil=0.000> be <sil=0.000> kept <sil=0.000> as <sil=0.000> the <sil=0.000> sum <sil=0.000> of <sil=0.000> square <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  in <sil=0.000> the
earlier <sil=0.000> example <sil=0.000> you <sil=0.000> could <sil=0.000> see <sil=0.000> that <sil=0.000> in <sil=0.000> the <sil=0.000> earlier <sil=0.000> example <sil=0.000> the <sil=0.000> first <sil=0.000> the <sil=0.000> function <sil=0.000> was <sil=0.000> return
and <sil=0.000> then <sil=0.000> the <sil=0.000> main <sil=0.000> now <sil=0.000> let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> go <sil=0.000> ahead <sil=0.000> function <sil=0.000> definition <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> seen <sil=0.000> that <sil=0.000> a function <sil=0.000> name <sil=0.000> preceded <sil=0.000> by <sil=0.000> return <sil=0.000> value <sil=0.000> type <sil=0.000> and <sil=0.000> declaration
statement <sil=0.000> and <sil=0.000> then <sil=0.000> the <sil=0.000> function <sil=0.000> body <sil=0.000> I am <sil=0.000> repeating <sil=0.000> certain <sil=0.000> things <sil=0.000> variables <sil=0.000> can <sil=0.000> be
declare <sil=0.000> declared <sil=0.000> inside <sil=0.000> the <sil=0.000> blocks <sil=0.000> the <sil=0.000> blocks <sil=0.000> can <sil=0.000> be <sil=0.000> nested <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  there <sil=0.000> can
multiple <sil=0.000> blocks <sil=0.000> function <sil=0.000> cannot <sil=0.000> be <sil=0.000> defined <sil=0.000> inside <sil=0.000> another <sil=0.000> function <sil=0.000> this <sil=0.000> must <sil=0.000> be <sil=0.000> clearly
understood <sil=0.000> a function <sil=0.000> cannot <sil=0.000> be <sil=0.000> defined <sil=0.000> within <sil=0.000> another <sil=0.000> function <sil=0.000> and <sil=0.000> returning <sil=0.000> of <sil=0.000> control
the <sil=0.000> control <sil=0.000> will <sil=0.000> have <sil=0.000> to <sil=0.000> be <sil=0.000> returned <sil=0.000> as <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=1.000> ,COMMA  if <sil=0.000> nothing <sil=0.000> returned <sil=0.000> then <sil=0.000> return <sil=0.000> we
have <sil=0.000> already <sil=0.000> seen <sil=0.000> that <sil=0.000> if <sil=0.000> something <sil=0.000> is <sil=0.000> returned <sil=0.000> then <sil=0.000> return <sil=0.000> that <sil=0.000> expression <sil=2.000> .PERIOD 

Here <sil=0.000> again <sil=0.000> another <sil=0.000> example <sil=0.000> of <sil=0.000> function <sil=1.000> ,COMMA  the <sil=0.000> more <sil=0.000> examples <sil=0.000> you <sil=0.000> do <sil=0.000> the <sil=0.000> better <sil=0.000> you <sil=0.000> will
understand <sil=2.000> .PERIOD  Here <sil=0.000> the <sil=0.000> function <sil=0.000> as <sil=0.000> the <sil=0.000> name <sil=0.000> implies <sil=0.000> you <sil=0.000> see <sil=0.000> its <sil=0.000> always <sil=0.000> better <sil=0.000> to <sil=0.000> use
meaningful <sil=0.000> names <sil=0.000> of <sil=0.000> functions <sil=0.000> some <sil=0.000> of <sil=0.000> digits <sil=0.000> of <sil=0.000> n <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> there <sil=0.000> be <sil=0.000> number <sil=0.000> like <sil=0.000> 125 <sil=0.000> then <sil=0.000> I
am <sil=0.000> trying <sil=0.000> to <sil=0.000> extract <sil=0.000> this <sil=0.000> digits <sil=0.000> 1 plus <sil=0.000> 2 plus <sil=0.000> 5 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> will <sil=0.000> be <sil=0.000> 8 that <sil=0.000> is <sil=0.000> what <sil=0.000> my <sil=0.000> program
wants <sil=0.000> to <sil=0.000> do <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  initially <sil=0.000> sum <sil=0.000> is <sil=0.000> equal <sil=0.000> to <sil=0.000> 0 while <sil=0.000> n is <sil=0.000> not <sil=0.000> equal <sil=0.000> to <sil=0.000> 0 <sil=1.000> ,COMMA  sum <sil=0.000> plus <sil=0.000> remainder <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  125 <sil=0.000> if <sil=0.000> I divide <sil=0.000> by <sil=0.000> 10 <sil=1.000> ,COMMA  then <sil=0.000> I will <sil=0.000> have <sil=0.000> 12 <sil=0.000> here <sil=0.000> and <sil=0.000> remainder <sil=0.000> is <sil=0.000> 5 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  sum <sil=0.000> plus <sil=0.000> 5 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
sum <sil=0.000> becomes <sil=0.000> 5 clear <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  then <sil=0.000> we <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> device <sil=0.000> dividend <sil=0.000> that <sil=0.000> is <sil=0.000> 12 <sil=0.000> and <sil=0.000> again <sil=0.000> divide <sil=0.000> that <sil=0.000> by <sil=0.000> 10 <sil=1.000> ,COMMA  we <sil=0.000> get
2 <sil=0.000> to <sil=0.000> be <sil=0.000> the <sil=0.000> remainder <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> take <sil=0.000> sum <sil=0.000> to <sil=0.000> be <sil=0.000> 5 plus <sil=0.000> 2 and <sil=0.000> so <sil=0.000> and <sil=0.000> so <sil=0.000> forth <sil=2.000> .PERIOD  Ultimately <sil=0.000> I
am <sil=0.000> getting <sil=0.000> the <sil=0.000> sum <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  return <sil=0.000> sum <sil=0.000> this <sil=0.000> another <sil=0.000> example <sil=0.000> of <sil=0.000> a function <sil=0.354> ;SEMICOLON  here <sil=0.000> you <sil=0.000> can <sil=0.000> see
that <sil=0.000> this <sil=0.000> n is <sil=0.000> coming <sil=0.000> as <sil=0.000> a parameter <sil=0.000> all <sil=0.000> these <sil=0.000> sum <sil=0.354> ;SEMICOLON  sum <sil=0.000> is <sil=0.000> a an <sil=0.000> internal <sil=0.000> variable <sil=0.000> and <sil=0.000> will
not <sil=0.000> have <sil=0.000> life <sil=0.000> beyond <sil=0.000> the <sil=0.000> body <sil=0.000> of <sil=0.000> the <sil=0.000> program <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> you <sil=0.000> see <sil=0.000> sum <sil=0.000> of <sil=0.000> digits <sil=0.000> is <sil=0.000> a function <sil=0.000> name <sil=0.000> int <sil=0.000> is <sil=0.000> a return <sil=0.000> data <sil=0.000> type <sil=1.000> ,COMMA  parameter <sil=0.000> list
is <sil=0.000> that <sil=0.000> local <sil=0.000> variables <sil=0.000> is <sil=0.000> sum <sil=2.000> .PERIOD  Sum <sil=0.000> is <sil=0.000> a local <sil=0.000> variable <sil=0.000> and <sil=0.000> return <sil=0.000> statement <sil=0.000> is <sil=0.000> return <sil=0.000> sum
clear <sil=0.000> all <sil=0.000> these <sil=0.000> we <sil=0.000> have <sil=0.000> already <sil=0.000> discussed <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> merely <sil=0.000> a division <sil=0.354> ;SEMICOLON  and <sil=0.000> here <sil=0.000> you <sil=0.000> can <sil=0.000> see
that <sil=0.000> the <sil=0.000> return <sil=0.000> can <sil=0.000> have <sil=0.000> an <sil=0.000> expression <sil=0.000> here <sil=0.000> only <sil=0.000> a variable <sil=0.000> is <sil=0.000> an <sil=0.000> expression <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  we <sil=0.000> come <sil=0.000> to <sil=0.000> a very <sil=0.000> important <sil=0.000> concept <sil=1.000> ,COMMA  which <sil=0.000> I was <sil=0.000> mentioning <sil=0.000> in <sil=0.000> the <sil=0.000> passing <sil=0.000> that
the <sil=0.000> life <sil=0.000> of <sil=0.000> an <sil=0.000> intern <sil=0.000> variable <sil=0.000> internal <sil=0.000> to <sil=0.000> a function <sil=0.000> exists <sil=0.000> as <sil=0.000> long <sil=0.000> as <sil=0.000> the <sil=0.000> function <sil=0.000> is <sil=0.000> live <sil=0.000> as
long <sil=0.000> as <sil=0.000> the <sil=0.000> function <sil=0.000> is <sil=0.000> active <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  that <sil=0.000> formally <sil=0.000> is <sil=0.000> known <sil=0.000> is <sil=0.000> called <sil=0.000> the <sil=0.000> scope <sil=0.000> of <sil=0.000> the <sil=0.000> variable <sil=0.000> or <sil=0.000> the <sil=0.000> variable <sil=0.000> scope <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
let <sil=0.000> us <sil=0.000> look <sil=0.000> here <sil=0.000> there <sil=0.000> is <sil=0.000> an <sil=0.000> interesting <sil=0.000> program <sil=2.000> .PERIOD  Now <sil=0.000> here <sil=0.000> you <sil=0.000> see <sil=0.000> my <sil=0.000> entry <sil=0.000> point <sil=0.000> is <sil=0.000> the
main <sil=1.000> ,COMMA  but <sil=0.000> even <sil=0.000> before <sil=0.000> that <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> declared <sil=0.000> a variable <sil=0.000> int <sil=0.000> A <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  this <sil=0.000> A is <sil=0.000> a global
variable <sil=0.000> that <sil=0.000> means <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> there <sil=0.000> always <sil=2.000> .PERIOD  Suppose <sil=0.000> it <sil=0.000> is <sil=0.000> A value <sil=0.000> 100 <sil=0.000> then <sil=0.000> it <sil=0.000> remains <sil=0.000> this <sil=0.000> this
is <sil=0.000> retained <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> keep <sil=0.000> this <sil=0.000> and <sil=0.000> let <sil=0.000> us <sil=0.000> see <sil=0.000> what <sil=0.000> happens <sil=2.000> .PERIOD  Now <sil=0.000> I am <sil=0.000> entering <sil=0.000> main <sil=0.000> and
I <sil=0.000> have <sil=0.000> assigned <sil=0.000> A to <sil=0.000> 1 now <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  now <sil=0.000> inside <sil=0.000> this <sil=0.000> function <sil=0.000> inside <sil=0.000> this <sil=0.000> main <sil=0.000> I have
got <sil=0.000> mains <sil=0.000> A which <sil=0.000> is <sil=0.000> another <sil=0.000> A let <sil=0.000> me <sil=0.000> write <sil=0.000> it <sil=0.000> m is <sil=0.000> it <sil=0.000> visible <sil=0.000> let <sil=0.000> me <sil=0.000> do <sil=0.000> it <sil=0.000> in <sil=0.000> a better <sil=0.000> way <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  there <sil=0.000> is <sil=0.000> one <sil=0.000> A <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> calling <sil=0.000> that <sil=0.000> A g <sil=0.000> that <sil=0.000> is <sil=0.000> this <sil=0.000> A <sil=1.000> ,COMMA  is <sil=0.000> A g <sil=0.000> that <sil=0.000> is <sil=0.000> the <sil=0.000> global <sil=0.000> A and
suppose <sil=0.000> that <sil=0.000> is <sil=0.000> 100 <sil=2.000> .PERIOD  Now <sil=0.000> this <sil=0.000> is <sil=0.000> another <sil=0.000> a which <sil=0.000> is <sil=0.000> defined <sil=0.000> in <sil=0.000> the <sil=0.000> main <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> function
this <sil=0.000> will <sil=0.000> be <sil=0.000> live <sil=0.000> inside <sil=0.000> main <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> me <sil=0.000> call <sil=0.000> it <sil=0.000> A m <sil=0.000> alright <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  A <sil=0.000> becomes <sil=0.000> 1 here <sil=0.000> as
I <sil=0.000> come <sil=0.000> here <sil=0.000> a 1 <sil=1.000> ,COMMA  then <sil=0.000> I am <sil=0.000> calling <sil=0.000> my <sil=0.000> proc <sil=0.000> a function <sil=0.000> my <sil=0.000> proc <sil=0.000> from <sil=0.000> here <sil=0.000> it <sil=0.000> comes <sil=0.000> to <sil=0.000> my
proc <sil=0.000> and <sil=0.000> suppose <sil=0.000> my <sil=0.000> proc <sil=0.000> has <sil=0.000> got <sil=0.000> another <sil=0.000> A here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> me <sil=0.000> call <sil=0.000> that <sil=0.000> to <sil=0.000> be <sil=0.000> A x <sil=0.000> just <sil=0.000> for
understanding <sil=0.000> that <sil=0.000> it <sil=0.000> is <sil=0.000> of <sil=0.000> my <sil=0.000> proc <sil=0.000> or <sil=0.000> let <sil=0.000> me <sil=0.000> call <sil=0.000> it <sil=0.000> let <sil=0.000> me <sil=0.000> call <sil=0.000> it <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=0.000> right <sil=0.354> ;SEMICOLON  so <sil=1.000> ,COMMA 
AF <sil=2.000> .PERIOD  Now <sil=0.000> that <sil=0.000> is <sil=0.000> initialised <sil=0.000> to <sil=0.000> 2 now <sil=0.000> you <sil=0.000> see <sil=0.000> how <sil=0.000> many <sil=0.000> different <sil=0.000> a s <sil=0.000> I have <sil=0.228> ?QUESTIONMARK  Multiple <sil=0.000> a s
now <sil=0.000> inside <sil=0.000> this <sil=0.000> block <sil=0.000> I initialise <sil=0.000> another <sil=0.000> A to <sil=0.000> be <sil=0.000> 3 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> another <sil=0.000> A that <sil=0.000> means <sil=1.000> ,COMMA  this
one <sil=0.000> is <sil=0.000> not <sil=0.000> being <sil=0.000> disturbed <sil=0.000> A is <sil=0.000> 2 and <sil=0.000> while <sil=0.000> A is <sil=0.000> 2 I <sil=0.000> am <sil=0.000> making <sil=0.000> another <sil=0.000> a because <sil=0.000> here <sil=0.000> I
am <sil=0.000> declaring <sil=0.000> you <sil=0.000> see <sil=0.000> this <sil=0.000> is <sil=0.000> a pure <sil=0.000> declaration <sil=0.000> int <sil=0.000> A <sil=2.000> .PERIOD  If <sil=0.000> I had <sil=0.000> just <sil=0.000> written <sil=0.000> A <sil=1.000> ,COMMA  if <sil=0.000> I had <sil=0.000> just
written <sil=0.000> A assigned <sil=0.000> 3 <sil=1.000> ,COMMA  then <sil=0.000> this <sil=0.000> A would <sil=0.000> be <sil=0.000> assigned <sil=0.000> 3 <sil=1.000> ,COMMA  but <sil=0.000> here <sil=0.000> I have <sil=0.000> declared <sil=0.000> another
A <sil=0.000> int <sil=0.000> A <sil=2.000> .PERIOD 
Therefore <sil=0.000> there <sil=0.000> is <sil=0.000> another <sil=0.000> A coming <sil=0.000> within <sil=0.000> this <sil=0.000> y while <sil=0.000> block <sil=0.000> that <sil=0.000> I am <sil=0.000> calling <sil=0.000> AB <sil=1.000> ,COMMA  and
that <sil=0.000> is <sil=0.000> becoming <sil=0.000> 3 <sil=2.000> .PERIOD  Now <sil=0.000> I am <sil=0.000> printing <sil=0.000> A <sil=1.000> ,COMMA  which <sil=0.000> here <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=0.000> the <sil=0.000> inner <sil=0.000> most <sil=0.000> the
current <sil=0.000> A that <sil=0.000> means <sil=1.000> ,COMMA  3 <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=0.000> then <sil=0.000> I break <sil=0.354> ;SEMICOLON  break <sil=0.000> means <sil=0.000> what <sil=0.228> ?QUESTIONMARK  I <sil=0.000> come <sil=0.000> out <sil=0.000> of <sil=0.000> the
while <sil=0.000> loop <sil=0.000> we <sil=0.000> have <sil=0.000> learned <sil=0.000> break <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> come <sil=0.000> out <sil=0.000> of <sil=0.000> the <sil=0.000> while <sil=0.000> loop <sil=0.000> and <sil=0.000> then <sil=0.000> I print <sil=0.000> a
which <sil=0.000> is <sil=0.000> so <sil=1.000> ,COMMA  as <sil=0.000> soon <sil=0.000> as <sil=0.000> I break <sil=0.000> out <sil=0.000> of <sil=0.000> this <sil=0.000> this <sil=0.000> is <sil=0.000> gone <sil=0.000> no <sil=0.000> longer <sil=0.000> live <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> coming <sil=0.000> here <sil=0.000> now <sil=0.000> which <sil=0.000> a is <sil=0.000> in <sil=0.000> my <sil=0.000> scope <sil=0.000> which <sil=0.000> a is <sil=0.000> in <sil=0.000> my <sil=0.000> scope <sil=1.000> ,COMMA  my <sil=0.000> scope <sil=0.000> is
this <sil=0.000> I am <sil=0.000> within <sil=0.000> this <sil=0.000> function <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> A <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  2 <sil=0.000> or <sil=0.000> there <sil=0.000> was

some <sil=0.000> back <sil=0.000> slash <sil=0.000> n I <sil=0.000> am <sil=0.000> ignoring <sil=0.000> them <sil=0.000> that <sil=0.000> will <sil=0.000> come <sil=0.000> one <sil=0.000> after <sil=0.000> another <sil=0.000> and <sil=0.000> then <sil=0.000> I come
out <sil=0.000> of <sil=0.000> this <sil=0.000> its <sil=0.000> over <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> go <sil=0.000> to <sil=0.000> this <sil=0.000> main <sil=0.000> function <sil=0.000> go <sil=0.000> back <sil=0.000> sorry <sil=0.000> not <sil=0.000> here <sil=0.000> I am <sil=0.000> sorry <sil=0.000> it
should <sil=0.000> go <sil=0.000> back <sil=0.000> to <sil=0.000> this <sil=0.000> point <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> now <sil=0.000> execute <sil=0.000> print <sil=0.000> which <sil=0.000> a is <sil=0.000> in <sil=0.000> my <sil=0.000> scope
now <sil=0.000> I have <sil=0.000> come <sil=0.000> out <sil=0.000> of <sil=0.000> this <sil=0.000> come <sil=0.000> out <sil=0.000> of <sil=0.000> this <sil=0.000> function <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> its <sil=0.000> scope <sil=0.000> is <sil=0.000> also <sil=0.000> gone <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
the <sil=0.000> scope <sil=0.000> of <sil=0.000> this <sil=0.000> function <sil=0.000> main <sil=0.000> is <sil=0.000> now <sil=0.000> live <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> the <sil=0.000> value <sil=0.000> one <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  that <sil=0.000> will <sil=0.000> be
printed <sil=0.354> ;SEMICOLON  that <sil=0.000> is <sil=0.000> how <sil=0.000> the <sil=0.000> things <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> repeat <sil=0.000> it <sil=0.000> if <sil=0.000> necessary <sil=1.000> ,COMMA  but <sil=0.000> let <sil=0.000> us
try <sil=0.000> to <sil=0.000> see <sil=0.000> the <sil=0.000> execution <sil=2.000> .PERIOD 

Now <sil=0.000> so <sil=1.000> ,COMMA  if <sil=0.000> I first <sil=0.000> do <sil=0.000> it <sil=0.000> then <sil=0.000> this <sil=0.000> one <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=0.000> a assigned <sil=0.000> 3 next <sil=0.000> that <sil=0.000> is <sil=0.000> gone <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
here <sil=0.000> A will <sil=0.000> be <sil=0.000> this <sil=0.000> will <sil=0.000> be <sil=0.000> assigned <sil=0.000> A assigned <sil=0.000> 2 <sil=1.000> ,COMMA  then <sil=0.000> I will <sil=0.000> go <sil=0.000> up <sil=0.000> there <sil=0.000> and <sil=0.000> the <sil=0.000> A that <sil=0.000> is
in <sil=0.000> the <sil=0.000> scope <sil=0.000> of <sil=0.000> this <sil=0.000> function <sil=0.000> that <sil=0.000> will <sil=0.000> be <sil=0.000> assigned <sil=0.000> and <sil=0.000> then <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> will <sil=0.000> be <sil=0.000> assigned <sil=0.000> ok <sil=2.000> .PERIOD 
You <sil=0.000> see <sil=0.000> although <sil=0.000> I declared <sil=0.000> a global <sil=0.000> A internally <sil=0.000> when <sil=0.000> I declare <sil=0.000> some <sil=0.000> other <sil=0.000> A <sil=1.000> ,COMMA  this
global <sil=0.000> A I <sil=0.000> have <sil=0.000> I look <sil=0.000> here <sil=0.000> a point <sil=0.000> has <sil=0.000> to <sil=0.000> be <sil=0.000> seen <sil=2.000> .PERIOD  I <sil=0.000> declared <sil=0.000> A <sil=1.000> ,COMMA  a <sil=0.000> global <sil=0.000> A here <sil=0.000> A g <sil=0.000> that
was <sil=0.000> declared <sil=2.000> .PERIOD  Here <sil=0.000> I have <sil=0.000> assigned <sil=0.000> to <sil=0.000> A <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> not <sil=0.000> declared <sil=0.000> another <sil=0.000> A <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> not
written <sil=0.000> int <sil=0.000> A I <sil=0.000> have <sil=0.000> simply <sil=0.000> written <sil=0.000> a assigned <sil=0.000> 1 that <sil=0.000> means <sil=1.000> ,COMMA  the <sil=0.000> a that <sil=0.000> was <sil=0.000> there <sil=0.000> is
already <sil=0.000> existing <sil=0.000> globally <sil=0.000> that <sil=0.000> has <sil=0.000> been <sil=0.000> assigned <sil=0.000> one <sil=2.000> .PERIOD 
But <sil=0.000> when <sil=0.000> I come <sil=0.000> here <sil=0.000> and <sil=0.000> I am <sil=0.000> declaring <sil=0.000> int <sil=0.000> A internally <sil=0.000> inside <sil=0.000> this <sil=0.000> process <sil=1.000> ,COMMA  another <sil=0.000> A
is <sil=0.000> created <sil=0.000> which <sil=0.000> is <sil=0.000> the <sil=0.000> A of <sil=0.000> the <sil=0.000> function <sil=0.000> and <sil=0.000> that <sil=0.000> is <sil=0.000> assigned <sil=0.000> by <sil=0.000> with <sil=0.000> 2 not <sil=0.000> this <sil=0.000> one <sil=1.000> ,COMMA  they
are <sil=0.000> 2 distinct <sil=0.000> entities <sil=2.000> .PERIOD  Now <sil=0.000> again <sil=0.000> here <sil=0.000> I have <sil=0.000> declared <sil=0.000> another <sil=0.000> A <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  since <sil=0.000> I have
declared <sil=0.000> another <sil=0.000> A <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> the <sil=0.000> A of <sil=0.000> this <sil=0.000> while <sil=0.000> loop <sil=0.000> might <sil=0.000> be <sil=0.000> and <sil=0.000> that <sil=0.000> is <sil=0.000> becoming <sil=0.000> 3 and

accordingly <sil=0.000> the <sil=0.000> corresponding <sil=0.000> whenever <sil=0.000> I say <sil=0.000> print <sil=0.000> which <sil=0.000> one <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=1.000> ,COMMA  which <sil=0.000> one
will <sil=0.000> be <sil=0.000> printed <sil=0.000> will <sil=0.000> be <sil=0.000> the <sil=0.000> one <sil=0.000> that <sil=0.000> is <sil=0.000> within <sil=0.000> its <sil=0.000> scope <sil=0.000> this <sil=0.000> a is <sil=0.000> in <sil=0.000> the <sil=0.000> scope <sil=0.000> of <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
that <sil=0.000> was <sil=0.000> printed <sil=0.000> this <sil=0.000> and <sil=0.000> gone <sil=0.000> this <sil=0.000> A was <sil=0.000> is <sil=0.000> in <sil=0.000> the <sil=0.000> scope <sil=0.000> of <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  printed <sil=0.000> and <sil=0.000> gone <sil=0.000> and
this <sil=0.000> A is <sil=0.000> in <sil=0.000> the <sil=0.000> scope <sil=0.000> of <sil=0.000> this <sil=0.000> and <sil=0.000> this <sil=0.000> is <sil=0.000> printed <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> the <sil=0.000> scope <sil=0.000> of
variables <sil=0.000> ok <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  if <sil=0.000> we <sil=0.000> summarise <sil=0.000> functions <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> see <sil=0.000> this <sil=0.000> I do <sil=0.000> not <sil=0.000> know <sil=0.000> how <sil=0.000> much <sil=0.000> is <sil=0.000> visible <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
main <sil=0.000> function <sil=0.000> I am <sil=0.000> calling <sil=0.000> of <sil=0.000> a function <sil=0.000> factorial <sil=1.000> ,COMMA  and <sil=0.000> we <sil=0.000> have <sil=0.000> already <sil=0.000> seen <sil=0.000> that <sil=0.000> and <sil=0.000> then
the <sil=0.000> function <sil=0.000> is <sil=0.000> having <sil=0.000> different <sil=0.000> its <sil=0.000> a self <sil=0.000> contained <sil=0.000> programme <sil=1.000> ,COMMA  which <sil=0.000> has <sil=0.000> got <sil=0.000> its <sil=0.000> definite
name <sil=0.000> function <sil=0.000> definition <sil=0.000> whether <sil=0.000> type <sil=0.000> of <sil=0.000> the <sil=0.000> argument <sil=0.000> is <sil=0.000> also <sil=0.000> specified <sil=2.000> .PERIOD  Now <sil=0.000> main <sil=0.000> is <sil=0.000> a
function <sil=0.000> and <sil=0.000> here <sil=0.000> I am <sil=0.000> calling <sil=0.000> a function <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> actually <sil=0.000> calling <sil=0.000> a function <sil=0.000> by <sil=0.000> name
calling <sil=0.000> by <sil=0.000> name <sil=0.000> and <sil=0.000> is <sil=0.000> a returned <sil=0.000> data <sil=0.000> type <sil=0.000> repeating <sil=0.000> that <sil=0.000> the <sil=0.000> function <sil=0.000> name <sil=0.000> is <sil=0.000> there <sil=0.000> the
parameter <sil=0.000> is <sil=0.000> there <sil=0.000> and <sil=0.000> the <sil=0.000> return <sil=0.000> statement <sil=2.000> .PERIOD 
And <sil=0.000> the <sil=0.000> other <sil=0.000> variables <sil=0.000> like <sil=0.000> temp <sil=0.000> and <sil=0.000> all <sil=0.000> those <sil=0.000> are <sil=0.000> local <sil=0.000> variables <sil=0.000> you <sil=0.000> are <sil=0.000> repeating <sil=2.000> .PERIOD 

Now <sil=0.000> some <sil=0.000> points <sil=0.000> is <sil=0.000> a function <sil=0.000> cannot <sil=0.000> be <sil=0.000> defined <sil=0.000> within <sil=0.000> another <sil=0.000> function <sil=1.000> ,COMMA  which <sil=0.000> we <sil=0.000> have
told <sil=1.000> ,COMMA  but <sil=0.000> I am <sil=0.000> repeating <sil=0.000> it <sil=0.000> again <sil=0.000> all <sil=0.000> function <sil=0.000> definitions <sil=0.000> must <sil=0.000> be <sil=0.000> disjoint <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  I
cannot <sil=0.000> define <sil=0.000> one <sil=0.000> function <sil=0.000> within <sil=0.000> another <sil=0.000> nested <sil=0.000> function <sil=0.000> calls <sil=0.000> are <sil=0.000> allowed <sil=0.000> what <sil=0.000> is
meant <sil=0.000> by <sil=0.000> nested <sil=0.000> function <sil=0.000> call <sil=0.000> nested <sil=0.000> function <sil=0.000> call <sil=0.000> means <sil=0.000> that <sil=0.000> suppose <sil=0.000> here <sil=0.000> is <sil=0.000> a main
program <sil=0.000> going <sil=0.000> on <sil=2.000> .PERIOD 

I <sil=0.000> call <sil=0.000> a function <sil=0.000> this <sil=0.000> is <sil=0.000> function <sil=0.000> say <sil=0.000> F 1 <sil=1.000> ,COMMA  and <sil=0.000> this <sil=0.000> was <sil=0.000> my <sil=0.000> main <sil=0.000> from <sil=0.000> some <sil=0.000> point <sil=0.000> in <sil=0.000> the
function <sil=0.000> in <sil=0.000> order <sil=0.000> to <sil=0.000> solve <sil=0.000> this <sil=0.000> problem <sil=0.000> F 1 <sil=1.000> ,COMMA  I <sil=0.000> may <sil=0.000> call <sil=0.000> another <sil=0.000> function <sil=0.000> F 2 <sil=0.000> this <sil=0.000> is <sil=0.000> nesting

calling <sil=1.000> ,COMMA  but <sil=0.000> not <sil=0.000> defined <sil=0.000> they <sil=0.000> are <sil=0.000> defined <sil=0.000> separately <sil=0.000> F 1 <sil=0.000> defined <sil=0.000> separately <sil=1.000> ,COMMA  F <sil=0.000> 2 defined
separately <sil=1.000> ,COMMA  m <sil=0.000> defined <sil=0.000> separately <sil=2.000> .PERIOD  Now <sil=0.000> from <sil=0.000> F 2 <sil=1.000> ,COMMA  I <sil=0.000> may <sil=0.000> call <sil=0.000> another <sil=0.000> function <sil=0.000> F 3 <sil=0.000> and <sil=0.000> F 3
completes <sil=0.000> F 2 <sil=0.000> has <sil=0.000> called <sil=0.000> F 3 <sil=0.000> because <sil=0.000> of <sil=0.000> some <sil=0.000> reason <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> problem <sil=0.000> reason <sil=0.000> is
answered <sil=0.000> I mean <sil=0.000> for <sil=0.000> some <sil=0.000> value <sil=0.000> of <sil=0.000> a some <sil=0.000> computation <sil=0.000> that <sil=0.000> computation <sil=0.000> has <sil=0.000> been <sil=0.000> done
from <sil=0.000> here <sil=0.000> it <sil=0.000> returns <sil=0.000> to <sil=0.000> the <sil=0.000> point <sil=0.000> from <sil=0.000> where <sil=0.000> it <sil=0.000> was <sil=0.000> called <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> a return <sil=0.000> point <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  is <sil=0.000> it
clear <sil=0.000> or <sil=0.000> should <sil=0.000> I use <sil=0.000> some <sil=0.000> other <sil=0.000> caller <sil=0.000> for <sil=0.000> the <sil=0.000> return <sil=0.000> point <sil=0.000> is <sil=0.000> it <sil=0.000> necessary <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> not
getting <sil=0.000> the <sil=0.000> colour <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> me <sil=0.000> use <sil=0.000> the <sil=0.000> existing <sil=0.000> colour <sil=0.000> whatever <sil=0.000> was <sil=0.000> there <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> it <sil=0.000> go <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
from <sil=0.000> here <sil=0.000> now <sil=0.000> the <sil=0.000> colour <sil=0.000> has <sil=0.000> come <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> show <sil=0.000> the <sil=0.000> return <sil=0.000> here <sil=0.000> I am <sil=0.000> returning <sil=1.000> ,COMMA  but
then <sil=0.000> again <sil=0.000> I am <sil=0.000> continuing <sil=0.000> with <sil=0.000> this <sil=0.000> function <sil=2.000> .PERIOD 
And <sil=0.000> when <sil=0.000> F 2 <sil=0.000> is <sil=0.000> over <sil=1.000> ,COMMA  then <sil=0.000> I again <sil=0.000> return <sil=0.000> to <sil=0.000> F 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> was <sil=0.000> called <sil=0.000> F 1 <sil=0.000> called <sil=0.000> F 2 <sil=0.000> for <sil=0.000> some
purpose <sil=0.000> that <sil=0.000> purpose <sil=0.000> is <sil=0.000> solved <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> return <sil=0.000> here <sil=0.000> and <sil=0.000> then <sil=0.000> F 1 <sil=0.000> continues <sil=0.000> again <sil=0.000> in <sil=0.000> its
whatever <sil=0.000> it <sil=0.000> has <sil=0.000> doing <sil=0.000> and <sil=0.000> F 1 <sil=0.000> was <sil=0.000> called <sil=0.000> by <sil=0.000> main <sil=0.000> for <sil=0.000> some <sil=0.000> particular <sil=0.000> reason <sil=0.000> when <sil=0.000> that
purpose <sil=0.000> is <sil=0.000> served <sil=1.000> ,COMMA  then <sil=0.000> we <sil=0.000> return <sil=0.000> to <sil=0.000> this <sil=0.000> point <sil=0.000> and <sil=0.000> then <sil=0.000> main <sil=0.000> continues <sil=0.000> right <sil=0.000> and
ultimately <sil=0.000> main <sil=0.000> ends <sil=0.000> with <sil=0.000> this <sil=0.000> bracket <sil=2.000> .PERIOD  Now <sil=0.000> here <sil=0.000> this <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> nesting <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  I
nesting <sil=0.000> of <sil=0.000> calls <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> made <sil=0.000> a call <sil=1.000> ,COMMA  and <sil=0.000> from <sil=0.000> that <sil=0.000> call <sil=0.000> I can <sil=0.000> make <sil=0.000> another <sil=0.000> call <sil=0.000> from <sil=0.000> there <sil=0.000> I can <sil=0.000> make
another <sil=0.000> call <sil=2.000> .PERIOD  But <sil=0.000> the <sil=0.000> point <sil=0.000> to <sil=0.000> point <sil=0.000> to <sil=0.000> note <sil=0.000> is <sil=0.000> that <sil=0.000> all <sil=0.000> this <sil=0.000> functions <sil=0.000> must <sil=0.000> be <sil=0.000> independently
and <sil=0.000> separately <sil=0.000> defined <sil=0.000> they <sil=0.000> cannot <sil=0.000> be <sil=0.000> defined <sil=0.000> one <sil=0.000> among <sil=0.000> the <sil=0.000> other <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  nested <sil=0.000> function
calls <sil=0.000> are <sil=0.000> allowed <sil=0.000> A calls <sil=0.000> B <sil=1.000> ,COMMA  B <sil=0.000> calls <sil=0.000> C as <sil=0.000> I have <sil=0.000> shown <sil=0.000> m calls <sil=0.000> F 1 <sil=1.000> ,COMMA  F <sil=0.000> 1 calls <sil=0.000> F 2 <sil=1.000> ,COMMA  F <sil=0.000> 2 calls
F <sil=0.000> 3 like <sil=0.000> that <sil=0.000> it <sil=0.000> can <sil=0.000> happen <sil=2.000> .PERIOD  The <sil=0.000> function <sil=0.000> called <sil=0.000> last <sil=0.000> will <sil=0.000> be <sil=0.000> the <sil=0.000> first <sil=0.000> to <sil=0.000> return <sil=0.354> ;SEMICOLON  obviously <sil=1.000> ,COMMA 
we <sil=0.000> have <sil=0.000> seen <sil=0.000> that <sil=0.000> in <sil=0.000> our <sil=0.000> earlier <sil=0.000> slide <sil=0.000> that <sil=0.000> we <sil=0.000> go <sil=0.000> back <sil=0.000> to <sil=0.000> the <sil=0.000> F 4 <sil=0.000> from <sil=0.000> F4 <sil=0.000> I return <sil=0.000> to <sil=0.000> F 2
and <sil=0.000> like <sil=0.000> that <sil=0.000> and <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  a <sil=0.000> function <sil=0.000> can <sil=0.000> call <sil=0.000> also <sil=0.000> call <sil=0.000> itself <sil=0.000> either <sil=0.000> directly <sil=0.000> or <sil=0.000> in <sil=0.000> a cycle <sil=1.000> ,COMMA  we
will <sil=0.000> see <sil=0.000> this <sil=0.000> separately <sil=0.000> what <sil=0.000> is <sil=0.000> meant <sil=0.000> by <sil=0.000> that <sil=2.000> .PERIOD  A <sil=0.000> calls <sil=0.000> B this <sil=0.000> is <sil=0.000> this <sil=0.000> can <sil=0.000> be <sil=0.000> in <sil=0.000> 2 ways <sil=0.000> one
is <sil=0.000> that <sil=0.000> say <sil=0.000> A calls <sil=0.000> B <sil=1.000> ,COMMA  B <sil=0.000> calls <sil=0.000> C <sil=1.000> ,COMMA  C <sil=0.000> calls <sil=0.000> back <sil=0.000> A that <sil=0.000> is <sil=0.000> possible <sil=0.000> like <sil=0.000> say <sil=0.000> here <sil=0.000> if <sil=0.000> we <sil=0.000> see <sil=0.000> that <sil=2.000> .PERIOD 

Main <sil=0.000> was <sil=0.000> running <sil=0.000> it <sil=0.000> called <sil=0.000> F 1 <sil=1.000> ,COMMA  F <sil=0.000> 1 called <sil=0.000> F 2 <sil=0.000> and <sil=0.000> then <sil=0.000> F 2 <sil=0.000> can <sil=0.000> again <sil=0.000> call <sil=0.000> F 1 <sil=0.000> and <sil=0.000> then
this <sil=0.000> call <sil=0.000> ultimately <sil=0.000> for <sil=0.000> this <sil=0.000> call <sil=0.000> the <sil=0.000> return <sil=0.000> has <sil=0.000> to <sil=0.000> come <sil=0.000> here <sil=0.000> and <sil=0.000> ultimately <sil=0.000> it <sil=0.000> will <sil=0.000> have <sil=0.000> to
return <sil=0.000> here <sil=0.000> etcetera <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> part <sil=0.000> will <sil=0.000> have <sil=0.000> to <sil=0.000> see <sil=0.000> separately <sil=0.000> that <sil=0.000> is <sil=0.000> its <sil=0.000> a function <sil=0.000> one
function <sil=0.000> is <sil=0.000> calling <sil=0.000> another <sil=0.000> and <sil=0.000> that <sil=0.000> can <sil=0.000> be <sil=0.000> in <sil=0.000> a cycle <sil=0.000> F 1 <sil=0.000> calling <sil=0.000> F 2 <sil=1.000> ,COMMA  F <sil=0.000> 2 calling <sil=0.000> F 1 <sil=0.000> it <sil=0.000> can
happen <sil=0.000> or <sil=0.000> recursion <sil=0.000> means <sil=0.000> say <sil=0.000> a particular <sil=0.000> function <sil=0.000> F 1 <sil=0.000> calling <sil=0.000> itself <sil=0.000> a number <sil=0.000> of <sil=0.000> times
that <sil=0.000> requires <sil=0.000> a special <sil=0.000> attention <sil=0.000> and <sil=0.000> a special <sil=0.000> discussion <sil=0.000> that <sil=0.000> we <sil=0.000> have <sil=0.000> to <sil=0.000> carry <sil=0.000> out <sil=0.000> we <sil=0.000> will
do <sil=0.000> that <sil=0.000> in <sil=0.000> subsequently <sil=2.000> .PERIOD 
But <sil=0.000> right <sil=0.000> now <sil=0.000> just <sil=0.000> it <sil=0.000> is <sil=0.000> remember <sil=0.000> that <sil=0.000> these <sil=0.000> calls <sil=0.000> can <sil=0.000> be <sil=0.000> in <sil=0.000> a cycle <sil=0.000> or <sil=0.000> it <sil=0.000> can <sil=0.000> be <sil=0.000> called <sil=0.000> to
itself <sil=0.000> which <sil=0.000> is <sil=0.000> a recursion <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> got <sil=0.000> some <sil=0.000> math <sil=0.000> library <sil=0.000> functions <sil=1.000> ,COMMA  which <sil=0.000> perform <sil=0.000> common <sil=0.000> mathematical
calculations <sil=0.000> and <sil=0.000> I do <sil=0.000> not <sil=0.000> remember <sil=0.000> whether <sil=0.000> in <sil=0.000> an <sil=0.000> earlier <sil=0.000> class <sil=0.000> I mistakenly <sil=0.000> said <sil=0.000> that <sil=1.000> ,COMMA  I
had <sil=0.000> mistakenly <sil=0.000> I do <sil=0.000> not <sil=0.000> remember <sil=0.000> exactly <sil=0.000> whether <sil=0.000> I did <sil=0.000> that <sil=0.000> or <sil=0.000> not <sil=0.000> that <sil=0.000> you <sil=0.000> need <sil=0.000> to
include <sil=0.000> just <sil=0.000> as <sil=0.000> we <sil=0.000> include <sil=0.000> math <sil=0.000> dot <sil=0.000> s t <sil=0.000> d i <sil=0.000> o dot <sil=0.000> h <sil=1.000> ,COMMA  similarly <sil=0.000> we <sil=0.000> have <sil=0.000> to <sil=0.000> include <sil=0.000> math <sil=0.000> dot
h <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  just <sil=0.000> as <sil=0.000> we <sil=0.000> include <sil=0.000> s t <sil=0.000> d i <sil=0.000> o dot <sil=0.000> h if <sil=0.000> we <sil=0.000> use <sil=0.000> some <sil=0.000> mathematical <sil=0.000> functions <sil=0.000> which <sil=0.000> are
already <sil=0.000> available <sil=0.000> in <sil=0.000> the <sil=0.000> c library <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> to <sil=0.000> include <sil=0.000> math <sil=0.000> dot <sil=0.000> h <sil=2.000> .PERIOD  I <sil=0.000> do <sil=0.000> not <sil=0.000> remember
whether <sil=0.000> while <sil=0.000> first <sil=0.000> introducing <sil=0.000> the <sil=0.000> square <sil=0.000> root <sil=0.000> function <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> might <sil=0.000> be <sil=0.000> mistakenly <sil=0.000> I
wrote <sil=0.000> math <sil=0.000> dot <sil=0.000> leap <sil=0.000> that <sil=0.000> is <sil=0.000> a library <sil=0.000> function <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  dot <sil=0.000> leap <sil=0.000> if <sil=0.000> I had <sil=0.000> said <sil=0.000> that <sil=0.000> that <sil=0.000> you
should <sil=0.000> ignore <sil=0.000> it <sil=0.000> is <sil=0.000> math <sil=0.000> dot <sil=0.000> h include <sil=0.000> math <sil=0.000> dot <sil=0.000> h and <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> there <sil=0.000> is <sil=0.000> an <sil=0.000> important <sil=0.000> thing <sil=1.000> ,COMMA  when <sil=0.000> I compile <sil=0.000> you <sil=0.000> known <sil=0.000> any <sil=0.000> function <sil=0.000> that <sil=0.000> we <sil=0.000> any
program <sil=0.000> that <sil=0.000> we <sil=0.000> write <sil=0.000> we <sil=0.000> have <sil=0.000> to <sil=0.000> compile <sil=0.000> it <sil=0.000> in <sil=0.000> order <sil=0.000> to <sil=0.000> get <sil=0.000> and <sil=0.000> executable <sil=0.000> code <sil=2.000> .PERIOD  Now <sil=0.000> in
your <sil=0.000> exercises <sil=0.000> you <sil=0.000> must <sil=0.000> have <sil=0.000> done <sil=0.000> by <sil=0.000> now <sil=0.000> the <sil=0.000> typically <sil=0.000> you <sil=0.000> compile <sil=0.000> a c <sil=0.000> program <sil=0.000> like
this <sil=2.000> .PERIOD 

C <sil=0.000> c myprog <sil=0.000> dot <sil=0.000> c right <sil=1.000> ,COMMA  but <sil=0.000> if <sil=0.000> you <sil=0.000> use <sil=0.000> some <sil=0.000> mathematical <sil=0.000> library <sil=0.000> in <sil=0.000> your <sil=0.000> function <sil=0.000> then
you <sil=0.000> should <sil=0.000> write <sil=0.000> c c <sil=0.000> minus <sil=0.000> l m <sil=0.000> myprog <sil=0.000> dot <sil=0.000> c or <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  link <sil=0.000> to <sil=0.000> the <sil=0.000> mathematical
library <sil=0.000> you <sil=0.000> compile <sil=0.000> first <sil=0.000> you <sil=0.000> compile <sil=0.000> now <sil=0.000> you <sil=0.000> see <sil=2.000> .PERIOD 

What <sil=0.000> is <sil=0.000> happening <sil=0.000> is <sil=0.000> the <sil=0.000> mathematical <sil=0.000> libraries <sil=0.000> are <sil=0.000> here <sil=0.000> say <sil=0.000> some <sil=0.000> square <sil=0.000> root <sil=0.000> function
somebody <sil=0.000> has <sil=0.000> written <sil=0.000> for <sil=0.000> you <sil=0.000> and <sil=0.000> that <sil=0.000> is <sil=0.000> in <sil=0.000> the <sil=0.000> c library <sil=0.000> alright <sil=0.000> may <sil=0.000> be <sil=0.000> some <sil=0.000> other
function <sil=0.000> like <sil=0.000> to <sil=0.000> upper <sil=1.000> ,COMMA  which <sil=0.000> converts <sil=0.000> from <sil=0.000> lower <sil=0.000> case <sil=0.000> to <sil=0.000> upper <sil=0.000> case <sil=0.000> all <sil=0.000> these <sil=0.000> things <sil=0.000> are
there <sil=2.000> .PERIOD  Now <sil=0.000> to <sil=0.000> upper <sil=0.000> is <sil=0.000> the <sil=0.000> separate <sil=0.000> library <sil=0.000> where <sil=0.000> square <sil=0.000> root <sil=0.000> is <sil=0.000> the <sil=0.000> math <sil=0.000> library <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> in
your <sil=0.000> function <sil=0.000> you <sil=0.000> if <sil=0.000> in <sil=0.000> your <sil=0.000> program <sil=0.000> you <sil=0.000> write <sil=0.000> you <sil=0.000> refer <sil=0.000> to <sil=0.000> the <sil=0.000> square <sil=0.000> root <sil=0.000> some
mathematical <sil=0.000> library <sil=1.000> ,COMMA  then <sil=0.000> you <sil=0.000> must <sil=0.000> do <sil=0.000> this <sil=0.000> why <sil=0.000> because <sil=0.000> purely <sil=0.000> myprog <sil=0.000> dot <sil=0.000> c will
generate <sil=0.000> some <sil=0.000> object <sil=0.000> code <sil=0.000> alright <sil=0.000> object <sil=0.000> code <sil=2.000> .PERIOD 
Now <sil=0.000> the <sil=0.000> code <sil=0.000> for <sil=0.000> this <sil=0.000> has <sil=0.000> to <sil=0.000> be <sil=0.000> linked <sil=0.000> to <sil=0.000> this <sil=0.000> has <sil=0.000> to <sil=0.000> linked <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> your <sil=0.000> ultimately <sil=0.000> the
fool <sil=0.000> executable <sil=0.000> code <sil=0.000> also <sil=0.000> takes <sil=0.000> into <sil=0.000> this <sil=0.000> account <sil=0.000> this <sil=0.000> code <sil=0.000> link <sil=0.000> to <sil=0.000> this <sil=0.000> code <sil=0.000> will <sil=0.000> be
forming <sil=0.000> your <sil=0.000> executable <sil=0.000> code <sil=0.000> because <sil=0.000> the <sil=0.000> square <sil=0.000> root <sil=0.000> you <sil=0.000> will <sil=0.000> need <sil=0.000> anyway <sil=0.000> at <sil=0.000> that <sil=0.000> time
of <sil=0.000> running <sil=0.000> it <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> it <sil=0.000> has <sil=0.000> shown <sil=0.000> minus <sil=0.000> l m <sil=0.000> at <sil=0.000> the <sil=0.000> later <sil=0.000> also <sil=0.000> c c <sil=0.000> program <sil=0.000> name
and <sil=0.000> then <sil=0.000> link <sil=0.000> with <sil=0.000> the <sil=0.000> mathematical <sil=0.000> library <sil=0.000> format <sil=0.000> for <sil=0.000> calling <sil=0.000> the <sil=0.000> functions <sil=1.000> ,COMMA  forget <sil=0.000> about
this <sil=0.000> let <sil=0.000> us <sil=0.000> make <sil=0.000> it <sil=0.000> for <sil=0.000> the <sil=0.000> time <sil=0.000> being <sil=0.000> ignore <sil=0.000> this <sil=0.000> just <sil=0.000> say <sil=0.000> percentage <sil=0.000> f function <sil=0.000> name <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
this <sil=0.000> is <sil=0.000> point <sil=0.000> number <sil=0.000> 1 <sil=1.000> ,COMMA  there <sil=0.000> are <sil=0.000> many <sil=0.000> mathematical <sil=0.000> library <sil=0.000> functions <sil=0.000> in <sil=0.000> order <sil=0.000> to <sil=0.000> include
in <sil=0.000> order <sil=0.000> to <sil=0.000> use <sil=0.000> them <sil=0.000> we <sil=0.000> have <sil=0.000> to <sil=0.000> include <sil=0.000> immediately <sil=0.000> after <sil=0.000> s t <sil=0.000> d i <sil=0.000> o dot <sil=0.000> h hash <sil=0.000> include
math <sil=0.000> dot <sil=0.000> h and <sil=0.000> we <sil=0.000> must <sil=0.000> use <sil=0.000> this <sil=0.000> give <sil=0.000> this <sil=0.000> linking <sil=0.000> command <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  when <sil=0.000> we <sil=0.000> call <sil=0.000> the <sil=0.000> function <sil=1.000> ,COMMA  the <sil=0.000> function <sil=0.000> name <sil=0.000> argument <sil=0.000> if <sil=0.000> multiple <sil=0.000> arguments <sil=0.000> then
we <sil=0.000> can <sil=0.000> use <sil=0.000> a comma <sil=0.000> separated <sil=0.000> list <sil=0.000> say <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  printf <sil=0.000> some <sil=0.000> format <sil=0.000> the <sil=0.000> square <sil=0.000> root
nine <sil=0.000> or <sil=0.000> there <sil=0.000> is <sil=0.000> only <sil=0.000> one <sil=2.000> .PERIOD  Argument <sil=0.000> not <sil=0.000> much <sil=0.000> arguments <sil=0.000> may <sil=0.000> be <sil=0.000> constant <sil=0.000> variables <sil=0.000> or
expressions <sil=0.000> all <sil=0.000> math <sil=0.000> now <sil=0.000> this <sil=0.000> is <sil=0.000> important <sil=2.000> .PERIOD  All <sil=0.000> math <sil=0.000> functions <sil=0.000> return <sil=0.000> the <sil=0.000> data <sil=0.000> type
double <sil=0.000> this <sil=0.000> is <sil=0.000> important <sil=0.000> you <sil=0.000> should <sil=0.000> keep <sil=0.000> in <sil=0.000> mind <sil=0.000> this <sil=0.000> are <sil=0.000> for <sil=0.000> c <sil=1.000> ,COMMA  all <sil=0.000> the <sil=0.000> math <sil=0.000> functions <sil=0.000> are
returning <sil=0.000> the <sil=0.000> data <sil=0.000> type <sil=0.000> double <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  in <sil=0.000> order <sil=0.000> to <sil=0.000> make <sil=0.000> it <sil=0.000> compatible <sil=0.000> with <sil=0.000> the <sil=0.000> variable <sil=0.000> where
you <sil=0.000> except <sil=0.000> the <sil=0.000> value <sil=0.000> returned <sil=0.000> by <sil=0.000> the <sil=0.000> math <sil=0.000> function <sil=0.000> that <sil=0.000> should <sil=0.000> also <sil=0.000> be <sil=0.000> double <sil=0.000> arguments
may <sil=0.000> be <sil=0.000> constants <sil=0.000> or <sil=0.000> variables <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> are <sil=0.000> some <sil=0.000> examples <sil=0.000> of <sil=0.000> math <sil=0.000> library <sil=0.000> function <sil=0.000> like <sil=0.000> finding <sil=0.000> the <sil=0.000> cos <sil=0.000> of <sil=0.000> some <sil=0.000> angle <sil=0.000> x
finding <sil=0.000> the <sil=0.000> sin <sil=0.000> thus <sil=0.000> all <sil=0.000> this <sil=0.000> functions <sil=0.000> are <sil=0.000> known <sil=0.000> as <sil=0.000> a sin <sil=0.000> a cos <sil=0.000> a tan <sil=0.000> inverse <sil=0.000> tan (Refer
Time:33:41) tan <sil=0.000> ceiling <sil=0.000> function <sil=0.000> floor <sil=0.000> function <sil=2.000> .PERIOD  Floor <sil=0.000> function <sil=0.000> means <sil=0.000> it <sil=0.000> finds <sil=0.000> the <sil=0.000> greatest
largest <sil=0.000> integral <sil=0.000> value <sil=0.000> that <sil=0.000> is <sil=0.000> less <sil=0.000> than <sil=0.000> x <sil=1.000> ,COMMA  suppose <sil=0.000> some <sil=0.000> say <sil=0.000> 200 <sil=2.000> .PERIOD <sil=0.000> 56 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> largest <sil=0.000> integral
value <sil=0.000> is <sil=0.000> 2 hundred <sil=0.000> that <sil=0.000> is <sil=0.000> the <sil=0.000> floor <sil=0.000> function <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  cos <sil=0.000> a cos <sil=0.000> is <sil=0.000> finding <sil=0.000> the <sil=0.000> cos <sil=0.000> of <sil=0.000> an <sil=0.000> angle <sil=0.000> in
degree <sil=0.000> whereas <sil=1.000> ,COMMA  a <sil=0.000> cos <sil=0.000> sorry <sil=0.000> cos <sil=0.000> is <sil=0.000> for <sil=0.000> finding <sil=0.000> the <sil=0.000> cosine <sil=0.000> of <sil=0.000> angle <sil=0.000> in <sil=0.000> radian <sil=0.000> now <sil=0.000> there <sil=0.000> is
no <sil=0.000> point <sil=0.000> in <sil=0.000> memorising <sil=0.000> them <sil=0.000> as <sil=0.000> and <sil=0.000> when <sil=0.000> you <sil=0.000> need <sil=0.000> them <sil=0.000> look <sil=0.000> at <sil=0.000> the <sil=0.000> manual <sil=0.000> look <sil=0.000> at <sil=0.000> the
book <sil=0.000> and <sil=0.000> very <sil=0.000> soon <sil=0.000> you <sil=0.000> will <sil=0.000> get <sil=0.000> a custom <sil=0.000> to <sil=0.000> the <sil=0.000> different <sil=0.000> library <sil=0.000> which <sil=0.000> are <sil=0.000> available <sil=0.000> for
c <sil=0.000> and <sil=2.000> .PERIOD 

We <sil=0.000> will <sil=0.000> come <sil=0.000> back <sil=0.000> to <sil=0.000> this <sil=0.000> in <sil=0.000> the <sil=0.000> next <sil=0.000> function <sil=1.000> ,COMMA  next <sil=0.000> lecture <sil=0.000> about <sil=0.000> some <sil=0.000> more <sil=0.000> very <sil=0.000> well-
known <sil=0.000> functions <sil=0.000> which <sil=0.000> you <sil=0.000> have <sil=0.000> already <sil=0.000> encountered <sil=0.000> with <sil=0.000> and <sil=0.000> then <sil=0.000> we <sil=0.000> will <sil=0.000> proceed <sil=0.000> further <sil=0.000> with <sil=0.000> recursion <sil=2.000> .PERIOD 
Thank <sil=0.000> you <sil=2.000> .PERIOD 

In <sil=0.000> the <sil=0.000> earlier <sil=0.000> lectures <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> looked <sil=0.000> at <sil=0.000> functions <sil=0.000> and <sil=0.000> we <sil=0.000> will <sil=0.000> still <sil=0.000> be <sil=0.000> looking <sil=0.000> at
functions <sil=2.000> .PERIOD  We <sil=0.000> have <sil=0.000> also <sil=0.000> looked <sil=0.000> at <sil=0.000> the <sil=0.000> library <sil=0.000> functions <sil=0.000> and <sil=0.000> just <sil=0.000> to <sil=0.000> recapitulate <sil=0.000> that <sil=1.000> ,COMMA 
whenever <sil=0.000> we <sil=0.000> are <sil=0.000> using <sil=0.000> some <sil=0.000> library <sil=0.000> functions <sil=0.000> in <sil=0.000> our <sil=0.000> program <sil=1.000> ,COMMA  then <sil=0.000> we <sil=0.000> have <sil=0.000> to <sil=0.000> some
mathematical <sil=0.000> library <sil=0.000> functions <sil=1.000> ,COMMA  then <sil=0.000> we <sil=0.000> have <sil=0.000> to <sil=0.000> hash <sil=0.000> include <sil=0.000> math <sil=0.000> dot <sil=0.000> h <sil=2.000> .PERIOD  And <sil=0.000> while <sil=0.000> we
link <sil=0.000> it <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> while <sil=0.000> we <sil=0.000> compile <sil=0.000> it <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> also <sil=0.000> have <sil=0.000> to <sil=0.000> link <sil=0.000> it <sil=0.000> with <sil=0.000> the <sil=0.000> maths <sil=0.000> library
with <sil=0.000> the <sil=0.000> option <sil=0.000> minus <sil=0.000> l m <sil=0.000> as <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  today <sil=1.000> ,COMMA  since <sil=0.000> now <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> got <sil=0.000> an <sil=0.000> idea <sil=0.000> of <sil=0.000> what <sil=0.000> functions <sil=0.000> are <sil=2.000> .PERIOD  Let <sil=0.000> us <sil=0.000> have <sil=0.000> a relook
at <sil=0.000> our <sil=0.000> old <sil=0.000> friend s <sil=0.000> scanf <sil=0.000> and <sil=0.000> printf <sil=1.000> ,COMMA  which <sil=0.000> we <sil=0.000> were <sil=0.000> using <sil=0.000> a number <sil=0.000> of <sil=0.000> times <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  scanf
and <sil=0.000> printf <sil=0.000> are <sil=0.000> nothing <sil=0.000> but <sil=0.000> functions <sil=2.000> .PERIOD  These <sil=0.000> are <sil=0.000> also <sil=0.000> some <sil=0.000> library <sil=0.000> functions <sil=0.000> and <sil=0.000> those <sil=0.000> are
included <sil=0.000> whenever <sil=0.000> we <sil=0.000> use <sil=0.000> include <sil=0.000> s t <sil=0.000> d I <sil=0.000> o dot <sil=0.000> h <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  you <sil=0.000> see <sil=0.000> scanf <sil=0.000> and <sil=0.000> printf <sil=0.000> being
functions <sil=0.000> when <sil=0.000> we <sil=0.000> enter <sil=0.000> data <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=0.000> structure <sil=2.000> .PERIOD 

We <sil=0.000> write <sil=0.000> scanf <sil=0.000> followed <sil=0.000> by <sil=0.000> some <sil=0.000> parameters <sil=2.000> .PERIOD  We <sil=0.000> have <sil=0.000> also <sil=0.000> seen <sil=0.000> that <sil=1.000> ,COMMA  a <sil=0.000> function <sil=0.000> is <sil=0.000> a
function <sil=0.000> is <sil=0.000> nothing <sil=0.000> but <sil=1.000> ,COMMA  something <sil=0.000> like <sil=0.000> f <sil=0.354> ;SEMICOLON  say <sil=1.000> ,COMMA  function <sil=0.000> name <sil=0.000> followed <sil=0.000> by <sil=0.000> some

parameters <sil=2.000> .PERIOD  Here <sil=1.000> ,COMMA  this <sil=0.000> scanf <sil=0.000> is <sil=0.000> that <sil=0.000> function <sil=0.000> name <sil=0.000> and <sil=0.000> the <sil=0.000> parameters <sil=0.000> are <sil=0.000> the <sil=0.000> control
string <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  say <sil=0.000> for <sil=0.000> scanf <sil=0.000> you <sil=0.000> have <sil=0.000> got <sil=0.000> something <sil=0.000> like <sil=0.000> percentage <sil=0.000> d and <sil=0.000> then <sil=0.000> x
alright <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> the <sil=0.000> control <sil=0.000> string <sil=0.000> and <sil=0.000> these <sil=0.000> are <sil=0.000> the <sil=0.000> arguments <sil=0.000> alright <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  both <sil=0.000> of <sil=0.000> these
are <sil=0.000> arguments <sil=0.000> to <sil=0.000> the <sil=0.000> functions <sil=0.000> scanf <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  scanf <sil=0.000> is <sil=0.000> nothing <sil=0.000> but <sil=0.000> a function <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  whenever <sil=0.000> in <sil=0.000> my <sil=0.000> program <sil=1.000> ,COMMA  suppose <sil=0.000> I am <sil=0.000> writing <sil=0.000> a
program <sil=0.000> and <sil=0.000> here <sil=0.000> I use <sil=0.000> scanf <sil=0.000> with <sil=0.000> some <sil=0.000> parameters <sil=2.000> .PERIOD  Like <sil=0.000> this <sil=1.000> ,COMMA  then <sil=0.000> it <sil=0.000> is <sil=0.000> nothing <sil=0.000> but <sil=0.000> a call
to <sil=0.000> a system <sil=0.000> function <sil=2.000> .PERIOD  A <sil=0.000> system <sil=0.000> function <sil=0.000> which <sil=0.000> actually <sil=0.000> does <sil=0.000> the <sil=0.000> task <sil=0.000> of <sil=0.000> reading <sil=0.000> the <sil=0.000> data
from <sil=0.000> the <sil=0.000> input <sil=0.000> input <sil=0.000> device <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  a <sil=0.000> control <sil=0.000> string <sil=0.000> refers <sil=0.000> to <sil=0.000> typically <sil=0.000> the <sil=0.000> data <sil=0.000> types <sil=0.000> of <sil=0.000> the <sil=0.000> arguments <sil=2.000> .PERIOD  We <sil=0.000> have <sil=0.000> seen
percentage <sil=0.000> d percentage <sil=0.000> f etcetera <sil=2.000> .PERIOD  And <sil=0.000> the <sil=0.000> arguments <sil=0.000> are <sil=0.000> pointers <sil=0.000> to <sil=0.000> data <sil=0.000> items <sil=0.000> in
memory <sil=2.000> .PERIOD  These <sil=0.000> arguments <sil=0.000> in <sil=0.000> scanf <sil=0.000> are <sil=0.000> what <sil=0.000> are <sil=0.354> ;SEMICOLON  the <sil=0.000> typical <sil=0.000> arguments <sil=0.000> in <sil=0.000> scanf <sil=0.228> ?QUESTIONMARK  They
are <sil=0.000> say <sil=1.000> ,COMMA  whenever <sil=0.000> I use <sil=0.000> scanf <sil=1.000> ,COMMA  say <sil=0.000> percentage <sil=0.000> d then <sil=0.000> and <sil=0.000> a or <sil=0.000> something <sil=0.000> like <sil=0.000> that <sil=0.000> right <sil=0.228> ?QUESTIONMARK 
Now <sil=1.000> ,COMMA  this <sil=0.000> and <sil=0.000> is <sil=0.000> nothing <sil=0.000> but <sil=0.000> an <sil=0.000> address <sil=0.000> of <sil=0.000> the <sil=0.000> variable <sil=0.000> a <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  in <sil=0.000> my <sil=0.000> memory <sil=1.000> ,COMMA  wherever
the <sil=0.000> variable <sil=0.000> a is <sil=1.000> ,COMMA  the <sil=0.000> variable <sil=0.000> a the <sil=0.000> compiler <sil=0.000> is <sil=0.000> allocated <sil=0.000> this <sil=0.000> memory <sil=0.000> location <sil=1.000> ,COMMA  for <sil=0.000> the
variable <sil=0.000> a and <sil=0.000> I am <sil=0.000> passing <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> that <sil=0.000> so <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> a pointer <sil=0.000> pointing <sil=0.000> to
some <sil=0.000> address <sil=0.000> or <sil=0.000> a pointer <sil=0.000> that <sil=0.000> is <sil=0.000> pointing <sil=0.000> to <sil=0.000> this <sil=0.000> particular <sil=0.000> location <sil=0.000> in <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> scanf <sil=1.000> ,COMMA 
ok <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> why <sil=1.000> ,COMMA  it <sil=0.000> said <sil=0.000> the <sil=0.000> arguments <sil=0.000> these <sil=0.000> arguments <sil=0.000> arg <sil=0.000> 1 arg <sil=0.000> 2 arg <sil=0.000> n are
representing <sil=0.000> nothing <sil=0.000> but <sil=0.000> pointers <sil=0.000> to <sil=0.000> data <sil=0.000> items <sil=0.000> in <sil=0.000> the <sil=0.000> memory  <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  the <sil=0.000> example <sil=1.000> ,COMMA  a <sil=0.000> typical <sil=0.000> example <sil=0.000> is <sil=1.000> ,COMMA  say <sil=1.000> ,COMMA  percentage <sil=0.000> d percentage <sil=0.000> f percentage <sil=0.000> c to
which <sil=0.000> is <sil=0.000> nothing <sil=0.000> but <sil=0.000> the <sil=0.000> control <sil=0.000> string <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> designating <sil=0.000> that <sil=0.000> and <sil=0.000> a <sil=0.354> ;SEMICOLON  a <sil=0.000> is <sil=0.000> a is <sil=0.000> an <sil=0.000> integer <sil=0.000> and
and <sil=0.000> a is <sil=0.000> a pointer <sil=0.000> to <sil=0.000> a <sil=2.000> .PERIOD  And <sil=0.000> average <sil=0.000> is <sil=0.000> a floating-point <sil=0.000> number <sil=2.000> .PERIOD  And <sil=0.000> and <sil=0.000> average <sil=0.000> is <sil=0.000> a
pointer <sil=0.000> to <sil=0.000> average <sil=2.000> .PERIOD  And <sil=0.000> type <sil=0.000> is <sil=0.000> a character <sil=0.000> type <sil=0.000> variable <sil=2.000> .PERIOD  And <sil=0.000> and <sil=0.000> type <sil=0.000> is <sil=1.000> ,COMMA  why <sil=0.000> is <sil=0.000> type <sil=0.000> a
character <sil=0.000> type <sil=0.000> variable <sil=0.228> ?QUESTIONMARK  Because <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> put <sil=0.000> in <sil=0.000> here <sil=0.000> and <sil=0.000> c since <sil=0.000> I have <sil=0.000> put <sil=0.000> in <sil=0.000> here <sil=0.000> and <sil=0.000> c
that <sil=0.000> tells <sil=0.000> me <sil=0.000> that <sil=0.000> this <sil=0.000> type <sil=0.000> is <sil=0.000> a character <sil=0.000> type <sil=0.000> variable <sil=0.000> and <sil=0.000> and <sil=0.000> type <sil=0.000> and <sil=0.000> type <sil=0.000> is <sil=0.000> a pointer
to <sil=0.000> the <sil=0.000> variable <sil=0.000> type <sil=2.000> .PERIOD 
The <sil=0.000> control <sil=0.000> string <sil=0.000> consists <sil=0.000> of <sil=0.000> individual <sil=0.000> groups <sil=0.000> of <sil=0.000> characters <sil=0.000> with <sil=0.000> one-character <sil=0.000> group
for <sil=0.000> each <sil=0.000> input <sil=0.000> data <sil=0.000> item <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> one-character <sil=0.000> group <sil=0.000> for <sil=0.000> this <sil=0.000> a type <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  percentage <sil=0.000> we
have <sil=0.000> seen <sil=0.000> that <sil=0.000> percentage <sil=0.000> sign <sil=0.000> means <sil=1.000> ,COMMA  is <sil=0.000> a conversion <sil=0.000> character <sil=2.000> .PERIOD 

The <sil=0.000> commonly <sil=0.000> used <sil=0.000> conversion <sil=0.000> characters <sil=0.000> we <sil=0.000> have <sil=0.000> already <sil=0.000> seen <sil=0.000> some <sil=0.000> of <sil=0.000> them <sil=1.000> ,COMMA  these <sil=0.000> are
known <sil=0.000> to <sil=0.000> us <sil=1.000> ,COMMA  percentage <sil=0.000> d is <sil=0.000> for <sil=0.000> decimal <sil=0.000> or <sil=0.000> integers <sil=1.000> ,COMMA  percentage <sil=0.000> f for <sil=0.000> floating <sil=0.000> point
numbers <sil=1.000> ,COMMA  percentage <sil=0.000> c for <sil=0.000> single <sil=0.000> character <sil=1.000> ,COMMA  percentage <sil=0.000> s is <sil=0.000> a string <sil=2.000> .PERIOD  Whenever <sil=1.000> ,COMMA  I <sil=0.000> am
reading <sil=0.000> something <sil=0.000> variable <sil=0.000> as <sil=0.000> a string <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> discussed <sil=0.000> that <sil=0.000> in <sil=0.000> that <sil=0.000> case <sil=1.000> ,COMMA  we <sil=0.000> are
reading <sil=0.000> the <sil=0.000> string <sil=0.000> using <sil=0.000> percentage <sil=0.000> s and <sil=0.000> that <sil=0.000> is <sil=0.000> a string <sil=0.000> is <sil=0.000> always <sil=0.000> terminated <sil=0.000> by <sil=0.000> null
character <sil=2.000> .PERIOD 
Similarly <sil=1.000> ,COMMA  percentage <sil=0.000> x denotes <sil=0.000> that <sil=1.000> ,COMMA  the <sil=0.000> number <sil=0.000> that <sil=0.000> I am <sil=0.000> reading <sil=0.000> is <sil=0.000> a hexadecimal
character <sil=2.000> .PERIOD  Hexadecimal <sil=0.000> means <sil=0.000> decimal <sil=0.000> is <sil=0.000> with <sil=0.000> a base <sil=0.000> ten <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  0 <sil=0.000> to <sil=0.000> 9 are <sil=0.000> my
elements <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  all <sil=0.000> the <sil=0.000> numbers <sil=0.000> I have <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> describing <sil=0.000> using <sil=0.000> 0 to <sil=0.000> 9 <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> my <sil=0.000> alphabet
set <sil=2.000> .PERIOD  Whereas <sil=1.000> ,COMMA  in <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> hexadecimal <sil=1.000> ,COMMA  the <sil=0.000> base <sil=0.000> is <sil=0.000> 16 <sil=0.000> and <sil=0.000> so <sil=1.000> ,COMMA  base <sil=0.000> being <sil=0.000> 16 <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got
0 <sil=0.000> 1 2 <sil=0.000> 3 4 <sil=0.000> 5 6 <sil=0.000> 7 8 <sil=0.000> 9 <sil=2.000> .PERIOD  These <sil=0.000> 10 <sil=0.000> numbers <sil=0.000> followed <sil=0.000> by <sil=0.000> A for <sil=0.000> 10 <sil=1.000> ,COMMA  B <sil=0.000> for <sil=0.000> 11 <sil=1.000> ,COMMA  C <sil=0.000> 12 <sil=1.000> ,COMMA  D <sil=0.000> 13 <sil=1.000> ,COMMA  E <sil=0.000> 14
and <sil=0.000> F 15 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  up <sil=0.000> to <sil=0.000> that <sil=1.000> ,COMMA  0 <sil=0.000> to <sil=0.000> 15 <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> have <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  in <sil=0.000> a 16 <sil=1.000> ,COMMA  when <sil=0.000> I work <sil=0.000> with <sil=0.000> a base <sil=0.000> 16 <sil=0.000> and <sil=0.000> that <sil=0.000> is
known <sil=0.000> as <sil=0.000> hexadecimal <sil=2.000> .PERIOD  Now <sil=0.000> so <sil=1.000> ,COMMA  so <sil=0.000> you <sil=0.000> can <sil=0.000> just <sil=0.000> establishing <sil=0.000> a similarity <sil=1.000> ,COMMA  analogy <sil=0.000> with
our <sil=0.000> binary <sil=0.000> numbers <sil=0.000> system <sil=0.000> that <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=1.000> ,COMMA  we <sil=0.000> can <sil=0.000> have <sil=1.000> ,COMMA  say <sil=1.000> ,COMMA  a <sil=0.000> number <sil=0.000> A B <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  A <sil=0.000> B is <sil=0.000> a string <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> position <sil=0.000> string <sil=0.000> position <sil=0.000> weights <sil=0.000> are <sil=1.000> ,COMMA  first <sil=0.000> position <sil=0.000> is <sil=0.000> 16 <sil=0.000> to
the <sil=0.000> power <sil=0.000> 0 <sil=1.000> ,COMMA  second <sil=0.000> position <sil=0.000> is <sil=0.000> 16 <sil=0.000> to <sil=0.000> the <sil=0.000> power <sil=0.000> 1 <sil=1.000> ,COMMA  third <sil=0.000> position <sil=0.000> is <sil=0.000> 16 <sil=0.000> to <sil=0.000> the <sil=0.000> power <sil=0.000> 2 <sil=1.000> ,COMMA  like
that <sil=2.000> .PERIOD  In <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> binary <sil=1.000> ,COMMA  we <sil=0.000> had <sil=0.000> the <sil=0.000> first <sil=0.000> position <sil=0.000> way <sil=1.000> ,COMMA  it <sil=0.000> was <sil=0.000> 2 to <sil=0.000> the <sil=0.000> power <sil=0.000> 0 <sil=1.000> ,COMMA  2 <sil=0.000> to <sil=0.000> the
power <sil=0.000> 1 <sil=1.000> ,COMMA  2 <sil=0.000> to <sil=0.000> the <sil=0.000> power <sil=0.000> 2 <sil=1.000> ,COMMA  like <sil=0.000> that <sil=0.000> right <sil=2.000> .PERIOD  Now <sil=0.000> and <sil=0.000> each <sil=0.000> of <sil=0.000> these <sil=0.000> positions <sil=0.000> can <sil=0.000> be <sil=0.000> filled
up <sil=0.000> in <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> binary <sil=0.000> by <sil=0.000> 0 and <sil=0.000> 1 <sil=1.000> ,COMMA  but <sil=0.000> here <sil=1.000> ,COMMA  in <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> hexadecimal <sil=1.000> ,COMMA  it <sil=0.000> can <sil=0.000> be <sil=0.000> filled
up <sil=0.000> with <sil=0.000> any <sil=0.000> of <sil=0.000> these <sil=0.000> 0 to <sil=0.000> a 0 <sil=0.000> to <sil=0.000> F <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  A <sil=0.000> B <sil=1.000> ,COMMA  when <sil=0.000> I say <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  B <sil=0.000> is <sil=0.000> what <sil=0.000> in <sil=0.000> decimal <sil=0.000> B is <sil=0.000> 11 <sil=0.000> 12 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  12 <sil=0.000> times <sil=0.000> what <sil=0.000> is
the <sil=0.000> weight <sil=0.000> of <sil=0.000> this <sil=0.000> position <sil=0.000> 16 <sil=0.000> to <sil=0.000> the <sil=0.000> power <sil=0.000> 0 plus <sil=0.000> A is <sil=0.000> 11 <sil=0.000> sorry <sil=1.000> ,COMMA  sorry <sil=1.000> ,COMMA  sorry <sil=1.000> ,COMMA  sorry <sil=1.000> ,COMMA  I <sil=0.000> am <sil=1.000> ,COMMA 
I <sil=0.000> am <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> sorry <sil=2.000> .PERIOD  this <sil=0.000> is <sil=0.000> 10 <sil=2.000> .PERIOD  10 <sil=0.000> to <sil=0.000> sorry <sil=0.000> let <sil=0.000> me <sil=0.000> correct <sil=0.000> that <sil=1.000> ,COMMA  A <sil=0.000> is <sil=0.000> 10 <sil=0.000> and <sil=0.000> B is <sil=0.000> 11 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> 11
into <sil=0.000> 16 <sil=0.000> to <sil=0.000> the <sil=0.000> power <sil=0.000> 0 and <sil=0.000> 10 <sil=0.000> times <sil=0.000> 16 <sil=0.000> to <sil=0.000> the <sil=0.000> power <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  how <sil=0.000> much <sil=0.000> is <sil=0.000> that <sil=0.000> coming <sil=0.000> to <sil=0.228> ?QUESTIONMARK 
160 <sil=0.000> plus <sil=0.000> 11 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> the <sil=0.000> number <sil=0.000> 171 <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  if <sil=0.000> I had <sil=0.000> to <sil=0.000> represent <sil=0.000> 171 <sil=0.000> in <sil=0.000> binary <sil=1.000> ,COMMA  I <sil=0.000> would
have <sil=0.000> required <sil=0.000> much <sil=0.000> more <sil=0.000> number <sil=0.000> of <sil=0.000> bits <sil=0.000> right <sil=2.000> .PERIOD 
And <sil=0.000> since <sil=0.000> it <sil=0.000> is <sil=0.000> hexadecimal <sil=1.000> ,COMMA  another <sil=0.000> so <sil=1.000> ,COMMA  here <sil=0.000> we <sil=0.000> using <sil=0.000> hexadecimal <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> being <sil=0.000> able <sil=0.000> to
do <sil=0.000> that <sil=0.000> using <sil=0.000> 2 hexadecimal <sil=0.000> bits <sil=1.000> ,COMMA  which <sil=0.000> we <sil=0.000> can <sil=0.000> call <sil=0.000> hex <sil=0.000> x <sil=1.000> ,COMMA  but <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> see <sil=0.000> A B <sil=2.000> .PERIOD 

A <sil=0.000> being <sil=0.000> 10 <sil=0.000> and <sil=0.000> B being <sil=0.000> 11 <sil=1.000> ,COMMA  in <sil=0.000> binary <sil=0.000> what <sil=0.000> would <sil=0.000> that <sil=0.000> be <sil=0.000> B is <sil=0.000> 11 <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  8 <sil=0.000> 2 1 <sil=1.000> ,COMMA  this
is <sil=0.000> 11 <sil=0.000> and <sil=0.000> 10 <sil=0.000> is <sil=0.000> 8 2 <sil=0.000> that <sil=0.000> is <sil=0.000> all <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> would <sil=0.000> have <sil=0.000> required <sil=0.000> 4 bits <sil=0.000> for <sil=0.000> representing <sil=0.000> 171 <sil=1.000> ,COMMA  which
I <sil=0.000> am <sil=0.000> representing <sil=0.000> using <sil=0.000> hex <sil=0.000> x alright <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> a hexadecimal <sil=0.000> integer <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> I if <sil=0.000> I print
something <sil=0.000> in <sil=0.000> hex <sil=0.000> in <sil=0.000> this <sil=0.000> in <sil=0.000> this <sil=0.000> format <sil=1.000> ,COMMA  then <sil=0.000> it <sil=0.000> would <sil=0.000> be <sil=0.000> printed <sil=0.000> like <sil=0.000> 171 <sil=0.000> will <sil=0.000> be <sil=0.000> printed
as <sil=0.000> A B <sil=2.000> .PERIOD  Otherwise <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=0.000> as <sil=0.000> in <sil=0.000> the <sil=0.000> binary <sil=0.000> number <sil=0.000> or <sil=0.000> in <sil=0.000> the <sil=0.000> decimal <sil=0.000> number <sil=2.000> .PERIOD  If
I <sil=0.000> do <sil=0.000> it <sil=0.000> with <sil=0.000> percentage <sil=0.000> d will <sil=0.000> be <sil=0.000> printed <sil=0.000> like <sil=0.000> this <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  it <sil=0.000> was <sil=0.000> a brief <sil=0.000> introduction <sil=0.000> to <sil=0.000> hexadecimal <sil=0.000> numbers <sil=1.000> ,COMMA  but <sil=0.000> that <sil=0.000> you <sil=0.000> can <sil=0.000> read <sil=0.000> up
yourself <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> proceed <sil=2.000> .PERIOD 

We <sil=0.000> can <sil=0.000> also <sil=0.000> specify <sil=0.000> the <sil=0.000> maximum <sil=0.000> field <sil=0.000> width <sil=0.000> of <sil=0.000> a data <sil=0.000> item <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> something <sil=0.000> I
had <sil=0.000> purposefully <sil=0.000> evaded <sil=0.000> till <sil=0.000> now <sil=1.000> ,COMMA  just <sil=0.000> to <sil=0.000> not <sil=0.000> to <sil=0.000> make <sil=0.000> the <sil=0.000> things <sil=0.000> complicated <sil=2.000> .PERIOD  I <sil=0.000> want <sil=0.000> that
you <sil=0.000> first <sil=0.000> get <sil=0.000> a custom <sil=0.000> to <sil=0.000> the <sil=0.000> normal <sil=0.000> features <sil=0.000> of <sil=0.000> c <sil=2.000> .PERIOD  But <sil=0.000> now <sil=1.000> ,COMMA  we <sil=0.000> are <sil=0.000> in <sil=0.000> a now <sil=1.000> ,COMMA  I <sil=0.000> think <sil=0.000> you
have <sil=0.000> you <sil=0.000> are <sil=0.000> in <sil=0.000> a position <sil=0.000> where <sil=0.000> you <sil=0.000> can <sil=0.000> write <sil=0.000> programs <sil=2.000> .PERIOD  Here <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> introducing <sil=0.000> the
notion <sil=0.000> of <sil=0.000> field <sil=0.000> width <sil=2.000> .PERIOD  A <sil=0.000> data <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=0.000> within <sil=0.000> a width <sil=1.000> ,COMMA  right <sil=0.228> ?QUESTIONMARK  So <sil=0.000> many <sil=0.000> positions <sil=0.000> will
be <sil=0.000> given <sil=0.000> to <sil=0.000> that <sil=0.000> number <sil=2.000> .PERIOD  data <sil=0.000> item <sil=0.000> the <sil=0.000> number <sil=0.000> indicating <sil=0.000> the <sil=0.000> field <sil=0.000> width <sil=0.000> before <sil=0.000> the
conversion <sil=0.000> character <sil=2.000> .PERIOD 
For <sil=0.000> example <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> make <sil=0.000> it <sil=0.000> clear <sil=2.000> .PERIOD  For <sil=0.000> example <sil=1.000> ,COMMA  percentage <sil=0.000> 3 d <sil=1.000> ,COMMA  percentage <sil=0.000> 5 d <sil=0.000> for <sil=0.000> A and
B <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  A <sil=0.000> will <sil=0.000> be <sil=0.000> expected <sil=0.000> to <sil=0.000> be <sil=0.000> of <sil=0.000> sorry <sil=0.354> ;SEMICOLON  A <sil=0.000> will <sil=0.000> be <sil=0.000> expected <sil=0.000> to <sil=0.000> be <sil=0.000> of <sil=0.000> 3 positions <sil=0.354> ;SEMICOLON 
say <sil=1.000> ,COMMA  percentage <sil=0.000> it <sil=0.000> is <sil=0.000> 3 d <sil=0.000> decimal <sil=0.000> 171 <sil=0.000> whereas <sil=1.000> ,COMMA  B <sil=0.000> will <sil=0.000> be <sil=0.000> 5 d <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  there <sil=0.000> will <sil=0.000> be <sil=0.000> 5 positions
for <sil=0.000> this <sil=0.000> 1 2 <sil=0.000> 3 4 <sil=0.000> 5 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  may <sil=0.000> be <sil=0.000> 52732 <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  if <sil=0.000> I want <sil=0.000> to <sil=0.000> print <sil=0.000> 171 <sil=0.000> or <sil=0.000> read <sil=0.000> 171 <sil=0.000> using <sil=0.000> the
format <sil=0.000> 5 d <sil=1.000> ,COMMA  then <sil=0.000> what <sil=0.000> should <sil=0.000> I print <sil=0.228> ?QUESTIONMARK  I <sil=0.000> should <sil=0.000> print <sil=0.000> a sorry <sil=0.000> I should <sil=0.000> provide <sil=0.000> the <sil=0.000> data <sil=0.000> for
the <sil=0.000> 5 fields <sil=2.000> .PERIOD  I <sil=0.000> should <sil=0.000> put <sil=0.000> it <sil=0.000> blank <sil=1.000> ,COMMA  blank <sil=0.000> or <sil=0.000> 0 0 <sil=0.000> then <sil=0.000> 171 <sil=0.000> assuming <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> right <sil=0.000> justify
alright <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> the <sil=0.000> width <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> the <sil=0.000> width <sil=0.000> that <sil=0.000> we <sil=0.000> are <sil=0.000> talking <sil=0.000> about <sil=2.000> .PERIOD  We <sil=0.000> can <sil=0.000> specify <sil=0.000> how
many <sil=0.000> what <sil=0.000> is <sil=0.000> the <sil=0.000> when <sil=0.000> I am <sil=0.000> reading <sil=0.000> what <sil=0.000> is <sil=0.000> the <sil=0.000> format <sil=0.000> of <sil=0.000> the <sil=0.000> data <sil=0.228> ?QUESTIONMARK  How <sil=0.000> many <sil=0.000> widths <sil=1.000> ,COMMA 
how <sil=0.000> many <sil=0.000> positions <sil=0.000> it <sil=0.000> is <sil=0.000> taking <sil=0.000> for <sil=0.000> as <sil=0.000> the <sil=0.000> data <sil=1.000> ,COMMA  right <sil=0.228> ?QUESTIONMARK 

So <sil=1.000> ,COMMA  say <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  if <sil=0.000> I have <sil=2.000> .PERIOD <sil=0.000> 171 <sil=0.000> 5 3 <sil=0.000> 2 then <sil=0.000> 7 <sil=1.000> ,COMMA  then <sil=1.000> ,COMMA  if <sil=0.000> I read <sil=0.000> it <sil=1.000> ,COMMA  the <sil=0.000> first <sil=0.000> data <sil=0.000> if <sil=0.000> field <sil=0.000> is
feed <sil=0.000> is <sil=0.000> this <sil=1.000> ,COMMA  I <sil=0.000> type <sil=0.000> to <sil=0.000> the <sil=0.000> keyboard <sil=0.000> and <sil=0.000> if <sil=0.000> it <sil=0.000> is <sil=0.000> in <sil=0.000> percentage <sil=0.000> 3 d <sil=0.000> it <sil=0.000> will <sil=0.000> be <sil=0.000> fine <sil=0.000> ok <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I
will <sil=0.000> read <sil=0.000> that <sil=2.000> .PERIOD 

Again <sil=1.000> ,COMMA  now <sil=0.000> coming <sil=0.000> to <sil=0.000> writing <sil=0.000> now <sil=1.000> ,COMMA  this <sil=0.000> printf <sil=0.000> is <sil=0.000> also <sil=0.000> a system <sil=0.000> function <sil=2.000> .PERIOD  Just <sil=0.000> like <sil=0.000> scanf
printf <sil=0.000> is <sil=0.000> also <sil=0.000> a system <sil=0.000> function <sil=0.000> and <sil=0.000> here <sil=0.000> also <sil=1.000> ,COMMA  since <sil=0.000> you <sil=0.000> know <sil=0.000> already <sil=1.000> ,COMMA  how <sil=0.000> do <sil=0.000> you <sil=0.000> write
printf <sil=0.228> ?QUESTIONMARK  I <sil=0.000> write <sil=0.000> printf <sil=0.000> using <sil=0.000> a control <sil=0.000> string <sil=0.000> within <sil=0.000> the <sil=0.000> double <sil=0.000> code <sil=0.000> and <sil=0.000> then <sil=0.000> followed <sil=0.000> by

this <sil=0.000> number <sil=0.000> of <sil=0.000> arguments <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> same <sil=0.000> thing <sil=0.000> will <sil=0.000> hold <sil=0.000> here <sil=2.000> .PERIOD  Control <sil=0.000> string <sil=0.000> refers <sil=0.000> to <sil=0.000> the
string <sil=0.000> containing <sil=0.000> formatting <sil=0.000> information <sil=0.000> and <sil=0.000> data <sil=0.000> types <sil=0.000> of <sil=0.000> the <sil=0.000> arguments <sil=0.000> to <sil=0.000> be <sil=0.000> output  <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  here <sil=0.000> while <sil=0.000> printing <sil=0.000> the <sil=0.000> arg <sil=0.000> 1 arg <sil=0.000> 2 <sil=1.000> ,COMMA  these <sil=0.000> are <sil=0.000> the <sil=0.000> representing <sil=0.000> the <sil=0.000> individual <sil=0.000> data
items <sil=2.000> .PERIOD  In <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> scanf <sil=1.000> ,COMMA  they <sil=0.000> were <sil=0.000> pointers <sil=0.000> to <sil=0.000> the <sil=0.000> data <sil=0.000> items <sil=2.000> .PERIOD  Here <sil=1.000> ,COMMA  they <sil=0.000> are <sil=0.000> individual
data <sil=0.000> items <sil=0.000> that <sil=0.000> I have <sil=0.000> told <sil=0.000> you <sil=0.000> earlier <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> why <sil=1.000> ,COMMA  we <sil=0.000> use <sil=0.000> ampersand <sil=0.000> a ampersand <sil=0.000> b in
the <sil=0.000> case <sil=0.000> of <sil=0.000> scanf <sil=2.000> .PERIOD  But <sil=0.000> in <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> printf <sil=1.000> ,COMMA  we <sil=0.000> just <sil=0.000> write <sil=0.000> a b <sil=1.000> ,COMMA  ok <sil=2.000> .PERIOD  Because <sil=1.000> ,COMMA  this <sil=0.000> a b <sil=0.000> are
directly <sil=0.000> referring <sil=0.000> to <sil=0.000> the <sil=0.000> variables <sil=0.000> the <sil=0.000> data <sil=0.000> items <sil=2.000> .PERIOD  The <sil=0.000> conversion <sil=0.000> characters <sil=0.000> are <sil=0.000> the <sil=0.000> same
as <sil=0.000> scanf <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> some <sil=0.000> examples <sil=2.000> .PERIOD  Printf <sil=0.000> the <sil=0.000> average <sil=0.000> of <sil=0.000> a and <sil=0.000> b is <sil=0.000> avg <sil=0.000> and <sil=0.000> that <sil=0.000> avg <sil=0.000> is
percentage <sil=0.000> f <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> see <sil=0.000> that <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  avg <sil=0.000> is <sil=0.000> a float <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  I <sil=0.000> could <sil=0.000> have <sil=0.000> also <sil=0.000> done <sil=0.000> this <sil=0.000> that <sil=1.000> ,COMMA  so <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> nothing <sil=0.000> but <sil=1.000> ,COMMA  there <sil=0.000> is <sil=0.000> a control <sil=0.000> string  <sil=1.000> ,COMMA 
here <sil=0.000> you <sil=0.000> see <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> said <sil=0.000> that <sil=0.000> 3 d <sil=0.000> 3 d <sil=0.000> 5 d <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  a <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  when <sil=0.000> do <sil=0.000> you <sil=0.000> printed <sil=0.000> a
will <sil=0.000> be <sil=0.000> printed <sil=1.000> ,COMMA  there <sil=0.000> is <sil=0.000> no <sil=0.000> new <sil=0.000> line <sil=0.000> here <sil=0.000> you <sil=0.000> can <sil=0.000> see <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  a <sil=0.000> b and <sil=0.000> a times <sil=0.000> b plus <sil=0.000> 2 will <sil=0.000> be <sil=0.000> printed <sil=0.000> side <sil=0.000> by <sil=0.000> side <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  a <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=0.000> on <sil=0.000> 3 fields
like <sil=1.000> ,COMMA  say <sil=0.000> 171 <sil=1.000> ,COMMA  b <sil=0.000> b will <sil=0.000> be <sil=0.000> printed <sil=0.000> on <sil=0.000> 3 next <sil=0.000> 3 there <sil=0.000> is <sil=0.000> no <sil=0.000> space <sil=0.000> given <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> will <sil=0.000> be <sil=0.000> b 6 <sil=0.000> 3
2 <sil=0.000> and <sil=0.000> the <sil=0.000> expression <sil=2.000> .PERIOD  Here <sil=0.000> a times <sil=0.000> b plus <sil=0.000> 2 will <sil=0.000> have <sil=0.000> have <sil=0.000> 5 spaces <sil=0.000> 5 positions <sil=0.000> given
now <sil=0.354> ;SEMICOLON  obviously <sil=1.000> ,COMMA  if <sil=0.000> my <sil=0.000> data <sil=0.000> for <sil=0.000> result <sil=0.000> for <sil=0.000> a was <sil=0.000> 1712 <sil=1.000> ,COMMA  then <sil=0.000> only <sil=0.000> this <sil=0.000> much <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=2.000> .PERIOD 
Then <sil=0.000> the <sil=0.000> rest <sil=0.000> will <sil=0.000> be <sil=0.000> left <sil=0.000> out <sil=1.000> ,COMMA  ok <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> you <sil=0.000> see <sil=0.000> for <sil=0.000> the <sil=0.000> percentage <sil=0.000> f <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  for <sil=0.000> this <sil=1.000> ,COMMA  I <sil=0.000> think <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> very <sil=0.000> difficult <sil=0.000> to <sil=0.000> understand <sil=2.000> .PERIOD  You <sil=0.000> can <sil=0.000> read <sil=0.000> them <sil=0.000> in <sil=0.000> the <sil=0.000> any
textbook <sil=2.000> .PERIOD  It <sil=0.000> is <sil=0.000> clearly <sil=0.000> discussed <sil=0.000> in <sil=0.000> most <sil=0.000> of <sil=0.000> the <sil=0.000> textbooks <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> recommend <sil=0.000> you <sil=0.000> to <sil=0.000> go
through <sil=0.000> these <sil=0.000> formats <sil=0.000> and <sil=0.000> as <sil=0.000> you <sil=0.000> practice <sil=1.000> ,COMMA  you <sil=0.000> will <sil=0.000> keep <sil=0.000> that <sil=0.000> in <sil=0.000> mind <sil=1.000> ,COMMA  but <sil=0.000> just <sil=0.000> to <sil=0.000> tell <sil=0.000> you
this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  floating <sil=0.000> point <sil=0.000> number <sil=0.000> will <sil=0.000> have <sil=0.000> 2 parts <sil=1.000> ,COMMA  right <sil=0.228> ?QUESTIONMARK  One <sil=0.000> is <sil=0.000> the <sil=0.000> integer <sil=0.000> part <sil=0.000> and <sil=0.000> the
other <sil=0.000> is <sil=0.000> a decimal <sil=0.000> part <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  suppose <sil=0.000> here <sil=1.000> ,COMMA  when <sil=0.000> I say <sil=0.000> 7 <sil=2.000> .PERIOD <sil=0.000> 2 f <sil=0.000> x is <sil=0.000> a floating-point <sil=0.000> number <sil=1.000> ,COMMA 
which <sil=0.000> is <sil=0.000> being <sil=0.000> printed <sil=0.000> in <sil=0.000> the <sil=0.000> formats <sil=0.000> 7 <sil=2.000> .PERIOD <sil=0.000> 2 f <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> entire <sil=0.000> width <sil=0.000> is <sil=0.000> 7 positions <sil=0.000> and <sil=0.000> the <sil=0.000> 2
positions <sil=0.000> here <sil=0.000> are <sil=0.000> kept <sil=0.000> for <sil=0.000> the <sil=0.000> decimal <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  these <sil=0.000> 2 are <sil=0.000> kept <sil=0.000> for <sil=0.000> the <sil=0.000> decimal <sil=0.000> and <sil=0.000> we
imagine <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> have <sil=0.000> a decimal <sil=0.000> point <sil=0.000> here <sil=0.000> and <sil=0.000> the <sil=0.000> rest <sil=0.000> 5 will <sil=0.000> be <sil=0.000> 5 will <sil=0.000> be <sil=0.000> for <sil=0.000> the <sil=0.000> integer
part <sil=2.000> .PERIOD 
For <sil=0.000> y what <sil=0.000> will <sil=0.000> happen <sil=0.228> ?QUESTIONMARK  For <sil=0.000> y the <sil=0.000> total <sil=0.000> field <sil=0.000> is <sil=0.000> 5 <sil=1.000> ,COMMA  out <sil=0.000> of <sil=0.000> which <sil=1.000> ,COMMA  so <sil=0.000> total <sil=0.000> field <sil=0.000> is <sil=0.000> 5 out <sil=0.000> of
which <sil=0.000> only <sil=0.000> 1 position <sil=0.000> is <sil=0.000> kept <sil=0.000> after <sil=0.000> the <sil=0.000> fraction <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=1.000> ,COMMA  I <sil=0.000> assume <sil=0.000> the <sil=0.000> this <sil=0.000> point <sil=2.000> .PERIOD 
And <sil=0.000> so <sil=1.000> ,COMMA  there <sil=0.000> are <sil=0.000> 4 positions <sil=0.000> to <sil=0.000> represent <sil=0.000> an <sil=0.000> integer <sil=0.000> and <sil=0.000> one <sil=0.000> position <sil=0.000> to <sil=0.000> deserve <sil=0.000> represent
a <sil=0.000> fraction <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> my <sil=0.000> result <sil=0.000> was <sil=0.000> 101 <sil=2.000> .PERIOD <sil=0.000> 52 <sil=0.000> in <sil=0.000> this <sil=0.000> format <sil=1.000> ,COMMA  if <sil=0.000> I print <sil=0.000> that <sil=1.000> ,COMMA  then <sil=0.000> I will <sil=0.000> get <sil=0.000> 0101
or <sil=0.000> this <sil=0.000> 0 can <sil=0.000> be <sil=0.000> may <sil=0.000> not <sil=0.000> be <sil=0.000> printed <sil=2.000> .PERIOD 

Many <sil=0.000> more <sil=0.000> options <sil=0.000> are <sil=0.000> available <sil=2.000> .PERIOD  You <sil=0.000> can <sil=0.000> read <sil=0.000> from <sil=0.000> the <sil=0.000> book <sil=0.000> and <sil=0.000> we <sil=0.000> will <sil=0.000> do <sil=0.000> this <sil=0.000> later <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  coming <sil=0.000> to <sil=0.000> a very <sil=0.000> important <sil=0.000> concept <sil=0.000> ah <sil=1.000> ,COMMA  that <sil=0.000> is <sil=1.000> ,COMMA  function <sil=0.000> prototypes <sil=2.000> .PERIOD  This <sil=0.000> is
possibly <sil=0.000> new <sil=0.000> name <sil=0.000> that <sil=0.000> you <sil=0.000> are <sil=0.000> getting <sil=2.000> .PERIOD  What <sil=0.000> are <sil=0.000> these <sil=0.000> prototypes <sil=0.228> ?QUESTIONMARK  Now <sil=1.000> ,COMMA  we <sil=0.000> are <sil=0.000> going
to <sil=0.000> write <sil=0.000> functions <sil=0.000> and <sil=0.000> those <sil=0.000> functions <sil=1.000> ,COMMA  one <sil=0.000> of <sil=0.000> the <sil=0.000> functions <sil=0.000> which <sil=0.000> must <sil=0.000> be <sil=0.000> there <sil=0.000> is <sil=0.000> the
main <sil=0.000> function <sil=1.000> ,COMMA  right <sil=0.228> ?QUESTIONMARK  Typically <sil=1.000> ,COMMA  people <sil=0.000> write <sil=0.000> first <sil=0.000> the <sil=0.000> main <sil=0.000> function <sil=0.000> and <sil=0.000> then <sil=0.000> the <sil=0.000> first <sil=0.000> the
functions <sil=0.000> and <sil=0.000> then <sil=0.000> the <sil=0.000> main <sil=0.000> function <sil=1.000> ,COMMA  but <sil=0.000> you <sil=0.000> are <sil=0.000> free <sil=0.000> not <sil=0.000> to <sil=0.000> do <sil=0.000> that <sil=0.000> also <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  usually <sil=0.000> a
function <sil=0.000> is <sil=0.000> defined <sil=0.000> before <sil=0.000> it <sil=0.000> is <sil=0.000> called <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  typically <sil=1.000> ,COMMA  what <sil=0.000> we <sil=0.000> do <sil=0.000> is <sil=1.000> ,COMMA  when <sil=0.000> our <sil=0.000> main <sil=0.000> our

programs <sil=0.000> starts <sil=1.000> ,COMMA  so <sil=1.000> ,COMMA  we <sil=0.000> start <sil=0.000> the <sil=0.000> program <sil=0.000> starts <sil=0.000> from <sil=0.000> here <sil=1.000> ,COMMA  we <sil=0.000> define <sil=0.000> of <sil=0.000> we <sil=0.000> write <sil=0.000> a
function <sil=0.000> with <sil=0.000> some <sil=0.000> parameters <sil=0.000> here <sil=0.000> and <sil=0.000> the <sil=0.000> body <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=0.000> is <sil=0.000> here <sil=1.000> ,COMMA  then <sil=1.000> ,COMMA  we <sil=0.000> write <sil=1.000> ,COMMA 
say <sil=1.000> ,COMMA  main <sil=2.000> .PERIOD  And <sil=0.000> inside <sil=0.000> main <sil=1.000> ,COMMA  I <sil=0.000> call <sil=0.000> f 1 <sil=0.000> this <sil=0.000> assigned <sil=0.000> to <sil=0.000> some <sil=0.000> variable <sil=0.000> x like <sil=0.000> that <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is
the <sil=0.000> typically <sil=0.000> some <sil=0.000> what <sil=0.000> we <sil=0.000> do <sil=0.000> alright <sil=2.000> .PERIOD  After <sil=0.000> I did <sil=1.000> ,COMMA  this <sil=0.000> include <sil=0.000> s t <sil=0.000> d I <sil=0.000> o dot <sil=0.000> h <sil=2.000> .PERIOD  I <sil=0.000> started
with <sil=0.000> the <sil=0.000> function <sil=0.000> first <sil=0.354> ;SEMICOLON  that <sil=0.000> is <sil=1.000> ,COMMA  one <sil=0.000> option <sil=0.000> now <sil=1.000> ,COMMA  but <sil=0.000> always <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> not <sil=0.000> done <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  main <sil=0.000> in <sil=0.000> that <sil=0.000> case <sil=1.000> ,COMMA  if <sil=0.000> I define <sil=0.000> the <sil=0.000> functions <sil=0.000> first <sil=0.000> the <sil=0.000> functions <sil=1.000> ,COMMA  that <sil=0.000> I am <sil=0.000> going <sil=0.000> to <sil=0.000> use <sil=1.000> ,COMMA  I
have <sil=0.000> thought <sil=0.000> about <sil=0.000> that <sil=0.000> I have <sil=0.000> designed <sil=0.000> them <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  first <sil=0.000> I write <sil=0.000> those <sil=0.000> functions <sil=0.000> and <sil=0.000> after
that <sil=1.000> ,COMMA  I <sil=0.000> write <sil=0.000> the <sil=0.000> main <sil=0.000> function <sil=2.000> .PERIOD  In <sil=0.000> that <sil=0.000> case <sil=1.000> ,COMMA  the <sil=0.000> main <sil=0.000> is <sil=0.000> the <sil=0.000> last <sil=0.000> function <sil=0.000> in <sil=0.000> the <sil=0.000> program <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> case <sil=1.000> ,COMMA  the <sil=0.000> compiler <sil=1.000> ,COMMA  so <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> my <sil=0.000> program <sil=0.000> here <sil=1.000> ,COMMA  entire <sil=0.000> program <sil=0.000> here <sil=2.000> .PERIOD  And <sil=0.000> I
have <sil=0.000> defined <sil=0.000> the <sil=0.000> function <sil=0.000> f 1 <sil=0.000> here <sil=2.000> .PERIOD  I <sil=0.000> have <sil=0.000> defined <sil=0.000> function <sil=0.000> f 2 <sil=0.000> here <sil=2.000> .PERIOD  And <sil=0.000> when <sil=0.000> I write
main <sil=0.000> here <sil=0.000> and <sil=0.000> in <sil=0.000> main <sil=1.000> ,COMMA  I <sil=0.000> refer <sil=0.000> to <sil=0.000> f 1 <sil=0.000> f 2 <sil=0.000> whichever <sil=0.000> whenever <sil=0.000> is <sil=0.000> this <sil=0.000> required <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> the <sil=0.000> compiler <sil=0.000> think <sil=0.000> of <sil=0.000> yourself <sil=0.000> to <sil=0.000> be <sil=0.000> the <sil=0.000> compiler <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  if <sil=0.000> you <sil=0.000> had
started <sil=0.000> compiling <sil=0.000> the <sil=0.000> main <sil=0.000> first <sil=0.000> and <sil=0.000> you <sil=0.000> would <sil=0.000> have <sil=0.000> come <sil=0.000> to <sil=0.000> f and <sil=0.000> f 2 <sil=1.000> ,COMMA  then <sil=0.000> you <sil=0.000> would
wonder <sil=0.000> what <sil=0.000> is <sil=0.000> that <sil=0.000> f 1 <sil=0.000> and <sil=0.000> f 2 <sil=2.000> .PERIOD  No <sil=0.000> variables <sil=0.000> are <sil=0.000> defined <sil=0.000> right <sil=0.228> ?QUESTIONMARK  You <sil=0.000> would <sil=0.000> have <sil=0.000> taken
just <sil=0.000> like <sil=1.000> ,COMMA  if <sil=0.000> you <sil=0.000> had <sil=0.000> written <sil=0.000> x in <sil=0.000> the <sil=0.000> main <sil=1.000> ,COMMA  some <sil=0.000> function <sil=0.000> f 1 <sil=0.000> some <sil=0.000> function <sil=0.000> like <sil=0.000> f 1 <sil=0.000> a b
right <sil=2.000> .PERIOD  Then <sil=1.000> ,COMMA  this <sil=0.000> f 1 <sil=0.000> is <sil=0.000> not <sil=0.000> recognised <sil=0.354> ;SEMICOLON  I <sil=0.000> mean <sil=0.000> you <sil=0.000> do <sil=0.000> not <sil=0.000> know <sil=0.000> about <sil=0.000> that <sil=0.000> here <sil=1.000> ,COMMA  but <sil=0.000> if <sil=0.000> you
write <sil=0.000> it <sil=0.000> before <sil=1.000> ,COMMA  the <sil=0.000> compiler <sil=0.000> will <sil=0.000> actually <sil=0.000> start <sil=0.000> looking <sil=0.000> from <sil=0.000> the <sil=0.000> beginning <sil=0.000> of <sil=0.000> the <sil=0.000> page <sil=1.000> ,COMMA 
beginning <sil=0.000> of <sil=0.000> the <sil=0.000> program <sil=2.000> .PERIOD  You <sil=0.000> will <sil=0.000> understand <sil=1.000> ,COMMA  a <sil=0.000> function <sil=0.000> has <sil=0.000> been <sil=0.000> defined <sil=0.000> here <sil=1.000> ,COMMA  I
understand <sil=0.000> that <sil=0.000> function <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> know <sil=0.000> that <sil=0.000> and <sil=0.000> the <sil=0.000> I know <sil=0.000> what <sil=0.000> this <sil=0.000> function <sil=0.000> does <sil=0.000> it

compiles <sil=0.000> that <sil=0.000> and <sil=0.000> f 2 <sil=0.000> also <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  when <sil=0.000> it <sil=0.000> comes <sil=0.000> to <sil=0.000> in <sil=0.000> this <sil=0.000> reduction <sil=1.000> ,COMMA  when <sil=0.000> it <sil=0.000> comes <sil=0.000> to <sil=0.000> the
main <sil=0.000> and <sil=0.000> finds <sil=0.000> f 1 <sil=0.000> and <sil=0.000> f 2 <sil=1.000> ,COMMA  it <sil=0.000> already <sil=0.000> knows <sil=0.000> that <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  there <sil=0.000> is <sil=0.000> no <sil=0.000> problem <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  easy <sil=0.000> for <sil=0.000> the
compiler <sil=0.000> to <sil=0.000> identify <sil=0.000> the <sil=0.000> functions <sil=1.000> ,COMMA  when <sil=0.000> it <sil=0.000> scans <sil=0.000> through <sil=0.000> the <sil=0.000> file <sil=0.000> this <sil=0.000> a file <sil=0.000> right <sil=1.000> ,COMMA  the
whole <sil=0.000> thing <sil=0.000> is <sil=0.000> a file

However <sil=1.000> ,COMMA  always <sil=0.000> that <sil=0.000> is <sil=0.000> not <sil=0.000> done <sil=0.000> many <sil=0.000> programmers <sil=0.000> prefer <sil=0.000> a top <sil=0.000> down <sil=0.000> approach <sil=1.000> ,COMMA  where
I <sil=0.000> will <sil=0.000> first <sil=0.000> define <sil=0.000> main <sil=0.000> and <sil=0.000> then <sil=0.000> I will <sil=0.000> put <sil=0.000> the <sil=0.000> functions <sil=1.000> ,COMMA  but <sil=0.000> then <sil=0.000> what <sil=0.000> will <sil=0.000> happen <sil=0.000> to <sil=0.000> the
compiler <sil=0.228> ?QUESTIONMARK  The <sil=0.000> compiler <sil=0.000> if <sil=0.000> it <sil=0.000> starts <sil=0.000> with <sil=0.000> main <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> starting <sil=0.000> from <sil=0.000> the <sil=0.000> beginning <sil=0.000> and <sil=0.000> if <sil=0.000> it
encounters <sil=0.000> f 1 <sil=0.000> or <sil=0.000> f 2 <sil=0.000> in <sil=0.000> the <sil=0.000> body <sil=0.000> of <sil=0.000> the <sil=0.000> main <sil=0.000> function <sil=1.000> ,COMMA  then <sil=0.000> it <sil=0.000> will <sil=0.000> get <sil=0.000> confused <sil=0.000> what <sil=0.000> is <sil=0.000> it
just <sil=0.000> like <sil=1.000> ,COMMA  if <sil=0.000> I had <sil=0.000> got <sil=0.000> a variable <sil=0.000> x being <sil=0.000> used <sil=0.000> and <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> defined <sil=0.000> there <sil=0.000> been <sil=0.000> error
because <sil=1.000> ,COMMA  I <sil=0.000> do <sil=0.000> not <sil=0.000> know <sil=0.000> what <sil=0.000> this <sil=0.000> x is <sil=1.000> ,COMMA  what <sil=0.000> type <sil=0.000> it <sil=0.000> is <sil=0.000> right <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> to <sil=0.000> declare <sil=0.000> that
before <sil=0.000> there <sil=2.000> .PERIOD  Similarly <sil=1.000> ,COMMA  for <sil=0.000> functions <sil=0.000> there <sil=0.000> must <sil=0.000> be <sil=0.000> some <sil=0.000> way <sil=0.000> to <sil=0.000> tell <sil=0.000> the <sil=0.000> compiler <sil=0.000> that <sil=0.000> is
the <sil=0.000> function <sil=0.000> and <sil=0.000> for <sil=0.000> that <sil=0.000> function <sil=0.000> prototypes <sil=0.000> are <sil=0.000> used <sil=0.000> function <sil=0.000> prototypes <sil=0.000> are <sil=0.000> used <sil=2.000> .PERIOD 

Let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=0.000> needed <sil=0.000> we <sil=0.000> the <sil=0.000> function <sil=0.000> comes <sil=0.000> later <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  function <sil=0.000> prototypes <sil=0.000> let <sil=0.000> us
look <sil=0.000> at  <sil=2.000> .PERIOD  Are <sil=0.000> usually <sil=0.000> written <sil=0.000> at <sil=0.000> the <sil=0.000> beginning <sil=0.000> of <sil=0.000> the <sil=0.000> program <sil=0.000> ahead <sil=0.000> of <sil=0.000> any <sil=0.000> other <sil=0.000> functions
including <sil=0.000> main <sil=1.000> ,COMMA  say <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> a prototype <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> a prototype <sil=1.000> ,COMMA  int <sil=0.000> g c <sil=0.000> d int <sil=0.000> a int
b <sil=0.000> ok <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  a <sil=0.000> and <sil=0.000> b are <sil=0.000> the <sil=0.000> parameters <sil=0.000> and <sil=0.000> g c <sil=0.000> d is <sil=0.000> a function <sil=0.000> of <sil=0.000> return <sil=0.000> type <sil=0.000> int <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> know
just <sil=0.000> by <sil=0.000> this <sil=0.000> prototype <sil=0.000> by <sil=0.000> this <sil=1.000> ,COMMA  I <sil=0.000> know <sil=0.000> the <sil=0.000> basic <sil=0.000> whatever <sil=0.000> is <sil=0.000> a body <sil=0.000> whatever <sil=0.000> is <sil=0.000> a body <sil=0.000> of
g <sil=0.000> c d <sil=1.000> ,COMMA  I <sil=0.000> know <sil=0.000> it <sil=0.000> is <sil=0.000> interface <sil=1.000> ,COMMA  I <sil=0.000> know <sil=0.000> it <sil=0.000> is <sil=0.000> input <sil=0.000> output <sil=2.000> .PERIOD  What <sil=0.000> is <sil=0.000> it <sil=0.000> is <sil=0.000> input <sil=0.000> output <sil=0.228> ?QUESTIONMARK  There
will <sil=0.000> be <sil=0.000> some <sil=0.000> a coming <sil=0.000> some <sil=0.000> parameter <sil=2.000> .PERIOD 
There <sil=0.000> are <sil=0.000> 2 parameters <sil=0.000> internally <sil=1.000> ,COMMA  they <sil=0.000> are <sil=0.000> named <sil=0.000> as <sil=0.000> a and <sil=0.000> b <sil=2.000> .PERIOD  I <sil=0.000> also <sil=0.000> know <sil=0.000> that <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> an
integer <sil=0.000> and <sil=0.000> this <sil=0.000> is <sil=0.000> also <sil=0.000> is <sil=0.000> integer <sil=0.000> and <sil=0.000> I know <sil=0.000> that <sil=0.000> it <sil=0.000> is <sil=0.000> name <sil=0.000> is <sil=0.000> g c <sil=0.000> d and <sil=0.000> I also <sil=0.000> know <sil=0.000> that <sil=1.000> ,COMMA 
it <sil=0.000> is <sil=0.000> output <sil=0.000> is <sil=0.000> an <sil=0.000> integer <sil=2.000> .PERIOD  Whatever <sil=0.000> is <sil=0.000> in <sil=0.000> between <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> not <sil=0.000> bothered <sil=0.000> about <sil=0.000> right <sil=0.000> now <sil=0.000> this
much <sil=0.000> I know <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> expect <sil=0.000> whenever <sil=0.000> g c <sil=0.000> d will <sil=0.000> come <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> allocate <sil=0.000> 2 integers <sil=0.000> space
for <sil=0.000> that <sil=0.000> and <sil=0.000> one <sil=0.000> return <sil=0.000> facility <sil=0.000> should <sil=0.000> be <sil=0.000> there <sil=2.000> .PERIOD 
Similarly <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> the <sil=0.000> second <sil=0.000> one <sil=0.000> div <sil=0.000> 7 int <sil=0.000> number <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  the <sil=0.000> prototype <sil=0.000> tells <sil=0.000> that <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> a function <sil=2.000> .PERIOD  It <sil=0.000> is <sil=0.000> name <sil=0.000> is <sil=0.000> div <sil=0.000> 7 <sil=2.000> .PERIOD  You <sil=0.000> can <sil=0.000> guess <sil=0.000> div <sil=0.000> 7
means <sil=1.000> ,COMMA  is <sil=0.000> testing <sil=0.000> the <sil=0.000> divisibility <sil=0.000> by <sil=0.000> 7 and <sil=0.000> there <sil=0.000> is <sil=0.000> one <sil=0.000> integer <sil=0.000> that <sil=0.000> is <sil=0.000> being <sil=0.000> fed <sil=0.000> and <sil=0.000> that
integers <sil=0.000> name <sil=0.000> is <sil=0.000> number <sil=0.000> and <sil=0.000> void <sil=0.000> is <sil=0.000> a type <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> not <sil=0.000> returning <sil=0.000> anything <sil=2.000> .PERIOD  May
be <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> printing <sil=0.000> something <sil=0.000> from <sil=0.000> here <sil=1.000> ,COMMA  it <sil=0.000> just <sil=0.000> checks <sil=0.000> takes <sil=0.000> a number <sil=0.354> ;SEMICOLON  it <sil=0.000> sees <sil=0.000> whether <sil=0.000> it <sil=0.000> is
divisible <sil=0.000> by <sil=0.000> 7 and <sil=0.000> prints <sil=0.000> it <sil=0.000> here <sil=0.000> divisible <sil=0.000> by <sil=0.000> 7 <sil=1.000> ,COMMA  not <sil=0.000> divisible <sil=0.000> by <sil=0.000> 7 <sil=1.000> ,COMMA  whatever <sil=0.000> you <sil=0.000> know <sil=2.000> .PERIOD 
How <sil=0.000> to <sil=0.000> find <sil=0.000> divisibility <sil=0.000> by <sil=0.000> 7 <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  you <sil=0.000> take <sil=0.000> the <sil=0.000> number <sil=0.000> and <sil=0.000> find <sil=0.000> the <sil=0.000> mod <sil=0.000> of <sil=0.000> that <sil=0.000> with <sil=0.000> 7
and <sil=0.000> if <sil=0.000> this <sil=0.000> is <sil=0.000> equal <sil=0.000> to <sil=0.000> 0 <sil=1.000> ,COMMA  then <sil=0.000> divisible <sil=0.000> by <sil=0.000> 7 <sil=1.000> ,COMMA  otherwise <sil=0.000> not <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> in <sil=0.000> the <sil=0.000> body <sil=0.000> of <sil=0.000> the
function <sil=0.000> and <sil=0.000> here <sil=1.000> ,COMMA  we <sil=0.000> just <sil=0.000> do <sil=0.000> the <sil=0.000> printing <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> not <sil=0.000> returning <sil=0.000> anything <sil=0.000> to <sil=0.000> the <sil=0.000> calling
function <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> why <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> void <sil=2.000> .PERIOD  Void <sil=0.000> is <sil=0.000> a valid <sil=0.000> type <sil=2.000> .PERIOD 

Note <sil=0.000> the <sil=0.000> semicolon <sil=0.000> now <sil=0.000> here <sil=0.000> this <sil=0.000> very <sil=0.000> important <sil=2.000> .PERIOD  Whenever <sil=0.000> for <sil=0.000> hash <sil=0.000> include <sil=0.000> the <sil=0.000> s t <sil=0.000> d I <sil=0.000> o
dot <sil=0.000> h <sil=1.000> ,COMMA  I <sil=0.000> did <sil=0.000> not <sil=0.000> give <sil=0.000> a semicolon <sil=2.000> .PERIOD  But <sil=0.000> whenever <sil=0.000> I am <sil=0.000> declaring <sil=0.000> a function <sil=0.000> of <sil=0.000> function
prototype <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> to <sil=0.000> give <sil=0.000> a semicolon <sil=0.000> just <sil=0.000> as <sil=0.000> I had <sil=0.000> given <sil=0.000> a semicolon <sil=0.000> when <sil=0.000> I declare
something <sil=0.000> like <sil=0.000> int <sil=0.000> x semicolon <sil=2.000> .PERIOD 
Similarly <sil=1.000> ,COMMA  here <sil=1.000> ,COMMA  this <sil=0.000> semicolon <sil=0.000> is <sil=0.000> very <sil=0.000> important <sil=2.000> .PERIOD  It <sil=0.000> just <sil=0.000> like <sil=0.000> a declaration <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the
argument <sil=0.000> names <sil=0.000> can <sil=0.000> be <sil=0.000> different <sil=1.000> ,COMMA  but <sil=0.000> it <sil=0.000> is <sil=0.000> I mean <sil=0.000> it <sil=0.000> is <sil=0.000> a good <sil=0.000> practice <sil=0.000> to <sil=0.000> use <sil=0.000> the <sil=0.000> same
names <sil=0.000> in <sil=0.000> the <sil=0.000> function <sil=2.000> .PERIOD  Now <sil=0.000> ah <sil=1.000> ,COMMA  so <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> being <sil=0.000> said <sil=0.000> here <sil=0.000> is <sil=0.000> that <sil=1.000> ,COMMA  although <sil=0.000> I am <sil=0.000> using
here <sil=1.000> ,COMMA  showing <sil=0.000> that <sil=0.000> A and <sil=0.000> A <sil=1.000> ,COMMA  but <sil=0.000> when <sil=0.000> I am <sil=0.000> actually <sil=0.000> writing <sil=0.000> the <sil=0.000> function <sil=0.000> later <sil=0.000> say <sil=1.000> ,COMMA  sorry <sil=2.000> .PERIOD 

When <sil=0.000> I am <sil=0.000> writing <sil=0.000> the <sil=0.000> function <sil=0.000> later <sil=1.000> ,COMMA  when <sil=0.000> I wrote <sil=0.000> later <sil=0.000> on <sil=0.000> int <sil=0.000> g c <sil=0.000> d <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> make <sil=1.000> ,COMMA  let <sil=0.000> us
space <sil=1.000> ,COMMA  sorry <sil=0.000> I can <sil=0.000> write <sil=0.000> int <sil=0.000> g c <sil=0.000> d int <sil=0.000> x comma <sil=0.000> int <sil=0.000> y that <sil=0.000> is <sil=0.000> also <sil=0.000> possible <sil=0.000> ok <sil=2.000> .PERIOD  Because <sil=1.000> ,COMMA  my
prototype <sil=0.000> just <sil=0.000> said <sil=0.000> that <sil=1.000> ,COMMA  2 <sil=0.000> integer <sil=0.000> places <sil=2.000> .PERIOD  Now <sil=0.000> actually <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> change <sil=0.000> the <sil=0.000> name <sil=1.000> ,COMMA  change
the <sil=0.000> name <sil=0.000> of <sil=0.000> the <sil=0.000> place <sil=1.000> ,COMMA  but <sil=0.000> that <sil=0.000> is <sil=0.000> not <sil=0.000> that <sil=0.000> important <sil=2.000> .PERIOD  I <sil=0.000> mean <sil=0.000> that <sil=0.000> is <sil=0.000> not <sil=0.000> I mean <sil=1.000> ,COMMA  usually <sil=0.000> it
is <sil=0.000> better <sil=0.000> if <sil=0.000> we <sil=0.000> can <sil=0.000> keep <sil=0.000> both <sil=0.000> of <sil=0.000> them <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> a function <sil=0.000> prototype <sil=0.000> example <sil=2.000> .PERIOD  I <sil=0.000> will <sil=0.000> continue <sil=0.000> with <sil=0.000> this <sil=0.000> in <sil=0.000> the <sil=0.000> next <sil=0.000> lecture <sil=2.000> .PERIOD  I
will <sil=0.000> discuss <sil=0.000> this <sil=0.000> and <sil=0.000> we <sil=0.000> will <sil=0.000> move <sil=0.000> to <sil=0.000> some <sil=0.000> other <sil=0.000> important <sil=0.000> feature <sil=0.000> of <sil=0.000> function <sil=0.000> like
parameter <sil=0.000> passing <sil=0.000> in <sil=0.000> the <sil=0.000> next <sil=0.000> lecture <sil=0.000> onwards <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  in <sil=0.000> the <sil=0.000> last <sil=0.000> lecture <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> discussed <sil=0.000> about <sil=0.000> function <sil=0.000> prototype <sil=2.000> .PERIOD  Before <sil=0.000> moving <sil=0.000> to
some <sil=0.000> other <sil=0.000> topic <sil=0.000> let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> an <sil=0.000> example <sil=0.000> of <sil=0.000> function <sil=0.000> prototype <sil=0.000> and <sil=0.000> so <sil=0.000> that <sil=0.000> we <sil=0.000> can
understand <sil=0.000> it <sil=0.000> better <sil=2.000> .PERIOD 

Here <sil=0.000> you <sil=0.000> see <sil=0.000> here <sil=0.000> is <sil=0.000> a program <sil=0.000> were <sil=0.000> I have <sil=0.000> got <sil=0.000> a function <sil=0.000> n c <sil=0.000> r <sil=1.000> ,COMMA  n <sil=0.000> choose <sil=0.000> r and <sil=0.000> another
function <sil=0.000> fact <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  the <sil=0.000> functions <sil=0.000> are <sil=0.000> actually <sil=0.000> little <sil=0.000> later <sil=0.000> here <sil=0.000> you <sil=0.000> see <sil=0.000> n choose <sil=0.000> r is <sil=0.000> like
this <sil=0.000> standard <sil=0.000> n choose <sil=0.000> r that <sil=0.000> you <sil=0.000> do <sil=2.000> .PERIOD  Here <sil=0.000> that <sil=0.000> is <sil=0.000> a factorial <sil=0.000> n by <sil=0.000> factorial <sil=0.000> r <sil=1.000> ,COMMA  so <sil=0.000> factorial <sil=0.000> n
divided <sil=0.000> by <sil=0.000> factorial <sil=0.000> r into <sil=0.000> factorial <sil=0.000> n minus <sil=0.000> r that <sil=0.000> we <sil=0.000> know <sil=0.000> from <sil=0.000> our <sil=0.000> school <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that
is <sil=0.000> one <sil=0.000> function <sil=0.000> that <sil=0.000> is <sil=0.000> one <sil=0.000> function <sil=2.000> .PERIOD 
The <sil=0.000> other <sil=0.000> function <sil=0.000> is <sil=0.000> the <sil=0.000> factorial <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> another <sil=0.000> function <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> one <sil=0.000> function <sil=0.000> this
another <sil=0.000> function <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  look <sil=0.000> at <sil=0.000> the <sil=0.000> beauty <sil=0.000> of <sil=0.000> this <sil=0.000> function <sil=0.000> this <sil=0.000> function <sil=0.000> is <sil=0.000> in <sil=0.000> a simple <sil=0.000> one
return <sil=0.000> statement <sil=0.000> I have <sil=0.000> written <sil=0.000> everything <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> you <sil=0.000> see <sil=0.000> the <sil=0.000> body <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=0.000> is
merely <sil=0.000> a computation <sil=0.000> of <sil=0.000> an <sil=0.000> expression <sil=0.000> fact <sil=0.000> 10 <sil=0.000> divided <sil=0.000> by <sil=0.000> fact <sil=0.000> r divided <sil=0.000> by <sil=0.000> n <sil=1.000> ,COMMA  fact <sil=0.000> n
minus <sil=0.000> r and <sil=0.000> this <sil=0.000> will <sil=0.000> be <sil=0.000> computed <sil=0.000> and <sil=0.000> that <sil=0.000> will <sil=0.000> be <sil=0.000> returned <sil=0.000> as <sil=0.000> an <sil=0.000> integer <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  what <sil=0.000> will
be <sil=0.000> the <sil=0.000> input <sil=0.000> the <sil=0.000> input <sil=0.000> will <sil=0.000> be <sil=0.000> n and <sil=0.000> the <sil=0.000> r both <sil=0.000> of <sil=0.000> them <sil=0.000> are <sil=0.000> integers <sil=2.000> .PERIOD 

Another <sil=0.000> point <sil=0.000> to <sil=0.000> note <sil=0.000> here <sil=0.000> is <sil=0.000> this <sil=0.000> function <sil=0.000> itself <sil=0.000> this <sil=0.000> function <sil=0.000> itself <sil=0.000> when <sil=0.000> is <sil=0.000> running <sil=0.000> first
say <sil=0.000> I get <sil=0.000> into <sil=0.000> this <sil=0.000> function <sil=0.000> and <sil=0.000> I tried <sil=0.000> to <sil=0.000> compute <sil=0.000> the <sil=0.000> return <sil=0.000> value <sil=1.000> ,COMMA  first <sil=0.000> I find <sil=0.000> fact <sil=0.000> n and
from <sil=0.000> here <sil=0.000> I am <sil=0.000> calling <sil=0.000> another <sil=0.000> function <sil=0.000> that <sil=0.000> is <sil=0.000> the <sil=0.000> factorial <sil=0.000> function <sil=0.000> and <sil=0.000> the <sil=0.000> factorial
function <sil=0.000> is <sil=0.000> taking <sil=0.000> only <sil=0.000> one <sil=0.000> input <sil=0.000> one <sil=0.000> integer <sil=0.000> n and <sil=0.000> based <sil=0.000> on <sil=0.000> that <sil=0.000> it <sil=0.000> is <sil=0.000> computing <sil=0.000> the
factorial <sil=2.000> .PERIOD  Computing <sil=0.000> the <sil=0.000> factorial <sil=0.000> you <sil=0.000> must <sil=0.000> be <sil=0.000> remembering <sil=0.000> by <sil=0.000> now <sil=1.000> ,COMMA  or <sil=0.000> knowing <sil=0.000> by
now <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> I am <sil=0.000> starting <sil=0.000> with <sil=0.000> 1 and <sil=0.000> 1 times <sil=0.000> 2 times <sil=0.000> 3 etcetera <sil=0.000> I am <sil=0.000> going <sil=0.000> on <sil=0.000> doing <sil=0.000> and
that <sil=0.000> is <sil=0.000> what <sil=0.000> is <sil=0.000> being <sil=0.000> done <sil=0.000> here <sil=0.000> temp <sil=0.000> is <sil=0.000> 1 and <sil=0.000> temp <sil=0.000> is <sil=0.000> equal <sil=0.000> to <sil=0.000> temp <sil=0.000> times <sil=0.000> i <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> wrong
this <sil=0.000> should <sil=0.000> be <sil=0.000> small <sil=0.000> i <sil=1.000> ,COMMA  temp <sil=0.000> is <sil=0.000> temp <sil=0.000> times <sil=0.000> i <sil=1.000> ,COMMA  whatever <sil=0.000> the <sil=0.000> i value <sil=0.000> is <sil=1.000> ,COMMA  1 <sil=0.000> times <sil=0.000> 1 <sil=1.000> ,COMMA  1 <sil=0.000> times <sil=0.000> 2 <sil=1.000> ,COMMA 
1 <sil=0.000> times <sil=0.000> 3 it <sil=0.000> goes <sil=0.000> on <sil=0.000> till <sil=0.000> i reaches <sil=0.000> n and <sil=0.000> then <sil=0.000> i return <sil=0.000> temp <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  the <sil=0.000> point <sil=0.000> to <sil=0.000> that <sil=0.000> you <sil=0.000> know <sil=1.000> ,COMMA  this <sil=0.000> will <sil=0.000> this <sil=0.000> thing <sil=0.000> you <sil=0.000> know <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> being <sil=0.000> done <sil=0.000> here
is <sil=0.000> when <sil=0.000> I am <sil=0.000> computing <sil=0.000> this <sil=0.000> function <sil=0.000> then <sil=0.000> I come <sil=0.000> to <sil=0.000> this <sil=0.000> I call <sil=0.000> this <sil=0.000> function <sil=0.000> return <sil=0.000> temp <sil=1.000> ,COMMA 
I <sil=0.000> return <sil=0.000> here <sil=0.000> and <sil=0.000> then <sil=0.000> I move <sil=0.000> here <sil=0.000> and <sil=0.000> again <sil=0.000> I find <sil=0.000> again <sil=0.000> I call <sil=0.000> to <sil=0.000> this <sil=0.000> fact <sil=0.000> again <sil=1.000> ,COMMA  this <sil=0.000> time
with <sil=0.000> the <sil=0.000> different <sil=0.000> parameter <sil=0.000> r and <sil=0.000> so <sil=0.000> again <sil=0.000> fact <sil=0.000> r is <sil=0.000> computed <sil=0.000> after <sil=0.000> this <sil=0.000> is <sil=0.000> computed
second <sil=0.000> time <sil=0.000> when <sil=0.000> I return <sil=0.000> back <sil=0.000> here <sil=2.000> .PERIOD  And <sil=0.000> then <sil=0.000> I again <sil=0.000> call <sil=0.000> this <sil=0.000> fact <sil=0.000> using <sil=0.000> n minus <sil=0.000> r <sil=1.000> ,COMMA  so
just <sil=0.000> to <sil=0.000> make <sil=0.000> the <sil=0.000> things <sil=0.000> clear <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> first <sil=0.000> time <sil=0.000> I am <sil=0.000> calling <sil=0.000> this <sil=0.000> from <sil=0.000> here <sil=0.000> and <sil=0.000> returning
back <sil=0.000> here <sil=1.000> ,COMMA  second <sil=0.000> time <sil=0.000> I am <sil=0.000> calling <sil=0.000> this <sil=0.000> from <sil=0.000> here <sil=0.000> the <sil=0.000> same <sil=0.000> thing <sil=0.000> and <sil=0.000> returning <sil=0.000> back
here <sil=0.000> and <sil=0.000> third <sil=0.000> time <sil=0.000> I am <sil=0.000> calling <sil=0.000> from <sil=0.000> here <sil=0.000> and <sil=0.000> returning <sil=0.000> back <sil=0.000> here <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  for <sil=0.000> the <sil=0.000> third <sil=0.000> call <sil=0.000> I am <sil=1.000> ,COMMA  so <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> one <sil=0.000> n and <sil=0.000> that <sil=0.000> this <sil=0.000> n and <sil=0.000> here <sil=0.000> what <sil=0.000> I am <sil=0.000> passing <sil=0.000> I
am <sil=0.000> passing <sil=0.000> n minus <sil=0.000> r <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> first <sil=0.000> computing <sil=0.000> this <sil=0.000> and <sil=0.000> that <sil=0.000> is <sil=0.000> being <sil=0.000> passed <sil=0.000> here <sil=0.000> and <sil=0.000> that <sil=0.000> is

being <sil=0.000> computed <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> you <sil=0.000> see <sil=0.000> it <sil=0.000> is <sil=0.000> an <sil=0.000> example <sil=0.000> of <sil=0.000> nested <sil=0.000> call <sil=0.000> this <sil=0.000> was <sil=0.000> called <sil=0.000> from <sil=0.000> the
main <sil=0.000> and <sil=0.000> this <sil=0.000> in <sil=0.000> turns <sil=0.000> call <sil=0.000> I mean <sil=0.000> call <sil=0.000> another <sil=0.000> function <sil=0.000> and <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=0.000> it <sil=0.000> goes <sil=0.000> on <sil=2.000> .PERIOD  That <sil=0.000> is
about <sil=0.000> the <sil=0.000> beauty <sil=0.000> of <sil=0.000> these <sil=0.000> two <sil=0.000> functions <sil=2.000> .PERIOD  But <sil=0.000> now <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> my <sil=0.000> main <sil=1.000> ,COMMA  main <sil=0.000> function <sil=0.000> here <sil=0.000> is
my <sil=0.000> main <sil=0.000> function <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> compilers <sil=0.000> comes <sil=0.000> from <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=0.000> and <sil=0.000> recognises <sil=0.000> at <sil=0.000> this <sil=0.000> point
that <sil=0.000> ok <sil=1.000> ,COMMA  n <sil=0.000> c r <sil=0.000> is <sil=0.000> a function <sil=0.000> how <sil=0.000> does <sil=0.000> it <sil=0.000> know <sil=0.000> it <sil=0.000> looks <sil=0.000> like <sil=0.000> int <sil=2.000> .PERIOD  But <sil=0.000> how <sil=0.000> does <sil=0.000> it <sil=0.000> recognise
that <sil=0.000> it <sil=0.000> is <sil=0.000> a function <sil=0.228> ?QUESTIONMARK  It <sil=0.000> recognises <sil=0.000> n c <sil=0.000> r to <sil=0.000> a function <sil=0.000> because <sil=0.000> of <sil=0.000> this <sil=0.000> parameter <sil=0.000> argument
list <sil=2.000> .PERIOD 

Here <sil=0.000> it <sil=0.000> is <sil=0.000> said <sil=0.000> int <sil=0.000> r there <sil=0.000> are <sil=0.000> two <sil=0.000> integers <sil=0.000> coming <sil=0.000> in <sil=0.000> as <sil=0.000> parameters <sil=0.000> next <sil=0.000> it <sil=0.000> understands
that <sil=0.000> fact <sil=0.000> is <sil=0.000> also <sil=0.000> a function <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  its <sil=0.000> expecting <sil=0.000> to <sil=0.000> encounter <sil=0.000> n c <sil=0.000> r and <sil=0.000> facts <sil=0.000> somewhere <sil=0.000> down
the <sil=0.000> line <sil=0.000> and <sil=0.000> proceeds <sil=0.000> here <sil=0.000> it <sil=0.000> takes <sil=0.000> m and <sil=0.000> n <sil=1.000> ,COMMA  reads <sil=0.000> m and <sil=0.000> n <sil=1.000> ,COMMA  then <sil=0.000> it <sil=0.000> is <sil=0.000> in <sil=0.000> a loop <sil=0.000> where <sil=0.000> it <sil=0.000> is
calling <sil=0.000> n c <sil=0.000> r <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> series <sil=0.000> you <sil=0.000> can <sil=0.000> understand <sil=0.000> n c <sil=0.000> r is <sil=0.000> computing <sil=0.000> some <sil=0.000> with <sil=0.000> some <sil=0.000> value
i <sil=0.000> initially <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> basically <sil=0.000> n c <sil=0.000> 1 plus <sil=0.000> n c <sil=0.000> 2 plus <sil=0.000> n c <sil=0.000> 3 plus <sil=0.000> etcetera <sil=0.000> it <sil=0.000> will <sil=0.000> go <sil=0.000> up <sil=0.000> to <sil=0.000> m
all <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> what <sil=0.000> is <sil=0.000> being <sil=0.000> computed <sil=0.000> here <sil=0.000> and <sil=0.000> so <sil=0.000> from <sil=0.000> here <sil=0.000> a call <sil=0.000> is <sil=0.000> made <sil=0.000> to <sil=0.000> this <sil=2.000> .PERIOD 
And <sil=0.000> as <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=0.000> earlier <sil=0.000> while <sil=0.000> this <sil=0.000> is <sil=0.000> being <sil=0.000> executed <sil=0.000> this <sil=0.000> one <sil=0.000> is <sil=0.000> calling <sil=0.000> here <sil=0.000> this <sil=0.000> is
returning <sil=0.000> back <sil=0.000> here <sil=0.000> then <sil=0.000> again <sil=0.000> this <sil=0.000> one <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  we <sil=0.000> are <sil=0.000> making <sil=0.000> a journey <sil=0.000> in <sil=0.000> this <sil=0.000> line <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
this <sil=0.000> one <sil=0.000> is <sil=0.000> calling <sil=0.000> this <sil=0.000> and <sil=0.000> we <sil=0.000> are <sil=0.000> returning <sil=0.000> back <sil=0.000> here <sil=0.000> as <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=0.000> just <sil=0.000> now <sil=2.000> .PERIOD  Now
ultimately <sil=0.000> when <sil=0.000> this <sil=0.000> entire <sil=0.000> thing <sil=0.000> is <sil=0.000> computed <sil=0.000> then <sil=0.000> we <sil=0.000> will <sil=0.000> come <sil=0.000> to <sil=0.000> this <sil=1.000> ,COMMA  last <sil=0.000> bracket <sil=0.000> here
sorry <sil=0.000> I should <sil=0.000> not <sil=0.000> this <sil=0.000> bracket <sil=0.000> here <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> a end <sil=0.000> of <sil=0.000> n c <sil=0.000> r <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> had <sil=0.000> called <sil=0.000> n c <sil=0.000> r

from <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> return <sil=0.000> back <sil=0.000> here <sil=0.000> and <sil=0.000> will <sil=0.000> whatever <sil=0.000> n c <sil=0.000> r value <sil=0.000> is <sil=0.000> that <sil=0.000> will <sil=0.000> be <sil=0.000> added
to <sil=0.000> sum <sil=0.000> and <sil=0.000> that <sil=0.000> will <sil=0.000> go <sil=0.000> to <sil=0.000> this <sil=0.000> sum <sil=0.000> and <sil=0.000> then <sil=0.000> will <sil=0.000> proceed <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=0.000> I hope <sil=0.000> this <sil=0.000> clear <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  here <sil=0.000> I have <sil=0.000> not <sil=0.000> written <sil=0.000> n c <sil=0.000> r <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> could <sil=0.000> have <sil=0.000> I could <sil=0.000> have <sil=0.000> written <sil=0.000> this <sil=0.000> earlier <sil=0.000> in
that <sil=0.000> case <sil=0.000> this <sil=0.000> prototype <sil=0.000> would <sil=0.000> not <sil=0.000> be <sil=0.000> needed <sil=1.000> ,COMMA  but <sil=0.000> since <sil=0.000> I decided <sil=0.000> that <sil=0.000> I will <sil=0.000> be <sil=0.000> writing <sil=0.000> it
later <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> decided <sil=0.000> to <sil=0.000> just <sil=0.000> introduce <sil=0.000> them <sil=0.000> as <sil=0.000> prototypes <sil=0.000> here <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  you <sil=0.000> should <sil=0.000> be <sil=0.000> very
careful <sil=0.000> about <sil=0.000> the <sil=0.000> syntax <sil=0.000> of <sil=0.000> the <sil=1.000> ,COMMA  of <sil=0.000> writing <sil=0.000> the <sil=0.000> prototypes <sil=0.000> it <sil=0.000> should <sil=0.000> have <sil=0.000> the <sil=0.000> function <sil=0.000> type
just <sil=0.000> like <sil=0.000> a function <sil=0.000> name <sil=0.000> and <sil=0.000> the <sil=0.000> parameters <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  you <sil=0.000> will <sil=0.000> see <sil=0.000> later <sil=0.000> that <sil=0.000> it <sil=0.000> is <sil=0.000> also <sil=0.000> possible <sil=0.000> that <sil=0.000> I could <sil=0.000> have <sil=0.000> written <sil=0.000> something <sil=0.000> like <sil=0.000> int
n <sil=0.000> c r <sil=1.000> ,COMMA  int <sil=0.000> comma <sil=0.000> int <sil=0.000> that <sil=0.000> will <sil=0.000> also <sil=0.000> mean <sil=0.000> that <sil=0.000> this <sil=0.000> n c <sil=0.000> r takes <sil=0.000> two <sil=0.000> integers <sil=0.000> as <sil=0.000> I mean <sil=0.000> arguments <sil=1.000> ,COMMA  that <sil=0.000> will <sil=0.000> also <sil=0.000> that <sil=0.000> is <sil=0.000> also <sil=0.000> allowed <sil=1.000> ,COMMA  but <sil=0.000> it <sil=0.000> is <sil=0.000> nice <sil=0.000> to <sil=0.000> write <sil=0.000> this <sil=0.000> in
this <sil=0.000> way <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  next <sil=0.000> will <sil=0.000> move <sil=0.000> to <sil=0.000> a very <sil=0.000> important <sil=0.000> concept <sil=0.354> ;SEMICOLON  let <sil=0.000> us <sil=0.000> quickly <sil=0.000> have <sil=0.000> a look <sil=0.000> at <sil=0.000> this <sil=0.000> the
prototype <sil=0.000> declaration <sil=0.000> and <sil=0.000> the <sil=0.000> function <sil=0.000> definitions <sil=0.000> are <sil=0.000> actually <sil=0.000> here <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  we <sil=0.000> are <sil=0.000> moving <sil=0.000> to <sil=0.000> a very <sil=0.000> important <sil=0.000> concept <sil=0.000> of <sil=0.000> passing <sil=0.000> the <sil=0.000> parameters <sil=1.000> ,COMMA  how <sil=0.000> do <sil=0.000> we
pass <sil=0.000> the <sil=0.000> parameters <sil=0.000> from <sil=0.000> the <sil=0.000> calling <sil=0.000> function <sil=0.000> to <sil=0.000> the <sil=0.000> called <sil=0.000> function <sil=2.000> .PERIOD  There <sil=0.000> are <sil=0.000> two
distinct <sil=0.000> ways <sil=0.000> in <sil=0.000> which <sil=0.000> it <sil=0.000> can <sil=0.000> be <sil=0.000> done <sil=0.000> one <sil=0.000> is <sil=0.000> calling <sil=0.000> by <sil=0.000> value <sil=0.000> another <sil=0.000> is <sil=0.000> calling <sil=0.000> by
reference <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  right <sil=0.000> now <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> think <sil=0.000> of <sil=0.000> calling <sil=0.000> by <sil=0.000> value <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> try <sil=0.000> to
understand <sil=0.000> it <sil=0.000> in <sil=0.000> a simple <sil=0.000> way <sil=2.000> .PERIOD 

Say <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> my <sil=0.000> main <sil=0.000> function <sil=0.000> or <sil=0.000> the <sil=0.000> calling <sil=0.000> function <sil=0.000> let <sil=0.000> me <sil=0.000> not <sil=0.000> call <sil=0.000> it <sil=0.000> main <sil=0.000> function <sil=0.000> as
we <sil=0.000> have <sil=0.000> seen <sil=0.000> they <sil=0.000> can <sil=0.000> be <sil=0.000> nested <sil=0.000> functions <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> the <sil=0.000> calling <sil=0.000> function <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  inside
the <sil=0.000> calling <sil=0.000> function <sil=0.000> I have <sil=0.000> got <sil=0.000> some <sil=0.000> variable <sil=0.000> x and <sil=0.000> which <sil=0.000> may <sil=0.000> have <sil=0.000> the <sil=0.000> value <sil=0.000> says
somewhere <sil=0.000> 5 it <sil=0.000> is <sil=0.000> an <sil=0.000> integer <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  somewhere <sil=0.000> here <sil=0.000> I am <sil=0.000> calling <sil=0.000> a function <sil=0.000> let <sil=0.000> us <sil=0.000> call <sil=0.000> a
simple <sil=0.000> function <sil=0.000> decrement <sil=0.000> or <sil=0.000> no <sil=0.000> decrement <sil=0.000> add <sil=0.000> 2 or <sil=0.000> say <sil=0.000> add <sil=0.000> 2 <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  whatever <sil=0.000> is <sil=0.000> a
value <sil=0.000> we <sil=0.000> will <sil=0.000> add <sil=0.000> 2 to <sil=0.000> that <sil=0.000> simple <sil=0.000> thing <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> I say <sil=0.000> y is <sil=0.000> add <sil=0.000> 2 x <sil=0.000> and <sil=0.000> then <sil=0.000> semicolon
and <sil=0.000> I go <sil=0.000> on <sil=2.000> .PERIOD  And <sil=0.000> here <sil=0.000> is <sil=0.000> my <sil=0.000> function <sil=0.000> add <sil=0.000> 2 int <sil=0.000> a all <sil=0.000> right <sil=0.000> and <sil=0.000> add <sil=0.000> 2 is <sil=0.000> also <sil=0.000> type <sil=0.000> integer <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  so <sil=0.000> a we <sil=0.000> know <sil=0.000> is <sil=0.000> a local <sil=0.000> variable <sil=0.000> to <sil=0.000> the <sil=0.000> function <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> I will <sil=0.000> take <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> will
happen <sil=0.228> ?QUESTIONMARK  Suppose <sil=0.000> it <sil=0.000> was <sil=0.000> 5 <sil=1.000> ,COMMA  this <sil=0.000> will <sil=0.000> result <sil=0.000> in <sil=0.000> a will <sil=0.000> get <sil=0.000> 5 and <sil=0.000> here <sil=0.000> may <sil=0.000> be <sil=0.000> here <sil=0.000> I declare
another <sil=0.000> variable <sil=0.000> say <sil=0.000> b although <sil=0.000> it <sil=0.000> was <sil=0.000> not <sil=0.000> necessary <sil=1.000> ,COMMA  but <sil=0.000> I am <sil=0.000> just <sil=0.000> saying <sil=0.000> b is <sil=0.000> a plus <sil=0.000> 2
because <sil=0.000> its <sil=0.000> task <sil=0.000> is <sil=0.000> to <sil=0.000> add <sil=0.000> 2 and <sil=0.000> then <sil=0.000> I say <sil=0.000> return <sil=0.000> b <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> b which <sil=0.000> is <sil=0.000> an <sil=0.000> integer <sil=0.000> is <sil=0.000> being
returned <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  b <sil=0.000> which <sil=0.000> will <sil=0.000> be <sil=0.000> in <sil=0.000> this <sil=0.000> case <sil=0.000> it <sil=0.000> was <sil=0.000> 5 it <sil=0.000> will <sil=0.000> be <sil=0.000> going <sil=0.000> back <sil=0.000> here <sil=2.000> .PERIOD  I <sil=0.000> hope <sil=0.000> this <sil=0.000> is
clear <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  when <sil=0.000> you <sil=0.000> know <sil=0.000> the <sil=0.000> scope <sil=0.000> of <sil=0.000> variables <sil=0.000> that <sil=0.000> b is <sil=0.000> a variable <sil=0.000> or <sil=0.000> a or <sil=0.000> b whatever <sil=0.000> the
life <sil=0.000> of <sil=0.000> those <sil=0.000> or <sil=0.000> the <sil=0.000> validity <sil=0.000> of <sil=0.000> those <sil=0.000> are <sil=0.000> restricted <sil=0.000> only <sil=0.000> during <sil=0.000> the <sil=0.000> life <sil=0.000> of <sil=0.000> this <sil=0.000> function <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
but <sil=0.354> ;SEMICOLON  however <sil=1.000> ,COMMA  in <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> a looking <sil=0.000> from <sil=0.000> the <sil=0.000> point <sil=0.000> of <sil=0.000> view <sil=0.000> of <sil=0.000> compiler <sil=0.000> I have <sil=0.000> got <sil=0.000> a
variable <sil=0.000> a and <sil=0.000> I have <sil=0.000> got <sil=0.000> another <sil=0.000> variable <sil=0.000> b and <sil=0.000> here <sil=0.000> I have <sil=0.000> another <sil=0.000> variable <sil=0.000> x <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  this
variable <sil=0.000> x was <sil=0.000> having <sil=0.000> the <sil=0.000> value <sil=0.000> 5 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> in <sil=0.000> x I <sil=0.000> had <sil=0.000> 5 by <sil=0.000> this <sil=0.000> statement <sil=1.000> ,COMMA  this <sil=0.000> statement
made <sil=0.000> it <sil=0.000> 5 <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  since <sil=0.000> x is <sil=0.000> 5 and <sil=0.000> this <sil=0.000> one <sil=0.000> is <sil=0.000> expecting <sil=0.000> the <sil=0.000> value <sil=0.000> a <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  this <sil=0.000> 5 will <sil=0.000> be

copied <sil=0.000> in <sil=0.000> a <sil=0.354> ;SEMICOLON  what <sil=0.000> is <sil=0.000> being <sil=0.000> copied <sil=0.228> ?QUESTIONMARK  Not <sil=0.000> x <sil=1.000> ,COMMA  but <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> x <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> one <sil=0.000> will <sil=0.000> be <sil=0.000> will <sil=0.000> be
getting <sil=0.000> 5 right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> copy <sil=0.000> value <sil=0.000> is <sil=0.000> being <sil=0.000> copied <sil=1.000> ,COMMA  the <sil=0.000> value <sil=0.000> is <sil=0.000> copied <sil=0.000> in <sil=0.000> this <sil=0.000> variable <sil=0.000> 5 <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  it <sil=0.000> takes <sil=0.000> b was <sil=0.000> something <sil=1.000> ,COMMA  but <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  b <sil=0.000> becomes <sil=0.000> 5 plus <sil=0.000> 2 b <sil=0.000> becomes <sil=0.000> 7 <sil=1.000> ,COMMA  7 <sil=0.000> comes
out <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  suppose <sil=0.000> I change <sil=0.000> this <sil=0.000> program <sil=0.000> a little <sil=0.000> bit <sil=2.000> .PERIOD  I <sil=0.000> erase <sil=0.000> this <sil=0.000> b and <sil=0.000> make <sil=0.000> it <sil=0.000> sorry <sil=0.000> I make <sil=0.000> it
a <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> b is <sil=0.000> no <sil=0.000> longer <sil=0.000> there <sil=0.000> this <sil=0.000> is <sil=0.000> not <sil=0.000> required <sil=0.000> all <sil=0.000> right <sil=0.000> this <sil=0.000> variable <sil=0.000> has <sil=0.000> not <sil=0.000> been
defined <sil=0.000> I say <sil=0.000> that <sil=0.000> this <sil=0.000> line <sil=0.000> is <sil=0.000> also <sil=0.000> not <sil=0.000> there <sil=1.000> ,COMMA  int <sil=0.000> a and <sil=0.000> I just <sil=0.000> do <sil=0.000> a plus <sil=1.000> ,COMMA  a <sil=0.000> assigned <sil=0.000> a plus <sil=0.000> 2 <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  when <sil=0.000> it <sil=0.000> was <sil=0.000> called <sil=0.000> add <sil=0.000> x then <sil=0.000> from <sil=0.000> here <sil=0.000> from <sil=0.000> here <sil=0.000> this <sil=0.000> x was <sil=0.000> copied <sil=0.000> here <sil=0.000> and <sil=0.000> a
will <sil=0.000> be <sil=0.000> incremented <sil=0.000> to <sil=0.000> 7 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> will <sil=0.000> be <sil=0.000> incremented <sil=0.000> to <sil=0.000> 7 and <sil=0.000> obviously <sil=1.000> ,COMMA  this <sil=0.000> will <sil=0.000> be
return <sil=0.000> a not <sil=0.000> return <sil=0.000> b because <sil=0.000> b is <sil=0.000> not <sil=0.000> there <sil=0.000> anymore <sil=1.000> ,COMMA  so <sil=0.000> 7 <sil=1.000> ,COMMA  that <sil=0.000> 7 will <sil=0.000> be <sil=0.000> returned <sil=0.000> here <sil=2.000> .PERIOD 
But <sil=0.000> you <sil=0.000> see <sil=0.000> if <sil=0.000> here <sil=0.000> now <sil=1.000> ,COMMA  7 <sil=0.000> has <sil=0.000> been <sil=0.000> returned <sil=0.000> and <sil=0.000> 7 will <sil=0.000> be <sil=0.000> y <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  suppose <sil=0.000> if <sil=0.000> I say <sil=0.000> I am
not <sil=0.000> following <sil=0.000> the <sil=0.000> syntax <sil=0.000> I am <sil=0.000> just <sil=0.000> saying <sil=0.000> because <sil=0.000> there <sil=0.000> is <sil=0.000> no <sil=0.000> space <sil=0.000> here <sil=0.000> printf <sil=0.000> something
x <sil=2.000> .PERIOD  What <sil=0.000> would <sil=0.000> be <sil=0.000> printed <sil=0.228> ?QUESTIONMARK  For <sil=0.000> x what <sil=0.000> would <sil=0.000> be <sil=0.000> printed <sil=0.228> ?QUESTIONMARK  5 <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=0.000> because <sil=0.000> x is
still <sil=0.000> 5 x <sil=0.000> has <sil=0.000> not <sil=0.000> changed <sil=2.000> .PERIOD  I <sil=0.000> have <sil=0.000> simply <sil=0.000> copied <sil=0.000> the <sil=0.000> value <sil=0.000> to <sil=0.000> the <sil=0.000> argument <sil=0.000> variable <sil=0.000> and
have <sil=0.000> played <sil=0.000> with <sil=0.000> that <sil=0.000> changed <sil=0.000> it <sil=0.000> whatever <sil=0.000> I wanted <sil=0.000> to <sil=0.000> do <sil=0.000> I have <sil=0.000> done <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  take <sil=0.000> a little <sil=0.000> time <sil=0.000> to <sil=0.000> understand <sil=0.000> this <sil=2.000> .PERIOD  This <sil=0.000> means <sil=0.000> that <sil=0.000> the <sil=0.000> variable <sil=0.000> that <sil=0.000> I have <sil=0.000> in <sil=0.000> the
calling <sil=0.000> function <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> that <sil=0.000> will <sil=0.000> be <sil=0.000> copied <sil=0.000> to <sil=0.000> the <sil=0.000> argument <sil=0.000> of <sil=0.000> the <sil=0.000> called <sil=0.000> function <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  there <sil=0.000> are <sil=0.000> several <sil=0.000> advantage <sil=0.000> is <sil=0.000> to <sil=0.000> this <sil=0.000> one <sil=0.000> is <sil=1.000> ,COMMA  so <sil=0.000> it <sil=0.000> passes <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> the <sil=0.000> argument
execution <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=0.000> does <sil=0.000> not <sil=0.000> change <sil=0.000> the <sil=0.000> actual <sil=0.000> parameter <sil=0.000> like <sil=0.000> the <sil=0.000> actual <sil=0.000> parameter
was <sil=0.000> x which <sil=0.000> was <sil=0.000> 5 <sil=1.000> ,COMMA  it <sil=0.000> remains <sil=0.000> as <sil=0.000> 5 although <sil=0.000> the <sil=0.000> function <sil=0.000> added <sil=0.000> two <sil=0.000> to <sil=0.000> that <sil=0.000> and <sil=0.000> it <sil=0.000> came
back <sil=0.000> all <sil=0.000> changes <sil=0.000> to <sil=0.000> a parameter <sil=0.000> done <sil=0.000> inside <sil=0.000> the <sil=0.000> function <sil=0.000> are <sil=0.000> done <sil=0.000> on <sil=0.000> a copy <sil=0.000> of <sil=0.000> the <sil=0.000> actual
parameter <sil=0.000> not <sil=0.000> the <sil=0.000> original <sil=0.000> parameter <sil=2.000> .PERIOD  The <sil=0.000> copy <sil=0.000> is <sil=0.000> removed <sil=0.000> when <sil=0.000> the <sil=0.000> function <sil=0.000> returns <sil=0.000> to
the <sil=0.000> caller <sil=0.000> that <sil=0.000> entire <sil=0.000> variable <sil=0.000> location <sil=0.000> that <sil=0.000> was <sil=0.000> given <sil=0.000> for <sil=0.000> the <sil=0.000> variable <sil=0.000> a in <sil=0.000> our <sil=0.000> example <sil=0.000> is
returned <sil=0.000> back <sil=0.000> to <sil=0.000> the <sil=0.000> pool <sil=0.000> of <sil=0.000> memory <sil=0.000> locations <sil=2.000> .PERIOD  The <sil=0.000> value <sil=0.000> of <sil=0.000> the <sil=0.000> actual <sil=0.000> parameters <sil=0.000> in <sil=0.000> the
caller <sil=0.000> is <sil=0.000> not <sil=0.000> affected <sil=2.000> .PERIOD  Consequently <sil=0.000> it <sil=0.000> also <sil=0.000> saves <sil=0.000> us <sil=0.000> from <sil=0.000> some <sil=0.000> accidental <sil=0.000> changes
programming <sil=0.000> that <sil=0.000> can <sil=0.000> come <sil=0.000> copying <sil=0.000> due <sil=0.000> to <sil=0.000> programming <sil=0.000> errors <sil=2.000> .PERIOD 

On <sil=0.000> the <sil=0.000> other <sil=0.000> hand <sil=0.000> the <sil=0.000> other <sil=0.000> thing <sil=0.000> that <sil=0.000> is <sil=0.000> another <sil=0.000> type <sil=0.000> of <sil=0.000> parameter <sil=0.000> passing <sil=0.000> is <sil=0.000> known <sil=0.000> as
call <sil=0.000> by <sil=0.000> reference <sil=1.000> ,COMMA  call <sil=0.000> by <sil=0.000> reference <sil=2.000> .PERIOD  Here <sil=0.000> we <sil=0.000> are <sil=0.000> not <sil=0.000> copying <sil=0.000> we <sil=0.000> are <sil=0.000> not <sil=0.000> copying <sil=0.000> the
variable <sil=1.000> ,COMMA  we <sil=0.000> are <sil=0.000> passing <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> the <sil=0.000> original <sil=0.000> argument <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> take <sil=0.000> the <sil=0.000> earlier <sil=0.000> example <sil=0.000> again <sil=0.000> if <sil=0.000> I had <sil=0.000> my <sil=0.000> main <sil=0.000> function <sil=0.000> here <sil=0.000> and <sil=0.000> I had
similarly <sil=0.000> int <sil=0.000> x and <sil=0.000> here <sil=0.000> y was <sil=0.000> add <sil=0.000> 2 x <sil=0.000> here <sil=0.000> printf <sil=0.000> something <sil=0.000> x <sil=1.000> ,COMMA  and <sil=0.000> here <sil=0.000> I had <sil=0.000> that
function <sil=0.000> add <sil=0.000> two <sil=0.000> int <sil=0.000> a and <sil=0.000> here <sil=0.000> in <sil=0.000> the <sil=0.000> body <sil=0.000> I did <sil=0.000> a assign <sil=0.000> a plus <sil=0.000> 2 and <sil=0.000> return <sil=0.000> a <sil=1.000> ,COMMA  return <sil=0.000> a <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> a variable <sil=0.000> x and <sil=0.000> that <sil=0.000> has <sil=0.000> got <sil=0.000> an <sil=0.000> address <sil=0.000> say <sil=0.000> that <sil=0.000> address <sil=0.000> is <sil=0.000> whatever <sil=0.000> 5000 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  its <sil=0.000> value <sil=0.000> here <sil=0.000> somewhere <sil=0.000> x was <sil=0.000> 5 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  its <sil=0.000> value <sil=0.000> is <sil=0.000> 5 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> what <sil=0.000> I am <sil=0.000> in <sil=0.000> the
case <sil=0.000> of <sil=0.000> reference <sil=0.000> I am <sil=0.000> not <sil=0.000> copying <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> 5 to <sil=0.000> a instead <sil=0.000> in <sil=0.000> the <sil=0.000> parameter <sil=0.000> passing <sil=0.000> I
will <sil=0.000> write <sil=0.000> it <sil=0.000> in <sil=0.000> a different <sil=0.000> way <sil=0.000> not <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=0.000> which <sil=0.000> I will <sil=0.000> discuss <sil=0.000> later <sil=2.000> .PERIOD 
If <sil=0.000> I assume <sil=0.000> that <sil=0.000> this <sil=0.000> one <sil=0.000> a <sil=1.000> ,COMMA  a <sil=0.000> is <sil=0.000> not <sil=0.000> taking <sil=0.000> the <sil=0.000> value <sil=1.000> ,COMMA  but <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> the <sil=0.000> parameter <sil=1.000> ,COMMA 
address <sil=0.000> of <sil=0.000> the <sil=0.000> parameter <sil=2.000> .PERIOD  Means <sil=0.000> what <sil=0.228> ?QUESTIONMARK  Means <sil=0.000> that <sil=0.000> this <sil=0.000> time <sil=0.000> this <sil=0.000> a here <sil=0.000> I am <sil=0.000> passing <sil=0.000> not
the <sil=0.000> value <sil=0.000> 5 <sil=1.000> ,COMMA  but <sil=0.000> I am <sil=0.000> just <sil=0.000> simply <sil=0.000> saying <sil=0.000> that <sil=0.000> whatever <sil=0.000> data <sil=0.000> you <sil=0.000> want <sil=0.000> to <sil=0.000> work <sil=0.000> with <sil=0.000> that <sil=0.000> is
the <sil=0.000> data <sil=0.000> is <sil=0.000> in <sil=0.000> this <sil=0.000> location <sil=0.000> 5000 <sil=2.000> .PERIOD  And <sil=0.000> it <sil=0.000> excepts <sil=0.000> that <sil=0.000> reference <sil=0.000> that <sil=0.000> the <sil=0.000> data <sil=0.000> that <sil=0.000> I am
working <sil=0.000> on <sil=0.000> my <sil=0.000> a is <sil=0.000> actually <sil=0.000> staying <sil=0.000> 5000 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> it <sil=0.000> does <sil=0.228> ?QUESTIONMARK  It <sil=0.000> takes <sil=0.000> the <sil=0.000> when <sil=0.000> it <sil=0.000> computes
a <sil=0.000> assigned <sil=0.000> a plus <sil=0.000> 2 this <sil=0.000> is <sil=0.000> not <sil=0.000> looking <sil=0.000> nice <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> me <sil=0.000> write <sil=0.000> it <sil=0.000> a <sil=1.000> ,COMMA  a <sil=0.000> assigned <sil=0.000> a plus <sil=0.000> 2 it <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  knows <sil=0.000> that <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> the <sil=0.000> value <sil=0.000> a is <sil=0.000> here <sil=0.000> I have <sil=0.000> to <sil=0.000> get <sil=0.000> the <sil=0.000> value <sil=0.000> from <sil=0.000> this <sil=0.000> location <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
it <sil=0.000> gets <sil=0.000> the <sil=0.000> value <sil=0.000> from <sil=0.000> this <sil=0.000> location <sil=1.000> ,COMMA  but <sil=0.000> no <sil=0.000> other <sil=0.000> variable <sil=0.000> location <sil=0.000> has <sil=0.000> been <sil=0.000> allocated
because <sil=0.000> I know <sil=0.000> where <sil=0.000> there <sil=0.000> is <sil=0.000> only <sil=0.000> one <sil=0.000> common <sil=0.000> place <sil=1.000> ,COMMA  only <sil=0.000> one <sil=0.000> common <sil=0.000> place <sil=0.000> you
have <sil=0.000> done <sil=0.000> given <sil=0.000> something <sil=0.000> here <sil=0.000> and <sil=0.000> you <sil=0.000> haves <sil=0.000> told <sil=0.000> me <sil=0.000> where <sil=0.000> you <sil=0.000> have <sil=0.000> kept <sil=0.000> the <sil=0.000> data
and <sil=0.000> I am <sil=0.000> also <sil=0.000> working <sil=0.000> in <sil=0.000> that <sil=0.000> vessel <sil=0.000> itself <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> happening <sil=0.000> here <sil=0.000> is <sil=0.000> this <sil=0.000> 5 will <sil=0.000> be <sil=0.000> changed <sil=0.000> to <sil=0.000> 7 <sil=1.000> ,COMMA  here <sil=0.000> only <sil=0.000> and <sil=0.000> return <sil=0.000> I need <sil=0.000> not
return <sil=0.000> a it <sil=0.000> was <sil=0.000> just <sil=0.000> return <sil=0.000> would <sil=0.000> be <sil=0.000> sufficient <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  changes <sil=0.000> have <sil=0.000> been <sil=0.000> done <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  in
this <sil=0.000> case <sil=0.000> when <sil=0.000> I come <sil=0.000> to <sil=0.000> this <sil=0.000> printf <sil=0.000> x what <sil=0.000> will <sil=0.000> happen <sil=0.000> what <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=0.000> 7 will <sil=0.000> be
printed <sil=0.000> because <sil=0.000> the <sil=0.000> actual <sil=0.000> data <sil=0.000> has <sil=0.000> changed <sil=0.000> here <sil=2.000> .PERIOD  Let <sil=0.000> me <sil=0.000> show <sil=0.000> it <sil=0.000> you <sil=0.000> another <sil=0.000> example <sil=2.000> .PERIOD 

Here <sil=0.000> is <sil=0.000> my <sil=0.000> calling <sil=0.000> function <sil=0.000> and <sil=0.000> I think <sil=0.000> this <sil=0.000> vessel <sil=0.000> analogy <sil=0.000> will <sil=0.000> be <sil=0.000> fine <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  it <sil=0.000> says <sil=0.000> that
here <sil=0.000> is <sil=0.000> the <sil=0.000> data <sil=0.000> where <sil=0.000> I have <sil=0.000> poured <sil=0.000> it <sil=0.000> only <sil=0.000> tells <sil=0.000> you <sil=0.000> where <sil=0.000> it <sil=0.000> has <sil=0.000> poured <sil=1.000> ,COMMA  the <sil=0.000> name <sil=0.000> of <sil=0.000> the
vessel <sil=1.000> ,COMMA  suppose <sil=0.000> the <sil=0.000> name <sil=0.000> of <sil=0.000> the <sil=0.000> vessel <sil=0.000> is <sil=0.000> a there <sil=0.000> are <sil=0.000> many <sil=0.000> other <sil=0.000> vessels <sil=0.000> A B <sil=0.000> C and <sil=0.000> only
this <sil=0.000> vessel <sil=0.000> name <sil=0.000> has <sil=0.000> been <sil=0.000> passed <sil=0.000> and <sil=0.000> when <sil=0.000> this <sil=0.000> one <sil=0.000> is <sil=0.000> doing <sil=0.000> something <sil=0.000> it <sil=0.000> knows <sil=0.000> the
vessel <sil=0.000> name <sil=0.000> A <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> comes <sil=0.000> here <sil=0.000> and <sil=0.000> takes <sil=0.000> the <sil=0.000> data <sil=0.000> from <sil=0.000> here <sil=0.000> does <sil=0.000> something <sil=0.000> and
returns <sil=0.000> the <sil=0.000> data <sil=0.000> from <sil=0.000> here <sil=0.000> and <sil=0.000> here <sil=0.000> this <sil=0.000> program <sil=0.000> when <sil=0.000> it <sil=0.000> is <sil=0.000> computing <sil=0.000> when <sil=0.000> it <sil=0.000> returns
and <sil=0.000> then <sil=0.000> ultimately <sil=0.000> it <sil=0.000> returns <sil=0.000> there <sil=0.000> and <sil=0.000> while <sil=0.000> it <sil=0.000> returns <sil=0.000> it <sil=0.000> takes <sil=0.000> this <sil=0.000> value <sil=0.000> this <sil=0.000> value <sil=0.000> the
change <sil=0.000> value <sil=0.000> and <sil=0.000> continues <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  in <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> calling <sil=0.000> by <sil=0.000> reference <sil=0.000> we <sil=0.000> are <sil=0.000> not <sil=0.000> copying
the <sil=0.000> value <sil=2.000> .PERIOD  On <sil=0.000> the <sil=0.000> other <sil=0.000> hand <sil=0.000> what <sil=0.000> would <sil=0.000> have <sil=0.000> happen <sil=0.000> in <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> call <sil=0.000> by <sil=0.000> value <sil=0.000> using
the <sil=0.000> same <sil=0.000> vessel <sil=0.000> analogy <sil=0.228> ?QUESTIONMARK 

Say <sil=1.000> ,COMMA  this <sil=0.000> program <sil=0.000> was <sil=0.000> running <sil=0.000> the <sil=0.000> value <sil=0.000> was <sil=0.000> in <sil=0.000> a vessel <sil=0.000> the <sil=0.000> value <sil=0.000> was <sil=0.000> there <sil=0.000> in <sil=0.000> a vessel <sil=1.000> ,COMMA 
but <sil=0.000> sorry <sil=1.000> ,COMMA  but <sil=0.000> my <sil=0.000> function <sil=0.000> do <sil=0.000> not <sil=0.000> bother <sil=0.000> about <sil=0.000> the <sil=0.000> inter <sil=0.000> change <sil=0.000> of <sil=0.000> colours <sil=0.354> ;SEMICOLON  my <sil=0.000> function
was <sil=0.000> also <sil=0.000> having <sil=0.000> its <sil=0.000> own <sil=0.000> vessel <sil=0.000> and <sil=0.000> when <sil=0.000> the <sil=0.000> function <sil=0.000> has <sil=0.000> been <sil=0.000> called <sil=0.000> the <sil=0.000> main <sil=0.000> function
calls <sil=0.000> this <sil=0.000> a calls <sil=0.000> or <sil=0.000> say <sil=0.000> x calls <sil=0.000> y right <sil=1.000> ,COMMA  then <sil=0.000> also <sil=0.000> x copies <sil=0.000> y <sil=1.000> ,COMMA  copies <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> the
variable <sil=0.000> suppose <sil=0.000> that <sil=0.000> was <sil=0.000> a that <sil=0.000> is <sil=0.000> copied <sil=0.000> in <sil=0.000> the <sil=0.000> vessel <sil=0.000> that <sil=0.000> is <sil=0.000> belonging <sil=0.000> to <sil=0.000> the <sil=0.000> function <sil=0.000> it
may <sil=0.000> be <sil=0.000> b <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> one <sil=0.000> does <sil=0.000> whatever <sil=0.000> it <sil=0.000> does <sil=0.000> here <sil=0.000> and <sil=0.000> returns <sil=0.000> this <sil=0.000> value <sil=0.000> over <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
this <sil=0.000> one <sil=0.000> is <sil=0.000> not <sil=0.000> disturbed <sil=0.000> whatever <sil=0.000> changes <sil=0.000> are <sil=0.000> being <sil=0.000> done <sil=0.000> are <sil=1.000> ,COMMA  done <sil=0.000> here <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> a very <sil=0.000> fundamental <sil=0.000> concept <sil=0.000> in <sil=0.000> parameter <sil=0.000> passing <sil=2.000> .PERIOD  There <sil=0.000> are <sil=0.000> two <sil=0.000> types <sil=0.000> of
parameter <sil=0.000> passing <sil=0.000> one <sil=0.000> is <sil=0.000> call <sil=0.000> by <sil=0.000> value <sil=0.000> another <sil=0.000> is <sil=0.000> call <sil=0.000> by <sil=0.000> reference <sil=2.000> .PERIOD  Now <sil=0.000> so <sil=1.000> ,COMMA  here <sil=0.000> you <sil=0.000> see

execution <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=0.000> may <sil=0.000> affect <sil=0.000> the <sil=0.000> original <sil=0.000> because <sil=0.000> I am <sil=0.000> sharing <sil=0.000> the <sil=0.000> same <sil=0.000> vessel <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  this <sil=0.000> in <sil=0.000> C <sil=1.000> ,COMMA  in <sil=0.000> C we <sil=0.000> actually <sil=0.000> we <sil=0.000> are <sil=0.000> in <sil=0.000> C we <sil=0.000> actually <sil=0.000> carry <sil=0.000> out <sil=0.000> only <sil=0.000> call <sil=0.000> by <sil=0.000> value <sil=1.000> ,COMMA 
only <sil=0.000> call <sil=0.000> by <sil=0.000> value <sil=0.000> except <sil=0.000> for <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> arrays <sil=0.000> except <sil=0.000> for <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> arrays <sil=0.000> there <sil=0.000> is <sil=0.000> a
reason <sil=0.000> for <sil=0.000> that <sil=0.000> you <sil=0.000> will <sil=0.000> understand <sil=0.000> and <sil=0.000> for <sil=0.000> arrays <sil=0.000> we <sil=0.000> are <sil=0.000> not <sil=0.000> passing <sil=0.000> the <sil=0.000> values <sil=0.000> we <sil=0.000> are
passing <sil=0.000> by <sil=0.000> reference <sil=0.000> otherwise <sil=0.000> its <sil=0.000> always <sil=0.000> call <sil=0.000> by <sil=0.000> value <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> have <sil=0.000> a look <sil=0.000> at <sil=0.000> some <sil=0.000> of <sil=0.000> the <sil=0.000> examples <sil=0.000> here <sil=1.000> ,COMMA  first <sil=0.000> example <sil=2.000> .PERIOD 

We <sil=0.000> have <sil=0.000> got <sil=0.000> the <sil=0.000> main <sil=0.000> let <sil=0.000> us <sil=0.000> see <sil=0.000> what <sil=0.000> is <sil=0.000> happening <sil=1.000> ,COMMA  a <sil=0.000> has <sil=0.000> been <sil=0.000> initialised <sil=0.000> to <sil=0.000> 10 <sil=0.000> and <sil=0.000> b is
not <sil=0.000> initialised <sil=1.000> ,COMMA  printf <sil=0.000> initially <sil=0.000> a <sil=1.000> ,COMMA  a <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=0.228> ?QUESTIONMARK  Look <sil=0.000> at <sil=0.000> this <sil=1.000> ,COMMA  this <sil=0.000> will <sil=0.000> print
first <sil=0.000> line <sil=0.000> initially <sil=0.000> a equals <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> a which <sil=0.000> is <sil=0.000> 10 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=1.000> ,COMMA  here <sil=0.000> there <sil=0.000> is <sil=0.000> a variable <sil=0.000> a
which <sil=0.000> has <sil=0.000> got <sil=0.000> the <sil=0.000> value <sil=0.000> 10 <sil=2.000> .PERIOD  Then <sil=0.000> b is <sil=0.000> being <sil=0.000> assigned <sil=0.000> change <sil=0.000> a what <sil=0.000> is <sil=0.000> change <sil=0.000> a change <sil=0.000> a
is <sil=0.000> a function <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  one <sil=0.000> mistake <sil=0.000> is <sil=0.000> here <sil=0.000> I should <sil=0.000> have <sil=0.000> declared <sil=0.000> this <sil=0.000> change <sil=0.000> prototype <sil=0.000> here <sil=0.354> ;SEMICOLON  however <sil=1.000> ,COMMA  I
should <sil=0.000> have <sil=0.000> the <sil=0.000> function <sil=0.000> prototype <sil=0.000> should <sil=0.000> have <sil=0.000> been <sil=0.000> defined <sil=0.000> earlier <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  I <sil=0.000> come <sil=0.000> here
printf <sil=0.000> before <sil=0.000> in <sil=0.000> the <sil=0.354> ;SEMICOLON  what <sil=0.000> does <sil=0.000> the <sil=0.000> function <sil=0.000> do <sil=0.000> prints <sil=0.000> before <sil=0.000> x x <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  before <sil=1.000> ,COMMA  so <sil=0.000> this <sil=0.000> point
before <sil=0.000> x equal <sil=0.000> to <sil=0.000> x whatever <sil=0.000> x was <sil=1.000> ,COMMA  it <sil=0.000> has <sil=0.000> got <sil=0.000> the <sil=0.000> copy <sil=0.000> of <sil=0.000> that <sil=0.000> x <sil=1.000> ,COMMA  it <sil=0.000> has <sil=0.000> got <sil=0.000> the <sil=0.000> copy <sil=0.000> of
that <sil=0.000> x <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> it <sil=0.000> was <sil=0.000> a <sil=1.000> ,COMMA  a <sil=0.000> and <sil=0.000> that <sil=0.000> has <sil=0.000> been <sil=0.000> copied <sil=0.000> here <sil=0.000> for <sil=0.000> its <sil=0.000> own <sil=0.000> x <sil=1.000> ,COMMA  x <sil=0.000> is <sil=0.000> also <sil=0.000> 10 <sil=0.000> copied
because <sil=0.000> when <sil=0.000> it <sil=0.000> called <sil=0.000> you <sil=0.000> actually <sil=0.000> copied <sil=0.000> this <sil=2.000> .PERIOD  When <sil=0.000> this <sil=0.000> call <sil=0.000> was <sil=0.000> made <sil=1.000> ,COMMA  when <sil=0.000> this <sil=0.000> call
was <sil=0.000> made <sil=0.000> first <sil=0.000> then <sil=0.000> before <sil=0.000> that <sil=1.000> ,COMMA  before <sil=0.000> that <sil=0.000> it <sil=0.000> was <sil=0.000> also <sil=0.000> copied <sil=0.000> here <sil=0.000> and <sil=0.000> then <sil=0.000> only <sil=0.000> this <sil=0.000> was
done <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> was <sil=0.000> printed <sil=0.000> then <sil=0.000> x divided <sil=0.000> by <sil=0.000> 2 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  x <sil=0.000> becomes <sil=0.000> 5 by <sil=0.000> this <sil=0.000> statement <sil=0.000> done <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> being <sil=0.000> printed <sil=0.228> ?QUESTIONMARK  After <sil=0.000> here <sil=0.000> this <sil=0.000> line <sil=0.000> is <sil=0.000> being <sil=0.000> printed <sil=0.000> here <sil=0.000> after <sil=0.000> x equals <sil=0.000> x <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
what <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=0.228> ?QUESTIONMARK  I <sil=0.000> am <sil=0.000> still <sil=0.000> inside <sil=0.000> the <sil=0.000> function <sil=0.000> please <sil=0.000> remember <sil=0.000> I am <sil=0.000> still <sil=0.000> inside <sil=0.000> the
function <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  5 <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=0.000> and <sil=0.000> then <sil=0.000> I return <sil=0.000> return <sil=0.000> x <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> being <sil=0.000> returned <sil=0.228> ?QUESTIONMARK  5 <sil=0.000> is
being <sil=0.000> returned <sil=0.000> where <sil=0.000> it <sil=0.000> is <sil=0.000> being <sil=0.000> returned <sil=0.000> here <sil=1.000> ,COMMA  x <sil=0.000> has <sil=0.000> been <sil=0.000> a has <sil=0.000> been <sil=0.000> changed <sil=0.000> and <sil=0.000> that <sil=0.000> is
going <sil=0.000> to <sil=0.000> b printf <sil=0.000> a assigned <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> printf <sil=0.000> is <sil=0.000> this <sil=0.000> printf <sil=0.000> a sorry <sil=0.000> a equals <sil=0.000> here <sil=0.000> it <sil=0.000> I am
printing <sil=0.000> a <sil=1.000> ,COMMA  a <sil=0.000> is <sil=0.000> a <sil=1.000> ,COMMA  so <sil=0.000> a is <sil=0.000> not <sil=0.000> changed <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> being <sil=0.000> printed <sil=0.000> as <sil=0.000> 10 <sil=0.000> and <sil=0.000> b is <sil=0.000> being <sil=0.000> printed
as <sil=0.000> 5 <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  you <sil=0.000> see <sil=0.000> a has <sil=0.000> not <sil=0.000> been <sil=0.000> changed <sil=0.000> the <sil=0.000> reflection <sil=0.000> of <sil=0.000> the <sil=0.000> change <sil=0.000> has <sil=0.000> been <sil=0.000> reflected <sil=0.000> in <sil=0.000> this
function <sil=0.000> and <sil=0.000> is <sil=0.000> being <sil=0.000> assigned <sil=0.000> to <sil=0.000> b <sil=1.000> ,COMMA  clear <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> take <sil=0.000> another <sil=0.000> example <sil=0.000> and <sil=0.000> you <sil=0.000> will
yourself <sil=0.000> try <sil=0.000> to <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=0.000> example <sil=0.000> and <sil=0.000> a little <sil=0.000> change <sil=0.000> has <sil=0.000> been <sil=0.000> done <sil=0.000> let <sil=0.000> us <sil=0.000> all <sil=0.000> together
try <sil=0.000> to <sil=0.000> follow <sil=0.000> this <sil=0.000> example <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  a <sil=0.000> starting <sil=0.000> again <sil=0.000> a mistake <sil=0.000> is <sil=0.000> I should <sil=0.000> have <sil=0.000> declared <sil=0.000> the
function <sil=0.000> prototype <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  those <sil=0.000> things <sil=0.000> I have <sil=0.000> not <sil=0.000> shown <sil=0.000> here <sil=0.000> so <sil=1.000> ,COMMA  but <sil=0.000> you <sil=0.000> should <sil=0.000> do <sil=0.000> it <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> see <sil=0.000> here <sil=2.000> .PERIOD  Again <sil=0.000> int <sil=0.000> x equals <sil=0.000> 10 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  x <sil=0.000> is <sil=0.000> a variable <sil=0.000> to <sil=0.000> the <sil=0.000> main <sil=0.000> function <sil=0.000> x is
having <sil=0.000> 10 <sil=0.000> printf <sil=0.000> M here <sil=0.000> main <sil=0.000> function <sil=1.000> ,COMMA  printing <sil=0.000> initially <sil=0.000> x is <sil=0.000> 10 <sil=1.000> ,COMMA  there <sil=0.000> is <sil=0.000> calling <sil=0.000> the
function <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> the <sil=0.000> function <sil=0.000> is <sil=0.000> being <sil=0.000> called <sil=2.000> .PERIOD  And <sil=0.000> whenever <sil=0.000> this <sil=0.000> function <sil=0.000> is <sil=0.000> being
called <sil=0.000> there <sil=0.000> is <sil=0.000> a local <sil=0.000> to <sil=0.000> the <sil=0.000> function <sil=0.000> there <sil=0.000> is <sil=0.000> an <sil=0.000> argument <sil=0.000> x where <sil=0.000> this <sil=0.000> 10 <sil=0.000> is <sil=0.000> being
copied <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  printf <sil=0.000> here <sil=1.000> ,COMMA  this <sil=0.000> printf <sil=0.000> in <sil=0.000> the <sil=0.000> function <sil=0.000> it <sil=0.000> prints <sil=0.000> before <sil=0.000> x was <sil=0.000> x before <sil=0.000> changing <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
x <sil=0.000> was <sil=0.000> x <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=0.228> ?QUESTIONMARK  10 <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=2.000> .PERIOD  Then <sil=0.000> I change <sil=0.000> x here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  at <sil=0.000> this

point <sil=0.000> x is <sil=0.000> becoming <sil=0.000> 5 <sil=1.000> ,COMMA  all <sil=0.000> right <sil=2.000> .PERIOD  Then <sil=0.000> I am <sil=0.000> saying <sil=0.000> print <sil=0.000> after <sil=0.000> the <sil=0.000> change <sil=0.000> this <sil=0.000> is <sil=0.000> this
printout <sil=0.000> after <sil=0.000> that <sil=0.000> change <sil=0.000> x is <sil=0.000> what <sil=0.000> it <sil=0.000> has <sil=0.000> been <sil=0.000> changed <sil=0.000> 5 and <sil=0.000> then <sil=0.000> I return <sil=0.000> to <sil=0.000> the <sil=0.000> main
function <sil=0.000> with <sil=0.000> the <sil=0.000> change <sil=0.000> value <sil=0.000> of <sil=0.000> x <sil=1.000> ,COMMA  so <sil=0.000> b gets <sil=0.000> 5 <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> printing <sil=0.000> in <sil=0.000> the <sil=0.000> main <sil=0.000> function
x <sil=0.000> is <sil=0.000> 10 <sil=0.000> and <sil=0.000> b is <sil=0.000> 5 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> has <sil=0.000> been <sil=0.000> changed <sil=0.000> that <sil=0.000> is <sil=0.000> being <sil=0.000> reflected <sil=0.000> in <sil=0.000> this <sil=0.000> printf <sil=0.000> and <sil=0.000> b is
also <sil=0.000> 5 b <sil=0.000> was <sil=0.000> here <sil=1.000> ,COMMA  b <sil=0.000> is <sil=0.000> in <sil=0.000> the <sil=0.000> main <sil=0.000> function <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> b has <sil=0.000> been <sil=0.000> assigned <sil=0.000> after <sil=0.000> this <sil=0.000> change
and <sil=0.000> that <sil=0.000> is <sil=0.000> also <sil=0.000> 5 <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  the <sil=0.000> distinction <sil=0.000> I think <sil=0.000> will <sil=0.000> be <sil=0.000> clear <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  so <sil=0.000> these <sil=0.000> are <sil=0.000> the <sil=0.000> two <sil=0.000> cases
that <sil=0.000> we <sil=0.000> have <sil=0.000> shown <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  here <sil=0.000> let <sil=0.000> us <sil=0.000> see <sil=0.000> this <sil=0.000> is <sil=0.000> another <sil=0.000> example <sil=2.000> .PERIOD 

Here <sil=0.000> the <sil=0.000> slight <sil=0.000> change <sil=0.000> that <sil=0.000> has <sil=0.000> been <sil=0.000> done <sil=0.000> is <sil=0.000> that <sil=0.000> the <sil=0.000> change <sil=0.000> value <sil=0.000> I am <sil=0.000> keeping <sil=0.000> in <sil=0.000> x <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  this <sil=0.000> was <sil=0.000> x <sil=1.000> ,COMMA  and <sil=0.000> x was <sil=0.000> 10 <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  note <sil=0.000> x was <sil=0.000> 10 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  initially <sil=0.000> x is <sil=0.000> 10 <sil=0.000> fine <sil=1.000> ,COMMA  from <sil=0.000> this
line <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> called <sil=0.000> change <sil=0.000> x <sil=1.000> ,COMMA  so <sil=0.000> it <sil=0.000> is <sil=0.000> coming <sil=0.000> here <sil=2.000> .PERIOD  But <sil=0.000> its <sil=0.000> parameter <sil=0.000> is <sil=0.000> also <sil=0.000> x <sil=1.000> ,COMMA  but
that <sil=0.000> really <sil=0.000> does <sil=0.000> not <sil=0.000> matter <sil=2.000> .PERIOD  These <sil=0.000> x from <sil=0.000> here <sil=0.000> I will <sil=0.000> create <sil=0.000> another <sil=0.000> x <sil=2.000> .PERIOD  This <sil=0.000> who <sil=0.000> is <sil=0.000> the
owner <sil=0.000> of <sil=0.000> this <sil=0.000> x <sil=1.000> ,COMMA  the <sil=0.000> owner <sil=0.000> of <sil=0.000> this <sil=0.000> x is <sil=0.000> only <sil=0.000> this <sil=0.000> function <sil=0.000> as <sil=0.000> long <sil=0.000> as <sil=0.000> this <sil=0.000> function <sil=0.000> is
running <sil=0.000> these <sil=0.000> x has <sil=0.000> got <sil=0.000> a meaning <sil=0.000> it <sil=0.000> is <sil=0.000> existing <sil=0.000> other <sil=0.000> after <sil=0.000> that <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> there <sil=2.000> .PERIOD  But <sil=0.000> since <sil=0.000> I
called <sil=0.000> it <sil=0.000> the <sil=0.000> value <sil=0.000> 10 <sil=0.000> was <sil=0.000> copied <sil=0.000> in <sil=0.000> this <sil=1.000> ,COMMA  but <sil=0.000> you <sil=0.000> see <sil=0.000> these <sil=0.000> two <sil=0.000> are <sil=0.000> two <sil=0.000> different <sil=0.000> memory
locations <sil=2.000> .PERIOD  Consequently <sil=0.000> what <sil=0.000> is <sil=0.000> happening <sil=0.228> ?QUESTIONMARK  When <sil=0.000> I print <sil=0.000> it <sil=0.000> here <sil=0.000> before <sil=0.000> x was <sil=0.000> 10 <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA 
see <sil=0.000> which <sil=0.000> x is <sil=0.000> being <sil=0.000> printed <sil=0.228> ?QUESTIONMARK  This <sil=0.000> x is <sil=0.000> being <sil=0.000> printed <sil=0.000> because <sil=0.000> this <sil=0.000> x is <sil=0.000> not <sil=0.000> known <sil=0.000> to <sil=0.000> this
function <sil=0.000> this <sil=0.000> function <sil=0.000> only <sil=0.000> knows <sil=0.000> its <sil=0.000> own <sil=0.000> x then <sil=0.000> x is <sil=0.000> changed <sil=0.000> to <sil=0.000> 5 that <sil=0.000> is <sil=0.000> also <sil=0.000> done <sil=0.000> to <sil=0.000> be
done <sil=0.000> locally <sil=0.000> here <sil=0.000> and <sil=0.000> is <sil=0.000> being <sil=0.000> said <sil=0.000> here <sil=0.000> after <sil=0.000> that <sil=0.000> the <sil=0.000> x is <sil=0.000> 5 because <sil=0.000> this <sil=0.000> x is <sil=0.000> known <sil=0.000> then
I <sil=0.000> return <sil=0.000> x <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  5 <sil=0.000> is <sil=0.000> returned <sil=0.000> and <sil=0.000> 5 is <sil=0.000> assigned <sil=0.000> to <sil=0.000> x <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  whenever <sil=0.000> I have <sil=0.000> gone <sil=0.000> out <sil=0.000> of <sil=0.000> this <sil=0.000> function <sil=0.000> this <sil=0.000> x is <sil=0.000> no <sil=0.000> longer <sil=0.000> existing <sil=0.000> vanishes <sil=0.354> ;SEMICOLON  that
means <sil=1.000> ,COMMA  the <sil=0.000> compiler <sil=0.000> returns <sil=0.000> it <sil=0.000> to <sil=0.000> the <sil=0.000> memory <sil=0.000> pool <sil=0.000> now <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  which <sil=0.000> x <sil=0.228> ?QUESTIONMARK  Is <sil=0.000> this <sil=0.000> x <sil=0.228> ?QUESTIONMARK  This <sil=0.000> x <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  this <sil=0.000> value <sil=0.000> that <sil=0.000> is <sil=0.000> 5 that <sil=0.000> is <sil=0.000> being <sil=0.000> changed <sil=0.000> will <sil=0.000> come <sil=0.000> here <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  here <sil=0.000> I am <sil=0.000> doing <sil=0.000> printf
x <sil=0.000> x <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  both <sil=0.000> b is <sil=1.000> ,COMMA  so <sil=0.000> x will <sil=0.000> be <sil=0.000> printed <sil=0.000> as <sil=0.000> 5 and <sil=0.000> b equals <sil=0.000> x <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  x <sil=0.000> is <sil=0.000> also <sil=0.000> 5 <sil=2.000> .PERIOD  Here
you <sil=0.000> see <sil=0.000> that <sil=0.000> the <sil=0.000> same <sil=0.000> value <sil=0.000> is <sil=0.000> the <sil=0.000> variable <sil=0.000> is <sil=0.000> x <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  both <sil=0.000> will <sil=0.000> be <sil=0.000> 5 <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> hope <sil=0.000> you <sil=0.000> could <sil=0.000> understand <sil=0.000> this <sil=0.000> difference <sil=2.000> .PERIOD  Let <sil=0.000> us <sil=0.000> take <sil=0.000> the <sil=0.000> another <sil=0.000> example <sil=0.000> or <sil=0.000> we
will <sil=0.000> come <sil=0.000> back <sil=0.000> to <sil=0.000> this <sil=0.000> in <sil=0.000> the <sil=0.000> next <sil=0.000> class <sil=0.000> and <sil=0.000> we <sil=0.000> will <sil=0.000> start <sil=0.000> with <sil=0.000> a new <sil=0.000> example <sil=0.000> and

continue <sil=0.000> with <sil=0.000> parameter <sil=0.000> passing <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> we <sil=0.000> learnt <sil=0.000> in <sil=0.000> today s <sil=0.000> lecture <sil=0.000> is <sil=0.000> a very
important <sil=0.000> concept <sil=0.000> of <sil=0.000> call <sil=0.000> by <sil=0.000> value <sil=0.000> and <sil=0.000> call <sil=0.000> by <sil=0.000> reference <sil=0.000> and <sil=0.000> we <sil=0.000> could <sil=0.000> see <sil=0.000> that <sil=0.000> in <sil=0.000> C in
general <sil=0.000> call <sil=0.000> by <sil=0.000> value <sil=0.000> is <sil=0.000> adopted <sil=0.000> except <sil=0.000> for <sil=0.000> arrays <sil=0.000> and <sil=0.000> what <sil=0.000> is <sil=0.000> call <sil=0.000> by <sil=0.000> value <sil=0.000> call <sil=0.000> by <sil=0.000> value
means <sil=0.000> the <sil=0.000> calling <sil=0.000> function <sil=0.000> copies <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> the <sil=0.000> parameter <sil=0.000> to <sil=0.000> the <sil=0.000> variable
corresponding <sil=0.000> to <sil=0.000> the <sil=0.000> argument <sil=2.000> .PERIOD  Whatever <sil=0.000> change <sil=0.000> is <sil=0.000> done <sil=0.000> is <sil=0.000> done <sil=0.000> locally <sil=0.000> inside <sil=0.000> that
argument <sil=0.000> and <sil=0.000> when <sil=0.000> is <sil=0.000> returned <sil=0.000> it <sil=0.000> goes <sil=0.000> back <sil=0.000> to <sil=0.000> the <sil=0.000> main <sil=0.000> function <sil=1.000> ,COMMA  the <sil=0.000> value <sil=0.000> goes <sil=0.000> back <sil=0.000> to
the <sil=0.000> main <sil=0.000> function <sil=2.000> .PERIOD  Whereas <sil=1.000> ,COMMA  in <sil=0.000> case <sil=0.000> of <sil=0.000> call <sil=0.000> by <sil=0.000> reference <sil=0.000> the <sil=0.000> there <sil=0.000> is <sil=0.000> only <sil=0.000> one <sil=0.000> vessel <sil=0.000> one
variable <sil=0.000> and <sil=0.000> I am <sil=0.000> not <sil=0.000> creating <sil=0.000> another <sil=0.000> variable <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> simply <sil=0.000> passing <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> that
variable <sil=0.000> to <sil=0.000> the <sil=0.000> called <sil=0.000> function <sil=0.000> and <sil=0.000> the <sil=0.000> called <sil=0.000> function <sil=0.000> changes <sil=0.000> in <sil=0.000> that <sil=0.000> particular <sil=0.000> variable
and <sil=0.000> whatever <sil=0.000> changes <sil=0.000> are <sil=0.000> happening <sil=0.000> they <sil=0.000> are <sil=0.000> reflected <sil=0.000> in <sil=0.000> the <sil=0.000> main <sil=0.000> function <sil=1.000> ,COMMA  calling
function <sil=0.000> as <sil=0.000> well <sil=2.000> .PERIOD 
We <sil=0.000> will <sil=0.000> continue <sil=0.000> with <sil=0.000> this <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  we <sil=0.000> had <sil=0.000> looked <sil=0.000> at <sil=0.000> parameter <sil=0.000> passing <sil=0.000> and <sil=0.000> we <sil=0.000> have <sil=0.000> looked <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> seen <sil=0.000> that <sil=0.000> the
difference <sil=0.000> between <sil=0.000> call <sil=0.000> by <sil=0.000> value <sil=0.000> and <sil=0.000> call <sil=0.000> by <sil=0.000> difference <sil=0.000> and <sil=0.000> we <sil=0.000> have <sil=0.000> see <sil=0.000> quite <sil=0.000> a few
examples <sil=0.000> to <sil=0.000> be <sil=0.000> specific <sil=0.000> 3 examples <sil=0.000> on <sil=0.000> call <sil=0.000> by <sil=0.000> value <sil=0.000> how <sil=2.000> .PERIOD  And <sil=0.000> also <sil=0.000> another <sil=0.000> thing <sil=0.000> that
was <sil=0.000> supposed <sil=0.000> to <sil=0.000> be <sil=0.000> noted <sil=0.000> I hope <sil=0.000> you <sil=0.000> have <sil=0.000> noted <sil=0.000> that <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> the <sil=0.000> scope <sil=0.000> of <sil=0.000> variables <sil=2.000> .PERIOD  That
whenever <sil=0.000> there <sil=0.000> is <sil=0.000> an <sil=0.000> x in <sil=0.000> the <sil=0.000> main <sil=0.000> function <sil=0.000> and <sil=0.000> the <sil=0.000> x in <sil=0.000> the <sil=0.000> called <sil=0.000> function <sil=0.000> then <sil=0.000> these
two <sil=0.000> x s <sil=0.000> are <sil=0.000> different <sil=2.000> .PERIOD  The <sil=0.000> x that <sil=0.000> is <sil=0.000> defined <sil=0.000> in <sil=0.000> the <sil=0.000> called <sil=0.000> function <sil=0.000> is <sil=0.000> a separate <sil=0.000> location
than <sil=0.000> the <sil=0.000> x in <sil=0.000> the <sil=0.000> main <sil=0.000> function <sil=0.000> and <sil=0.000> that <sil=0.000> the <sil=0.000> life <sil=0.000> of <sil=0.000> that <sil=0.000> variable <sil=0.000> ends <sil=0.000> with <sil=0.000> the <sil=0.000> end <sil=0.000> of <sil=0.000> the
function <sil=1.000> ,COMMA  right <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> these <sil=0.000> example <sil=1.000> ,COMMA  you <sil=0.000> yourself <sil=0.000> will <sil=0.000> be <sil=0.000> able <sil=0.000> to <sil=0.000> trace <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> give <sil=0.000> you
some <sil=0.000> time <sil=0.000> to <sil=0.000> trace <sil=0.000> this <sil=0.000> through <sil=0.000> and <sil=0.000> then <sil=0.000> we <sil=0.000> will <sil=0.000> continue <sil=2.000> .PERIOD  Look <sil=0.000> at <sil=0.000> this <sil=0.000> function <sil=0.000> carefully
and <sil=0.000> do <sil=0.000> not <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=0.000> green <sil=0.000> part <sil=1.000> ,COMMA  do <sil=0.000> not <sil=0.000> look <sil=0.000> at <sil=0.000> the <sil=0.000> green <sil=0.000> part <sil=0.000> yourself <sil=0.000> and <sil=0.000> try <sil=0.000> to
without <sil=0.000> looking <sil=0.000> at <sil=0.000> that <sil=0.000> try <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> what <sil=0.000> the <sil=0.000> values <sil=0.000> will <sil=0.000> be <sil=0.000> for <sil=0.000> the <sil=0.000> different <sil=0.000> printf
statements <sil=2.000> .PERIOD 

Let <sil=0.000> us <sil=0.000> start <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> got <sil=0.000> x assigned <sil=0.000> to <sil=0.000> 10 <sil=0.000> and <sil=0.000> y assigned <sil=0.000> to <sil=0.000> 5 <sil=1.000> ,COMMA  x <sil=0.000> and <sil=0.000> y <sil=1.000> ,COMMA  x <sil=0.000> is <sil=0.000> 10 <sil=0.000> and <sil=0.000> y
is <sil=0.000> 5 <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  so <sil=0.000> when <sil=0.000> the <sil=0.000> I printf <sil=0.000> do <sil=0.000> this <sil=0.000> printf <sil=0.000> x is <sil=0.000> printed <sil=0.000> to <sil=0.000> be <sil=0.000> 10 <sil=0.000> y is <sil=0.000> printed <sil=0.000> to <sil=0.000> be <sil=0.000> 5 fine <sil=1.000> ,COMMA 
no <sil=0.000> issue <sil=2.000> .PERIOD  Then <sil=0.000> I call <sil=0.000> a function <sil=0.000> interchange <sil=0.000> x y <sil=2.000> .PERIOD  Look <sil=0.000> at <sil=0.000> this <sil=0.000> the <sil=0.000> type <sil=0.000> of <sil=0.000> this <sil=0.000> function
interchange <sil=0.000> the <sil=0.000> type <sil=0.000> of <sil=0.000> this <sil=0.000> function <sil=0.000> interchange <sil=0.000> is <sil=0.000> void <sil=0.000> because <sil=0.000> that <sil=0.000> immediately <sil=0.000> tells <sil=0.000> us
that <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> going <sil=0.000> to <sil=0.000> return <sil=0.000> anything <sil=0.000> it <sil=0.000> is <sil=0.000> going <sil=0.000> to <sil=0.000> do <sil=0.000> something <sil=0.000> as <sil=0.000> the <sil=0.000> name <sil=0.000> implies <sil=0.000> it <sil=0.000> is
going <sil=0.000> to <sil=0.000> interchange <sil=0.000> x and <sil=0.000> y <sil=2.000> .PERIOD  And <sil=0.000> what <sil=0.000> are <sil=0.000> the <sil=0.000> parameters <sil=0.228> ?QUESTIONMARK  Parameters <sil=0.000> are <sil=0.000> x and <sil=0.000> y this
is <sil=0.000> the <sil=0.000> argument <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> I have <sil=0.000> got <sil=0.000> another <sil=0.000> set <sil=0.000> of <sil=0.000> x and <sil=0.000> y <sil=2.000> .PERIOD 
Again <sil=0.000> note <sil=0.000> that <sil=0.000> this <sil=0.000> x and <sil=0.000> y are <sil=0.000> different <sil=2.000> .PERIOD  Now <sil=0.000> I initialize <sil=0.000> temp <sil=1.000> ,COMMA  so <sil=0.000> temp <sil=0.000> is <sil=0.000> another
variable <sil=0.000> here <sil=0.000> temp <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  what <sil=0.000> I am <sil=0.000> doing <sil=0.000> here <sil=0.228> ?QUESTIONMARK  The <sil=0.000> first <sil=0.000> printf <sil=0.000> what <sil=0.000> is <sil=0.000> being <sil=0.000> done <sil=0.000> here
printf <sil=0.000> x equal <sil=0.000> to <sil=0.000> x and <sil=0.000> y equal <sil=0.000> to <sil=0.000> y which <sil=0.000> x and <sil=0.000> which <sil=0.000> y the <sil=0.000> x this <sil=0.000> x and <sil=0.000> this <sil=0.000> y <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA 
when <sil=0.000> I entered <sil=0.000> this <sil=0.000> function <sil=0.000> these <sil=0.000> values <sil=0.000> have <sil=0.000> been <sil=0.000> copied <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> printf <sil=0.000> will
simply <sil=0.000> print <sil=0.000> 10 <sil=0.000> and <sil=0.000> 5 no <sil=0.000> issue <sil=0.000> now <sil=0.000> temp <sil=0.000> is <sil=0.000> getting <sil=0.000> x <sil=1.000> ,COMMA  x <sil=0.000> was <sil=0.000> 10 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> put <sil=0.000> 10 <sil=0.000> here <sil=0.000> and
then <sil=0.000> x assigned <sil=0.000> y sorry <sil=0.000> y assigned <sil=0.000> x <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  the <sil=0.000> value <sil=0.000> of <sil=0.000> y I <sil=0.000> am <sil=0.000> still <sil=0.000> within <sil=0.000> the
function <sil=0.000> I am <sil=0.000> within <sil=0.000> the <sil=0.000> function <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> value <sil=0.000> is <sil=0.000> being <sil=0.000> assigned <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  by <sil=0.000> this <sil=0.000> statement
what <sil=0.000> happens <sil=0.000> this <sil=0.000> becomes <sil=0.000> 5 and <sil=0.000> this <sil=0.000> remains <sil=0.000> 5 right <sil=0.000> and <sil=0.000> then <sil=0.000> what <sil=0.000> is <sil=0.000> being <sil=0.000> done <sil=0.000> here <sil=0.000> y
assign <sil=0.000> temp <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  this <sil=0.000> temp <sil=0.000> is <sil=0.000> becoming <sil=0.000> 5 right <sil=0.000> temp <sil=0.000> is <sil=0.000> becoming <sil=0.000> sorry <sil=1.000> ,COMMA  sorry <sil=0.000> I
am <sil=0.000> sorry <sil=0.000> absolutely <sil=0.000> sorry <sil=0.000> this <sil=0.000> was <sil=0.000> 10 <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  for <sil=0.000> this <sil=0.000> statement <sil=0.000> temp <sil=0.000> is <sil=0.000> going <sil=0.000> to <sil=0.000> y <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  y <sil=0.000> will <sil=0.000> be <sil=0.000> changed <sil=0.000> to <sil=0.000> 10 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here
I <sil=0.000> find <sil=0.000> 5 and <sil=0.000> 10 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> a when <sil=0.000> it <sil=0.000> entered <sil=0.000> here <sil=0.000> I could <sil=0.000> see <sil=0.000> 10 <sil=0.000> and <sil=0.000> 5 and <sil=0.000> so <sil=0.000> when <sil=0.000> I come
and <sil=0.000> print <sil=0.000> from <sil=0.000> here <sil=0.000> x will <sil=0.000> be <sil=0.000> 5 and <sil=0.000> y will <sil=0.000> be <sil=0.000> 10 <sil=1.000> ,COMMA  I <sil=0.000> come <sil=0.000> out <sil=0.000> of <sil=0.000> the <sil=0.000> program <sil=0.000> and <sil=0.000> printf <sil=0.000> x
and <sil=0.000> y <sil=2.000> .PERIOD  What <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=0.228> ?QUESTIONMARK  My <sil=0.000> god <sil=1.000> ,COMMA  what <sil=0.000> I find <sil=0.000> is <sil=0.000> x is <sil=0.000> being <sil=0.000> printed <sil=0.000> as <sil=0.000> 10 <sil=0.000> and <sil=0.000> y is
being <sil=0.000> printed <sil=0.000> as <sil=0.000> 5 as <sil=0.000> it <sil=0.000> was <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  no <sil=0.000> change <sil=0.000> has <sil=0.000> actually <sil=0.000> taken <sil=0.000> place <sil=2.000> .PERIOD  Why <sil=0.000> did <sil=0.000> it
happen <sil=0.000> like <sil=0.000> this <sil=0.228> ?QUESTIONMARK  You <sil=0.000> can <sil=0.000> immediately <sil=0.000> see <sil=0.000> the <sil=0.000> reason <sil=0.000> that <sil=0.000> whatever <sil=0.000> change <sil=0.000> took <sil=0.000> place
took <sil=0.000> place <sil=0.000> here <sil=0.000> inside <sil=0.000> the <sil=0.000> function <sil=0.000> and <sil=0.000> this <sil=0.000> actually <sil=0.000> tells <sil=0.000> you <sil=0.000> the <sil=0.000> importance <sil=0.000> of <sil=0.000> the <sil=0.000> scope
of <sil=0.000> variables <sil=2.000> .PERIOD  These <sil=0.000> variables <sil=0.000> scope <sil=0.000> ended <sil=0.000> with <sil=0.000> this <sil=0.000> function <sil=0.000> and <sil=0.000> their <sil=0.000> change <sil=0.000> was <sil=0.000> not
reflected <sil=0.000> in <sil=0.000> the <sil=0.000> main <sil=0.000> here <sil=0.000> that <sil=0.000> is <sil=0.000> why <sil=0.000> although <sil=0.000> I did <sil=0.000> it <sil=0.000> here <sil=0.000> it <sil=0.000> would <sil=0.000> not <sil=0.000> change <sil=2.000> .PERIOD 
However <sil=1.000> ,COMMA  suppose <sil=0.000> let <sil=0.000> us <sil=0.000> do <sil=0.000> some <sil=0.000> intellectual <sil=0.000> exercise <sil=0.000> here <sil=2.000> .PERIOD 

Suppose <sil=0.000> x was <sil=0.000> 10 <sil=0.000> and <sil=0.000> y was <sil=0.000> 5 and <sil=0.000> there <sil=0.000> was <sil=0.000> a temp <sil=1.000> ,COMMA  now <sil=0.000> temp <sil=0.000> is <sil=0.000> inside <sil=0.000> the <sil=0.000> function <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
I <sil=0.000> will <sil=0.000> use <sil=0.000> different <sil=0.000> colours <sil=0.000> for <sil=0.000> that <sil=0.000> I will <sil=1.000> ,COMMA  now <sil=0.000> although <sil=0.000> I remind <sil=0.000> you <sil=0.000> that <sil=0.000> C does <sil=0.000> not
allow <sil=0.000> call <sil=0.000> by <sil=0.000> reference <sil=1.000> ,COMMA  but <sil=0.000> just <sil=0.000> to <sil=0.000> see <sil=0.000> whether <sil=0.000> you <sil=0.000> have <sil=0.000> understood <sil=0.000> call <sil=0.000> by <sil=0.000> reference
properly <sil=2.000> .PERIOD  Suppose <sil=0.000> we <sil=0.000> are <sil=0.000> allowed <sil=0.000> to <sil=0.000> use <sil=0.000> call <sil=0.000> by <sil=0.000> reference <sil=0.000> then <sil=0.000> my <sil=0.000> main <sil=0.000> program <sil=0.000> has <sil=0.000> got
this <sil=0.000> x and <sil=0.000> y <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> comes <sil=0.000> here <sil=0.000> prints <sil=0.000> say <sil=0.000> prints <sil=0.000> x and <sil=0.000> y <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  10 <sil=0.000> and <sil=0.000> 5 are <sil=0.000> printed <sil=0.000> x equal
to <sil=0.000> 10 <sil=0.000> y is <sil=0.000> equal <sil=0.000> to <sil=0.000> 5 and <sil=0.000> it <sil=0.000> calls <sil=0.000> interchange <sil=0.000> all <sil=0.000> right <sil=1.000> ,COMMA  it <sil=0.000> calls <sil=0.000> interchange <sil=2.000> .PERIOD 
And <sil=0.000> suppose <sil=0.000> just <sil=0.000> suppose <sil=0.000> that <sil=0.000> this <sil=0.000> call <sil=0.000> has <sil=0.000> been <sil=0.000> done <sil=0.000> by <sil=0.000> call <sil=0.000> by <sil=0.000> reference <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> has
been <sil=0.000> passed <sil=0.000> here <sil=0.228> ?QUESTIONMARK  The <sil=0.000> address <sil=0.000> of <sil=0.000> this <sil=0.000> and <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> this <sil=0.000> not <sil=0.000> the <sil=0.000> values <sil=1.000> ,COMMA  so <sil=0.000> no <sil=0.000> other
copies <sil=0.000> have <sil=0.000> been <sil=0.000> made <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> the <sil=0.000> local <sil=0.000> variable <sil=0.000> temp <sil=0.000> and <sil=0.000> here <sil=0.000> I do <sil=0.000> temp <sil=0.000> is
assigned <sil=0.000> x <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  temp <sil=0.000> gets <sil=0.000> 10 <sil=0.000> then <sil=0.000> x assigned <sil=0.000> y <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> my <sil=0.000> x and <sil=0.000> what <sil=0.000> is <sil=0.000> my <sil=0.000> y <sil=0.228> ?QUESTIONMARK 
The <sil=0.000> content <sil=0.000> of <sil=0.000> this <sil=0.000> address <sil=0.000> which <sil=0.000> have <sil=0.000> been <sil=0.000> passed <sil=0.000> will <sil=0.000> go <sil=0.000> to <sil=0.000> the <sil=0.000> content <sil=0.000> of <sil=0.000> x <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this
will <sil=0.000> be <sil=0.000> 5 and <sil=0.000> then <sil=0.000> y will <sil=0.000> be <sil=0.000> assigned <sil=0.000> temp <sil=2.000> .PERIOD  What <sil=0.000> will <sil=0.000> happen <sil=0.228> ?QUESTIONMARK  <sil=2.000> .PERIOD 
This <sil=0.000> temp <sil=0.000> this <sil=0.000> value <sil=0.000> will <sil=0.000> go <sil=0.000> to <sil=0.000> the <sil=0.000> suppose <sil=0.000> I can <sil=0.000> make <sil=0.000> call <sil=0.000> by <sil=0.000> reference <sil=0.000> then <sil=0.000> this <sil=0.000> will <sil=0.000> go
to <sil=0.000> this <sil=0.000> address <sil=1.000> ,COMMA  but <sil=0.000> if <sil=0.000> I just <sil=0.000> simply <sil=0.000> write <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=0.000> that <sil=0.000> does <sil=0.000> not <sil=0.000> mean <sil=0.000> it <sil=0.000> really <sil=0.000> does <sil=0.000> not
tell <sil=0.000> me <sil=0.000> whether <sil=0.000> I am <sil=0.000> saying <sil=0.000> that <sil=0.000> I am <sil=0.000> copying <sil=0.000> the <sil=0.000> from <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> actually <sil=0.000> copying
the <sil=0.000> value <sil=1.000> ,COMMA  but <sil=0.000> I am <sil=0.000> just <sil=0.000> taking <sil=0.000> telling <sil=0.000> a hypothetical <sil=0.000> case <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> 10 <sil=0.000> will <sil=0.000> go <sil=0.000> there <sil=0.000> and
this <sil=0.000> 5 would <sil=0.000> be <sil=0.000> changed <sil=2.000> .PERIOD  In <sil=0.000> that <sil=0.000> case <sil=0.000> when <sil=0.000> I come <sil=0.000> back <sil=0.000> from <sil=0.000> here <sil=0.000> and <sil=0.000> I print <sil=0.000> here <sil=0.000> then <sil=0.000> I
would <sil=0.000> have <sil=0.000> got <sil=0.000> the <sil=0.000> change <sil=0.000> scenario <sil=0.000> reflected <sil=1.000> ,COMMA  but <sil=0.000> the <sil=0.000> mechanism <sil=0.000> writing <sil=0.000> simply <sil=0.000> like <sil=0.000> this

in <sil=0.000> C means <sil=0.000> it <sil=0.000> is <sil=0.000> called <sil=0.000> by <sil=0.000> value <sil=0.000> not <sil=0.000> called <sil=0.000> by <sil=0.000> reference <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> being <sil=0.000> passed <sil=0.000> is
actually <sil=0.000> the <sil=0.000> value <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  if <sil=0.000> I could <sil=1.000> ,COMMA  if <sil=0.000> I could <sil=0.000> do <sil=0.000> that <sil=0.000> then <sil=0.000> it <sil=0.000> was <sil=0.000> possible <sil=0.000> to <sil=0.000> have <sil=0.000> that <sil=0.000> interchange <sil=0.000> and <sil=0.000> there <sil=0.000> is
a <sil=0.000> mechanism <sil=0.000> for <sil=0.000> passing <sil=0.000> the <sil=0.000> addresses <sil=0.000> and <sil=0.000> not <sil=0.000> the <sil=0.000> actual <sil=0.000> values <sil=0.000> by <sil=0.000> using <sil=0.000> a concept
called <sil=0.000> I mean <sil=0.000> structure <sil=0.000> called <sil=0.000> pointers <sil=0.000> which <sil=0.000> are <sil=0.000> nothing <sil=1.000> ,COMMA  but <sil=0.000> addresses <sil=0.000> we <sil=0.000> will <sil=0.000> have <sil=0.000> to
we <sil=0.000> will <sil=0.000> see <sil=0.000> that <sil=0.000> later <sil=0.000> if <sil=0.000> time <sil=0.000> permits <sil=2.000> .PERIOD  But <sil=0.000> in <sil=0.000> general <sil=0.000> remember <sil=0.000> that <sil=0.000> this <sil=0.000> interchange <sil=0.000> has
not <sil=0.000> been <sil=0.000> possible <sil=0.000> by <sil=0.000> call <sil=0.000> by <sil=0.000> value <sil=0.000> in <sil=0.000> the <sil=0.000> way <sil=0.000> we <sil=0.000> wrote <sil=0.000> the <sil=0.000> program <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  with <sil=0.000> this <sil=0.000> we
complete <sil=0.000> our <sil=0.000> discussion <sil=0.000> on <sil=0.000> parameter <sil=0.000> passing <sil=0.000> normally <sil=1.000> ,COMMA  but <sil=0.000> a distinction <sil=0.000> between
parameter <sil=0.000> passing <sil=0.000> by <sil=0.000> call <sil=0.000> by <sil=0.000> value <sil=0.000> and <sil=0.000> call <sil=0.000> by <sil=0.000> reference <sil=2.000> .PERIOD 

And <sil=0.000> we <sil=0.000> now <sil=0.000> start <sil=0.000> another <sil=0.000> very <sil=0.000> important <sil=0.000> point <sil=0.000> that <sil=0.000> is <sil=0.000> passing <sil=0.000> arrays <sil=0.000> to <sil=0.000> functions <sil=2.000> .PERIOD 

Now <sil=0.000> let <sil=0.000> us <sil=0.000> try <sil=0.000> to <sil=0.000> think <sil=2.000> .PERIOD  Here <sil=0.000> when <sil=0.000> we <sil=0.000> were <sil=0.000> having <sil=0.000> a variable <sil=0.000> x another <sil=0.000> variable <sil=0.000> y in <sil=0.000> the
called <sil=0.000> function <sil=1.000> ,COMMA  in <sil=0.000> the <sil=0.000> caller <sil=0.000> function <sil=0.000> and <sil=0.000> I was <sil=0.000> having <sil=0.000> in <sil=0.000> my <sil=0.000> called <sil=0.000> function <sil=0.000> two <sil=0.000> other
variables <sil=0.000> a and <sil=0.000> b <sil=1.000> ,COMMA  then <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> this <sil=0.000> would <sil=0.000> be <sil=0.000> copied <sil=0.000> here <sil=0.000> and <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> this <sil=0.000> was
copied <sil=0.000> here <sil=2.000> .PERIOD  But <sil=0.000> suppose <sil=0.000> x is <sil=0.000> not <sil=0.000> an <sil=0.000> integer <sil=0.000> x is <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> 20 <sil=0.000> elements <sil=0.000> then <sil=0.000> all <sil=0.000> those <sil=0.000> 20
elements <sil=0.000> have <sil=0.000> to <sil=0.000> copy <sil=0.000> here <sil=0.000> and <sil=0.000> suppose <sil=0.000> this <sil=0.000> is <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> another <sil=0.000> 20 <sil=0.000> elements <sil=1.000> ,COMMA  so
another <sil=0.000> 20 <sil=0.000> elements <sil=0.000> I have <sil=0.000> to <sil=0.000> copy <sil=0.000> here <sil=0.000> right <sil=2.000> .PERIOD  C <sil=0.000> allows <sil=0.000> only <sil=0.000> for <sil=0.000> arrays <sil=0.000> the <sil=0.000> parameter
passing <sil=0.000> by <sil=0.000> difference <sil=2.000> .PERIOD  Now <sil=0.000> in <sil=0.000> order <sil=0.000> to <sil=0.000> understand <sil=0.000> that <sil=0.000> let <sil=0.000> us <sil=0.000> try <sil=0.000> to <sil=0.000> look <sil=0.000> at <sil=0.000> the <sil=0.000> structure
of <sil=0.000> an <sil=0.000> array <sil=2.000> .PERIOD 

Suppose <sil=0.000> I have <sil=0.000> got <sil=0.000> an <sil=0.000> array <sil=0.000> a 10 <sil=0.000> now <sil=0.000> I am <sil=0.000> not <sil=0.000> making <sil=0.000> a distinction <sil=0.000> between <sil=0.000> the <sil=0.000> size <sil=0.000> of
the <sil=0.000> array <sil=0.000> actual <sil=0.000> size <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=0.000> and <sil=0.000> the <sil=0.000> dimension <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=0.000> I am <sil=0.000> assuming <sil=0.000> that <sil=0.000> the
array <sil=0.000> a has <sil=0.000> got <sil=0.000> 10 <sil=0.000> elements <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> 1 2 <sil=0.000> 3 4 <sil=0.000> 5 6 <sil=0.000> 7 8 <sil=0.000> 9 10 <sil=0.000> all <sil=0.000> right <sil=0.000> and <sil=0.000> these <sil=0.000> are <sil=0.000> a 0
a <sil=0.000> 1 a <sil=0.000> 2 up <sil=0.000> to <sil=0.000> a 9 <sil=1.000> ,COMMA  right <sil=0.000> these <sil=0.000> are <sil=0.000> the <sil=0.000> locations <sil=0.000> we <sil=0.000> know <sil=0.000> that <sil=2.000> .PERIOD  We <sil=0.000> also <sil=0.000> know <sil=0.000> that <sil=0.000> an <sil=0.000> array
is <sil=0.000> allocated <sil=0.000> contiguous <sil=0.000> memory <sil=0.000> locations <sil=0.000> by <sil=0.000> the <sil=0.000> compiler <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  all <sil=0.000> these <sil=0.000> are <sil=0.000> contiguous <sil=0.000> therefore <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> sufficient <sil=0.000> to <sil=0.000> know <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> the <sil=0.000> starting
location <sil=1.000> ,COMMA  suppose <sil=0.000> this <sil=0.000> is <sil=0.000> 1000 <sil=2.000> .PERIOD  If <sil=0.000> this <sil=0.000> is <sil=0.000> 1000 <sil=0.000> and <sil=0.000> if <sil=0.000> it <sil=0.000> be <sil=0.000> an <sil=0.000> integer <sil=0.000> and <sil=0.000> I assume <sil=0.000> that <sil=0.000> an
integer <sil=1.000> ,COMMA  integer <sil=0.000> takes <sil=0.000> 2 bytes <sil=0.000> say <sil=0.000> 16 <sil=0.000> bits <sil=0.000> and <sil=0.000> then <sil=0.000> this <sil=0.000> will <sil=0.000> be <sil=0.000> 1002 <sil=0.000> this <sil=0.000> will <sil=0.000> be <sil=0.000> 1004
etcetera <sil=0.000> I can <sil=0.000> compute <sil=0.000> any <sil=0.000> particular <sil=0.000> address <sil=1.000> ,COMMA  any <sil=0.000> particular <sil=0.000> address <sil=0.000> of <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> I say <sil=0.000> a
5 <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> this <sil=0.000> a 5 <sil=0.000> address <sil=0.000> of <sil=0.000> a 5 <sil=0.000> can <sil=0.000> be <sil=0.000> easily <sil=0.000> computed <sil=0.000> as <sil=0.000> the <sil=0.000> starting <sil=0.000> address
thousand <sil=0.000> whatever <sil=0.000> is <sil=0.000> a starting <sil=0.000> address <sil=0.000> plus <sil=0.000> the <sil=0.000> index <sil=0.000> is <sil=0.000> 5 <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  and <sil=0.000> the <sil=0.000> size <sil=0.000> of
integer <sil=0.000> which <sil=0.000> I know <sil=0.000> in <sil=0.000> a particular <sil=0.000> machine <sil=0.000> say <sil=0.000> 2 bytes <sil=0.000> times <sil=0.000> how <sil=0.000> much <sil=0.000> will <sil=0.000> be <sil=0.000> 106 <sil=1.000> ,COMMA 
108 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> will <sil=0.000> be <sil=0.000> 2 into <sil=0.000> whatever <sil=0.000> is <sil=0.000> a index <sil=0.000> minus <sil=0.000> 1 <sil=0.354> ;SEMICOLON  sorry <sil=0.000> a 5 <sil=1.000> ,COMMA  a <sil=0.000> 5 will <sil=0.000> be <sil=0.000> the <sil=0.000> 6th
element <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  5 <sil=0.000> times <sil=0.000> whatever <sil=0.000> this <sil=0.000> is <sil=0.000> suppose <sil=0.000> this <sil=0.000> i <sil=1.000> ,COMMA  i <sil=0.000> times <sil=0.000> i right <sil=0.000> size <sil=0.000> of <sil=0.000> the <sil=0.000> integer
times <sil=0.000> i <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> 1000 <sil=0.000> plus <sil=0.000> 2 times <sil=0.000> 5 <sil=1.000> ,COMMA  1010 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> a 0 <sil=0.000> a 2 <sil=0.000> a 0 <sil=0.000> will <sil=0.000> be <sil=0.000> 1006 <sil=1.000> ,COMMA  a <sil=0.000> 4 will <sil=0.000> be
1008 <sil=0.000> and <sil=0.000> a 5 <sil=0.000> will <sil=0.000> be <sil=0.000> 1010 <sil=2.000> .PERIOD  Since <sil=0.000> it <sil=0.000> is <sil=0.000> contiguous <sil=0.000> it <sil=0.000> is <sil=0.000> sufficient <sil=0.000> for <sil=0.000> me <sil=0.000> to <sil=0.000> know <sil=0.000> the
starting <sil=0.000> address <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=1.000> ,COMMA  therefore <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> good <sil=0.000> enough <sil=0.000> to <sil=0.000> establish <sil=0.000> the <sil=0.000> correspondence
between <sil=0.000> the <sil=0.000> name <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=0.000> and <sil=0.000> the <sil=0.000> starting <sil=0.000> point <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=2.000> .PERIOD  What <sil=0.000> I mean <sil=0.000> by <sil=0.000> that <sil=0.000> is
again <sil=0.000> I draw <sil=0.000> this <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  I <sil=0.000> named <sil=0.000> the <sil=0.000> array <sil=0.000> differently <sil=0.000> A and <sil=0.000> suppose <sil=0.000> it <sil=0.000> has <sil=0.000> got <sil=0.000> 5 elements <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD  Now <sil=0.000> A
and <sil=0.000> A 0 <sil=0.000> are <sil=0.000> treated <sil=0.000> to <sil=0.000> be <sil=0.000> synonymous <sil=2.000> .PERIOD  When <sil=0.000> I say <sil=0.000> a <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> actually <sil=0.000> referring
to <sil=0.000> this <sil=0.000> element <sil=1.000> ,COMMA  this <sil=0.000> address <sil=1.000> ,COMMA  not <sil=0.000> this <sil=0.000> element <sil=0.000> this <sil=0.000> address <sil=2.000> .PERIOD  And <sil=0.000> since <sil=0.000> I know <sil=0.000> that
therefore <sil=1.000> ,COMMA  A <sil=0.000> i depending <sil=0.000> on <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> i <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> compute <sil=0.000> where <sil=0.000> the <sil=0.000> actual <sil=0.000> location <sil=0.000> will
be <sil=0.000> this <sil=0.000> is <sil=0.000> the <sil=0.000> fundamental <sil=0.000> concept <sil=0.000> we <sil=0.000> need <sil=0.000> to <sil=0.000> understand <sil=1.000> ,COMMA  all <sil=0.000> right <sil=2.000> .PERIOD  Therefore <sil=1.000> ,COMMA  we <sil=0.000> can
pass <sil=0.000> the <sil=0.000> an <sil=0.000> array <sil=0.000> to <sil=0.000> a function <sil=0.000> as <sil=0.000> ordinary <sil=0.000> arguments <sil=2.000> .PERIOD 
For <sil=0.000> example <sil=1.000> ,COMMA  is <sil=0.000> factor <sil=0.000> whether <sil=0.000> x i <sil=0.000> is <sil=0.000> a factor <sil=0.000> of <sil=0.000> x 0 <sil=1.000> ,COMMA  suppose <sil=0.000> I want <sil=0.000> to <sil=0.000> do <sil=0.000> that <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you
see <sil=0.000> is <sil=0.000> factor <sil=0.000> earlier <sil=0.000> I did <sil=0.000> x or <sil=0.000> y here <sil=0.000> I am <sil=0.000> writing <sil=0.000> x i <sil=1.000> ,COMMA  x <sil=0.000> 0 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  x <sil=0.000> i is <sil=0.000> what <sil=0.228> ?QUESTIONMARK  Suppose <sil=0.000> x is <sil=0.000> an
integer <sil=0.000> array <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  x <sil=0.000> i is <sil=0.000> an <sil=0.000> integer <sil=0.000> x 0 <sil=0.000> is <sil=0.000> another <sil=0.000> integer <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> simply <sil=0.000> pass <sil=0.000> this <sil=1.000> ,COMMA  sin <sil=0.000> of
a <sil=0.000> particular <sil=0.000> angle <sil=2.000> .PERIOD  Where <sil=0.000> is <sil=0.000> that <sil=0.000> angle <sil=0.228> ?QUESTIONMARK  In <sil=0.000> an <sil=0.000> array <sil=0.000> x an <sil=0.000> array <sil=0.000> x is <sil=0.000> there <sil=0.000> and <sil=0.000> in <sil=0.000> that <sil=0.000> the
fifth <sil=1.000> ,COMMA  sixth <sil=0.000> element <sil=0.000> I am <sil=0.000> taking <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> element <sil=0.000> is <sil=0.000> coming <sil=0.000> as <sil=0.000> the <sil=0.000> parameter <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> us
proceed <sil=0.000> a little <sil=0.000> further <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> for <sil=0.000> the <sil=0.000> individual <sil=0.000> elements <sil=0.000> x i <sil=0.000> or <sil=0.000> x 5 <sil=0.000> x 0 <sil=0.000> I am <sil=0.000> just <sil=0.000> passing <sil=0.000> an <sil=0.000> element <sil=0.000> and <sil=0.000> if
it <sil=0.000> is <sil=0.000> an <sil=0.000> integer <sil=0.000> array <sil=0.000> then <sil=0.000> an <sil=0.000> integer <sil=0.000> is <sil=0.000> being <sil=0.000> passed <sil=0.000> if <sil=0.000> it <sil=0.000> is <sil=0.000> a floating <sil=0.000> array <sil=1.000> ,COMMA  floating <sil=0.000> point
array <sil=0.000> then <sil=0.000> a float <sil=0.000> will <sil=0.000> be <sil=0.000> passed <sil=1.000> ,COMMA  but <sil=0.000> what <sil=0.000> if <sil=0.000> I want <sil=0.000> to <sil=0.000> pass <sil=0.000> the <sil=0.000> entire <sil=0.000> array <sil=0.000> to <sil=0.000> a function <sil=2.000> .PERIOD 
That <sil=0.000> is <sil=0.000> what <sil=0.000> I just <sil=0.000> now <sil=0.000> explained <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> an <sil=0.000> array <sil=0.000> name <sil=0.000> like <sil=0.000> A can <sil=0.000> be <sil=0.000> used <sil=0.000> as <sil=0.000> an
argument <sil=0.000> to <sil=0.000> a function <sil=0.000> because <sil=0.000> A essentially <sil=0.000> means <sil=0.000> A 0 <sil=0.000> and <sil=0.000> if <sil=0.000> I can <sil=0.000> pass <sil=0.000> A 0 <sil=0.000> the <sil=0.000> address
of <sil=0.000> A 0 <sil=0.000> is <sil=0.000> known <sil=0.000> then <sil=0.000> all <sil=0.000> the <sil=0.000> elements <sil=0.000> are <sil=0.000> known <sil=0.000> because <sil=0.000> they <sil=0.000> are <sil=0.000> contiguous <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  the <sil=0.000> way <sil=0.000> it <sil=0.000> is <sil=0.000> passed <sil=0.000> differs <sil=0.000> from <sil=0.000> that <sil=0.000> of <sil=0.000> the <sil=0.000> ordinary <sil=0.000> variables <sil=2.000> .PERIOD  Why <sil=0.228> ?QUESTIONMARK  Here <sil=0.000> when <sil=0.000> I
have <sil=0.000> got <sil=0.000> an <sil=0.000> array <sil=0.000> and <sil=0.000> array <sil=0.000> A with <sil=0.000> A 0 <sil=0.000> when <sil=0.000> I am <sil=0.000> passing <sil=0.000> the <sil=0.000> array <sil=0.000> suppose <sil=0.000> somewhere
in <sil=0.000> my <sil=0.000> function <sil=0.000> f I <sil=0.000> am <sil=0.000> passing <sil=0.000> the <sil=0.000> array <sil=0.000> A and <sil=0.000> just <sil=0.000> to <sil=0.000> say <sil=0.000> that <sil=0.000> it <sil=0.000> is <sil=0.000> an <sil=0.000> area <sil=0.000> I just <sil=0.000> do
something <sil=0.000> like <sil=0.000> this <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> not <sil=0.000> the <sil=0.000> correct <sil=0.000> syntax <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> show <sil=0.000> you <sil=0.000> the <sil=0.000> syntax <sil=0.000> a little
later <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  you <sil=0.000> see <sil=0.000> I write <sil=0.000> it <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD  Now <sil=0.000> that <sil=0.000> means <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> passing <sil=0.000> A 0 <sil=1.000> ,COMMA  but <sil=0.000> if <sil=0.000> I
pass <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> A 0 <sil=0.000> which <sil=0.000> might <sil=0.000> be <sil=0.000> a 50 <sil=0.000> I have <sil=0.000> got <sil=0.000> no <sil=0.000> clue <sil=0.000> about <sil=0.000> the <sil=0.000> other <sil=0.000> values <sil=0.000> I am
not <sil=0.000> passing <sil=0.000> all <sil=0.000> the <sil=0.000> values <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> do <sil=0.000> I have <sil=0.000> to <sil=0.000> pass <sil=0.228> ?QUESTIONMARK  if <sil=0.000> I pass <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> A 0 <sil=0.000> address
of <sil=0.000> A 0 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> what <sil=0.000> is <sil=0.000> being <sil=0.000> passed <sil=0.000> is <sil=0.000> address <sil=0.000> of <sil=0.000> A 0 <sil=0.000> then <sil=0.000> I can <sil=0.000> get <sil=0.000> access <sil=0.000> to <sil=0.000> all <sil=0.000> these
elements <sil=0.000> A i <sil=1.000> ,COMMA  A <sil=0.000> 1 <sil=1.000> ,COMMA  A <sil=0.000> 2 anything <sil=0.000> because <sil=0.000> I can <sil=0.000> compute <sil=0.000> the <sil=0.000> address <sil=0.000> very <sil=0.000> easily <sil=0.000> as <sil=0.000> I have
shown <sil=0.000> just <sil=0.000> now <sil=1.000> ,COMMA  all <sil=0.000> right <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> do <sil=0.000> that <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> an <sil=0.000> example <sil=0.000> this <sil=0.000> is <sil=0.000> a case <sil=0.000> where <sil=0.000> we <sil=0.000> call <sil=0.000> by <sil=0.000> reference <sil=0.000> we <sil=0.000> actually <sil=0.000> will <sil=0.000> pass <sil=0.000> the
address <sil=0.000> and <sil=0.000> not <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> A 0 <sil=2.000> .PERIOD  We <sil=0.000> are <sil=0.000> passing <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> A 0 <sil=0.000> and <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> A
0 <sil=0.000> is <sil=0.000> the <sil=0.000> same <sil=0.000> as <sil=0.000> the <sil=0.000> name <sil=0.000> A this <sil=0.000> is <sil=0.000> a very <sil=0.000> fundamental <sil=0.000> concept <sil=0.000> and <sil=0.000> let <sil=0.000> us <sil=0.000> try <sil=0.000> to
understand <sil=0.000> this <sil=2.000> .PERIOD  How <sil=0.000> is <sil=0.000> it <sil=0.000> passed <sil=0.228> ?QUESTIONMARK  The <sil=0.000> array <sil=0.000> name <sil=0.000> must <sil=0.000> appear <sil=0.000> by <sil=0.000> itself <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  we <sil=0.000> are
talking <sil=0.000> about <sil=0.000> the <sil=0.000> some <sil=0.000> syntaxes <sil=1.000> ,COMMA  the <sil=0.000> array <sil=0.000> name <sil=0.000> must <sil=0.000> appear <sil=0.000> by <sil=0.000> itself <sil=0.000> as <sil=0.000> argument
without <sil=0.000> brackets <sil=0.000> or <sil=0.000> subscripts <sil=0.000> the <sil=0.000> corresponding <sil=0.000> formal <sil=0.000> argument <sil=0.000> is <sil=0.000> written <sil=0.000> in <sil=0.000> the <sil=0.000> same
manner <sil=2.000> .PERIOD  Let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> an <sil=0.000> example <sil=2.000> .PERIOD 

Say <sil=0.000> here <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> going <sil=0.000> to <sil=0.000> pass <sil=0.000> the <sil=0.000> whole <sil=0.000> array <sil=0.000> as <sil=0.000> a parameter <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> declared <sil=0.000> constant
int <sil=0.000> a size <sil=0.000> 5 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  something <sil=0.000> some <sil=0.000> variable <sil=0.000> a size <sil=0.000> is <sil=0.000> assigned <sil=0.000> 5 <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  float <sil=0.000> average <sil=0.000> is <sil=0.000> a
function <sil=0.000> which <sil=0.000> will <sil=0.000> which <sil=0.000> is <sil=0.000> taking <sil=0.000> as <sil=0.000> parameter <sil=1.000> ,COMMA  sorry <sil=0.000> which <sil=0.000> is <sil=0.000> taking <sil=0.000> as <sil=0.000> parameter <sil=0.000> an
array <sil=0.000> B all <sil=0.000> right <sil=1.000> ,COMMA  just <sil=0.000> the <sil=0.000> name <sil=0.000> of <sil=0.000> the <sil=0.000> B only <sil=0.000> array <sil=0.000> name <sil=0.000> or <sil=0.000> address <sil=0.000> of <sil=0.000> B is <sil=0.000> passed <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA 
this <sil=0.000> symbol <sil=0.000> is <sil=0.000> mentioned <sil=0.000> to <sil=0.000> indicate <sil=0.000> that <sil=0.000> this <sil=0.000> is <sil=0.000> an <sil=0.000> array <sil=0.000> right <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> see <sil=0.000> what <sil=0.000> is
happening <sil=0.000> int <sil=0.000> i total <sil=0.000> 0 <sil=1.000> ,COMMA  for <sil=0.000> i equals <sil=0.000> 0 i <sil=0.000> less <sil=0.000> than <sil=0.000> a size <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  less <sil=0.000> than <sil=0.000> 5 i <sil=0.000> plus <sil=0.000> plus
total <sil=0.000> equals <sil=0.000> total <sil=0.000> plus <sil=0.000> b i <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> happening <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> an <sil=0.000> array <sil=0.000> B <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> an <sil=0.000> array
A <sil=1.000> ,COMMA  a <sil=0.000> size <sil=0.000> the <sil=0.000> array <sil=0.000> size <sil=0.000> is <sil=0.000> 5 and <sil=0.000> all <sil=0.000> these <sil=0.000> elements <sil=0.000> are <sil=0.000> being <sil=0.000> added <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  all <sil=0.000> these <sil=0.000> elements <sil=0.000> are <sil=0.000> being <sil=0.000> added <sil=0.000> in <sil=0.000> this <sil=0.000> loop <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  B <sil=0.000> i only <sil=0.000> B 1 <sil=1.000> ,COMMA  B <sil=0.000> 2 <sil=1.000> ,COMMA  B <sil=0.000> 0 <sil=1.000> ,COMMA  B <sil=0.000> 1 <sil=1.000> ,COMMA  B <sil=0.000> 2 <sil=1.000> ,COMMA 
B <sil=0.000> 0 <sil=1.000> ,COMMA  B <sil=0.000> 4 they <sil=0.000> are <sil=0.000> being <sil=0.000> added <sil=0.000> to <sil=0.000> total <sil=0.000> and <sil=0.000> then <sil=0.000> I am <sil=0.000> returning <sil=0.000> what <sil=0.000> am <sil=0.000> I returning <sil=0.000> I am
returning <sil=0.000> total <sil=0.000> divided <sil=0.000> by <sil=0.000> a size <sil=0.000> now <sil=0.000> there <sil=0.000> is <sil=0.000> a new <sil=0.000> thing <sil=0.000> here <sil=0.000> also <sil=0.000> its <sil=0.000> better <sil=0.000> to <sil=0.000> look <sil=0.000> into
that <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  the <sil=0.000> array <sil=0.000> now <sil=0.000> average <sil=0.000> will <sil=0.000> be <sil=0.000> a floating <sil=0.000> point <sil=0.000> number <sil=0.000> and <sil=0.000> B is <sil=0.000> an <sil=0.000> integer
array <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  sometimes <sil=1.000> ,COMMA  when <sil=0.000> i <sil=1.000> ,COMMA  so <sil=0.000> what <sil=0.000> has <sil=0.000> been <sil=0.000> done <sil=0.000> here <sil=0.000> is <sil=0.000> float <sil=0.000> a size <sil=0.000> when <sil=0.000> we <sil=0.000> do <sil=0.000> this
float <sil=0.000> some <sil=0.000> variable <sil=0.000> x <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  this <sil=0.000> variable <sil=0.000> is <sil=0.000> being <sil=0.000> type <sil=0.000> casted <sil=0.000> is <sil=0.000> being <sil=0.000> made <sil=0.000> to <sil=0.000> be
represented <sil=0.000> as <sil=0.000> a float <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> it <sil=0.000> was <sil=0.000> 5 <sil=1.000> ,COMMA  5 <sil=0.000> suppose <sil=0.000> then <sil=0.000> float <sil=0.000> A size <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  since <sil=0.000> is <sil=0.000> 5 float <sil=0.000> A
size <sil=0.000> will <sil=0.000> make <sil=0.000> it <sil=0.000> 5 <sil=2.000> .PERIOD <sil=0.000> 0 <sil=2.000> .PERIOD 
And <sil=0.000> suppose <sil=0.000> the <sil=0.000> array <sil=0.000> was <sil=0.000> 1 2 <sil=0.000> 0 4 <sil=0.000> 5 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  9 <sil=0.000> to <sil=0.000> 11 <sil=1.000> ,COMMA  12 <sil=0.000> total <sil=0.000> was <sil=0.000> 12 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  float <sil=0.000> total <sil=0.000> will
make <sil=0.000> it <sil=0.000> 12 <sil=2.000> .PERIOD <sil=0.000> 0 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> casting <sil=0.000> twelve <sil=0.000> forcing <sil=0.000> it <sil=0.000> to <sil=0.000> be <sil=0.000> represented <sil=0.000> as <sil=0.000> a float <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  then <sil=0.000> 12 <sil=2.000> .PERIOD <sil=0.000> 0
is <sil=0.000> being <sil=0.000> divided <sil=0.000> by <sil=0.000> 5 with <sil=0.000> 5 <sil=2.000> .PERIOD <sil=0.000> 0 and <sil=0.000> I am <sil=0.000> getting <sil=0.000> the <sil=0.000> average <sil=0.000> and <sil=0.000> that <sil=0.000> average <sil=0.000> is <sil=0.000> being

returned <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> that <sil=0.000> was <sil=0.000> not <sil=0.000> our <sil=0.000> main <sil=0.000> contention <sil=0.000> here <sil=0.000> that <sil=0.000> is <sil=0.000> the <sil=0.000> purpose <sil=0.000> of <sil=0.000> this
float <sil=2.000> .PERIOD  But <sil=0.000> the <sil=0.000> main <sil=0.000> contention <sil=0.000> here <sil=0.000> is <sil=0.000> that <sil=0.000> I have <sil=0.000> passed <sil=0.000> this <sil=0.000> array <sil=0.000> B <sil=1.000> ,COMMA  but <sil=0.000> who <sil=0.000> passed <sil=0.000> it
the <sil=0.000> main <sil=0.000> function <sil=2.000> .PERIOD  Let <sil=0.000> us <sil=0.000> study <sil=0.000> the <sil=0.000> main <sil=0.000> function <sil=2.000> .PERIOD 
The <sil=0.000> main <sil=0.000> function <sil=0.000> x is <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> size <sil=0.000> A size <sil=0.000> that <sil=0.000> is <sil=0.000> 5 and <sil=0.000> x average <sil=0.000> is <sil=0.000> of <sil=0.000> some <sil=0.000> variable
and <sil=0.000> x has <sil=0.000> been <sil=0.000> assigned <sil=0.000> as <sil=0.000> 10 <sil=0.000> 20 <sil=0.000> 30 <sil=0.000> 40 <sil=0.000> 50 <sil=0.354> ;SEMICOLON  x <sil=0.000> average <sil=0.000> I will <sil=0.000> compute <sil=1.000> ,COMMA  but <sil=0.000> I am <sil=0.000> calling
this <sil=0.000> function <sil=0.000> average <sil=0.000> from <sil=0.000> here <sil=0.000> and <sil=0.000> I am <sil=0.000> passing <sil=0.000> x <sil=2.000> .PERIOD  What <sil=0.000> is <sil=0.000> x <sil=0.228> ?QUESTIONMARK  x <sil=0.000> is <sil=0.000> an <sil=0.000> array <sil=0.000> and <sil=0.000> that <sil=0.000> is
appearing <sil=0.000> just <sil=0.000> as <sil=0.000> a variable <sil=0.000> here <sil=0.000> and <sil=0.000> that <sil=0.000> is <sil=0.000> being <sil=0.000> accepted <sil=0.000> as <sil=0.000> B <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> a
correspondence <sil=0.000> between <sil=0.000> x and <sil=0.000> B <sil=1.000> ,COMMA  x <sil=0.000> is <sil=0.000> somewhere <sil=0.000> suppose <sil=0.000> starting <sil=0.000> with <sil=0.000> location <sil=0.000> 5000
and <sil=0.000> there <sil=0.000> are <sil=0.000> 5 elements <sil=0.000> as <sil=0.000> I been <sil=0.000> said <sil=0.000> here <sil=0.000> 10 <sil=1.000> ,COMMA  20 <sil=1.000> ,COMMA  30 <sil=1.000> ,COMMA  40 <sil=1.000> ,COMMA  50 <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  when <sil=0.000> this <sil=0.000> x is <sil=0.000> passed <sil=0.000> to <sil=0.000> B this <sil=0.000> function <sil=0.000> now <sil=0.000> knows <sil=0.000> that <sil=0.000> B is <sil=0.000> an <sil=0.000> array <sil=0.000> because <sil=0.000> it
had <sil=0.000> this <sil=0.000> thing <sil=0.000> and <sil=0.000> this <sil=0.000> 5000 <sil=0.000> is <sil=0.000> passed <sil=0.000> to <sil=0.000> B <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  B <sil=0.000> knows <sil=0.000> where <sil=0.000> is <sil=0.000> B <sil=1.000> ,COMMA  B <sil=0.000> is <sil=0.000> the <sil=0.000> same
array <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  whatever <sil=0.000> change <sil=0.000> I do <sil=0.000> here <sil=1.000> ,COMMA  suppose <sil=0.000> in <sil=0.000> this <sil=0.000> function <sil=0.000> instead <sil=0.000> of <sil=0.000> computing <sil=0.000> the
total <sil=0.000> if <sil=0.000> I had <sil=0.000> written <sil=0.000> this <sil=0.000> function <sil=0.000> in <sil=0.000> a different <sil=0.000> way <sil=0.000> for <sil=0.000> example <sil=0.000> let <sil=0.000> us <sil=0.000> do <sil=0.000> that <sil=0.000> and
suppose <sil=0.000> I have <sil=0.000> got <sil=0.000> this <sil=0.000> function <sil=0.000> x <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> this <sil=0.000> function <sil=0.000> x this <sil=0.000> array <sil=1.000> ,COMMA  sorry <sil=0.000> I am <sil=0.000> sorry <sil=0.000> x
where <sil=0.000> 10 <sil=0.000> 20 <sil=0.000> 30 <sil=0.000> 40 <sil=0.000> 50 <sil=0.000> are <sil=0.000> there <sil=0.000> and <sil=0.000> in <sil=0.000> my <sil=0.000> function <sil=0.000> change <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> also <sil=0.000> say <sil=0.000> void <sil=0.000> change <sil=0.000> int
B <sil=0.000> this <sil=0.000> and <sil=0.000> in <sil=0.000> the <sil=0.000> body <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=0.000> what <sil=0.000> I do <sil=0.000> is <sil=0.000> for <sil=0.000> please <sil=0.000> try <sil=0.000> to <sil=0.000> understand <sil=0.000> i assign <sil=0.000> 0
to <sil=0.000> this <sil=1.000> ,COMMA  i <sil=0.000> less <sil=0.000> than <sil=0.000> equal <sil=0.000> to <sil=0.000> A size <sil=0.000> or <sil=0.000> 5 whatever <sil=0.000> it <sil=0.000> is <sil=1.000> ,COMMA  i <sil=0.000> plus <sil=0.000> plus <sil=1.000> ,COMMA  B <sil=0.000> i plus <sil=0.000> plus <sil=0.000> say <sil=0.000> this <sil=2.000> .PERIOD 
What <sil=0.000> will <sil=0.000> happen <sil=0.228> ?QUESTIONMARK 

Inside <sil=0.000> this <sil=0.000> function <sil=0.000> change <sil=0.000> I will <sil=0.000> take <sil=0.000> the <sil=0.000> first <sil=0.000> one <sil=0.000> change <sil=0.000> it <sil=0.000> to <sil=0.000> 11 <sil=1.000> ,COMMA  this <sil=0.000> one <sil=0.000> will <sil=0.000> be <sil=0.000> 21 <sil=1.000> ,COMMA 
this <sil=0.000> one <sil=0.000> will <sil=0.000> be <sil=0.000> 31 <sil=1.000> ,COMMA  this <sil=0.000> only <sil=0.000> 41 <sil=1.000> ,COMMA  this <sil=0.000> only <sil=0.000> 51 <sil=0.000> and <sil=0.000> when <sil=0.000> I return <sil=0.000> I made <sil=0.000> a change <sil=0.000> in <sil=0.000> B <sil=1.000> ,COMMA  but
B <sil=0.000> and <sil=0.000> x are <sil=0.000> the <sil=0.000> same <sil=0.000> because <sil=0.000> this <sil=0.000> address <sil=0.000> 5000 <sil=0.000> was <sil=0.000> passed <sil=0.000> to <sil=0.000> the <sil=0.000> function <sil=0.000> change <sil=0.000> and
this <sil=0.000> b got <sil=0.000> 5000 <sil=0.000> and <sil=0.000> so <sil=0.000> whatever <sil=0.000> change <sil=0.000> has <sil=0.000> been <sil=0.000> done <sil=0.000> here <sil=0.000> will <sil=0.000> be <sil=0.000> reflected <sil=0.000> in <sil=0.000> the <sil=0.000> main
function <sil=0.000> when <sil=0.000> I return <sil=1.000> ,COMMA  clear <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> the <sil=0.000> importance <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> I have <sil=0.000> called <sil=0.000> it <sil=0.000> with <sil=0.000> the <sil=0.000> actual <sil=0.000> array <sil=0.000> name <sil=0.000> here <sil=0.000> of
course <sil=1.000> ,COMMA  I <sil=0.000> computed <sil=0.000> a total <sil=0.000> and <sil=0.000> return <sil=0.000> some <sil=0.000> other <sil=0.000> value <sil=1.000> ,COMMA  but <sil=0.000> if <sil=0.000> I had <sil=0.000> just <sil=0.000> change <sil=0.000> it <sil=0.000> inside
this <sil=0.000> function <sil=0.000> I could <sil=0.000> have <sil=0.000> made <sil=0.000> it <sil=0.000> void <sil=0.000> function <sil=0.000> and <sil=0.000> the <sil=0.000> change <sil=0.000> would <sil=0.000> have <sil=0.000> been
automatically <sil=0.000> reflected <sil=0.000> in <sil=0.000> the <sil=0.000> name <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> you <sil=0.000> see <sil=0.000> we <sil=0.000> do <sil=0.000> not <sil=0.000> need <sil=0.000> to <sil=0.000> write <sil=0.000> the <sil=0.000> array <sil=0.000> size <sil=0.000> it <sil=0.000> works <sil=0.000> with <sil=0.000> arrays <sil=0.000> of <sil=0.000> any <sil=0.000> size <sil=2.000> .PERIOD 
For <sil=0.000> example <sil=1.000> ,COMMA  here <sil=0.000> void <sil=0.000> this <sil=0.000> etcetera <sil=0.000> where <sil=0.000> list <sil=0.000> is <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> 100 <sil=0.000> elements <sil=0.000> and <sil=0.000> average <sil=0.000> I
am <sil=0.000> calling <sil=0.000> here <sil=0.000> float <sil=0.000> average <sil=0.000> int <sil=0.000> a is <sil=0.000> an <sil=0.000> integer <sil=1.000> ,COMMA  and <sil=0.000> float <sil=0.000> x is <sil=0.000> map <sil=0.000> to <sil=0.000> list <sil=0.000> all <sil=0.000> right <sil=1.000> ,COMMA  x <sil=0.000> is <sil=0.000> an
array <sil=0.000> because <sil=0.000> here <sil=0.000> how <sil=0.000> is <sil=0.000> the <sil=0.000> correspondence <sil=0.000> done <sil=2.000> .PERIOD  This <sil=0.000> list <sil=1.000> ,COMMA  list <sil=0.000> is <sil=0.000> being <sil=0.000> mapped <sil=0.000> to <sil=0.000> this
same <sil=0.000> address <sil=0.000> is <sil=0.000> being <sil=0.000> passed <sil=0.000> and <sil=0.000> n is <sil=0.000> being <sil=0.000> passed <sil=0.000> to <sil=0.000> a how <sil=0.000> many <sil=0.000> elements <sil=0.000> are <sil=0.000> there <sil=1.000> ,COMMA  all
right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> need <sil=0.000> not <sil=0.000> specify <sil=0.000> the <sil=0.000> size <sil=0.000> because <sil=0.000> the <sil=0.000> size <sil=0.000> is <sil=0.000> already <sil=0.000> specified <sil=0.000> here <sil=2.000> .PERIOD  I <sil=0.000> have <sil=0.000> got
100 <sil=0.000> element <sil=0.000> array <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> my <sil=0.000> list <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> list <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> 100 <sil=0.000> element <sil=0.000> here <sil=0.000> I
know <sil=2.000> .PERIOD  What <sil=0.000> I have <sil=0.000> passed <sil=0.000> to <sil=0.000> x is <sil=0.000> just <sil=0.000> the <sil=0.000> address <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  whatever <sil=0.000> it <sil=0.000> is <sil=0.000> 100 <sil=0.000> or <sil=0.000> 150 <sil=0.000> that <sil=0.000> be
true <sil=0.000> for <sil=0.000> x also <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> do <sil=0.000> not <sil=0.000> need <sil=0.000> to <sil=0.000> write <sil=0.000> the <sil=0.000> size <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  similarly <sil=0.000> array <sil=0.000> is <sil=0.000> used <sil=0.000> as <sil=0.000> output <sil=0.000> parameters <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  suppose <sil=0.000> I am <sil=0.000> going <sil=0.000> to <sil=0.000> do <sil=0.000> vector
sum <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> two <sil=0.000> arrays <sil=0.000> a and <sil=0.000> b <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> I am <sil=0.000> doing <sil=0.000> here <sil=0.228> ?QUESTIONMARK  I <sil=0.000> have <sil=0.000> got <sil=0.000> two
arrays <sil=0.000> a <sil=1.000> ,COMMA  an <sil=0.000> integer <sil=0.000> array <sil=0.000> another <sil=0.000> integer <sil=0.000> array <sil=0.000> b and <sil=0.000> I am <sil=0.000> adding <sil=0.000> them <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> add <sil=0.000> this
element <sil=0.000> say <sil=0.000> 5 with <sil=0.000> this <sil=0.000> 7 and <sil=0.000> I have <sil=0.000> got <sil=0.000> another <sil=0.000> array <sil=0.000> v sum <sil=1.000> ,COMMA  v <sil=0.000> sum <sil=0.000> where <sil=0.000> the <sil=0.000> sum <sil=0.000> will
be <sil=0.000> stored <sil=0.000> so <sil=0.000> this <sil=0.000> will <sil=0.000> be <sil=0.000> 12 <sil=1.000> ,COMMA  if <sil=0.000> it <sil=0.000> was <sil=0.000> 6 and <sil=0.000> this <sil=0.000> was <sil=0.000> 5 here <sil=0.000> we <sil=0.000> will <sil=0.000> store <sil=0.000> I will <sil=0.000> add <sil=0.000> these
two <sil=0.000> and <sil=0.000> I will <sil=0.000> store <sil=0.000> 11 <sil=0.000> ok <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> see <sil=0.000> how <sil=0.000> the <sil=0.000> vector <sil=0.000> sum <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  vector <sil=0.000> sum <sil=0.000> will <sil=0.000> be <sil=0.000> void <sil=0.000> you <sil=0.000> know <sil=0.000> because <sil=0.000> it <sil=0.000> is
doing <sil=0.000> the <sil=0.000> addition <sil=0.000> and <sil=0.000> the <sil=0.000> addition <sil=0.000> is <sil=0.000> remaining <sil=0.000> in <sil=0.000> this <sil=0.000> vector <sil=0.000> sum <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> let <sil=0.000> us
start <sil=0.000> with <sil=0.000> the <sil=0.000> main <sil=0.000> function <sil=0.000> x is <sil=0.000> an <sil=0.000> array <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> actually <sil=0.000> x a <sil=0.000> or <sil=0.000> let <sil=0.000> me <sil=0.000> say <sil=0.000> let <sil=0.000> me <sil=0.000> put
the <sil=0.000> main <sil=0.000> function <sil=0.000> first <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> x in <sil=0.000> the <sil=0.000> main <sil=0.000> function <sil=0.000> and <sil=0.000> a in <sil=0.000> the <sil=0.000> this <sil=0.000> function <sil=0.000> y
slash <sil=0.000> b <sil=2.000> .PERIOD  I <sil=0.000> am <sil=0.000> writing <sil=0.000> slash <sil=0.000> b because <sil=0.000> these <sil=0.000> two <sil=0.000> was <sil=0.000> the <sil=0.000> same <sil=0.000> because <sil=0.000> the <sil=0.000> address <sil=0.000> is
shared <sil=0.000> all <sil=0.000> right <sil=0.000> and <sil=0.000> vector <sil=0.000> sum <sil=0.000> will <sil=0.000> be <sil=0.000> z <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  z <sil=0.000> or <sil=0.000> vector <sil=0.000> sum <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  x <sil=0.000> is <sil=0.000> 1 2 <sil=0.000> 3 <sil=1.000> ,COMMA  y <sil=0.000> is <sil=0.000> 4 5 <sil=0.000> 6
and <sil=0.000> z <sil=1.000> ,COMMA  z <sil=0.000> has <sil=0.000> not <sil=0.000> been <sil=0.000> initialized <sil=0.000> because <sil=1.000> ,COMMA  so <sil=0.000> let <sil=0.000> me <sil=0.000> let <sil=0.000> me <sil=0.354> ;SEMICOLON  so <sil=0.000> that <sil=0.000> you <sil=0.000> are <sil=0.000> not <sil=0.000> confused <sil=1.000> ,COMMA 
let <sil=0.000> me <sil=0.000> do <sil=0.000> it <sil=0.000> like <sil=0.000> this <sil=2.000> .PERIOD 

I <sil=0.000> have <sil=0.000> got <sil=0.000> an <sil=0.000> array <sil=0.000> that <sil=0.000> is <sil=0.000> x having <sil=0.000> values <sil=0.000> 1 2 <sil=0.000> 3 <sil=1.000> ,COMMA  another <sil=0.000> array <sil=0.000> y having <sil=0.000> values <sil=0.000> 4 5 <sil=0.000> 6 and
another <sil=0.000> array <sil=1.000> ,COMMA  another <sil=0.000> array <sil=0.000> z which <sil=0.000> will <sil=0.000> have <sil=0.000> the <sil=0.000> final <sil=0.000> value <sil=0.000> and <sil=0.000> z all <sil=0.000> right <sil=0.000> it <sil=0.000> is <sil=0.000> 0
elements <sil=1.000> ,COMMA  but <sil=0.000> we <sil=0.000> do <sil=0.000> not <sil=0.000> know <sil=0.000> the <sil=0.000> value <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> calling <sil=0.000> vector <sil=0.000> sum <sil=0.000> and <sil=0.000> what <sil=0.000> am <sil=0.000> I
passing <sil=0.000> x is <sil=0.000> being <sil=0.000> passed <sil=0.000> to <sil=0.000> this <sil=0.000> x goes <sil=0.000> to <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> a for <sil=0.000> the <sil=0.000> function <sil=0.000> y
goes <sil=0.000> to <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> b <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  x <sil=0.000> and <sil=0.000> a locations <sil=0.000> are <sil=0.000> shared <sil=0.000> z and <sil=0.000> v sum <sil=0.000> the
locations <sil=0.000> are <sil=0.000> shared <sil=1.000> ,COMMA  all <sil=0.000> right <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> calling <sil=0.000> vector <sil=0.000> sum <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  all <sil=0.000> these <sil=0.000> are <sil=0.000> being <sil=0.000> added <sil=0.000> in <sil=0.000> a loop <sil=0.000> 5 7 <sil=0.000> 9 <sil=1.000> ,COMMA  then <sil=0.000> I come
out <sil=0.000> I come <sil=0.000> out <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  you <sil=0.000> see <sil=0.000> when <sil=0.000> I come <sil=0.000> out <sil=0.000> of <sil=0.000> this <sil=0.000> function <sil=0.000> these <sil=0.000> are <sil=0.000> already <sil=0.000> reflected
because <sil=0.000> it <sil=0.000> was <sil=0.000> passed <sil=0.000> by <sil=0.000> reference <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> the <sil=0.000> print <sil=1.000> ,COMMA  print <sil=0.000> vector <sil=0.000> what <sil=0.000> is
happening <sil=0.000> here <sil=2.000> .PERIOD  Void <sil=0.000> print <sil=0.000> vector <sil=0.000> that <sil=0.000> is <sil=0.000> another <sil=0.000> function <sil=0.000> that <sil=0.000> I am <sil=0.000> calling <sil=0.000> here <sil=0.000> z 3 <sil=0.354> ;SEMICOLON  that
means <sil=1.000> ,COMMA  3 <sil=0.000> elements <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=0.000> from <sil=0.000> that <sil=0.000> z array <sil=0.000> z array <sil=0.000> was <sil=0.000> here <sil=0.000> which <sil=0.000> had <sil=0.000> that
elements <sil=0.000> like <sil=0.000> 5 <sil=1.000> ,COMMA  7 <sil=0.000> and <sil=0.000> 9 <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  with <sil=0.000> that <sil=0.000> print <sil=0.000> vector <sil=0.000> it <sil=0.000> is <sil=0.000> just <sil=0.000> in <sil=0.000> a loop <sil=0.000> i equal <sil=0.000> to <sil=0.000> 0 <sil=1.000> ,COMMA  i <sil=0.000> less <sil=0.000> than <sil=0.000> length <sil=2.000> .PERIOD  What <sil=0.000> is
length <sil=0.228> ?QUESTIONMARK  Length <sil=0.000> is <sil=0.000> 3 and <sil=0.000> what <sil=0.000> is <sil=0.000> the <sil=0.000> array <sil=0.000> z is <sil=0.000> a <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  this <sil=0.000> a and <sil=0.000> this <sil=0.000> a are <sil=0.000> different <sil=0.000> again <sil=1.000> ,COMMA 
this <sil=0.000> a and <sil=0.000> this <sil=0.000> a are <sil=0.000> different <sil=2.000> .PERIOD  This <sil=0.000> a <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> this <sil=0.000> a was <sil=0.000> this <sil=0.000> functions <sil=0.000> a and <sil=0.000> this <sil=0.000> a is <sil=0.000> this
function <sil=0.000> a <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  they <sil=0.000> are <sil=0.000> different <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> they <sil=0.000> are <sil=0.000> printing <sil=0.000> 5 <sil=1.000> ,COMMA  7 <sil=1.000> ,COMMA  9 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> as <sil=0.000> an
output <sil=0.000> parameter <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  you <sil=0.000> see <sil=0.000> actually <sil=0.000> whenever <sil=0.000> I am <sil=0.000> reflecting <sil=0.000> on <sil=0.000> an <sil=0.000> array <sil=0.000> I need <sil=0.000> not <sil=0.000> pass <sil=0.000> it <sil=0.000> because
essentially <sil=0.000> automatically <sil=0.000> passed <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> what <sil=0.000> is <sil=0.000> very <sil=0.000> important <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> hope <sil=0.000> you
have <sil=0.000> understood <sil=0.000> this <sil=2.000> .PERIOD 

The <sil=0.000> actual <sil=0.000> mechanism <sil=0.000> is <sil=0.000> when <sil=0.000> an <sil=0.000> array <sil=0.000> is <sil=0.000> passed <sil=0.000> it <sil=0.000> is <sil=0.000> the <sil=0.000> array <sil=0.000> elements <sil=0.000> are <sil=0.000> not <sil=0.000> passed <sil=1.000> ,COMMA 
but <sil=0.000> what <sil=0.000> is <sil=0.000> passed <sil=0.000> is <sil=0.000> an <sil=0.000> address <sil=0.000> and <sil=0.000> the <sil=0.000> argument <sil=0.000> becomes <sil=0.000> a pointer <sil=0.000> to <sil=0.000> the <sil=0.000> first <sil=0.000> element
or <sil=0.000> a pointer <sil=0.000> to <sil=0.000> the <sil=0.000> first <sil=0.000> element <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  the <sil=0.000> address <sil=0.000> of <sil=0.000> the <sil=0.000> first <sil=0.000> element <sil=2.000> .PERIOD  And <sil=0.000> when
an <sil=0.000> array <sil=0.000> element <sil=0.000> is <sil=0.000> accessed <sil=0.000> inside <sil=0.000> the <sil=0.000> function <sil=0.000> the <sil=0.000> address <sil=0.000> is <sil=0.000> calculated <sil=0.000> I have <sil=0.000> already
explained <sil=0.000> the <sil=0.000> formula <sil=0.000> that <sil=0.000> is <sil=0.000> used <sil=0.000> for <sil=0.000> finding <sil=0.000> the <sil=0.000> array <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> call <sil=0.000> by
reference <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> think <sil=0.000> you <sil=0.000> have <sil=0.000> understood <sil=0.000> this <sil=2.000> .PERIOD  We <sil=0.000> will <sil=0.000> continue <sil=0.000> our <sil=0.000> discussions <sil=0.000> in <sil=0.000> the <sil=0.000> future
lectures <sil=0.000> on <sil=0.000> some <sil=0.000> other <sil=0.000> important <sil=0.000> issues <sil=2.000> .PERIOD 

We <sil=0.000> have <sil=0.000> discussed <sil=0.000> about <sil=0.000> passing <sil=0.000> arrays <sil=0.000> as <sil=0.000> parameters <sil=2.000> .PERIOD  And <sil=0.000> for <sil=0.000> passing <sil=0.000> arrays <sil=0.000> as
parameters <sil=0.000> in <sil=0.000> C to <sil=1.000> ,COMMA  C <sil=0.000> functions <sil=0.000> we <sil=0.000> take <sil=0.000> the <sil=0.000> course <sil=0.000> to <sil=0.000> call <sil=0.000> by <sil=0.000> reference <sil=2.000> .PERIOD  Otherwise <sil=0.000> for <sil=0.000> all
other <sil=0.000> parameter <sil=0.000> passing <sil=0.000> we <sil=0.000> take <sil=0.000> the <sil=0.000> course <sil=0.000> to <sil=0.000> call <sil=0.000> by <sil=0.000> value <sil=2.000> .PERIOD  And <sil=0.000> just <sil=0.000> to <sil=0.000> summarize <sil=0.000> the
call <sil=0.000> by <sil=0.000> value <sil=0.000> and <sil=0.000> call <sil=0.000> by <sil=0.000> reference <sil=2.000> .PERIOD  Call <sil=0.000> by <sil=0.000> value <sil=0.000> we <sil=0.000> copy <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> the <sil=0.000> actual
parameter <sil=0.000> to <sil=0.000> the <sil=0.000> formal <sil=0.000> parameter <sil=0.354> ;SEMICOLON  formal <sil=0.000> argument <sil=0.000> and <sil=0.000> in <sil=0.000> call <sil=0.000> by <sil=0.000> reference <sil=0.000> we <sil=0.000> do <sil=0.000> not
copy <sil=0.000> the <sil=0.000> value <sil=1.000> ,COMMA  but <sil=0.000> we <sil=0.000> just <sil=0.000> pass <sil=0.000> on <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> the <sil=0.000> pointer <sil=0.000> and <sil=0.000> reference <sil=0.000> to <sil=0.000> the <sil=0.000> actual
parameter <sil=0.000> ok <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  as <sil=0.000> a result <sil=0.354> ;SEMICOLON  what <sil=0.000> happens <sil=0.228> ?QUESTIONMARK  That <sil=0.000> if <sil=0.000> any <sil=0.000> change <sil=0.000> to <sil=0.000> that <sil=0.000> variable <sil=0.000> is <sil=0.000> resulted <sil=0.000> in <sil=0.000> the
function <sil=0.000> itself <sil=1.000> ,COMMA  in <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> call <sil=0.000> by <sil=0.000> value <sil=0.000> that <sil=0.000> will <sil=0.000> not <sil=0.000> be <sil=0.000> automatically <sil=0.000> reflected <sil=0.000> to <sil=0.000> the
main <sil=0.000> program <sil=1.000> ,COMMA  but <sil=0.000> in <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> call <sil=0.000> by <sil=0.000> reference <sil=0.000> since <sil=0.000> there <sil=0.000> is <sil=0.000> no <sil=0.000> other <sil=0.000> separate <sil=0.000> copy
that <sil=0.000> will <sil=0.000> automatically <sil=0.000> be <sil=0.000> reflected <sil=2.000> .PERIOD  Just <sil=0.000> to <sil=0.000> conclude <sil=0.000> that <sil=0.000> part <sil=0.000> we <sil=0.000> will <sil=0.000> see <sil=0.000> a number <sil=0.000> of
applications <sil=0.000> of <sil=0.000> functions <sil=0.000> just <sil=0.000> to <sil=0.000> come <sil=0.000> to <sil=0.000> conclude <sil=0.000> that <sil=2.000> .PERIOD 

Let <sil=0.000> us <sil=0.000> have <sil=0.000> a quick <sil=0.000> look <sil=0.000> at <sil=0.000> 1 function <sil=1.000> ,COMMA  but <sil=0.000> there <sil=0.000> is <sil=0.000> no <sil=0.000> idea <sil=1.000> ,COMMA  but <sil=0.000> just <sil=0.000> vision <sil=0.000> of <sil=0.000> the
prototypes <sil=0.000> that <sil=0.000> you <sil=0.000> can <sil=0.000> see <sil=0.000> here <sil=1.000> ,COMMA  finding <sil=0.000> the <sil=0.000> maximum <sil=0.000> of <sil=0.000> 3 integers <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> the <sil=0.000> header <sil=0.000> file <sil=1.000> ,COMMA  here <sil=0.000> include <sil=0.000> studio <sil=0.000> dot <sil=0.000> h <sil=2.000> .PERIOD  Then <sil=0.000> here <sil=0.000> we <sil=0.000> declared <sil=0.000> a function
prototype <sil=2.000> .PERIOD  The <sil=0.000> actual <sil=0.000> function <sil=0.000> maximum <sil=0.000> has <sil=0.000> been <sil=0.000> written <sil=0.000> later <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> you <sil=0.000> see <sil=0.000> that
what <sil=0.000> does <sil=0.000> this <sil=0.000> line <sil=0.000> tell <sil=0.000> us <sil=0.228> ?QUESTIONMARK  This <sil=0.000> line <sil=0.000> tells <sil=0.000> us <sil=0.000> that <sil=0.000> maximum <sil=0.000> is <sil=0.000> a function <sil=0.000> and <sil=0.000> it <sil=0.000> consists <sil=0.000> of
3 <sil=0.000> integer <sil=0.000> arguments <sil=1.000> ,COMMA  or <sil=0.000> 3 integer <sil=0.000> parameters <sil=0.000> will <sil=0.000> come <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  as <sil=0.000> if <sil=0.000> this <sil=0.000> is <sil=0.000> a function <sil=0.000> which
has <sil=0.000> got <sil=0.000> 3 input <sil=0.000> doors <sil=0.000> and <sil=0.000> each <sil=0.000> door <sil=0.000> is <sil=0.000> wide <sil=0.000> enough <sil=0.000> to <sil=0.000> accommodate <sil=0.000> an <sil=0.000> integer <sil=0.000> ok <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
that <sil=0.000> much <sil=0.000> is <sil=0.000> told <sil=2.000> .PERIOD  And <sil=0.000> whatever <sil=0.000> is <sil=0.000> inside <sil=0.000> this <sil=0.000> I am <sil=0.000> not <sil=0.000> aware <sil=0.000> of <sil=0.000> that <sil=1.000> ,COMMA  and <sil=0.000> at <sil=0.000> this <sil=0.000> stage <sil=0.000> I
am <sil=0.000> not <sil=0.000> aware <sil=0.000> of <sil=0.000> that <sil=2.000> .PERIOD  And <sil=0.000> the <sil=0.000> output <sil=0.000> will <sil=0.000> also <sil=0.000> be <sil=0.000> another <sil=0.000> integer <sil=0.000> that <sil=0.000> is <sil=0.000> told <sil=0.000> by <sil=0.000> this <sil=2.000> .PERIOD 
Then <sil=0.000> so <sil=1.000> ,COMMA  here <sil=0.000> the <sil=0.000> salient <sil=0.000> point <sil=0.000> to <sil=0.000> see <sil=0.000> is <sil=0.000> that <sil=0.000> here <sil=0.000> I have <sil=0.000> just <sil=0.000> it <sil=0.000> was <sil=0.000> sufficient <sil=0.000> to <sil=0.000> just
specify <sil=0.000> the <sil=0.000> types <sil=1.000> ,COMMA  no <sil=0.000> names <sil=0.000> have <sil=0.000> been <sil=0.000> put <sil=0.000> in <sil=2.000> .PERIOD  Now <sil=0.000> comes <sil=0.000> the <sil=0.000> main <sil=0.000> program <sil=0.000> that <sil=0.000> is <sil=0.000> very
simple <sil=0.000> a <sil=1.000> ,COMMA  b <sil=1.000> ,COMMA  c <sil=0.000> are <sil=0.000> 3 integers <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  they <sil=0.000> are <sil=0.000> local <sil=0.000> to <sil=0.000> this <sil=0.000> function <sil=1.000> ,COMMA  enter <sil=0.000> the <sil=0.000> integers <sil=0.000> abc <sil=0.000> are <sil=0.000> interred <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you <sil=0.000> know <sil=0.354> ;SEMICOLON 
what <sil=0.000> a is <sil=0.228> ?QUESTIONMARK  what <sil=0.000> b is <sil=1.000> ,COMMA  and <sil=0.000> what <sil=0.000> c is <sil=1.000> ,COMMA  and <sil=0.000> then <sil=0.000> you <sil=0.000> are <sil=0.000> calling <sil=0.000> inside <sil=0.000> c <sil=2.000> .PERIOD  Here <sil=0.000> inside <sil=0.000> the <sil=0.000> print
f <sil=0.000> I can <sil=0.000> call <sil=0.000> maximum <sil=0.000> with <sil=0.000> the <sil=0.000> parameters <sil=0.000> a <sil=1.000> ,COMMA  b <sil=1.000> ,COMMA  c <sil=0.000> and <sil=0.000> we <sil=0.000> come <sil=0.000> here <sil=2.000> .PERIOD  And <sil=0.000> here <sil=0.000> I have
defined <sil=0.000> here <sil=0.000> I did <sil=0.000> not <sil=0.000> name <sil=0.000> here <sil=0.000> I did <sil=0.000> not <sil=0.000> name <sil=0.000> the <sil=0.000> variables <sil=0.354> ;SEMICOLON  here <sil=0.000> I have <sil=0.000> defined <sil=0.000> the
names <sil=0.000> of <sil=0.000> the <sil=0.000> variables <sil=0.000> int <sil=0.000> x <sil=1.000> ,COMMA  int <sil=0.000> y <sil=1.000> ,COMMA  int <sil=0.000> z <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> x <sil=1.000> ,COMMA  y <sil=1.000> ,COMMA  z <sil=0.000> again <sil=0.000> property <sil=0.000> of <sil=0.000> this <sil=0.000> maximum
alright <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  xyz <sil=0.000> are <sil=0.000> here <sil=2.000> .PERIOD  And <sil=0.000> the <sil=0.000> algorithm <sil=0.000> of <sil=0.000> the <sil=0.000> logic <sil=0.000> is <sil=0.000> simple <sil=2.000> .PERIOD  Initially <sil=0.000> I make <sil=0.000> max <sil=0.000> to <sil=0.000> be <sil=0.000> x <sil=0.354> ;SEMICOLON  if
y <sil=0.000> is <sil=0.000> greater <sil=0.000> than <sil=0.000> max <sil=0.000> and <sil=0.000> y is <sil=0.000> the <sil=0.000> max <sil=1.000> ,COMMA  otherwise <sil=0.000> z is <sil=0.000> the <sil=0.000> max <sil=0.000> and <sil=0.000> then <sil=0.000> I am <sil=0.000> returning
max <sil=2.000> .PERIOD  I <sil=0.000> am <sil=0.000> returning <sil=0.000> max <sil=0.000> means <sil=0.000> I am <sil=0.000> coming <sil=0.000> here <sil=1.000> ,COMMA  and <sil=0.000> then <sil=0.000> that <sil=0.000> max <sil=0.000> is <sil=0.000> being <sil=0.000> printed <sil=2.000> .PERIOD 

And <sil=0.000> returns <sil=0.000> 0 now <sil=0.000> my <sil=0.000> main <sil=0.000> function <sil=1.000> ,COMMA  where <sil=0.000> is <sil=0.000> my <sil=0.000> main <sil=0.228> ?QUESTIONMARK  Main <sil=0.000> is <sil=0.000> here <sil=1.000> ,COMMA  main <sil=0.000> has <sil=0.000> got <sil=0.000> a
type <sil=0.000> int <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> returning <sil=0.000> 0 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  int <sil=0.000> will <sil=0.000> if <sil=0.000> at <sil=0.000> the <sil=0.000> end <sil=0.000> of <sil=1.000> ,COMMA  the <sil=0.000> main <sil=0.000> function <sil=0.000> a 0 <sil=0.000> is
returned <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> assume <sil=0.000> that <sil=0.000> the <sil=0.000> program <sil=0.000> has <sil=0.000> successfully <sil=0.000> completed <sil=0.000> ok <sil=2.000> .PERIOD  The <sil=0.000> reason <sil=0.000> I
brought <sil=0.000> up <sil=0.000> this <sil=0.000> example <sil=0.000> is <sil=0.000> just <sil=0.000> to <sil=0.000> illustrate <sil=0.000> this <sil=0.000> case <sil=0.000> that <sil=0.000> you <sil=0.000> need <sil=0.000> not <sil=0.000> at <sil=0.000> the <sil=0.000> prototype
level <sil=0.000> you <sil=0.000> can <sil=0.000> escape <sil=0.000> specifying <sil=0.000> the <sil=0.000> parameters <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> a prototype <sil=0.000> declaration <sil=1.000> ,COMMA  function <sil=0.000> calling <sil=1.000> ,COMMA  and <sil=0.000> function <sil=0.000> definition <sil=0.000> you <sil=0.000> know
that <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> are <sil=0.000> already <sil=0.000> repeated <sil=0.000> I am <sil=0.000> not <sil=0.000> going <sil=0.000> into <sil=0.000> that <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  instead <sil=0.000> I will <sil=0.000> be <sil=0.000> talking <sil=0.000> about <sil=0.000> a new <sil=0.000> thing <sil=0.000> here <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> hash <sil=0.000> include <sil=2.000> .PERIOD 

We <sil=0.000> have <sil=0.000> talked <sil=0.000> about <sil=0.000> hash <sil=0.000> include <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> used <sil=0.000> hash <sil=0.000> include <sil=2.000> .PERIOD  And <sil=0.000> we <sil=0.000> menti1d <sil=0.000> that
hash <sil=0.000> include <sil=0.000> is <sil=0.000> nothing <sil=0.000> but <sil=0.000> a preprocessor <sil=0.000> statement <sil=2.000> .PERIOD  A <sil=0.000> preprocessor <sil=0.000> statement <sil=0.000> how <sil=0.228> ?QUESTIONMARK  Say
hash <sil=0.000> includes <sil=0.000> filename <sil=2.000> .PERIOD  We <sil=0.000> have <sil=0.000> seen <sil=0.000> hash <sil=0.000> include <sil=0.000> studio <sil=0.000> dot <sil=0.000> h <sil=1.000> ,COMMA  but <sil=0.000> it <sil=0.000> can <sil=0.000> be <sil=0.000> for <sil=0.000> that
matter <sil=0.000> any <sil=0.000> file <sil=0.000> name <sil=1.000> ,COMMA  hash <sil=0.000> include <sil=0.000> file <sil=0.000> name <sil=2.000> .PERIOD 
Say <sil=0.000> for <sil=0.000> example <sil=0.000> I can <sil=0.000> specify <sil=0.000> the <sil=0.000> full <sil=0.000> path <sil=1.000> ,COMMA  say <sil=0.000> slash <sil=0.000> usr <sil=0.000> in <sil=0.000> a Linux <sil=0.000> environment <sil=0.000> slash
home <sil=0.000> rajan <sil=0.000> my <sil=0.000> file <sil=0.000> dot <sil=0.000> h <sil=2.000> .PERIOD  I <sil=0.000> want <sil=0.000> to <sil=0.000> include <sil=0.000> this <sil=0.000> file <sil=0.354> ;SEMICOLON  I <sil=0.000> want <sil=0.000> to <sil=0.000> include <sil=0.000> this <sil=0.000> file <sil=0.000> in <sil=0.000> mind <sil=0.000> for
serving <sil=2.000> .PERIOD  This <sil=0.000> file <sil=0.000> in <sil=0.000> my <sil=0.000> program <sil=1.000> ,COMMA  all <sil=0.000> right <sil=0.354> ;SEMICOLON  the <sil=0.000> content <sil=0.000> of <sil=0.000> the <sil=0.000> corresponding <sil=0.000> file <sil=0.000> will <sil=0.000> be
included <sil=0.000> in <sil=0.000> the <sil=0.000> present <sil=0.000> file <sil=1.000> ,COMMA  before <sil=0.000> compilation <sil=0.000> is <sil=0.000> d1 <sil=0.000> before <sil=0.000> compilation <sil=0.000> is <sil=0.000> d1 <sil=2.000> .PERIOD  And <sil=0.000> the
compiler <sil=0.000> will <sil=0.000> compile <sil=0.000> there <sil=0.000> after <sil=0.000> considering <sil=0.000> the <sil=0.000> content <sil=0.000> as <sil=0.000> it <sil=0.000> is <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> a preprocessor
statement <sil=2.000> .PERIOD  That <sil=0.000> is <sil=1.000> ,COMMA  I <sil=0.000> put <sil=0.000> that <sil=0.000> inside <sil=0.000> that <sil=0.000> hash <sil=0.000> include <sil=0.000> that <sil=0.000> file <sil=0.000> is <sil=0.000> included <sil=0.000> and <sil=0.000> then <sil=0.000> the
compilation <sil=0.000> is <sil=0.000> d1 <sil=0.000> ok <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=0.000> hash <sil=0.000> include <sil=0.000> example <sil=2.000> .PERIOD  Look <sil=0.000> at <sil=0.000> this <sil=0.000> program <sil=0.000> segment <sil=0.000> which <sil=0.000> is
my <sil=0.000> source <sil=0.000> program <sil=1.000> ,COMMA  which <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> proc <sil=0.000> dot <sil=0.000> c <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> my <sil=0.000> source <sil=0.000> program <sil=2.000> .PERIOD  This
source <sil=0.000> program <sil=0.000> has <sil=0.000> got <sil=0.000> hash <sil=0.000> include <sil=0.000> no <sil=0.000> stdio <sil=0.000> dot <sil=0.000> h <sil=1.000> ,COMMA  but <sil=0.000> it <sil=0.000> has <sil=0.000> just <sil=0.000> said <sil=0.000> that <sil=0.000> in <sil=0.000> hash
include <sil=0.000> my <sil=0.000> file <sil=0.000> dot <sil=0.000> h <sil=1.000> ,COMMA  and <sil=0.000> then <sil=0.000> a main <sil=0.000> program <sil=0.000> follows <sil=0.000> ok <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  this <sil=0.000> my <sil=0.000> file <sil=0.000> dot <sil=0.000> h is
nothing <sil=0.000> but <sil=0.000> another <sil=0.000> file <sil=1.000> ,COMMA  which <sil=0.000> is <sil=0.000> which <sil=0.000> has <sil=0.000> got <sil=0.000> hash <sil=0.000> include <sil=0.000> stdio <sil=0.000> dot <sil=0.000> h and <sil=0.000> index <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  when <sil=0.000> I include <sil=0.000> my <sil=0.000> file <sil=0.000> dot <sil=0.000> h <sil=1.000> ,COMMA  then <sil=0.000> this <sil=0.000> particular <sil=0.000> file <sil=0.000> will <sil=0.000> be <sil=0.000> included <sil=0.000> this <sil=0.000> particular
file <sil=0.000> that <sil=0.000> is <sil=0.000> this <sil=0.000> segment <sil=0.000> will <sil=0.000> be <sil=0.000> included <sil=0.000> here <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  consequently <sil=0.000> what <sil=0.000> will <sil=0.000> happen <sil=0.000> is <sil=0.000> when <sil=0.000> I say <sil=0.000> in <sil=0.000> general <sil=0.000> hash <sil=0.000> include <sil=0.000> file <sil=0.000> name <sil=0.000> dot <sil=0.000> h
it <sil=0.000> includes <sil=0.000> a file <sil=0.000> name <sil=0.000> file <sil=1.000> ,COMMA  file <sil=0.000> name <sil=0.000> dot <sil=0.000> h from <sil=0.000> a specific <sil=0.000> directory <sil=0.000> which <sil=0.000> is <sil=0.000> known <sil=0.000> as
the <sil=0.000> include <sil=0.000> directory <sil=2.000> .PERIOD  When <sil=0.000> I say <sil=0.000> hash <sil=0.000> include <sil=0.000> it <sil=0.000> takes <sil=0.000> from <sil=0.000> the <sil=0.000> include <sil=0.000> directory <sil=1.000> ,COMMA  and <sil=0.000> in
the <sil=0.000> include <sil=0.000> directory <sil=0.000> I have <sil=0.000> kept <sil=0.000> my <sil=0.000> file <sil=0.000> dot <sil=0.000> h <sil=1.000> ,COMMA  and <sil=0.000> consequently <sil=0.000> when <sil=0.000> that <sil=0.000> is <sil=0.000> included
the <sil=0.000> ultimately <sil=0.000> the <sil=0.000> thing <sil=0.000> that <sil=0.000> looks <sil=0.000> like <sil=0.000> is <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> it <sil=0.000> will <sil=0.000> look <sil=0.000> like <sil=0.000> this <sil=2.000> .PERIOD 
Because <sil=0.000> that <sil=0.000> hash <sil=0.000> include <sil=0.000> I am <sil=0.000> sorry <sil=1.000> ,COMMA  there <sil=0.000> should <sil=0.000> not <sil=0.000> be <sil=0.000> an <sil=0.000> inverted <sil=0.000> comma <sil=0.000> here <sil=1.000> ,COMMA  it
should <sil=0.000> be <sil=0.000> just <sil=0.000> hash <sil=0.000> include <sil=0.000> stdio <sil=0.000> dot <sil=0.000> h followed <sil=0.000> by <sil=0.000> intex <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> whole <sil=0.000> thing <sil=0.000> whole
thing <sil=0.000> has <sil=0.000> been <sil=0.000> has <sil=0.000> replaced <sil=0.000> my <sil=0.000> file <sil=0.000> dot <sil=0.000> h <sil=2.000> .PERIOD  And <sil=0.000> where <sil=0.000> was <sil=0.000> my <sil=0.000> file <sil=0.000> dot <sil=0.000> h <sil=0.228> ?QUESTIONMARK  My <sil=0.000> file <sil=0.000> dot <sil=0.000> h
was <sil=0.000> under <sil=0.000> user <sil=0.000> usr <sil=0.000> include <sil=0.000> file <sil=0.000> name <sil=0.000> dot <sil=0.000> h <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> how <sil=0.000> the <sil=0.000> include <sil=0.000> I can <sil=0.000> have <sil=0.000> other
files <sil=0.000> included <sil=0.000> in <sil=0.000> my <sil=0.000> program <sil=2.000> .PERIOD  Now <sil=0.000> another <sil=0.000> point <sil=0.000> of <sil=0.000> critical <sil=0.000> discussion <sil=0.000> a is <sil=0.000> macro
definition <sil=2.000> .PERIOD  We <sil=0.000> have <sil=0.000> seen <sil=0.000> the <sil=0.000> macros <sil=0.000> like <sil=0.000> hash <sil=0.000> define <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> so <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> again <sil=0.000> a preprocessor <sil=0.000> directive <sil=2.000> .PERIOD  We <sil=0.000> have <sil=0.000> seen <sil=0.000> that <sil=0.000> hash <sil=0.000> include <sil=0.000> is <sil=0.000> a
preprocessor <sil=0.000> command <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  even <sil=0.000> before <sil=0.000> the <sil=0.000> compilation <sil=0.000> is <sil=0.000> d1 <sil=0.354> ;SEMICOLON  that <sil=0.000> is <sil=1.000> ,COMMA  that <sil=0.000> is
copied <sil=0.000> there <sil=0.000> on <sil=0.000> the <sil=0.000> other <sil=0.000> hand <sil=1.000> ,COMMA  you <sil=0.000> see <sil=0.000> the <sil=0.000> preprocessor <sil=0.000> directive <sil=0.000> of <sil=0.000> hash <sil=0.000> defined <sil=0.000> string
1 <sil=0.000> string <sil=0.000> 2 <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  string <sil=0.000> 1 should <sil=0.000> be <sil=0.000> replaced <sil=0.000> by <sil=0.000> string <sil=0.000> 2 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  how <sil=0.000> does <sil=0.000> it <sil=0.000> happen <sil=0.228> ?QUESTIONMARK  It
replaces <sil=0.000> string <sil=0.000> 1 by <sil=0.000> string <sil=0.000> to <sil=0.000> whenever <sil=0.000> it <sil=0.000> occurs <sil=1.000> ,COMMA  where <sil=0.000> ever <sil=0.000> it <sil=0.000> occurs <sil=1.000> ,COMMA  where <sil=0.000> ever <sil=0.000> it
occurs <sil=0.000> before <sil=0.000> compilation <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  for <sil=0.000> example <sil=1.000> ,COMMA  hash <sil=0.000> defined <sil=0.000> pi <sil=0.000> to <sil=0.000> be <sil=0.000> 3 <sil=2.000> .PERIOD <sil=0.000> 14 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  wherever <sil=0.000> it <sil=0.000> will <sil=0.000> find <sil=0.000> this <sil=0.000> pi <sil=1.000> ,COMMA  wherever <sil=0.000> it
will <sil=0.000> find <sil=0.000> this <sil=0.000> pi <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> replace <sil=0.000> that <sil=0.000> with <sil=0.000> 3 <sil=2.000> .PERIOD <sil=0.000> 14 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  you <sil=0.000> see <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> got <sil=0.000> hash <sil=0.000> include <sil=0.000> stdio <sil=0.000> dot <sil=0.000> h <sil=1.000> ,COMMA  then <sil=0.000> we <sil=0.000> define <sil=0.000> pi <sil=0.000> to
be <sil=0.000> 3 <sil=2.000> .PERIOD <sil=0.000> 14 <sil=0.000> as <sil=0.000> the <sil=0.000> hash <sil=0.000> define <sil=0.000> preprocessor <sil=0.000> command <sil=2.000> .PERIOD  Now <sil=0.000> in <sil=0.000> my <sil=0.000> main <sil=0.000> program <sil=0.000> I have <sil=0.000> got
float <sil=0.000> r 4-time <sil=0.000> 4 <sil=0.354> ;SEMICOLON  r <sil=0.000> is <sil=0.000> 4 <sil=1.000> ,COMMA  and <sil=0.000> area <sil=0.000> is <sil=0.000> another <sil=0.000> variable <sil=0.000> both <sil=0.000> are <sil=0.000> float <sil=2.000> .PERIOD  Now <sil=0.000> area <sil=0.000> is <sil=0.000> pi <sil=0.000> times <sil=0.000> r
times <sil=0.000> r <sil=1.000> ,COMMA  r <sil=0.000> is <sil=0.000> already <sil=0.000> initialized <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> will <sil=0.000> happen <sil=0.000> is <sil=0.000> this <sil=0.000> will <sil=0.000> be <sil=0.000> translated <sil=0.000> to <sil=0.000> this <sil=0.000> pi
will <sil=0.000> be <sil=0.000> replaced <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> body <sil=0.000> will <sil=0.000> be <sil=0.000> float <sil=0.000> r assigned <sil=0.000> 4 and <sil=0.000> area <sil=2.000> .PERIOD 
And <sil=0.000> area <sil=0.000> is <sil=0.000> so <sil=1.000> ,COMMA  r <sil=0.000> is <sil=0.000> 4 <sil=1.000> ,COMMA  and <sil=0.000> area <sil=0.000> will <sil=0.000> be <sil=0.000> 3 <sil=2.000> .PERIOD <sil=0.000> 14 <sil=0.000> times <sil=0.000> r times <sil=0.000> r <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  before <sil=0.000> come <sil=0.000> even <sil=0.000> before
compilation <sil=1.000> ,COMMA  this <sil=0.000> pi <sil=0.000> is <sil=0.000> being <sil=0.000> replaced <sil=0.000> by <sil=0.000> 3 of <sil=0.000> the <sil=0.000> value <sil=0.000> 3 <sil=2.000> .PERIOD <sil=0.000> 14 <sil=0.000> as <sil=0.000> has <sil=0.000> been <sil=0.000> stated <sil=0.000> in <sil=0.000> the <sil=0.000> hash
defined <sil=0.000> command <sil=2.000> .PERIOD 

We <sil=0.000> can <sil=0.000> also <sil=0.000> give <sil=0.000> hash <sil=0.000> define <sil=0.000> with <sil=0.000> an <sil=0.000> argument <sil=2.000> .PERIOD  Till <sil=0.000> now <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=0.000> hash <sil=0.000> define <sil=0.000> pi <sil=0.000> as
a <sil=0.000> constant <sil=0.000> hash <sil=0.000> define <sil=0.000> some <sil=0.000> constant <sil=0.000> k to <sil=0.000> be <sil=0.000> 5 or <sil=0.000> whatever <sil=2.000> .PERIOD  Here <sil=0.000> we <sil=0.000> can <sil=0.000> also <sil=0.000> define
some <sil=0.000> functions <sil=2.000> .PERIOD  Like <sil=0.000> you <sil=0.000> see <sil=0.000> hash <sil=0.000> define <sil=0.000> square <sil=0.000> x is <sil=0.000> x times <sil=0.000> x <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  wherever <sil=0.000> square <sil=0.000> x
will <sil=0.000> appear <sil=1.000> ,COMMA  that <sil=0.000> will <sil=0.000> be <sil=0.000> replaced <sil=0.000> by <sil=0.000> x times <sil=0.000> x ok <sil=2.000> .PERIOD 

Say <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  here <sil=0.000> let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=0.000> program <sil=0.000> again <sil=2.000> .PERIOD  I <sil=0.000> think <sil=0.000> you <sil=0.000> are <sil=0.000> not <sil=0.000> being <sil=0.000> able <sil=0.000> to
read <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> me <sil=0.000> go <sil=0.000> back <sil=0.000> say <sil=0.000> let <sil=0.000> me <sil=0.000> have <sil=0.000> if <sil=0.000> I have <sil=1.000> ,COMMA  declared <sil=0.000> say <sil=1.000> ,COMMA  hash <sil=0.000> define <sil=0.000> square <sil=0.000> x
is <sil=0.000> x times <sil=0.000> x <sil=2.000> .PERIOD 

Then <sil=0.000> in <sil=0.000> my <sil=0.000> program <sil=1.000> ,COMMA  wherever <sil=0.000> I will <sil=0.000> get <sil=0.000> say <sil=1.000> ,COMMA  p <sil=0.000> is <sil=0.000> assigned <sil=0.000> square <sil=0.000> y <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> will <sil=0.000> be
translated <sil=0.000> as <sil=0.000> p assigned <sil=0.000> y times <sil=0.000> y ok <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.354> ;SEMICOLON  what <sil=0.000> should <sil=0.000> be <sil=0.000> d1 <sil=0.000> that <sil=0.000> has <sil=0.000> already <sil=0.000> been
told <sil=0.000> here <sil=0.000> that <sil=0.000> square <sil=0.000> x is <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> will <sil=0.000> simply <sil=0.000> replace <sil=0.000> it <sil=0.000> ok <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> the <sil=0.000> purpose <sil=0.000> of
hash <sil=0.000> define <sil=0.000> here <sil=1.000> ,COMMA  we <sil=0.000> can <sil=0.000> see <sil=0.000> that <sil=0.000> and <sil=0.000> so <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=0.000> example <sil=0.000> again <sil=2.000> .PERIOD 

Main <sil=0.000> y is <sil=0.000> 5 <sil=1.000> ,COMMA  print <sil=0.000> f value <sil=0.000> is <sil=0.000> y times <sil=0.000> y <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> being <sil=0.000> repeat <sil=0.000> this <sil=0.000> is <sil=0.000> what <sil=0.000> has
been <sil=0.000> generated <sil=0.000> after <sil=0.000> the <sil=0.000> square <sil=0.000> x has <sil=0.000> been <sil=0.000> square <sil=0.000> here <sil=0.000> it <sil=0.000> was <sil=0.000> square <sil=0.000> x plus <sil=0.000> 3 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> has
become <sil=0.000> y times <sil=0.000> y plus <sil=0.000> 3 <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  which <sil=0.000> 1 is <sil=0.000> faster <sil=0.000> to <sil=0.000> execute <sil=0.228> ?QUESTIONMARK  You <sil=0.000> can <sil=0.000> think <sil=0.000> of <sil=0.000> I can <sil=0.000> if <sil=0.000> I

write <sil=0.000> square <sil=0.000> x written <sil=0.000> as <sil=0.000> a macro <sil=0.000> definition <sil=1.000> ,COMMA  then <sil=0.000> I am <sil=0.000> pasting <sil=0.000> as <sil=0.000> if <sil=0.000> I am <sil=0.000> pasting <sil=0.000> the <sil=0.000> body
of <sil=0.000> the <sil=0.000> code <sil=0.000> inside <sil=0.000> this <sil=0.000> in <sil=0.000> the <sil=0.000> main <sil=0.000> program <sil=0.000> replacing <sil=0.000> that <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> do <sil=0.000> not <sil=0.000> need <sil=0.000> to <sil=0.000> call <sil=0.000> any
function <sil=2.000> .PERIOD  I <sil=0.000> can <sil=0.000> write <sil=0.000> it <sil=0.000> as <sil=0.000> a macro <sil=0.000> definition <sil=0.000> and <sil=0.000> I as <sil=0.000> a result <sil=0.000> even <sil=0.000> before <sil=0.000> compilation <sil=2.000> .PERIOD 
Even <sil=0.000> before <sil=0.000> compilation <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> get <sil=0.000> this <sil=0.000> look <sil=2.000> .PERIOD  And <sil=0.000> so <sil=1.000> ,COMMA  this <sil=0.000> can <sil=0.000> be <sil=0.000> straightaway <sil=0.000> applied
without <sil=0.000> requiring <sil=0.000> to <sil=0.000> call <sil=0.000> a function <sil=2.000> .PERIOD  Now <sil=0.000> if <sil=0.000> square <sil=0.000> x is <sil=0.000> written <sil=0.000> as <sil=0.000> an <sil=0.000> ordinary <sil=0.000> function <sil=1.000> ,COMMA 
not <sil=0.000> like <sil=0.000> a macro <sil=0.000> definition <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> case <sil=0.000> I have <sil=0.000> to <sil=0.000> call <sil=0.000> a function <sil=1.000> ,COMMA  and <sil=0.000> calling <sil=0.000> a function
has <sil=0.000> got <sil=0.000> some <sil=0.000> overheads <sil=0.000> which <sil=0.000> I am <sil=0.000> not <sil=0.000> discussing <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> it <sil=0.000> be <sil=0.000> a very <sil=0.000> simple <sil=0.000> thing
like <sil=0.000> this <sil=0.000> it <sil=0.000> is <sil=0.000> better <sil=0.000> to <sil=0.000> make <sil=0.000> it <sil=0.000> a macro <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> it <sil=0.000> automatically <sil=0.000> gets <sil=0.000> pasted <sil=0.000> and <sil=0.000> it
becomes <sil=0.000> faster <sil=2.000> .PERIOD 

However <sil=1.000> ,COMMA  there <sil=0.000> is <sil=0.000> a word <sil=0.000> of <sil=0.000> caution <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  if <sil=0.000> I had <sil=0.000> defined <sil=0.000> square <sil=0.000> x <sil=1.000> ,COMMA  now <sil=0.000> it <sil=0.000> is <sil=0.000> now
when <sil=0.000> I am <sil=0.000> defining <sil=0.000> as <sil=0.000> a macro <sil=0.000> it <sil=0.000> is <sil=0.000> I have <sil=0.000> to <sil=0.000> ensure <sil=0.000> that <sil=0.000> it <sil=0.000> is <sil=0.000> correct <sil=2.000> .PERIOD  Therefore <sil=1.000> ,COMMA  if <sil=0.000> I
define <sil=0.000> square <sil=0.000> x as <sil=0.000> x times <sil=0.000> x <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  how <sil=0.000> the <sil=0.000> macro <sil=0.000> definition <sil=0.000> substitution <sil=0.000> will <sil=0.000> be <sil=0.000> carried
out <sil=0.228> ?QUESTIONMARK  Let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=2.000> .PERIOD  If <sil=0.000> there <sil=0.000> be <sil=0.000> something <sil=0.000> like <sil=0.000> r assigned <sil=0.000> square <sil=0.000> of <sil=0.000> a plus <sil=0.000> square <sil=0.000> of
30 <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> a times <sil=0.000> a plus <sil=0.000> 30 <sil=0.000> times <sil=0.000> 30 <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> how <sil=0.000> it <sil=0.000> will <sil=0.000> happen <sil=0.000> ok <sil=1.000> ,COMMA  now <sil=0.000> what <sil=0.000> about <sil=0.000> r
square <sil=0.000> of <sil=0.000> a plus <sil=0.000> b <sil=0.228> ?QUESTIONMARK  It <sil=0.000> will <sil=0.000> be <sil=0.000> simply <sil=0.000> pasted <sil=0.000> as <sil=0.000> a plus <sil=0.000> b times <sil=0.000> a plus <sil=0.000> b <sil=2.000> .PERIOD  Consequently <sil=1.000> ,COMMA  the
result <sil=0.000> will <sil=0.000> be <sil=0.000> wrong <sil=1.000> ,COMMA  because <sil=0.000> in <sil=0.000> the <sil=0.000> during <sil=0.000> execution <sil=0.000> b times <sil=0.000> a will <sil=0.000> be <sil=0.000> d1 <sil=0.000> first <sil=1.000> ,COMMA  and <sil=0.000> then
that <sil=0.000> will <sil=0.000> be <sil=0.000> added <sil=0.000> with <sil=0.000> a and <sil=0.000> with <sil=0.000> b <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> not <sil=0.000> what <sil=0.000> I intended <sil=2.000> .PERIOD  Therefore <sil=1.000> ,COMMA  if <sil=0.000> I had
d1 <sil=0.000> this <sil=1.000> ,COMMA  define <sil=0.000> this <sil=0.000> as <sil=0.000> like <sil=0.000> this <sil=1.000> ,COMMA  and <sil=0.000> like <sil=0.000> this <sil=1.000> ,COMMA  this <sil=0.000> problem <sil=0.000> would <sil=0.000> not <sil=0.000> have <sil=0.000> occurred <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  unless <sil=0.000> I do <sil=0.000> that <sil=0.000> this <sil=0.000> a plus <sil=0.000> b should <sil=0.000> will <sil=0.000> not <sil=0.000> be <sil=0.000> I need <sil=0.000> to <sil=0.000> take <sil=0.000> if <sil=0.000> I define <sil=0.000> it <sil=0.000> like <sil=0.000> this
then <sil=0.000> it <sil=0.000> becomes <sil=0.000> this <sil=0.000> which <sil=0.000> is <sil=0.000> the <sil=0.000> correct <sil=0.000> 1 <sil=2.000> .PERIOD  But <sil=0.000> unless <sil=0.000> I do <sil=0.000> that <sil=0.000> it <sil=0.000> will <sil=0.000> lead <sil=0.000> to <sil=0.000> a wrong
result <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  you <sil=0.000> must <sil=0.000> be <sil=0.000> very <sil=0.000> careful <sil=0.000> about <sil=0.000> it <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> wrong <sil=2.000> .PERIOD  And <sil=0.000> the <sil=0.000> macro <sil=0.000> definition <sil=0.000> should
have <sil=0.000> been <sil=0.000> written <sil=0.000> as <sil=0.000> I have <sil=0.000> shown <sil=0.000> square <sil=0.000> x is <sil=0.000> x times <sil=0.000> x <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> case <sil=0.000> we <sil=0.000> would <sil=0.000> have <sil=0.000> got
the <sil=0.000> correct <sil=0.000> result <sil=2.000> .PERIOD  Now <sil=0.000> before <sil=0.000> moving <sil=0.000> to <sil=0.000> anything <sil=0.000> else <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> now <sil=0.000> look <sil=0.000> at <sil=0.000> some
applications <sil=0.000> of <sil=0.000> what <sil=0.000> we <sil=0.000> have <sil=0.000> learned <sil=2.000> .PERIOD  We <sil=0.000> are <sil=0.000> now <sil=0.000> at <sil=0.000> a position <sil=0.000> where <sil=0.000> we <sil=0.000> have <sil=0.000> learnt <sil=0.000> all
the <sil=0.000> fundamental <sil=0.000> tools <sil=1.000> ,COMMA  without <sil=0.000> the <sil=0.000> sophistications <sil=1.000> ,COMMA  that <sil=0.000> are <sil=0.000> required <sil=0.000> to <sil=0.000> write <sil=0.000> a program
ok <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  suppose <sil=0.000> I want <sil=0.000> to <sil=0.000> solve <sil=0.000> a problem <sil=0.000> like <sil=0.000> this <sil=2.000> .PERIOD  That <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> 5 students <sil=0.000> in <sil=0.000> the <sil=0.000> class <sil=0.354> ;SEMICOLON 
and <sil=0.000> the <sil=0.000> 5 students <sil=0.000> have <sil=0.000> got <sil=0.000> 5 names <sil=0.000> of <sil=0.000> course <sil=1.000> ,COMMA  and <sil=0.000> each <sil=0.000> of <sil=0.000> them <sil=0.000> have <sil=0.000> got <sil=0.000> some <sil=0.000> marks <sil=1.000> ,COMMA 
total <sil=0.000> marks <sil=1.000> ,COMMA  right <sil=2.000> .PERIOD  Now <sil=0.000> how <sil=0.000> do <sil=0.000> I represent <sil=0.000> that <sil=0.228> ?QUESTIONMARK  And <sil=0.000> I want <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> which <sil=0.000> student <sil=0.000> I
want <sil=0.000> to <sil=0.000> print <sil=0.000> the <sil=0.000> name <sil=0.000> of <sil=0.000> the <sil=0.000> student <sil=0.000> who <sil=0.000> has <sil=0.000> got <sil=0.000> the <sil=0.000> highest <sil=0.000> marks <sil=1.000> ,COMMA  all <sil=0.000> right <sil=0.228> ?QUESTIONMARK  Is <sil=0.000> the
problem <sil=0.000> clear <sil=0.000> let <sil=0.000> me <sil=0.000> repeat <sil=0.000> the <sil=0.000> problem <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> 5 students <sil=0.000> in <sil=0.000> a class <sil=0.228> ?QUESTIONMARK  And <sil=0.000> I want <sil=0.000> to
find <sil=0.000> out <sil=0.000> which <sil=0.000> student <sil=0.000> has <sil=0.000> got <sil=0.000> the <sil=0.000> highest <sil=0.000> marks <sil=2.000> .PERIOD  And <sil=0.000> I want <sil=0.000> to <sil=0.000> know <sil=0.000> the <sil=0.000> name <sil=0.000> of <sil=0.000> that
student <sil=0.000> ok <sil=2.000> .PERIOD 
How <sil=0.000> can <sil=0.000> I solve <sil=0.000> this <sil=0.000> problem <sil=0.228> ?QUESTIONMARK  This <sil=0.000> is <sil=0.000> a simple <sil=0.000> problem <sil=2.000> .PERIOD  Here <sil=0.000> what <sil=0.000> I will <sil=0.000> need <sil=0.000> is <sil=1.000> ,COMMA  first <sil=0.000> I
will <sil=0.000> need <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> the <sil=0.000> names <sil=0.000> of <sil=0.000> the <sil=0.000> students <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  first <sil=0.000> I need <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> the <sil=0.000> names <sil=0.000> of
the <sil=0.000> students <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> 5 names <sil=0.000> will <sil=0.000> be <sil=0.000> stored <sil=0.000> very <sil=1.000> ,COMMA  very <sil=0.000> disproportionate <sil=0.000> array <sil=2.000> .PERIOD  And <sil=0.000> let <sil=0.000> me <sil=0.000> call <sil=0.000> this
array <sil=0.000> to <sil=0.000> be <sil=0.000> name <sil=0.000> or <sil=0.000> names <sil=2.000> .PERIOD  And <sil=0.000> on <sil=0.000> this <sil=0.000> side <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> another <sil=0.000> array <sil=1.000> ,COMMA  which <sil=0.000> holds <sil=0.000> the
marks <sil=0.000> order <sil=0.000> of <sil=0.000> the <sil=0.000> different <sil=0.000> students <sil=2.000> .PERIOD  Corresponding <sil=0.000> to <sil=0.000> the <sil=0.000> roll <sil=0.000> number <sil=0.000> maybe <sil=0.000> 1 <sil=1.000> ,COMMA  2 <sil=1.000> ,COMMA  3 <sil=1.000> ,COMMA  4 <sil=1.000> ,COMMA 
5 <sil=0.000> the <sil=0.000> marks <sil=0.000> are <sil=0.000> stored <sil=0.000> here <sil=2.000> .PERIOD  Somebody <sil=0.000> got <sil=0.000> 50 <sil=1.000> ,COMMA  somebody <sil=0.000> got <sil=0.000> 55 <sil=1.000> ,COMMA  somebody <sil=0.000> got <sil=0.000> 62 <sil=1.000> ,COMMA 
somebody <sil=0.000> 70 <sil=1.000> ,COMMA  somebody <sil=0.000> 32 <sil=2.000> .PERIOD  Say <sil=1.000> ,COMMA  and <sil=0.000> their <sil=0.000> names <sil=0.000> are <sil=0.000> a <sil=1.000> ,COMMA  b <sil=1.000> ,COMMA  c <sil=1.000> ,COMMA  l <sil=0.000> m p <sil=0.000> q x <sil=0.000> and <sil=0.000> y <sil=0.354> ;SEMICOLON  suppose <sil=1.000> ,COMMA 
these <sil=0.000> are <sil=0.000> names <sil=1.000> ,COMMA  these <sil=0.000> are <sil=0.000> the <sil=0.000> different <sil=0.000> names <sil=2.000> .PERIOD  Now <sil=0.000> why <sil=0.000> do <sil=0.000> I need <sil=0.000> to <sil=0.000> add <sil=0.000> is <sil=1.000> ,COMMA  these <sil=0.000> are
this <sil=0.354> ;SEMICOLON  the <sil=0.000> array <sil=0.000> called <sil=0.000> marks <sil=2.000> .PERIOD  Why <sil=0.000> do <sil=0.000> I need <sil=0.000> 2 <sil=0.228> ?QUESTIONMARK  2 <sil=0.000> arrays <sil=1.000> ,COMMA  first <sil=0.000> of <sil=0.000> all <sil=0.000> the <sil=0.000> arrays <sil=0.000> should <sil=0.000> be
holding <sil=0.000> same <sil=0.000> type <sil=0.000> of <sil=0.000> data <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> the <sil=0.000> type <sil=0.000> of <sil=0.000> data <sil=0.000> that <sil=0.000> the <sil=0.000> array <sil=0.000> names <sil=0.000> are <sil=0.000> holding <sil=0.228> ?QUESTIONMARK  It <sil=0.000> is <sil=0.000> a array <sil=0.000> of <sil=0.000> character <sil=0.000> or
character <sil=0.000> string <sil=2.000> .PERIOD  Now <sil=0.000> how <sil=0.000> can <sil=0.000> I represent <sil=0.000> these <sil=0.000> names <sil=0.228> ?QUESTIONMARK  I <sil=0.000> can <sil=0.000> represent <sil=0.000> them <sil=0.000> as <sil=0.000> an <sil=0.000> array
of <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> strings <sil=1.000> ,COMMA  or <sil=0.000> each <sil=0.000> of <sil=0.000> these <sil=0.000> names <sil=0.000> is <sil=0.000> what <sil=0.000> each <sil=0.000> of <sil=0.000> these <sil=0.000> names <sil=0.000> is <sil=0.000> a character
array <sil=2.000> .PERIOD  Therefore <sil=1.000> ,COMMA  if <sil=0.000> I just <sil=0.000> look <sil=0.000> at <sil=0.000> names <sil=1.000> ,COMMA  names <sil=0.000> will <sil=0.000> look <sil=0.000> like <sil=0.000> a 2-dimensional <sil=0.000> array <sil=2.000> .PERIOD  Now
what <sil=0.000> would <sil=0.000> be <sil=0.000> my <sil=0.000> algorithm <sil=0.000> first <sil=0.000> of <sil=0.000> all <sil=0.000> come <sil=0.000> to <sil=0.000> the <sil=0.000> representation <sil=2.000> .PERIOD 
Later <sil=1.000> ,COMMA  what <sil=0.000> would <sil=0.000> my <sil=0.354> ;SEMICOLON  be <sil=0.000> my <sil=0.000> algorithm <sil=0.228> ?QUESTIONMARK  First <sil=0.000> of <sil=0.000> all <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> have <sil=0.000> to <sil=0.000> go <sil=0.000> to <sil=0.000> this <sil=0.000> mark <sil=0.000> array
which <sil=0.000> is <sil=0.000> simpler <sil=0.000> it <sil=0.000> is <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> integers <sil=1.000> ,COMMA  assuming <sil=0.000> all <sil=0.000> integer <sil=0.000> marks <sil=0.000> are <sil=0.000> given <sil=2.000> .PERIOD  Then <sil=0.000> I
will <sil=0.000> have <sil=0.000> to <sil=0.000> carry <sil=0.000> out <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> maximum <sil=0.000> of <sil=0.000> this <sil=2.000> .PERIOD  And <sil=0.000> you <sil=0.000> can <sil=0.000> write <sil=0.000> a function <sil=0.000> to <sil=0.000> find
the <sil=0.000> maximum <sil=0.000> of <sil=0.000> an <sil=0.000> array <sil=1.000> ,COMMA  right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> try <sil=0.000> to <sil=0.000> write <sil=0.000> the <sil=0.000> function <sil=0.000> first <sil=0.000> so <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> an
array <sil=0.000> marks <sil=0.354> ;SEMICOLON  which <sil=0.000> has <sil=0.000> got <sil=0.000> 5 elements <sil=1.000> ,COMMA  all <sil=0.000> right <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> call <sil=0.000> a function <sil=0.000> max <sil=1.000> ,COMMA  what <sil=0.000> let <sil=0.000> us <sil=0.000> first <sil=0.000> of <sil=0.000> all <sil=0.000> think <sil=0.000> of <sil=0.000> this <sil=0.000> maximum <sil=0.000> value <sil=0.000> what
will <sil=0.000> it <sil=0.000> return <sil=0.000> me <sil=0.228> ?QUESTIONMARK  Say <sil=1.000> ,COMMA  it <sil=0.000> we <sil=0.000> will <sil=0.000> find <sil=0.000> out <sil=0.000> say <sil=0.000> if <sil=0.000> I come <sil=0.000> to <sil=0.000> this <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> find <sil=0.000> out <sil=0.000> which <sil=0.000> 1 is
the <sil=0.000> maximum <sil=1.000> ,COMMA  and <sil=0.000> will <sil=0.000> return <sil=0.000> me <sil=0.000> an <sil=0.000> index <sil=1.000> ,COMMA  right <sil=0.000> or <sil=0.000> this <sil=0.000> is <sil=0.000> not <sil=0.000> the <sil=0.000> maximum <sil=0.000> sorry <sil=0.000> this <sil=0.000> 1
is <sil=0.000> the <sil=0.000> maximum <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> return <sil=0.000> me <sil=0.000> an <sil=0.000> index <sil=0.000> 0 1 <sil=0.000> 2 3 <sil=0.000> so <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> return <sil=0.000> me <sil=0.000> an <sil=0.000> integer <sil=2.000> .PERIOD  Therefore <sil=1.000> ,COMMA  I <sil=0.000> can
start <sil=0.000> with <sil=0.000> like <sil=0.000> this <sil=0.000> that <sil=0.000> int <sil=0.000> maximum <sil=0.000> of <sil=0.000> I can <sil=0.000> call <sil=0.000> an <sil=0.000> array <sil=1.000> ,COMMA  integer <sil=0.000> array <sil=0.000> int <sil=0.000> suppose <sil=0.000> that
is <sil=0.000> m <sil=1.000> ,COMMA  this <sil=0.000> and <sil=0.000> the <sil=0.000> main <sil=0.000> function <sil=0.000> will <sil=0.000> call <sil=0.000> it <sil=0.000> with <sil=0.000> marks <sil=2.000> .PERIOD  And <sil=0.000> inside <sil=0.000> this <sil=0.000> what <sil=0.000> will <sil=0.000> happen <sil=0.228> ?QUESTIONMARK 
You <sil=0.000> know <sil=1.000> ,COMMA  initially <sil=0.000> let <sil=0.000> me <sil=0.000> call <sil=0.000> a value <sil=0.000> int <sil=0.000> this <sil=0.000> is <sil=0.000> a local <sil=0.000> max <sil=0.000> assigned <sil=0.000> m 0 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> initialize
a <sil=0.000> variable <sil=0.000> max <sil=0.000> with <sil=0.000> m 0 <sil=2.000> .PERIOD  Now <sil=0.000> for <sil=0.000> I assign <sil=0.000> some <sil=0.000> index <sil=0.000> i <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> to <sil=0.000> declare <sil=0.000> I also <sil=0.000> here <sil=2.000> .PERIOD  I <sil=0.000> assigned <sil=0.000> 1 i <sil=0.000> less <sil=0.000> than <sil=0.000> equal <sil=0.000> to <sil=0.000> 5 less <sil=0.000> than <sil=0.000> equal <sil=0.000> to <sil=0.000> 4 <sil=1.000> ,COMMA 
sorry <sil=1.000> ,COMMA  less <sil=0.000> than <sil=0.000> equal <sil=0.000> to <sil=0.000> 4 <sil=1.000> ,COMMA  i <sil=0.000> plus
 <sil=2.000> .PERIOD  Here <sil=0.000> if <sil=0.000> mi <sil=0.000> is <sil=0.000> greater <sil=0.000> than <sil=0.000> max <sil=1.000> ,COMMA  then <sil=0.000> if <sil=0.000> I then <sil=0.000> max <sil=0.000> is <sil=0.000> mi <sil=2.000> .PERIOD  And <sil=0.000> that <sil=0.000> will <sil=0.000> go <sil=0.000> on <sil=2.000> .PERIOD  Now
ultimately <sil=0.000> what <sil=0.000> shall <sil=0.000> I turned <sil=0.000> from <sil=0.000> this <sil=0.228> ?QUESTIONMARK  Should <sil=0.000> I return <sil=0.000> the <sil=0.000> max <sil=1.000> ,COMMA  no <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> returning <sil=0.000> the
value <sil=0.000> of <sil=0.000> i <sil=2.000> .PERIOD  Because <sil=1.000> ,COMMA  where <sil=0.000> I found <sil=0.000> the <sil=0.000> maximum <sil=0.000> now <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  for <sil=0.000> that <sil=0.000> now <sil=0.000> this <sil=0.000> I is
changing <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> I will <sil=0.000> also <sil=0.000> have <sil=0.000> to <sil=0.000> make <sil=0.000> say <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> me <sil=0.000> just <sil=0.000> make <sil=0.000> this <sil=0.000> I to <sil=0.000> be <sil=0.000> 0 <sil=1.000> ,COMMA  let <sil=0.000> me
make <sil=0.000> this <sil=0.000> i to <sil=0.000> be <sil=0.000> initially <sil=0.000> i is <sil=0.000> 0 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> could <sil=0.000> have <sil=0.000> d1 <sil=0.000> away <sil=0.000> with <sil=0.000> this <sil=2.000> .PERIOD  And <sil=0.000> wherever <sil=0.000> I get
this <sil=0.000> max <sil=0.000> I am <sil=0.000> changing <sil=0.000> this <sil=0.000> i <sil=1.000> ,COMMA  whenever <sil=0.000> I am <sil=0.000> getting <sil=0.000> this <sil=0.000> max <sil=0.000> I can <sil=0.000> say <sil=0.000> that <sil=0.000> there <sil=0.000> is
another <sil=0.000> max <sil=0.000> index <sil=2.000> .PERIOD  And <sil=0.000> I am <sil=0.000> making <sil=0.000> max <sil=0.000> index <sil=0.000> equals <sil=0.000> i <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> remembering <sil=0.000> where <sil=0.000> I
found <sil=0.000> the <sil=0.000> max <sil=0.000> and <sil=0.000> I will <sil=0.000> be <sil=0.000> returning <sil=0.000> the <sil=0.000> max <sil=0.000> index <sil=1.000> ,COMMA  all <sil=0.000> right <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  my <sil=0.000> maximum <sil=0.000> function <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=1.000> ,COMMA  what <sil=0.000> it <sil=0.000> will <sil=0.000> do <sil=0.000> is <sil=0.000> it <sil=0.000> will <sil=0.000> sorry <sil=0.000> it <sil=0.000> will <sil=0.000> find <sil=0.000> out <sil=0.000> the
maximum <sil=0.000> so <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> return <sil=0.000> 3 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> first <sil=0.000> thing <sil=0.000> is <sil=0.000> find <sil=0.000> max <sil=2.000> .PERIOD  Now <sil=0.000> I have <sil=0.000> got <sil=0.000> an <sil=0.000> array
names <sil=1.000> ,COMMA  how <sil=0.000> does <sil=0.000> that <sil=0.000> represent <sil=0.000> it <sil=0.228> ?QUESTIONMARK  The <sil=0.000> representation <sil=0.000> can <sil=0.000> be <sil=0.000> as <sil=0.000> strings <sil=0.000> or <sil=0.000> it <sil=0.000> can <sil=0.000> be <sil=0.000> as <sil=0.000> an
array <sil=0.000> of <sil=0.000> characters <sil=2.000> .PERIOD  If <sil=0.000> I consider <sil=0.000> this <sil=0.000> to <sil=0.000> be <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> characters <sil=1.000> ,COMMA  then <sil=0.000> remember <sil=0.000> that <sil=0.000> it <sil=0.000> is
a <sil=0.000> 2-dimensional <sil=0.000> array <sil=0.000> ok <sil=2.000> .PERIOD  And <sil=0.000> I will <sil=0.000> in <sil=0.000> that <sil=0.000> case <sil=0.000> I will <sil=0.000> take <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> 3 and <sil=0.000> I will <sil=0.000> come <sil=0.000> to
this <sil=0.000> 3 this <sil=1.000> ,COMMA  and <sil=0.000> I will <sil=0.000> print <sil=0.000> out <sil=0.000> this <sil=0.000> particular <sil=0.000> element <sil=0.000> from <sil=0.000> that <sil=0.000> array <sil=0.000> ok <sil=2.000> .PERIOD  So <sil=0.000> now <sil=1.000> ,COMMA  what
about <sil=0.000> these <sil=0.000> names <sil=0.000> let <sil=0.000> us <sil=0.000> see <sil=2.000> .PERIOD  Names <sil=0.000> is <sil=0.000> an <sil=0.000> address <sil=0.000> a p <sil=1.000> ,COMMA  q <sil=1.000> ,COMMA  r <sil=0.000> or <sil=0.000> something <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> have <sil=0.000> this <sil=0.000> as <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> characters <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  p <sil=0.000> q r <sil=0.000> l m <sil=0.000> whatever <sil=0.000> it <sil=0.000> is <sil=1.000> ,COMMA  and <sil=0.000> this <sil=0.000> part <sil=0.000> is
blank <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> my <sil=0.000> declaration <sil=0.000> of <sil=0.000> names <sil=0.228> ?QUESTIONMARK  Names <sil=0.000> will <sil=0.000> be <sil=0.000> there <sil=0.000> are <sil=0.000> 5 names <sil=1.000> ,COMMA  5 <sil=0.000> rows
and <sil=0.000> each <sil=0.000> row <sil=0.000> is <sil=0.000> a character <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> a character <sil=0.000> array <sil=0.000> char <sil=0.000> names <sil=1.000> ,COMMA  let <sil=0.000> me <sil=0.000> write <sil=0.000> it <sil=0.000> here <sil=2.000> .PERIOD  Char <sil=0.000> names <sil=0.000> 5 rows <sil=1.000> ,COMMA  and <sil=0.000> each
row <sil=0.000> may <sil=0.000> have <sil=0.000> 3 columns <sil=1.000> ,COMMA  right <sil=2.000> .PERIOD  At <sil=0.000> best <sil=0.000> like <sil=0.000> this <sil=0.000> lm <sil=0.000> p lm <sil=0.000> k pq <sil=0.000> r like <sil=0.000> that <sil=0.000> say <sil=2.000> .PERIOD  Now <sil=0.000> I have
suppose <sil=0.000> come <sil=0.000> with <sil=0.000> that <sil=0.000> maximum <sil=0.000> index <sil=0.000> was <sil=0.000> this <sil=0.000> rows <sil=0.000> so <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> 3 <sil=2.000> .PERIOD  Now <sil=0.000> how <sil=0.000> do <sil=0.000> I print
this <sil=0.000> pq <sil=0.000> r name <sil=0.000> here <sil=1.000> ,COMMA  if <sil=0.000> it <sil=0.000> is <sil=0.000> kept <sil=0.000> is <sil=0.000> a string <sil=0.000> I could <sil=0.000> have <sil=0.000> straight <sil=0.000> with <sil=0.000> percentage <sil=0.000> s format <sil=2.000> .PERIOD 
But <sil=0.000> here <sil=0.000> how <sil=0.000> would <sil=0.000> I do <sil=0.000> with <sil=0.000> this <sil=0.000> here <sil=0.000> I can <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> have <sil=0.000> I will <sil=0.000> print <sil=0.000> which <sil=0.000> row <sil=0.000> I will
print <sil=2.000> .PERIOD  I <sil=0.000> am <sil=0.000> not <sil=0.000> writing <sil=0.000> the <sil=0.000> entire <sil=0.000> code <sil=0.000> ok <sil=2.000> .PERIOD  Print <sil=0.000> f which <sil=0.000> row <sil=0.000> would <sil=0.000> I print <sil=0.000> I had <sil=0.000> print <sil=0.000> the
names <sil=0.000> 3 <sil=1.000> ,COMMA  but <sil=0.000> there <sil=0.000> are <sil=0.000> 3 characters <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  names <sil=0.000> 3 in <sil=0.000> a loop <sil=0.000> I have <sil=0.000> to <sil=0.000> print <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  print <sil=0.000> f
so <sil=1.000> ,COMMA  how <sil=0.000> would <sil=0.000> the <sil=0.000> printing <sil=0.000> be <sil=0.000> d1 <sil=0.228> ?QUESTIONMARK  How <sil=0.000> do <sil=0.000> I print <sil=0.228> ?QUESTIONMARK  1 <sil=0.000> rows <sil=0.000> of <sil=0.000> an <sil=0.000> array <sil=0.000> a 2 <sil=0.000> dimensional <sil=0.000> so <sil=1.000> ,COMMA 

here <sil=0.000> I come <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> print <sil=0.000> in <sil=0.000> a loop <sil=0.000> names <sil=0.000> 3 0 <sil=0.000> 3 1 <sil=0.000> 3 2 <sil=0.000> ok <sil=2.000> .PERIOD  Actually <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> 3 should <sil=0.000> be
somewhere <sil=0.000> here <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> confusing <sil=0.000> 3 should <sil=0.000> be <sil=0.000> somewhere <sil=0.000> here <sil=0.000> say <sil=0.000> a <sil=1.000> ,COMMA  b <sil=1.000> ,COMMA  c <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  3 <sil=0.000> is <sil=0.000> actually <sil=0.000> this <sil=0.000> row <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  names <sil=0.000> I will <sil=0.000> be <sil=0.000> printing <sil=0.000> 3 0 <sil=0.000> 3 1 <sil=0.000> 3 2 <sil=0.000> and <sil=0.000> that <sil=0.000> I can <sil=0.000> print <sil=0.000> in <sil=0.000> a
for <sil=0.000> loop <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> leave <sil=0.000> it <sil=0.000> to <sil=0.000> you <sil=0.000> to <sil=0.000> try <sil=0.000> to <sil=0.000> print <sil=0.000> this <sil=0.000> in <sil=0.000> the <sil=0.000> character <sil=0.000> format <sil=2.000> .PERIOD  You <sil=0.000> can <sil=0.000> also <sil=0.000> try
it <sil=0.000> in <sil=0.000> the <sil=0.000> string <sil=0.000> format <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> we <sil=0.000> have <sil=0.000> d1 <sil=0.000> here <sil=0.000> is <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> seen <sil=0.000> the <sil=0.000> how <sil=0.000> the <sil=0.000> macros <sil=0.000> are
replace <sil=0.000> replaced <sil=1.000> ,COMMA  and <sil=0.000> we <sil=0.000> will <sil=0.000> see <sil=0.000> further <sil=0.000> examples <sil=0.000> of <sil=0.000> functions <sil=0.000> all <sil=0.000> through <sil=0.000> in <sil=0.000> the <sil=0.000> future
lectures <sil=1.000> ,COMMA  where <sil=0.000> we <sil=0.000> will <sil=0.000> be <sil=0.000> applying <sil=0.000> functions <sil=0.000> and <sil=0.000> arrays <sil=0.000> consequently <sil=2.000> .PERIOD 

We <sil=0.000> have <sil=0.000> seen <sil=0.000> functions <sil=0.000> in <sil=0.000> the <sil=0.000> earlier <sil=0.000> lecture <sil=2.000> .PERIOD  And <sil=0.000> we <sil=0.000> have <sil=0.000> also <sil=0.000> seen <sil=0.000> we <sil=0.000> tried <sil=0.000> to <sil=0.000> solve <sil=0.000> a
problem <sil=0.000> with <sil=0.000> where <sil=0.000> there <sil=0.000> were <sil=0.000> names <sil=0.000> of <sil=0.000> the <sil=0.000> students <sil=0.000> in <sil=0.000> one <sil=0.000> array <sil=1.000> ,COMMA  and <sil=0.000> the <sil=0.000> marks <sil=0.000> in
another <sil=0.000> array <sil=2.000> .PERIOD  And <sil=0.000> we <sil=0.000> tried <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> try <sil=0.000> to <sil=0.000> print <sil=0.000> out <sil=0.000> the <sil=0.000> name <sil=0.000> of <sil=0.000> the <sil=0.000> student <sil=0.000> who <sil=0.000> got
the <sil=0.000> highest <sil=0.000> marks <sil=0.000> so <sil=1.000> ,COMMA  for <sil=0.000> that <sil=0.000> we <sil=0.000> had <sil=0.000> 2 different <sil=0.000> arrays <sil=2.000> .PERIOD  Now <sil=0.000> the <sil=0.000> same <sil=0.000> thing <sil=0.000> I can <sil=0.000> do
today <sil=0.000> say <sil=0.000> I have <sil=0.000> 10 <sil=0.000> students <sil=2.000> .PERIOD 

And <sil=0.000> each <sil=0.000> of <sil=0.000> them <sil=0.000> have <sil=0.000> appeared <sil=0.000> for <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> so <sil=0.000> sorry <sil=1.000> ,COMMA  each <sil=0.000> of <sil=0.000> them <sil=0.000> has <sil=0.000> appeared <sil=0.000> for <sil=0.000> 4
subjects <sil=1.000> ,COMMA  all <sil=0.000> right <sil=2.000> .PERIOD  Or <sil=0.000> let <sil=0.000> us <sil=0.000> say <sil=0.000> there <sil=0.000> are <sil=0.000> 5 students <sil=1.000> ,COMMA  and <sil=0.000> each <sil=0.000> of <sil=0.000> them <sil=0.000> has <sil=0.000> appeared <sil=0.000> for <sil=0.000> 4
subjects <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  how <sil=0.000> do <sil=0.000> I <sil=1.000> ,COMMA  what <sil=0.000> would <sil=0.000> be <sil=0.000> a convenient <sil=0.000> way <sil=0.000> of <sil=0.000> representing <sil=0.000> them <sil=0.228> ?QUESTIONMARK  One
convenient <sil=0.000> way <sil=0.000> of <sil=0.000> representing <sil=0.000> them <sil=0.000> would <sil=0.000> be <sil=0.000> to <sil=0.000> have <sil=0.000> a 2-dimensional <sil=0.000> matrix <sil=1.000> ,COMMA  2-
dimensional <sil=0.000> array <sil=1.000> ,COMMA  where <sil=0.000> on <sil=0.000> this <sil=0.000> side <sil=0.000> I will <sil=0.000> have <sil=0.000> the <sil=0.000> roll <sil=0.000> number <sil=0.000> of <sil=0.000> the <sil=0.000> students <sil=1.000> ,COMMA  which
is <sil=0.000> an <sil=0.000> integer <sil=0.000> and <sil=0.000> I have <sil=0.000> got <sil=0.000> 5 students <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  1 <sil=1.000> ,COMMA  2 <sil=1.000> ,COMMA  3 <sil=1.000> ,COMMA  4 <sil=0.000> and <sil=0.000> 5 <sil=1.000> ,COMMA  5 <sil=0.000> students <sil=1.000> ,COMMA  and <sil=0.000> the <sil=0.000> marks <sil=0.000> as
the <sil=0.000> columns <sil=0.000> right <sil=1.000> ,COMMA  for <sil=0.000> any <sil=0.000> problem <sil=0.000> solving <sil=0.000> we <sil=0.000> will <sil=0.000> have <sil=0.000> to <sil=0.000> think <sil=0.000> of <sil=0.000> how <sil=0.000> can <sil=0.000> we
represent <sil=0.000> the <sil=0.000> data <sil=0.000> so <sil=0.000> that <sil=0.000> our <sil=0.000> computation <sil=0.000> is <sil=0.000> made <sil=0.000> easy <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  at <sil=0.000> our <sil=0.000> computation <sil=0.000> is
facilitated <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  suppose <sil=0.000> there <sil=0.000> are <sil=0.000> 5 students <sil=0.000> say <sil=0.000> roll <sil=0.000> number <sil=0.000> one <sil=1.000> ,COMMA  roll <sil=0.000> number <sil=0.000> 2 <sil=1.000> ,COMMA  roll <sil=0.000> number <sil=0.000> 3 <sil=1.000> ,COMMA  roll
number <sil=0.000> 4 <sil=1.000> ,COMMA  roll <sil=0.000> number <sil=0.000> 5 <sil=1.000> ,COMMA  and <sil=0.000> for <sil=0.000> each <sil=0.000> of <sil=0.000> them <sil=0.000> we <sil=0.000> have <sil=0.000> got <sil=0.000> 4 columns <sil=0.000> for <sil=0.000> the <sil=0.000> 4 subjects <sil=1.000> ,COMMA 
right <sil=2.000> .PERIOD  Suppose <sil=0.000> the <sil=0.000> subjects <sil=0.000> are <sil=0.000> say <sil=0.000> language <sil=0.000> science <sil=1.000> ,COMMA  mathematics <sil=0.000> and <sil=0.000> say <sil=0.000> history <sil=1.000> ,COMMA  4
subjects <sil=0.000> right <sil=2.000> .PERIOD  And <sil=0.000> so <sil=1.000> ,COMMA  how <sil=0.000> would <sil=0.000> I read <sil=0.000> the <sil=0.000> marks <sil=0.228> ?QUESTIONMARK  How <sil=0.000> would <sil=0.000> I first <sil=0.000> of <sil=0.000> all <sil=0.000> store <sil=0.000> the
marks <sil=0.000> of <sil=0.000> the <sil=0.000> students <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> very <sil=0.000> easily <sil=0.000> understand <sil=0.000> now <sil=1.000> ,COMMA  now <sil=0.000> I am <sil=0.000> not <sil=0.000> writing <sil=0.000> the
program <sil=0.000> I am <sil=0.000> leaving <sil=0.000> the <sil=0.000> writing <sil=0.000> of <sil=0.000> the <sil=0.000> program <sil=0.000> to <sil=0.000> you <sil=2.000> .PERIOD 
But <sil=0.000> let <sil=0.000> us <sil=0.000> try <sil=0.000> to <sil=0.000> understand <sil=0.000> how <sil=0.000> it <sil=0.000> can <sil=0.000> possibly <sil=0.000> be <sil=0.000> solved <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> have <sil=0.000> a function <sil=1.000> ,COMMA  I
can <sil=0.000> write <sil=0.000> a function <sil=0.000> of <sil=0.000> acquiring <sil=0.000> data <sil=2.000> .PERIOD  What <sil=0.000> will <sil=0.000> that <sil=0.000> do <sil=0.228> ?QUESTIONMARK  For <sil=0.000> on <sil=0.000> this <sil=0.000> side <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> have <sil=0.000> an
index <sil=0.000> i <sil=1.000> ,COMMA  that <sil=0.000> will <sil=0.000> talk <sil=0.000> about <sil=0.000> the <sil=0.000> row <sil=0.000> that <sil=0.000> I am <sil=0.000> talking <sil=0.000> about <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  which <sil=0.000> student <sil=0.000> I
am <sil=0.000> talking <sil=0.000> about <sil=0.000> and <sil=0.000> another <sil=0.000> index <sil=0.000> maybe <sil=0.000> j or <sil=0.000> instead <sil=0.000> of <sil=0.000> i j <sil=0.000> you <sil=0.000> can <sil=0.000> say <sil=0.000> roll <sil=0.000> and <sil=0.000> marks <sil=1.000> ,COMMA 
that <sil=0.000> is <sil=0.000> also <sil=0.000> fine <sil=0.000> ok <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  keeping <sil=0.000> I fixed <sil=1.000> ,COMMA  and <sil=0.000> then <sil=0.000> you <sil=0.000> can <sil=0.000> fill <sil=0.000> up <sil=0.000> the <sil=0.000> row <sil=0.000> of <sil=0.000> the <sil=0.000> marks <sil=0.000> of
the <sil=0.000> student <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  how <sil=0.000> would <sil=0.000> that <sil=0.000> program <sil=0.000> segment <sil=0.000> look <sil=0.000> like <sil=0.228> ?QUESTIONMARK  That <sil=0.000> program <sil=0.000> segment <sil=0.000> will
look <sil=0.000> like <sil=0.000> for <sil=0.000> i assigned <sil=0.000> 0 <sil=1.000> ,COMMA  i <sil=0.000> less <sil=0.000> than <sil=0.000> equal <sil=0.000> to <sil=0.000> 4 <sil=1.000> ,COMMA  because <sil=0.000> there <sil=0.000> are <sil=0.000> 5 students <sil=1.000> ,COMMA  i <sil=0.000> plus <sil=0.000> plus <sil=2.000> .PERIOD 

That <sil=0.000> is <sil=0.000> for <sil=0.000> one <sil=0.000> row <sil=0.000> for <sil=0.000> j equals <sil=0.000> 0  <sil=1.000> ,COMMA  j <sil=0.000> less <sil=0.000> than <sil=0.000> equal <sil=0.000> to <sil=0.000> 3 <sil=1.000> ,COMMA  because <sil=0.000> there <sil=0.000> are <sil=0.000> 4 columns <sil=0.000> j
plus <sil=0.000> plus  <sil=1.000> ,COMMA  scanf <sil=0.000> now <sil=0.000> you <sil=0.000> know <sil=0.000> what <sil=0.000> to <sil=0.000> write <sil=0.000> within <sil=0.000> the <sil=0.000> scanf <sil=0.000> ok <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> way <sil=0.000> I can <sil=0.000> read <sil=0.000> the <sil=0.000> marks <sil=2.000> .PERIOD  What <sil=0.000> I was <sil=0.000> saying <sil=0.000> is <sil=0.000> that <sil=0.000> instead <sil=0.000> of <sil=0.000> this <sil=0.000> I can <sil=0.000> see
for <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> be <sil=0.000> very <sil=0.000> clear <sil=0.000> about <sil=0.000> it <sil=1.000> ,COMMA  for <sil=0.000> roll <sil=0.000> equal <sil=0.000> to <sil=0.000> 0 roll <sil=0.000> less <sil=0.000> than <sil=0.000> equal <sil=0.000> to <sil=0.000> 4 roll <sil=0.000> plus <sil=0.000> plus <sil=1.000> ,COMMA 
sorry  <sil=1.000> ,COMMA  roll <sil=0.000> plus <sil=0.000> plus <sil=2.000> .PERIOD  And <sil=0.000> for <sil=0.000> j similarly <sil=0.000> I can <sil=0.000> make <sil=0.000> marks <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  marks <sil=0.000> 0 <sil=1.000> ,COMMA  marks <sil=0.000> less <sil=0.000> than
3 <sil=1.000> ,COMMA  marks <sil=0.000> plus <sil=0.000> plus <sil=0.000> it <sil=0.000> is <sil=0.000> a train <sil=0.000> that <sil=0.000> way <sil=0.000> I can <sil=0.000> fill <sil=0.000> up <sil=0.000> the <sil=0.000> table <sil=0.000> ok <sil=2.000> .PERIOD  So <sil=0.000> now <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> way <sil=1.000> ,COMMA  I

can <sil=0.000> fill <sil=0.000> up <sil=0.000> the <sil=0.000> table <sil=0.000> and <sil=0.000> say <sil=1.000> ,COMMA  I <sil=0.000> get <sil=0.000> the <sil=0.000> marks <sil=0.000> as <sil=0.000> 50 <sil=1.000> ,COMMA  25 <sil=1.000> ,COMMA  70 <sil=1.000> ,COMMA  35 <sil=0.000> like <sil=0.000> that <sil=0.000> some <sil=0.000> numbers <sil=2.000> .PERIOD 
Now <sil=0.000> I can <sil=0.000> have <sil=0.000> another <sil=0.000> function <sil=0.000> that <sil=0.000> will <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> total <sil=0.000> marks <sil=0.000> of <sil=0.000> each <sil=0.000> student <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
right <sil=0.000> now <sil=0.000> I do <sil=0.000> not <sil=0.000> have <sil=0.000> a space <sil=0.000> for <sil=0.000> that <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> keep <sil=0.000> that <sil=0.000> in <sil=0.000> mind <sil=0.000> when <sil=0.000> I am <sil=0.000> preparing <sil=0.000> my <sil=0.000> table <sil=1.000> ,COMMA  then <sil=0.000> I can <sil=0.000> have <sil=0.000> the <sil=0.000> fifth
column <sil=0.000> for <sil=0.000> the <sil=0.000> total <sil=0.000> marks <sil=1.000> ,COMMA  right <sil=2.000> .PERIOD  Now <sil=0.000> I will <sil=0.000> pass <sil=0.000> on <sil=0.000> I have <sil=0.000> read <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  first <sil=0.000> of <sil=0.000> all <sil=1.000> ,COMMA  I <sil=0.000> in
from <sil=0.000> my <sil=0.000> main <sil=0.000> program <sil=1.000> ,COMMA  I <sil=0.000> went <sil=0.000> to <sil=0.000> a particular <sil=0.000> function <sil=0.000> I called <sil=0.000> a particular <sil=0.000> function <sil=1.000> ,COMMA 
which <sil=0.000> acquired <sil=0.000> the <sil=0.000> data <sil=0.000> and <sil=0.000> filled <sil=0.000> up <sil=0.000> all <sil=0.000> these <sil=2.000> .PERIOD  Say <sil=1.000> ,COMMA  70 <sil=1.000> ,COMMA  20 <sil=1.000> ,COMMA  90 <sil=1.000> ,COMMA  15 <sil=1.000> ,COMMA  35 <sil=1.000> ,COMMA  75 <sil=1.000> ,COMMA  90 <sil=1.000> ,COMMA  80 <sil=1.000> ,COMMA  20 <sil=1.000> ,COMMA  25 <sil=1.000> ,COMMA 
60 <sil=1.000> ,COMMA  30 <sil=1.000> ,COMMA  10 <sil=1.000> ,COMMA  20 <sil=1.000> ,COMMA  30 <sil=1.000> ,COMMA  40 <sil=2.000> .PERIOD  Like <sil=0.000> that <sil=0.000> that <sil=0.000> it <sil=0.000> has <sil=0.000> been <sil=0.000> prepared <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  quickly <sil=0.000> let <sil=0.000> us <sil=0.000> see <sil=0.000> what <sil=0.000> we
did <sil=2.000> .PERIOD 

We <sil=0.000> had <sil=0.000> we <sil=0.000> entered <sil=0.000> into <sil=0.000> a main <sil=0.000> function <sil=2.000> .PERIOD  And <sil=0.000> from <sil=0.000> the <sil=0.000> main <sil=0.000> function <sil=1.000> ,COMMA  I <sil=0.000> called <sil=0.000> invoked <sil=0.000> a
function <sil=1.000> ,COMMA  which <sil=0.000> is <sil=0.000> acquired <sil=0.000> data <sil=1.000> ,COMMA  and <sil=0.000> what <sil=0.000> should <sil=0.000> the <sil=0.000> type <sil=0.000> of <sil=0.000> that <sil=0.000> function <sil=0.000> be <sil=0.000> acquired
data <sil=1.000> ,COMMA  is <sil=0.000> it <sil=0.000> returning <sil=0.000> anything <sil=0.228> ?QUESTIONMARK  No <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  it <sil=0.000> should <sil=0.000> be <sil=0.000> something <sil=0.000> like <sil=0.000> void <sil=0.000> acquire <sil=0.000> data <sil=0.000> d <sil=2.000> .PERIOD  And <sil=0.000> where <sil=0.000> is <sil=0.000> it <sil=0.000> acquiring <sil=0.000> the <sil=0.000> data <sil=0.228> ?QUESTIONMARK 
In <sil=0.000> the <sil=0.000> integer <sil=0.000> array <sil=1.000> ,COMMA  int <sil=0.000> say <sil=0.000> let <sil=0.000> us <sil=0.000> call <sil=0.000> that <sil=0.000> array <sil=0.000> A and <sil=0.000> there <sil=0.000> should <sil=0.000> be <sil=0.000> it <sil=0.000> is <sil=0.000> a 2-
dimensional <sil=0.000> array <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> should <sil=0.000> have <sil=0.000> something <sil=0.000> like <sil=0.000> this <sil=2.000> .PERIOD  This <sil=0.000> time <sil=0.000> writing <sil=0.000> clearly <sil=0.000> int <sil=0.000> a if
that <sil=0.000> array <sil=0.000> was <sil=0.000> a <sil=1.000> ,COMMA  that <sil=0.000> was <sil=0.000> the <sil=0.000> parameter <sil=2.000> .PERIOD  Now <sil=0.000> so <sil=1.000> ,COMMA  here <sil=0.000> that <sil=0.000> was <sil=0.000> array <sil=0.000> A <sil=1.000> ,COMMA  and <sil=0.000> here <sil=0.000> it <sil=0.000> has
been <sil=0.000> called <sil=0.000> like <sil=0.000> acquire <sil=0.000> data <sil=1.000> ,COMMA  say <sil=1.000> ,COMMA  my <sil=0.000> array <sil=2.000> .PERIOD  And <sil=0.000> also <sil=0.000> the <sil=0.000> size <sil=0.000> has <sil=0.000> been <sil=0.000> specified <sil=2.000> .PERIOD  The
size <sil=0.000> is <sil=0.000> suppose <sil=0.000> globally <sil=0.000> specified <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> get <sil=0.000> that <sil=0.000> array <sil=0.000> size <sil=2.000> .PERIOD  Suppose <sil=0.000> it <sil=0.000> is <sil=0.000> defined <sil=0.000> that <sil=0.000> row <sil=0.000> roll <sil=0.000> size <sil=0.000> is <sil=0.000> 5 and <sil=0.000> subject <sil=0.000> size <sil=0.000> is <sil=0.000> 4 <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> know <sil=1.000> ,COMMA  but <sil=0.000> this <sil=0.000> says <sil=0.000> subject <sil=0.000> size <sil=0.000> plus <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> needed <sil=0.000> one <sil=0.000> more <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> I can <sil=0.000> go
here <sil=0.000> and <sil=0.000> from <sil=0.000> there <sil=1.000> ,COMMA  I <sil=0.000> returned <sil=0.000> here <sil=2.000> .PERIOD  And <sil=0.000> then <sil=0.000> I can <sil=0.000> call <sil=0.000> another <sil=0.000> fine <sil=0.000> total <sil=0.000> of <sil=0.000> my <sil=0.000> array <sil=2.000> .PERIOD 
Then <sil=0.000> what <sil=0.000> will <sil=0.000> you <sil=0.000> do <sil=0.228> ?QUESTIONMARK  Essentially <sil=1.000> ,COMMA  I <sil=0.000> come <sil=0.000> to <sil=0.000> this <sil=1.000> ,COMMA  and <sil=0.000> what <sil=0.000> does <sil=0.000> that <sil=0.000> function <sil=0.000> do <sil=0.000> that
piece <sil=0.000> of <sil=0.000> function <sil=0.354> ;SEMICOLON  that <sil=0.000> is <sil=1.000> ,COMMA  finding <sil=0.000> out <sil=0.000> the <sil=0.000> total <sil=0.000> of <sil=0.000> each <sil=0.000> student <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  that <sil=0.000> will <sil=0.000> again <sil=0.000> be <sil=0.000> a for <sil=0.000> loop <sil=0.000> like <sil=0.000> the <sil=0.000> one <sil=0.000> that <sil=0.000> we <sil=0.000> had <sil=0.000> done <sil=0.000> earlier <sil=1.000> ,COMMA  and <sil=0.000> I will <sil=0.000> add <sil=0.000> keep
I <sil=0.000> to <sil=0.000> be <sil=0.000> fixed <sil=1.000> ,COMMA  and <sil=0.000> add <sil=0.000> these <sil=0.000> and <sil=0.000> write <sil=0.000> the <sil=0.000> total <sil=0.000> here <sil=2.000> .PERIOD  Now <sil=0.000> I could <sil=0.000> have <sil=0.000> kept <sil=0.000> it <sil=0.000> here <sil=1.000> ,COMMA  or <sil=0.000> I
can <sil=0.000> have <sil=0.000> another <sil=0.000> array <sil=0.000> total <sil=0.000> let <sil=0.000> us <sil=0.000> do <sil=0.000> that <sil=1.000> ,COMMA  suppose <sil=0.000> I am <sil=0.000> not <sil=0.000> having <sil=0.000> I am <sil=0.000> just <sil=0.000> having <sil=0.000> the
marks <sil=0.000> here <sil=2.000> .PERIOD  And <sil=0.000> the <sil=0.000> total <sil=0.000> array <sil=0.000> is <sil=0.000> not <sil=0.000> here <sil=1.000> ,COMMA  but <sil=0.000> a separate <sil=0.000> array <sil=0.000> all <sil=0.000> together <sil=1.000> ,COMMA  all <sil=0.000> right <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> another <sil=0.000> array <sil=0.000> which <sil=0.000> is <sil=0.000> total <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> have <sil=0.000> the <sil=0.000> sum <sil=0.000> of <sil=0.000> each <sil=0.000> of <sil=0.000> them <sil=0.000> being
passed <sil=0.000> to <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> case <sil=0.000> when <sil=0.000> I am <sil=0.000> calling <sil=1.000> ,COMMA  when <sil=0.000> I am <sil=0.000> calling <sil=0.000> fine <sil=0.000> total <sil=0.000> then <sil=0.000> I am
passing <sil=0.000> on <sil=0.000> this <sil=0.000> array <sil=0.000> as <sil=0.000> well <sil=0.000> as <sil=0.000> the <sil=0.000> total <sil=0.000> array <sil=0.000> 2 arrays <sil=0.000> because <sil=0.000> I want <sil=0.000> to <sil=0.000> put <sil=0.000> the <sil=0.000> sum <sil=0.000> on
the <sil=0.000> total <sil=0.000> array <sil=0.000> ok <sil=2.000> .PERIOD  With <sil=0.000> that <sil=0.000> I can <sil=0.000> find <sil=0.000> the <sil=0.000> sum <sil=0.000> of <sil=0.000> this <sil=0.000> sum <sil=0.000> of <sil=0.000> this <sil=1.000> ,COMMA  sum <sil=0.000> of <sil=0.000> this <sil=1.000> ,COMMA  sum <sil=0.000> of
this <sil=1.000> ,COMMA  sum <sil=0.000> of <sil=0.000> this <sil=2.000> .PERIOD  And <sil=0.000> then <sil=0.000> I can <sil=0.000> make <sil=0.000> another <sil=0.000> function <sil=1.000> ,COMMA  where <sil=0.000> it <sil=0.000> finds <sil=0.000> the <sil=0.000> max <sil=0.000> or
whatever <sil=0.000> I want <sil=0.000> to <sil=0.000> do <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  accordingly <sil=0.000> the <sil=0.000> point <sil=0.000> is <sil=0.000> that <sil=0.000> for <sil=0.000> each <sil=0.000> of <sil=0.000> the <sil=0.000> activities <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> make <sil=0.000> small <sil=0.000> small
functions <sil=2.000> .PERIOD  One <sil=0.000> is <sil=0.000> for <sil=0.000> acquiring <sil=0.000> data <sil=0.354> ;SEMICOLON  one <sil=0.000> is <sil=0.000> for <sil=0.000> finding <sil=0.000> the <sil=0.000> total <sil=2.000> .PERIOD  One <sil=0.000> is <sil=0.000> for <sil=0.000> finding <sil=0.000> the
maximum <sil=0.000> number <sil=1.000> ,COMMA  or <sil=0.000> maybe <sil=0.000> some <sil=0.000> other <sil=0.000> things <sil=0.000> also <sil=0.000> sorting <sil=0.000> and <sil=0.000> all <sil=0.000> those <sil=2.000> .PERIOD  I <sil=0.000> can <sil=0.000> do <sil=1.000> ,COMMA  I <sil=0.000> can
find <sil=0.000> out <sil=0.000> the <sil=0.000> failure <sil=0.000> list <sil=0.000> another <sil=0.000> function <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> have <sil=0.000> a complete <sil=0.000> set <sil=0.000> of <sil=0.000> small <sil=0.000> small
functions <sil=2.000> .PERIOD 

Each <sil=0.000> independently <sil=0.000> done <sil=1.000> ,COMMA  say <sil=0.000> did <sil=0.000> acquiring <sil=0.000> data <sil=1.000> ,COMMA  finding <sil=0.000> total <sil=1.000> ,COMMA  finding <sil=0.000> max <sil=1.000> ,COMMA  all <sil=0.000> these <sil=0.000> and
they <sil=0.000> are <sil=0.000> communicating <sil=0.000> through <sil=0.000> a main <sil=0.000> program <sil=1.000> ,COMMA  and <sil=0.000> the <sil=0.000> main <sil=0.000> program <sil=0.000> my <sil=0.000> data <sil=0.000> is <sil=0.000> one
array <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> me <sil=0.000> let <sil=0.000> me <sil=0.000> draw <sil=0.000> the <sil=0.000> data <sil=0.000> using <sil=0.000> red <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  here <sil=0.000> I have <sil=0.000> got <sil=0.000> my <sil=0.000> array <sil=1.000> ,COMMA  which <sil=0.000> was <sil=0.000> called <sil=0.000> my <sil=0.000> array <sil=1.000> ,COMMA  array <sil=0.000> which <sil=0.000> had <sil=0.000> the <sil=0.000> size <sil=0.000> 5 <sil=1.000> ,COMMA  5
and <sil=0.000> 4 <sil=2.000> .PERIOD  And <sil=0.000> I had <sil=0.000> another <sil=0.000> array <sil=0.000> total <sil=1.000> ,COMMA  total <sil=0.000> which <sil=0.000> is <sil=0.000> a one-dimensional <sil=0.000> array <sil=0.000> how <sil=0.000> many <sil=0.228> ?QUESTIONMARK  5
students <sil=0.000> so <sil=0.000> these <sil=0.000> 2 so <sil=1.000> ,COMMA  the <sil=0.000> main <sil=0.000> function <sil=0.000> is <sil=0.000> invoking <sil=0.000> from <sil=0.000> different <sil=0.000> points <sil=0.000> for <sil=0.000> different
tasks <sil=0.000> these <sil=0.000> functions <sil=2.000> .PERIOD  And <sil=0.000> this <sil=0.000> function <sil=0.000> is <sil=0.000> working <sil=0.000> on <sil=0.000> this <sil=0.000> array <sil=1.000> ,COMMA  shared <sil=0.000> array <sil=2.000> .PERIOD  This
function <sil=0.000> is <sil=0.000> working <sil=0.000> on <sil=0.000> this <sil=0.000> array <sil=0.000> and <sil=0.000> generating <sil=0.000> the <sil=0.000> total <sil=1.000> ,COMMA  maybe <sil=0.000> this <sil=0.000> function <sil=0.000> is <sil=0.000> doing
something <sil=0.000> else <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  that <sil=0.000> these <sil=0.000> arrays <sil=0.000> are <sil=0.000> being <sil=0.000> shared <sil=0.000> by <sil=0.000> the <sil=0.000> main <sil=0.000> function <sil=0.000> and <sil=0.000> the <sil=0.000> small <sil=0.000> functions <sil=2.000> .PERIOD  That
is <sil=0.000> how <sil=0.000> using <sil=0.000> functions <sil=0.000> I can <sil=0.000> divide <sil=0.000> a task <sil=0.000> into <sil=0.000> smaller <sil=0.000> sub <sil=0.000> tasks <sil=0.000> and <sil=0.000> can <sil=0.000> do <sil=0.000> it <sil=0.000> very <sil=0.000> nicely <sil=2.000> .PERIOD 
Now <sil=0.000> with <sil=0.000> this <sil=1.000> ,COMMA  now <sil=0.000> let <sil=0.000> us <sil=0.000> move <sil=0.000> to <sil=0.000> another <sil=0.000> problem <sil=0.000> one <sil=0.000> a version <sil=0.000> of <sil=0.000> which <sil=0.000> we <sil=0.000> had
encountered <sil=0.000> earlier <sil=0.354> ;SEMICOLON  that <sil=0.000> is <sil=1.000> ,COMMA  searching <sil=0.000> an <sil=0.000> array <sil=2.000> .PERIOD  When <sil=0.000> we <sil=0.000> have <sil=0.000> got <sil=0.000> an <sil=0.000> array <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA 
here <sil=0.000> when <sil=0.000> he <sil=0.000> found <sil=0.000> say <sil=0.000> suppose <sil=1.000> ,COMMA  I <sil=0.000> found <sil=0.000> the <sil=0.000> total <sil=0.000> here <sil=2.000> .PERIOD  I <sil=0.000> found <sil=0.000> the <sil=0.000> total <sil=1.000> ,COMMA  and <sil=0.000> from <sil=0.000> there <sil=0.000> I
find <sil=0.000> out <sil=0.000> which <sil=0.000> one <sil=0.000> is <sil=0.000> a maximum <sil=0.000> or <sil=0.000> is <sil=0.000> it <sil=0.000> that <sil=0.000> if <sil=0.000> there <sil=0.000> is <sil=0.000> any <sil=0.000> student <sil=0.000> whose <sil=0.000> total <sil=0.000> is <sil=0.000> less
than <sil=0.000> 100 <sil=1.000> ,COMMA  I <sil=0.000> want <sil=0.000> to <sil=0.000> test <sil=0.000> that <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> to <sil=0.000> search <sil=0.000> this <sil=0.000> array <sil=2.000> .PERIOD  Similarly <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> search <sil=0.000> if <sil=0.000> there <sil=0.000> is <sil=0.000> any <sil=0.000> student <sil=1.000> ,COMMA  who <sil=0.000> has <sil=0.000> got
in <sil=0.000> science <sil=0.000> more <sil=0.000> than <sil=0.000> 90 <sil=2.000> .PERIOD  I <sil=0.000> can <sil=0.000> search <sil=0.000> that <sil=0.000> along <sil=0.000> this <sil=0.000> array <sil=1.000> ,COMMA  all <sil=0.000> right <sil=0.228> ?QUESTIONMARK  I <sil=0.000> find <sil=0.000> if <sil=0.000> there <sil=0.000> is <sil=0.000> any
40 <sil=0.000> is <sil=0.000> the <sil=0.000> pass <sil=0.000> mark <sil=1.000> ,COMMA  if <sil=0.000> there <sil=0.000> is <sil=0.000> any <sil=0.000> student <sil=2.000> .PERIOD  Who <sil=0.000> has <sil=0.000> not <sil=0.000> passed <sil=0.000> in <sil=0.000> maths <sil=0.228> ?QUESTIONMARK  I <sil=0.000> find <sil=0.000> here

there <sil=0.000> is <sil=0.000> a failure <sil=0.000> case <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  for <sil=0.000> that <sil=0.000> I need <sil=0.000> to <sil=0.000> do <sil=0.000> a search <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  search <sil=0.000> is <sil=0.000> very <sil=0.000> fundamental <sil=1.000> ,COMMA 
search <sil=0.000> is <sil=0.000> absolutely <sil=0.000> fundamental <sil=0.000> to <sil=0.000> computation <sil=2.000> .PERIOD  And <sil=0.000> so <sil=1.000> ,COMMA  first <sil=0.000> we <sil=0.000> have <sil=0.000> already <sil=0.000> seen
linear <sil=0.000> search <sil=1.000> ,COMMA  but <sil=0.000> I once <sil=0.000> again <sil=0.000> have <sil=0.000> a journey <sil=0.000> through <sil=0.000> that <sil=0.000> ok <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  we <sil=0.000> know <sil=0.000> that <sil=0.000> in <sil=0.000> a search <sil=0.000> we <sil=0.000> are <sil=0.000> given <sil=0.000> a key <sil=0.000> which <sil=0.000> we <sil=0.000> are <sil=0.000> searching <sil=0.000> for <sil=0.000> a particular
key <sil=0.000> that <sil=0.000> we <sil=0.000> want <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=1.000> ,COMMA  if <sil=0.000> the <sil=0.000> key <sil=0.000> is <sil=0.000> present <sil=0.000> in <sil=0.000> the <sil=0.000> array <sil=1.000> ,COMMA  then <sil=0.000> we <sil=0.000> have <sil=0.000> to <sil=0.000> say <sil=0.000> that
the <sil=0.000> key <sil=0.000> is <sil=0.000> present <sil=0.000> and <sil=0.000> also <sil=0.000> the <sil=0.000> position <sil=0.000> where <sil=0.000> the <sil=0.000> key <sil=0.000> is <sil=0.000> present <sil=1.000> ,COMMA  all <sil=0.000> right <sil=2.000> .PERIOD  Now <sil=0.000> we <sil=0.000> will
consider <sil=0.000> 2 cases <sil=2.000> .PERIOD  One <sil=0.000> is <sil=0.000> that <sil=0.000> the <sil=0.000> array <sil=0.000> is <sil=0.000> unsorted <sil=2.000> .PERIOD 
What <sil=0.000> do <sil=0.000> I mean <sil=0.000> by <sil=0.000> unsorted <sil=0.228> ?QUESTIONMARK  By <sil=0.000> unsorted <sil=0.000> I mean <sil=0.000> that <sil=0.000> the <sil=0.000> elements <sil=0.000> are <sil=0.000> not <sil=0.000> in <sil=0.000> any
particular <sil=0.000> order <sil=2.000> .PERIOD 

For <sil=0.000> example <sil=1.000> ,COMMA  think <sil=0.000> of <sil=0.000> this <sil=0.000> array <sil=0.000> where <sil=0.000> the <sil=0.000> elements <sil=0.000> are <sil=0.000> 5 <sil=1.000> ,COMMA  3 <sil=1.000> ,COMMA  2 <sil=1.000> ,COMMA  9 <sil=1.000> ,COMMA  8 <sil=1.000> ,COMMA  17 <sil=1.000> ,COMMA  6 <sil=2.000> .PERIOD  Now <sil=0.000> this <sil=0.000> array
is <sil=0.000> not <sil=0.000> in <sil=0.000> any <sil=0.000> increasing <sil=0.000> order <sil=1.000> ,COMMA  not <sil=0.000> in <sil=0.000> some <sil=0.000> decreasing <sil=0.000> order <sil=2.000> .PERIOD  It <sil=0.000> is <sil=0.000> decreasing <sil=0.000> here
decreasing <sil=0.000> here <sil=2.000> .PERIOD  Again <sil=1.000> ,COMMA  increased <sil=0.000> here <sil=1.000> ,COMMA  decreased <sil=0.000> here <sil=1.000> ,COMMA  again <sil=0.000> increased <sil=0.000> here <sil=1.000> ,COMMA  decreased
here <sil=2.000> .PERIOD  On <sil=0.000> the <sil=0.000> other <sil=0.000> hand <sil=1.000> ,COMMA  if <sil=0.000> the <sil=0.000> array <sil=0.000> was <sil=0.000> something <sil=0.000> like <sil=0.000> this <sil=0.354> ;SEMICOLON  say <sil=1.000> ,COMMA  2 <sil=1.000> ,COMMA  3 <sil=1.000> ,COMMA  5 <sil=1.000> ,COMMA  6 <sil=1.000> ,COMMA  sorry <sil=1.000> ,COMMA  2 <sil=1.000> ,COMMA  3 <sil=1.000> ,COMMA  5 <sil=1.000> ,COMMA 
5 <sil=1.000> ,COMMA  6 <sil=1.000> ,COMMA  8 <sil=1.000> ,COMMA  9 <sil=1.000> ,COMMA  17 <sil=2.000> .PERIOD  Then <sil=0.000> this <sil=0.000> array <sil=0.000> is <sil=0.000> sorted <sil=0.000> in <sil=0.000> an <sil=0.000> increasing <sil=0.000> order <sil=2.000> .PERIOD  That <sil=0.000> as <sil=0.000> I go <sil=0.000> from <sil=0.000> top <sil=0.000> to
down <sil=0.000> it <sil=0.000> is <sil=0.000> in <sil=0.000> an <sil=0.000> increasing <sil=0.000> order <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> sorted <sil=0.000> in <sil=0.000> increasing <sil=0.000> order <sil=2.000> .PERIOD  It <sil=0.000> could <sil=0.000> be <sil=0.000> sorted <sil=1.000> ,COMMA  in <sil=0.000> the
decreasing <sil=0.000> order <sil=0.000> also <sil=2.000> .PERIOD  Like <sil=1.000> ,COMMA  say <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  I <sil=0.000> start <sil=0.000> with <sil=0.000> 17 <sil=1.000> ,COMMA  then <sil=0.000> 9 <sil=1.000> ,COMMA  then <sil=0.000> 8 <sil=1.000> ,COMMA  then <sil=0.000> 6 <sil=1.000> ,COMMA  then
5 <sil=1.000> ,COMMA  then <sil=0.000> 3 <sil=1.000> ,COMMA  then <sil=0.000> 2 <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> as <sil=0.000> we <sil=0.000> go <sil=0.000> down <sil=0.000> the <sil=0.000> numbers <sil=0.000> are <sil=0.000> decreasing <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  these <sil=0.000> are <sil=0.000> ordered <sil=0.000> or <sil=0.000> sorted <sil=2.000> .PERIOD 
And <sil=0.000> this <sil=0.000> is <sil=0.000> unsorted <sil=2.000> .PERIOD  These <sil=0.000> also <sil=0.000> sorted <sil=1.000> ,COMMA  but <sil=0.000> in <sil=0.000> a different <sil=0.000> order <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> may <sil=0.000> have <sil=0.000> to <sil=0.000> search
from <sil=0.000> an <sil=0.000> array <sil=0.000> that <sil=0.000> is <sil=0.000> either <sil=0.000> unsorted <sil=0.000> or <sil=0.000> sorted <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  first <sil=0.000> let <sil=0.000> us <sil=0.000> think <sil=0.000> of <sil=0.000> dealing <sil=0.000> with
unsorted <sil=0.000> arrays <sil=1.000> ,COMMA  all <sil=0.000> right <sil=2.000> .PERIOD  And <sil=0.000> we <sil=0.000> will <sil=0.000> look <sil=0.000> into <sil=0.000> the <sil=0.000> linear <sil=0.000> search <sil=0.000> algorithm <sil=0.000> for <sil=0.000> doing
that <sil=2.000> .PERIOD  And <sil=0.000> if <sil=0.000> the <sil=0.000> elements <sil=0.000> are <sil=0.000> sorted <sil=0.000> we <sil=0.000> have <sil=0.000> got <sil=0.000> a more <sil=0.000> efficient <sil=0.000> such <sil=0.000> algorithm <sil=0.000> called
the <sil=0.000> binary <sil=0.000> search <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  linear <sil=0.000> search <sil=0.000> we <sil=0.000> have <sil=0.000> already <sil=0.000> seen <sil=0.000> in <sil=0.000> an <sil=0.000> earlier <sil=0.000> lecture <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> basic <sil=0.000> idea <sil=0.000> is <sil=0.000> we <sil=0.000> start
at <sil=0.000> the <sil=0.000> beginning <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> we <sil=0.000> come <sil=0.000> here <sil=1.000> ,COMMA  if <sil=0.000> we <sil=0.000> come <sil=0.000> here <sil=1.000> ,COMMA  sorry <sil=1.000> ,COMMA  we <sil=0.000> start <sil=0.000> say <sil=0.000> I
want <sil=0.000> to <sil=0.000> search <sil=0.000> this <sil=2.000> .PERIOD  I <sil=0.000> start <sil=0.000> at <sil=0.000> the <sil=0.000> beginning <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=2.000> .PERIOD  I <sil=0.000> start <sil=0.000> here <sil=2.000> .PERIOD  And <sil=0.000> I have <sil=0.000> got <sil=0.000> a key <sil=2.000> .PERIOD 
A <sil=0.000> key <sil=0.000> is <sil=0.000> there <sil=1.000> ,COMMA  say <sil=0.000> key <sil=0.000> is <sil=0.000> 8 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> start <sil=0.000> from <sil=0.000> the <sil=0.000> top <sil=2.000> .PERIOD 
Look <sil=0.000> for <sil=0.000> the <sil=0.000> availability <sil=0.000> of <sil=0.000> a look <sil=0.000> for <sil=0.000> the <sil=0.000> element <sil=0.000> matching <sil=0.000> the <sil=0.000> key <sil=1.000> ,COMMA  5 <sil=0.000> is <sil=0.000> not <sil=0.000> matching <sil=0.000> 8 <sil=1.000> ,COMMA 
then <sil=0.000> I go <sil=0.000> on <sil=0.000> increasing <sil=0.000> this <sil=0.000> index <sil=1.000> ,COMMA  and <sil=0.000> go <sil=0.000> on <sil=0.000> comparing <sil=0.000> till <sil=0.000> I find <sil=0.000> either <sil=0.000> if <sil=0.000> 8 is <sil=0.000> not <sil=0.000> there <sil=1.000> ,COMMA  I
will <sil=0.000> come <sil=0.000> to <sil=0.000> the <sil=0.000> end <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=0.000> all <sil=0.000> the <sil=0.000> elements <sil=0.000> have <sil=0.000> been <sil=0.000> checked <sil=0.000> I have <sil=0.000> not <sil=0.000> found <sil=0.000> the
match <sil=1.000> ,COMMA  or <sil=0.000> when <sil=0.000> I get <sil=0.000> the <sil=0.000> match <sil=0.000> I will <sil=0.000> say <sil=0.000> that <sil=0.000> at <sil=0.000> this <sil=0.000> position <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> the <sil=0.000> key
matching <sil=1.000> ,COMMA  all <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> start <sil=0.000> at <sil=0.000> the <sil=0.000> beginning <sil=0.000> of <sil=0.000> the <sil=0.000> adding <sil=1.000> ,COMMA  and <sil=0.000> inspect <sil=0.000> every
element <sil=0.000> to <sil=0.000> see <sil=0.000> if <sil=0.000> it <sil=0.000> matches <sil=0.000> the <sil=0.000> key <sil=2.000> .PERIOD  Now <sil=0.000> if <sil=0.000> I want <sil=0.000> to <sil=0.000> do <sil=0.000> it <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=1.000> ,COMMA  we <sil=0.000> often <sil=0.000> talk
about <sil=0.000> time <sil=0.000> complexity <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> a measure <sil=0.000> I am <sil=0.000> not <sil=0.000> going <sil=0.000> into <sil=0.000> the <sil=0.000> formal <sil=0.000> way <sil=0.000> of <sil=0.000> the
measure <sil=1.000> ,COMMA  the <sil=0.000> measure <sil=0.000> of <sil=0.000> how <sil=0.000> long <sil=0.000> an <sil=0.000> algorithm <sil=0.000> takes <sil=0.000> to <sil=0.000> run <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  as <sil=0.000> you <sil=0.000> can <sil=0.000> understand <sil=1.000> ,COMMA  if <sil=0.000> there <sil=0.000> are <sil=0.000> n elements <sil=0.000> in <sil=0.000> the <sil=0.000> array <sil=1.000> ,COMMA  then <sil=0.000> the <sil=0.000> best <sil=0.000> case <sil=0.000> would
be <sil=0.000> let <sil=0.000> us <sil=0.000> you <sil=0.000> will <sil=0.000> find <sil=0.000> out <sil=0.000> what <sil=0.000> it <sil=0.000> will <sil=0.000> be <sil=0.000> say <sil=1.000> ,COMMA  I <sil=0.000> start <sil=0.000> with <sil=0.000> this <sil=2.000> .PERIOD  It <sil=0.000> may <sil=0.000> be <sil=0.000> supposed <sil=1.000> ,COMMA  the
key <sil=0.000> was <sil=0.000> 5 <sil=1.000> ,COMMA  suppose <sil=0.000> the <sil=0.000> key <sil=0.000> was <sil=0.000> 5 <sil=2.000> .PERIOD  In <sil=0.000> that <sil=0.000> case <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> the <sil=0.000> best <sil=0.000> case <sil=0.000> with <sil=0.000> one <sil=0.000> match <sil=0.000> one
comparison <sil=0.000> I find <sil=0.000> it <sil=0.000> how <sil=0.000> many <sil=0.000> comparisons <sil=0.000> how <sil=0.000> many <sil=0.000> inspections <sil=0.000> I needed <sil=0.000> only <sil=0.000> one <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> the <sil=0.000> best <sil=0.000> case <sil=1.000> ,COMMA  the <sil=0.000> worst <sil=0.000> case <sil=0.000> could <sil=0.000> be <sil=0.000> if <sil=0.000> my <sil=0.000> key <sil=0.000> was <sil=0.000> 6 <sil=2.000> .PERIOD  If <sil=0.000> my <sil=0.000> key <sil=0.000> was <sil=0.000> 6 <sil=1.000> ,COMMA  then <sil=0.000> I
would <sil=0.000> have <sil=0.000> to <sil=0.000> inspect <sil=0.000> every <sil=0.000> element <sil=2.000> .PERIOD  And <sil=0.000> since <sil=0.000> there <sil=0.000> are <sil=0.000> 7 elements <sil=0.000> here <sil=1.000> ,COMMA  I <sil=0.000> had <sil=0.000> to <sil=0.000> carry
out <sil=0.000> 7 comparisons <sil=1.000> ,COMMA  7 <sil=0.000> inspections <sil=0.000> till <sil=0.000> I found <sil=0.000> the <sil=0.000> match <sil=0.000> right <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  the <sil=0.000> best <sil=0.000> case <sil=0.000> would <sil=0.000> be <sil=0.000> first <sil=0.000> element <sil=0.000> one <sil=0.000> inspection <sil=0.000> one <sil=0.000> search <sil=0.000> operation <sil=2.000> .PERIOD  And <sil=0.000> the
worst <sil=0.000> case <sil=0.000> would <sil=0.000> be <sil=0.000> no <sil=0.000> match <sil=0.000> found <sil=2.000> .PERIOD  Either <sil=0.000> the <sil=0.000> last <sil=0.000> element <sil=0.000> or <sil=0.000> not <sil=0.000> at <sil=0.000> all <sil=0.000> found <sil=0.000> even <sil=0.000> after
that <sil=2.000> .PERIOD  In <sil=0.000> that <sil=0.000> case <sil=0.000> I need <sil=0.000> n search <sil=0.000> operations <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> best <sil=0.000> case <sil=0.000> is <sil=0.000> one <sil=1.000> ,COMMA  the <sil=0.000> worst <sil=0.000> case <sil=0.000> is <sil=0.000> if
the <sil=0.000> size <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=0.000> is <sil=0.000> n <sil=1.000> ,COMMA  then <sil=0.000> n <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> average <sil=0.000> would <sil=0.000> be <sil=0.000> n plus <sil=0.000> 1 by <sil=0.000> 2 search
operations <sil=1.000> ,COMMA  n <sil=0.000> plus <sil=0.000> 1 by <sil=0.000> 2 that <sil=0.000> is <sil=0.000> a cost <sil=0.000> how <sil=0.000> much <sil=0.000> time <sil=0.000> that <sil=0.000> gives <sil=0.000> a measure <sil=0.000> of <sil=0.000> the <sil=0.000> time
the <sil=0.000> algorithm <sil=0.000> will <sil=0.000> take <sil=0.000> to <sil=0.000> run <sil=2.000> .PERIOD 

So <sil=0.000> now <sil=0.000> we <sil=0.000> are <sil=0.000> trying <sil=0.000> to <sil=0.000> write <sil=0.000> it <sil=0.000> we <sil=0.000> had <sil=0.000> explained <sil=0.000> this <sil=0.000> algorithm <sil=0.000> also <sil=0.000> earlier <sil=2.000> .PERIOD  But <sil=0.000> now
that <sil=0.000> we <sil=0.000> have <sil=0.000> done <sil=0.000> functions <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> write <sil=0.000> a function <sil=0.000> for <sil=0.000> linear <sil=0.000> search <sil=2.000> .PERIOD  Why <sil=0.000> am <sil=0.000> I writing
the <sil=0.000> function <sil=0.228> ?QUESTIONMARK  Say <sil=0.000> again <sil=0.000> if <sil=0.000> I go <sil=0.000> to <sil=0.000> this <sil=0.000> case <sil=2.000> .PERIOD  Now <sil=0.000> I may <sil=0.000> like <sil=0.000> to <sil=0.000> say <sil=0.000> my <sil=0.000> task <sil=0.000> is <sil=0.000> to <sil=0.000> find <sil=0.000> out
whether <sil=0.000> I any <sil=0.000> student <sil=0.000> who <sil=0.000> has <sil=0.000> got <sil=0.000> more <sil=0.000> than <sil=0.000> 80 <sil=1.000> ,COMMA  all <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> need <sil=0.000> to <sil=0.000> write <sil=0.000> a
function <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> to <sil=0.000> search <sil=0.000> this <sil=0.000> in <sil=0.000> a linear <sil=0.000> way <sil=0.000> in <sil=0.000> a sequential <sil=0.000> way <sil=0.000> one <sil=0.000> after <sil=0.000> another <sil=0.000> and
for <sil=0.000> that <sil=0.000> I have <sil=0.000> to <sil=0.000> write <sil=0.000> a function <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  how <sil=0.000> is <sil=0.000> that <sil=0.000> function <sil=1.000> ,COMMA  how <sil=0.000> will <sil=0.000> that <sil=0.000> function <sil=0.000> look <sil=0.000> like <sil=0.228> ?QUESTIONMARK  Let <sil=0.000> us <sil=0.000> see <sil=0.000> what <sil=0.000> are <sil=0.000> the <sil=0.000> things <sil=0.000> I
need <sil=0.000> I have <sil=0.000> got <sil=0.000> an <sil=0.000> array <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> need <sil=0.000> to <sil=0.000> know <sil=0.000> which <sil=0.000> array <sil=0.000> I will <sil=0.000> be <sil=0.000> working <sil=0.000> with <sil=1.000> ,COMMA  and <sil=0.000> that
is <sil=0.000> this <sil=0.000> array <sil=0.000> A <sil=2.000> .PERIOD  And <sil=0.000> what <sil=0.000> is <sil=0.000> the <sil=0.000> size <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=0.000> n whatever <sil=0.000> that <sil=0.000> is <sil=0.000> 7 maybe <sil=0.000> in <sil=0.000> our <sil=0.000> case
the <sil=0.000> example <sil=0.000> that <sil=0.000> I was <sil=0.000> showing <sil=0.000> was <sil=0.000> 7 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> so <sil=1.000> ,COMMA  after <sil=0.000> I compare <sil=0.000> 7 elements <sil=1.000> ,COMMA  if <sil=0.000> I do
not <sil=0.000> find <sil=0.000> the <sil=0.000> key <sil=1.000> ,COMMA  then <sil=0.000> I am <sil=0.000> unsuccessful <sil=0.000> in <sil=0.000> finding <sil=0.000> the <sil=0.000> search <sil=0.000> is <sil=0.000> not <sil=0.000> yielding <sil=0.000> any <sil=0.000> result <sil=2.000> .PERIOD 
The <sil=0.000> other <sil=0.000> thing <sil=0.000> is <sil=0.000> key <sil=0.000> the <sil=0.000> element <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  8 <sil=0.000> which <sil=0.000> I am <sil=0.000> finding <sil=0.000> out <sil=0.000> in <sil=0.000> this <sil=0.000> array <sil=0.000> of
numbers <sil=1.000> ,COMMA  right <sil=2.000> .PERIOD  Say <sil=0.000> something <sil=0.000> like <sil=0.000> this <sil=0.000> I am <sil=0.000> trying <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> 8 <sil=2.000> .PERIOD 

So <sil=0.000> now <sil=0.000> let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> the <sil=0.000> algorithm <sil=2.000> .PERIOD  Int <sil=0.000> pos <sil=0.000> equal <sil=0.000> to <sil=0.000> 0 pos <sil=0.000> means <sil=0.000> position <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  initially <sil=0.000> I
am <sil=0.000> in <sil=0.000> this <sil=0.000> position <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> this <sil=0.000> array <sil=0.000> is <sil=0.000> a so <sil=1.000> ,COMMA  a <sil=0.000> 0 <sil=1.000> ,COMMA  while <sil=0.000> pos <sil=0.000> is <sil=0.000> less <sil=0.000> than <sil=0.000> size <sil=0.000> it <sil=0.000> is <sil=1.000> ,COMMA  right
now <sil=0.000> 0 it <sil=0.000> is <sil=0.000> less <sil=0.000> than <sil=0.000> size <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  the <sil=0.000> pos <sil=0.000> is <sil=0.000> not <sil=0.000> has <sil=0.000> not <sil=0.000> exceeded <sil=0.000> the <sil=0.000> last <sil=0.000> element <sil=0.354> ;SEMICOLON 
that <sil=0.000> means <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> not <sil=0.000> yet <sil=0.000> checked <sil=0.000> the <sil=0.000> last <sil=0.000> element <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> why <sil=0.000> this <sil=0.000> is <sil=0.000> said <sil=1.000> ,COMMA  and <sil=0.000> the <sil=0.000> this
pos <sil=0.000> the <sil=0.000> element <sil=0.000> a pos <sil=0.000> a pos <sil=1.000> ,COMMA  pos <sil=0.000> is <sil=0.000> the <sil=0.000> index <sil=0.000> is <sil=0.000> 5 <sil=1.000> ,COMMA  and <sil=0.000> suppose <sil=0.000> my <sil=0.000> key <sil=0.000> is <sil=0.000> 8 <sil=1.000> ,COMMA  if <sil=0.000> a pos <sil=0.000> is <sil=0.000> not
equal <sil=0.000> to <sil=0.000> key <sil=2.000> .PERIOD 
Then <sil=0.000> I will <sil=0.000> increment <sil=0.000> pos <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> check <sil=0.000> for <sil=0.000> the <sil=0.000> next <sil=0.000> element <sil=2.000> .PERIOD  Now <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> an
end <sil=0.000> here <sil=2.000> .PERIOD  If <sil=0.000> either <sil=0.000> of <sil=0.000> these <sil=0.000> conditions <sil=0.000> fail <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  if <sil=0.000> I have <sil=0.000> not <sil=0.000> found <sil=0.000> it <sil=0.000> fine <sil=1.000> ,COMMA  but <sil=0.000> I
have <sil=0.000> exceeded <sil=0.000> the <sil=0.000> key <sil=0.000> exceeded <sil=0.000> the <sil=0.000> array <sil=0.000> size <sil=1.000> ,COMMA  I <sil=0.000> mean <sil=0.000> limit <sil=0.000> then <sil=0.000> I will <sil=0.000> stop <sil=2.000> .PERIOD  Or <sil=0.000> if <sil=0.000> I have
found <sil=0.000> the <sil=0.000> key <sil=0.000> 8 here <sil=1.000> ,COMMA  although <sil=0.000> I have <sil=0.000> not <sil=0.000> reached <sil=0.000> the <sil=0.000> end <sil=0.000> I will <sil=0.000> stop <sil=0.000> ok <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> the
condition <sil=1.000> ,COMMA  then <sil=0.000> I go <sil=0.000> on <sil=0.000> increasing <sil=0.000> pos <sil=0.354> ;SEMICOLON  if <sil=0.000> pos <sil=0.000> is <sil=0.000> less <sil=0.000> than <sil=0.000> n <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  when <sil=0.000> I come <sil=0.000> out
of <sil=0.000> this <sil=0.000> while <sil=0.000> loop <sil=1.000> ,COMMA  when <sil=0.000> any <sil=0.000> of <sil=0.000> these <sil=0.000> conditions <sil=0.000> are <sil=0.000> not <sil=0.000> satisfied <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  if <sil=0.000> pos <sil=0.000> is <sil=0.000> less <sil=0.000> than <sil=0.000> n <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  actually <sil=0.000> it <sil=0.000> should <sil=0.000> have <sil=0.000> been <sil=0.000> pos <sil=0.000> is <sil=0.000> less <sil=0.000> than <sil=0.000> sighs <sil=0.000> ok <sil=2.000> .PERIOD 
If <sil=0.000> I have <sil=0.000> come <sil=1.000> ,COMMA  if <sil=0.000> still <sil=0.000> pos <sil=0.000> is <sil=0.000> let <sil=0.000> us <sil=0.000> it <sil=0.000> should <sil=0.000> be <sil=0.000> pos <sil=0.000> is <sil=0.000> less <sil=0.000> than <sil=0.000> size <sil=2.000> .PERIOD  If <sil=0.000> pos <sil=0.000> is <sil=0.000> less <sil=0.000> than
size <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> not <sil=0.000> come <sil=0.000> to <sil=0.000> the <sil=0.000> end <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=0.000> then <sil=0.354> ;SEMICOLON  obviously <sil=1.000> ,COMMA  why <sil=0.000> did <sil=0.000> I come
out <sil=0.228> ?QUESTIONMARK  Because <sil=0.000> this <sil=0.000> condition <sil=0.000> was <sil=0.000> false <sil=0.000> this <sil=0.000> condition <sil=0.000> was <sil=0.000> false <sil=0.000> means <sil=0.000> what <sil=0.228> ?QUESTIONMARK  I <sil=0.000> have
already <sil=0.000> found <sil=0.000> the <sil=0.000> key <sil=1.000> ,COMMA  right <sil=0.000> then <sil=0.000> I will <sil=0.000> return <sil=0.000> the <sil=0.000> position <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  pos <sil=0.000> increments <sil=0.000> from <sil=0.000> 0 to <sil=0.000> 1 to <sil=0.000> 2 <sil=1.000> ,COMMA  to <sil=0.000> 3 <sil=1.000> ,COMMA  then <sil=0.000> to <sil=0.000> 4 <sil=1.000> ,COMMA  when <sil=0.000> I do <sil=0.000> that <sil=0.000> the <sil=0.000> size <sil=0.000> was <sil=0.000> 5 <sil=1.000> ,COMMA  I <sil=0.000> have
not <sil=0.000> exceeded <sil=0.000> 5 is <sil=0.000> still <sil=0.000> less <sil=0.000> than <sil=0.000> 5 <sil=2.000> .PERIOD  And <sil=0.000> so <sil=1.000> ,COMMA  pos <sil=0.000> could <sil=0.000> be <sil=0.000> in <sil=0.000> 2 <sil=1.000> ,COMMA  but <sil=0.000> I have <sil=0.000> come <sil=0.000> out <sil=0.000> I have
come <sil=0.000> out <sil=0.000> because <sil=0.000> I found <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  at <sil=0.000> pos <sil=0.000> pos <sil=0.000> position <sil=0.000> 4 <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> getting <sil=0.000> the <sil=0.000> key <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  pos <sil=0.000> is
returned <sil=1.000> ,COMMA  otherwise <sil=0.000> if <sil=0.000> this <sil=0.000> is <sil=0.000> not <sil=0.000> true <sil=1.000> ,COMMA  then <sil=0.000> I will <sil=0.000> return <sil=0.000> minus <sil=0.000> 1 <sil=1.000> ,COMMA  minus <sil=0.000> 1 <sil=2.000> .PERIOD  If <sil=0.000> it <sil=0.000> is <sil=0.000> returned <sil=0.354> ;SEMICOLON 
that <sil=0.000> means <sil=1.000> ,COMMA  that <sil=0.000> I have <sil=0.000> not <sil=0.000> found <sil=0.000> the <sil=0.000> key <sil=0.000> ok <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> the <sil=0.000> look <sil=0.000> of <sil=0.000> the <sil=0.000> linear <sil=0.000> search
function <sil=1.000> ,COMMA  very <sil=0.000> simple <sil=2.000> .PERIOD  Now <sil=0.000> so <sil=1.000> ,COMMA  the <sil=0.000> key <sil=0.000> appears <sil=0.000> in <sil=0.000> if <sil=0.000> the <sil=0.000> key <sil=0.000> appears <sil=0.000> within <sil=0.000> this <sil=0.000> limit <sil=1.000> ,COMMA 
then <sil=0.000> I will <sil=0.000> return <sil=0.000> the <sil=0.000> pointer <sil=0.000> pos <sil=0.000> otherwise <sil=0.000> I shall <sil=0.000> return <sil=0.000> the <sil=0.000> key <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> an <sil=0.000> example <sil=0.000> say <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> the <sil=0.000> array <sil=0.000> x <sil=1.000> ,COMMA  12 <sil=0.000> minus <sil=0.000> 3 <sil=1.000> ,COMMA  78 <sil=1.000> ,COMMA  67 <sil=1.000> ,COMMA  6 <sil=1.000> ,COMMA  50 <sil=0.000> etcetera <sil=2.000> .PERIOD  I <sil=0.000> want
to <sil=0.000> trace <sil=0.000> the <sil=0.000> following <sil=0.000> calls <sil=2.000> .PERIOD  I <sil=0.000> call <sil=0.000> search <sil=0.000> so <sil=1.000> ,COMMA  if <sil=0.000> you <sil=0.000> go <sil=0.000> up <sil=0.000> the <sil=0.000> linear <sil=0.000> search <sil=1.000> ,COMMA  let <sil=0.000> me <sil=0.000> call <sil=0.000> this
is <sil=0.000> linear <sil=0.000> search <sil=2.000> .PERIOD  It <sil=0.000> should <sil=0.000> be <sil=0.000> written <sil=0.000> down <sil=0.000> as <sil=0.000> linear <sil=0.000> search <sil=2.000> .PERIOD  I <sil=0.000> am <sil=0.000> calling <sil=0.000> with <sil=0.000> the <sil=0.000> array <sil=0.000> x
all <sil=0.000> right <sil=0.000> the <sil=0.000> size <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=0.000> 8 <sil=1.000> ,COMMA  and <sil=0.000> the <sil=0.000> key <sil=0.000> is <sil=0.000> 6 ok <sil=2.000> .PERIOD  Here <sil=0.000> what <sil=0.000> will <sil=0.000> happen <sil=0.228> ?QUESTIONMARK  Size <sil=0.000> of <sil=0.000> the
array <sil=0.000> is <sil=0.000> 8 <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> start <sil=0.000> from <sil=0.000> here <sil=0.000> 12 <sil=1.000> ,COMMA  no <sil=0.000> minus <sil=0.000> 3 <sil=1.000> ,COMMA  no <sil=0.000> my <sil=0.000> key <sil=0.000> is <sil=0.000> 6 right <sil=1.000> ,COMMA  I <sil=0.000> increment <sil=0.000> pos <sil=0.000> from <sil=0.000> here
to <sil=0.000> here <sil=1.000> ,COMMA  no <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> not <sil=0.000> matching <sil=0.000> pos <sil=0.000> is <sil=0.000> not <sil=0.000> the <sil=0.000> key <sil=1.000> ,COMMA  a <sil=0.000> pos <sil=0.000> is <sil=0.000> not <sil=0.000> the <sil=0.000> key <sil=0.000> here <sil=0.000> a pos <sil=0.000> the <sil=0.000> key <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> come <sil=0.000> out <sil=0.000> with <sil=0.000> 0 <sil=1.000> ,COMMA  1 <sil=1.000> ,COMMA  2 <sil=1.000> ,COMMA  3 <sil=1.000> ,COMMA  4 <sil=1.000> ,COMMA  pos <sil=0.000> value <sil=0.000> is <sil=0.000> 4 here <sil=2.000> .PERIOD  What <sil=0.000> will <sil=0.000> happen <sil=0.000> for <sil=0.000> this <sil=0.228> ?QUESTIONMARK  I <sil=0.000> the
same <sil=0.000> array <sil=0.000> x size <sil=0.000> 8 <sil=1.000> ,COMMA  but <sil=0.000> my <sil=0.000> key <sil=0.000> is <sil=0.000> 5 you <sil=0.000> can <sil=0.000> see <sil=0.000> that <sil=0.000> I will <sil=0.000> go <sil=0.000> up <sil=0.000> to <sil=0.000> this <sil=0.000> and <sil=0.000> after <sil=0.000> that <sil=0.000> I
will <sil=0.000> increment <sil=0.000> pos <sil=0.000> plus <sil=0.000> plus <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> more <sil=0.000> than <sil=0.000> 8 <sil=2.000> .PERIOD  And <sil=0.000> so <sil=1.000> ,COMMA  the <sil=0.000> size <sil=0.000> is <sil=0.000> 8 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> will
not <sil=0.000> be <sil=0.000> able <sil=0.000> to <sil=0.000> I will <sil=0.000> say <sil=0.000> that <sil=0.000> I have <sil=0.000> not <sil=0.000> got <sil=0.000> the <sil=0.000> key <sil=1.000> ,COMMA  all <sil=0.000> right <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> so <sil=1.000> ,COMMA  this <sil=0.000> one <sil=0.000> will <sil=0.000> return <sil=0.000> 4 <sil=1.000> ,COMMA  and <sil=0.000> this <sil=0.000> one <sil=0.000> will <sil=0.000> return <sil=0.000> minus <sil=0.000> 1 <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> how <sil=0.000> the
linear <sil=0.000> search <sil=0.000> algorithm <sil=0.000> works <sil=2.000> .PERIOD  Now <sil=0.000> let <sil=0.000> us <sil=0.000> stop <sil=0.000> here <sil=0.000> for <sil=0.000> today <sil=2.000> .PERIOD  Next <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> look <sil=0.000> at
another <sil=0.000> more <sil=0.000> efficient <sil=0.000> search <sil=1.000> ,COMMA  but <sil=0.000> it <sil=0.000> require <sil=0.000> that <sil=0.000> demands <sil=0.000> something <sil=0.000> more <sil=0.000> from <sil=0.000> us <sil=0.000> that
the <sil=0.000> array <sil=0.000> must <sil=0.000> be <sil=0.000> sorted <sil=0.000> in <sil=0.000> that <sil=0.000> case <sil=0.000> we <sil=0.000> can <sil=0.000> apply <sil=0.000> the <sil=0.000> binary <sil=0.000> search <sil=0.000> algorithm <sil=0.000> to <sil=0.000> make <sil=0.000> it
more <sil=0.000> efficient <sil=0.000> ok <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  today <sil=0.000> what <sil=0.000> we <sil=0.000> saw <sil=0.000> is <sil=0.000> how <sil=0.000> we <sil=0.000> can <sil=0.000> write <sil=0.000> as <sil=0.000> small <sil=0.000> small <sil=0.000> functions <sil=0.000> to
solve <sil=0.000> a big <sil=0.000> problem <sil=0.000> after <sil=0.000> a break <sil=0.000> down <sil=0.000> that <sil=0.000> big <sil=0.000> problem <sil=0.000> into <sil=0.000> smaller <sil=0.000> parts <sil=2.000> .PERIOD  And <sil=0.000> also <sil=1.000> ,COMMA  we
found <sil=0.000> how <sil=0.000> we <sil=0.000> can <sil=0.000> the <sil=0.000> concept <sil=0.000> of <sil=0.000> linear <sil=0.000> search <sil=0.000> which <sil=0.000> we <sil=0.000> learnt <sil=0.000> earlier <sil=1.000> ,COMMA  how <sil=0.000> we <sil=0.000> can <sil=0.000> write
a <sil=0.000> function <sil=0.000> for <sil=0.000> that <sil=0.000> ok <sil=2.000> .PERIOD 

In <sil=0.000> the <sil=0.000> earlier <sil=0.000> lecture <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> seen <sil=1.000> ,COMMA  how <sil=0.000> we <sil=0.000> can <sil=0.000> search <sil=0.000> in <sil=0.000> a list <sil=0.000> of <sil=0.000> items <sil=1.000> ,COMMA  may <sil=0.000> be <sil=0.000> list <sil=0.000> of
integers <sil=0.000> or <sil=0.000> may <sil=0.000> be <sil=0.000> list <sil=0.000> of <sil=0.000> names <sil=0.000> or <sil=0.000> list <sil=0.000> of <sil=0.000> real <sil=0.000> numbers <sil=0.000> in <sil=0.000> a linear <sil=0.000> way <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  we
start <sil=0.000> from <sil=0.000> one <sil=0.000> end <sil=0.000> of <sil=0.000> the <sil=0.000> list <sil=0.000> and <sil=0.000> we <sil=0.000> have <sil=0.000> got <sil=0.000> a key <sil=0.000> and <sil=0.000> we <sil=0.000> check <sil=0.000> for <sil=0.000> every <sil=0.000> element
whether <sil=0.000> the <sil=0.000> element <sil=0.000> in <sil=0.000> the <sil=0.000> list <sil=0.000> matches <sil=0.000> the <sil=0.000> key <sil=0.000> or <sil=0.000> not <sil=2.000> .PERIOD  In <sil=0.000> that <sil=0.000> way <sil=1.000> ,COMMA  we <sil=0.000> go <sil=0.000> on <sil=0.000> from <sil=0.000> top <sil=0.000> to
bottom <sil=2.000> .PERIOD  And <sil=0.000> ultimately <sil=1.000> ,COMMA  if <sil=0.000> we <sil=0.000> get <sil=0.000> the <sil=0.000> match <sil=0.000> of <sil=0.000> the <sil=0.000> key <sil=0.000> to <sil=0.000> an <sil=0.000> element <sil=0.000> of <sil=0.000> the <sil=0.000> list <sil=1.000> ,COMMA  we
declare <sil=0.000> it <sil=0.000> is <sil=0.000> found <sil=2.000> .PERIOD  And <sil=0.000> we <sil=0.000> also <sil=0.000> say <sil=0.000> where <sil=0.000> it <sil=0.000> is <sil=0.000> found <sil=2.000> .PERIOD 
Otherwise <sil=1.000> ,COMMA  if <sil=0.000> it <sil=1.000> ,COMMA  if <sil=0.000> we <sil=0.000> exhaust <sil=0.000> the <sil=0.000> list <sil=0.000> and <sil=0.000> still <sil=0.000> do <sil=0.000> not <sil=0.000> find <sil=0.000> the <sil=0.000> element <sil=1.000> ,COMMA  then <sil=0.000> we <sil=0.000> say <sil=0.000> that
the <sil=0.000> list <sil=0.000> is <sil=0.000> not <sil=0.000> found <sil=2.000> .PERIOD  And <sil=0.000> the <sil=0.000> way <sil=0.000> in <sil=0.000> which <sil=0.000> we <sil=0.000> have <sil=0.000> find <sil=0.000> searching <sil=0.000> from <sil=0.000> the <sil=0.000> top <sil=0.000> to
bottom <sil=1.000> ,COMMA  that <sil=0.000> process <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> linear <sil=0.000> search <sil=2.000> .PERIOD  We <sil=0.000> have <sil=0.000> also <sil=0.000> seen <sil=0.000> that <sil=1.000> ,COMMA  the <sil=0.000> time <sil=0.000> that <sil=0.000> time
that <sil=0.000> is <sil=0.000> required <sil=0.000> to <sil=0.000> search <sil=0.000> for <sil=0.000> an <sil=0.000> element <sil=0.000> in <sil=0.000> the <sil=0.000> best <sil=0.000> case <sil=1.000> ,COMMA  it <sil=0.000> would <sil=0.000> be <sil=0.000> of <sil=0.000> order <sil=0.000> 1 <sil=0.354> ;SEMICOLON  that
means <sil=1.000> ,COMMA  at <sil=0.000> the <sil=0.000> very <sil=0.000> beginning <sil=1.000> ,COMMA  we <sil=0.000> can <sil=0.000> find <sil=0.000> the <sil=0.000> element <sil=2.000> .PERIOD  Otherwise <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> to <sil=0.000> show
many <sil=0.000> comparisons <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> to <sil=0.000> do <sil=0.228> ?QUESTIONMARK  The <sil=0.000> minimum <sil=0.000> is <sil=0.000> 1 if <sil=0.000> we <sil=0.000> get <sil=0.000> the <sil=0.000> match <sil=0.000> at <sil=0.000> the
beginning <sil=0.000> of <sil=0.000> the <sil=0.000> top <sil=0.000> of <sil=0.000> the <sil=0.000> list <sil=2.000> .PERIOD  Otherwise <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> to <sil=0.000> we <sil=0.000> may <sil=0.000> have <sil=0.000> to <sil=0.000> exhaust <sil=0.000> all <sil=0.000> the
elements <sil=0.000> and <sil=0.000> whether <sil=0.000> it <sil=0.000> is <sil=0.000> found <sil=0.000> or <sil=0.000> not <sil=0.000> found <sil=2.000> .PERIOD  We <sil=0.000> can <sil=0.000> say <sil=0.000> only <sil=0.000> after <sil=0.000> we <sil=0.000> have <sil=0.000> compared
all <sil=0.000> the <sil=0.000> elements <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  if <sil=0.000> there <sil=0.000> is <sil=0.000> a list <sil=0.000> of <sil=0.000> n elements <sil=1.000> ,COMMA  the <sil=0.000> maximum <sil=0.000> number <sil=0.000> of <sil=0.000> comparisons <sil=0.000> that <sil=0.000> I may <sil=0.000> have
to <sil=0.000> do <sil=0.000> will <sil=0.000> be <sil=0.000> n <sil=2.000> .PERIOD  Therefore <sil=1.000> ,COMMA  on <sil=0.000> an <sil=0.000> average <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> n plus <sil=0.000> 1 by <sil=0.000> 2 that <sil=0.000> we <sil=0.000> say <sil=0.000> in
complexity <sil=0.000> of <sil=0.000> algorithms <sil=0.000> parlance <sil=2.000> .PERIOD  In <sil=0.000> that <sil=0.000> parlance <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> terminology <sil=1.000> ,COMMA  we <sil=0.000> call <sil=0.000> it <sil=0.000> order
of <sil=0.000> n ok <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> not <sil=0.000> the <sil=0.000> main <sil=0.000> issue <sil=0.000> with <sil=0.000> us <sil=1.000> ,COMMA  but <sil=0.000> with <sil=0.000> we <sil=0.000> can <sil=0.000> say <sil=0.000> therefore <sil=1.000> ,COMMA  that <sil=0.000> in <sil=0.000> a list <sil=0.000> of
elements <sil=1.000> ,COMMA  if <sil=0.000> I have <sil=0.000> got <sil=0.000> n elements <sil=0.000> and <sil=0.000> the <sil=0.000> list <sil=0.000> is <sil=0.000> not <sil=0.000> sorted <sil=1.000> ,COMMA  so <sil=1.000> ,COMMA  may <sil=0.000> be <sil=0.000> 5 2 <sil=0.000> 7 9 <sil=0.000> 11 <sil=0.000> 1 <sil=1.000> ,COMMA  say <sil=1.000> ,COMMA 
this <sil=0.000> is <sil=0.000> the <sil=0.000> list <sil=0.000> and <sil=0.000> I want <sil=0.000> to <sil=0.000> search <sil=0.000> for <sil=0.000> a key <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> in <sil=0.000> this <sil=0.000> case <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> 6 <sil=2.000> .PERIOD  But <sil=1.000> ,COMMA  in <sil=0.000> general <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> say <sil=0.000> that <sil=0.000> there <sil=0.000> are <sil=0.000> n elements <sil=0.000> right <sil=2.000> .PERIOD  In
general <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> say <sil=0.000> number <sil=0.000> of <sil=0.000> elements <sil=0.000> is <sil=0.000> n <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> best <sil=0.000> case <sil=0.000> I can <sil=0.000> get <sil=0.000> a match <sil=0.000> here <sil=1.000> ,COMMA  the
number <sil=0.000> of <sil=0.000> comparisons <sil=0.000> I require <sil=0.000> is <sil=0.000> 1 and <sil=0.000> the <sil=0.000> worst <sil=0.000> case <sil=0.000> I have <sil=0.000> to <sil=0.000> come <sil=0.000> up <sil=0.000> to <sil=0.000> this <sil=0.000> and
compare <sil=0.000> all <sil=0.000> these <sil=0.000> n elements <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  the <sil=0.000> number <sil=0.000> of <sil=0.000> comparison <sil=0.000> on <sil=0.000> an <sil=0.000> average <sil=0.000> will <sil=0.000> be <sil=0.000> n plus <sil=0.000> 1 by <sil=0.000> 2 <sil=1.000> ,COMMA  all <sil=0.000> right <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> a
average <sil=0.000> number <sil=0.000> of <sil=0.000> comparisons <sil=0.000> that <sil=0.000> we <sil=0.000> denote <sil=0.000> in <sil=0.000> computer <sil=0.000> parlance <sil=0.000> as <sil=0.000> of <sil=0.000> the <sil=0.000> order <sil=0.000> of <sil=0.000> n <sil=2.000> .PERIOD 
This <sil=0.000> o is <sil=0.000> has <sil=0.000> got <sil=0.000> name <sil=0.000> called <sil=0.000> big <sil=0.000> o <sil=2.000> .PERIOD  I <sil=0.000> am <sil=0.000> sorry <sil=0.000> let <sil=0.000> me <sil=0.000> write <sil=0.000> it <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=2.000> .PERIOD  This <sil=0.000> called <sil=0.000> big
o <sil=0.000> notation <sil=0.000> big <sil=0.000> o notation <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  where <sil=0.000> it <sil=0.000> just <sil=0.000> denotes <sil=0.000> the <sil=0.000> how <sil=0.000> much <sil=0.000> time <sil=0.000> a computer <sil=0.000> can <sil=0.000> a
program <sil=0.000> will <sil=0.000> take <sil=0.000> to <sil=0.000> run <sil=1.000> ,COMMA  in <sil=0.000> terms <sil=0.000> of <sil=0.000> the <sil=0.000> input <sil=0.000> size <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> this <sil=0.000> n <sil=0.228> ?QUESTIONMARK  This <sil=0.000> is <sil=0.000> the <sil=0.000> size <sil=0.000> of <sil=0.000> the
input <sil=0.000> data <sil=1.000> ,COMMA  we <sil=0.000> call <sil=0.000> it <sil=0.000> input <sil=0.000> size <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  obviously <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> see <sil=0.000> that <sil=1.000> ,COMMA  as <sil=0.000> these <sil=0.000> list <sil=0.000> increases <sil=1.000> ,COMMA  if <sil=0.000> it <sil=0.000> becomes <sil=0.000> 100 <sil=1.000> ,COMMA  then <sil=0.000> the <sil=0.000> time
average <sil=0.000> time <sil=0.000> that <sil=0.000> will <sil=0.000> be <sil=0.000> taken <sil=0.000> average <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> average <sil=0.000> complexity <sil=0.000> all <sil=0.000> right <sil=1.000> ,COMMA  will <sil=0.000> be
more <sil=0.000> than <sil=0.000> this <sil=2.000> .PERIOD  If <sil=0.000> it <sil=0.000> is <sil=0.000> with <sil=0.000> 1000 <sil=0.000> even <sil=0.000> more <sil=0.000> and <sil=0.000> as <sil=0.000> increases <sil=1.000> ,COMMA  the <sil=0.000> time <sil=0.000> will <sil=0.000> increase <sil=0.000> in <sil=0.000> a
linear <sil=0.000> fashion <sil=2.000> .PERIOD  As <sil=0.000> n increases <sil=1.000> ,COMMA  the <sil=0.000> time <sil=0.000> will <sil=0.000> increase <sil=0.000> in <sil=0.000> a linear <sil=0.000> fashion <sil=2.000> .PERIOD  However <sil=1.000> ,COMMA  the
way <sil=0.000> we <sil=0.000> are <sil=0.000> searching <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> linear <sil=0.000> search <sil=2.000> .PERIOD  One <sil=0.000> thing <sil=0.000> to <sil=0.000> note <sil=0.000> is <sil=0.000> that <sil=1.000> ,COMMA  in <sil=0.000> this <sil=0.000> case <sil=1.000> ,COMMA  we
are <sil=0.000> not <sil=0.000> making <sil=0.000> any <sil=0.000> assumption <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> time <sil=2.000> .PERIOD  We <sil=0.000> are <sil=0.000> not <sil=0.000> making <sil=0.000> any <sil=0.000> assumption <sil=0.000> about
the <sil=0.000> way <sil=0.000> in <sil=0.000> which <sil=0.000> the <sil=0.000> data <sil=0.000> items <sil=0.000> are <sil=0.000> organized <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  in <sil=0.000> an <sil=0.000> endeavor <sil=1.000> ,COMMA  to <sil=0.000> see <sil=1.000> ,COMMA  if <sil=0.000> we <sil=0.000> can <sil=0.000> make <sil=0.000> it <sil=0.000> better <sil=1.000> ,COMMA  we <sil=0.000> today <sil=0.000> discuss <sil=0.000> another <sil=0.000> very
important <sil=0.000> type <sil=0.000> of <sil=0.000> search <sil=0.000> algorithm <sil=1.000> ,COMMA  which <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> binary <sil=0.000> search <sil=2.000> .PERIOD  Why <sil=0.000> the <sil=0.000> name
binary <sil=0.000> is <sil=0.000> coming <sil=0.000> very <sil=0.000> clear <sil=0.000> in <sil=0.000> a moment <sil=1.000> ,COMMA  but <sil=0.000> the <sil=0.000> important <sil=0.000> thing <sil=0.000> to <sil=0.000> note <sil=0.000> is <sil=0.000> that <sil=1.000> ,COMMA  in <sil=0.000> this
case <sil=1.000> ,COMMA  the <sil=0.000> list <sil=0.000> or <sil=0.000> the <sil=0.000> array <sil=0.000> must <sil=0.000> be <sil=0.000> sorted <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> organized <sil=0.000> in <sil=0.000> some <sil=0.000> particular
way <sil=0.354> ;SEMICOLON  either <sil=0.000> in <sil=0.000> an <sil=0.000> ascending <sil=0.000> order <sil=0.000> or <sil=0.000> in <sil=0.000> the <sil=0.000> descending <sil=0.000> order <sil=0.000> ok <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> why <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> called <sil=0.000> binary <sil=2.000> .PERIOD  Let <sil=0.000> us <sil=0.000> let <sil=0.000> me <sil=0.000> just <sil=0.000> try <sil=0.000> to <sil=0.000> explain <sil=0.000> it <sil=0.000> with <sil=0.000> an <sil=0.000> example <sil=2.000> .PERIOD 
Say <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> the <sil=0.000> array <sil=1.000> ,COMMA  but <sil=0.000> in <sil=0.000> a sorted <sil=0.000> way <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> 1 2 <sil=0.000> the <sil=0.000> elements <sil=0.000> where <sil=0.000> there <sil=0.000> in <sil=0.000> the <sil=0.000> earlier <sil=0.000> case <sil=0.000> one <sil=0.000> 2 five <sil=0.000> seven <sil=0.000> nine
eleven <sil=0.000> right <sil=0.000> 1 2 <sil=0.000> 5 7 <sil=0.000> 9 11 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  1 <sil=0.000> 2 5 <sil=0.000> 7 9 <sil=0.000> 11 <sil=2.000> .PERIOD  Now <sil=0.000> suppose <sil=0.000> my <sil=0.000> key <sil=0.000> is <sil=0.000> well <sil=1.000> ,COMMA  let <sil=0.000> the <sil=0.000> key <sil=0.000> be <sil=0.000> 2 <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> start <sil=0.000> at <sil=0.000> middle <sil=0.000> of <sil=0.000> this <sil=0.000> array <sil=0.000> first <sil=0.000> we <sil=0.000> will <sil=0.000> look <sil=0.000> at <sil=0.000> the <sil=0.000> middle <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  since <sil=0.000> is
this <sil=0.000> is <sil=0.000> an <sil=0.000> even <sil=0.000> number <sil=1.000> ,COMMA  even <sil=0.000> sized <sil=0.000> array <sil=1.000> ,COMMA  6 <sil=0.000> elements <sil=0.000> middle <sil=0.000> can <sil=0.000> be <sil=0.000> somewhere <sil=0.000> here <sil=2.000> .PERIOD  Say <sil=1.000> ,COMMA 
let <sil=0.000> me <sil=0.000> take <sil=0.000> this <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> the <sil=0.000> midpoint <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  I <sil=0.000> compare <sil=0.000> the <sil=0.000> key <sil=0.000> with <sil=0.000> the <sil=0.000> middle <sil=0.000> element <sil=0.000> 2 and <sil=0.000> 7 are <sil=0.000> being <sil=0.000> compared <sil=2.000> .PERIOD  2 <sil=0.000> things
can <sil=0.000> happen <sil=0.354> ;SEMICOLON  either <sil=0.000> 2 the <sil=0.000> key <sil=0.000> I I <sil=0.000> will <sil=0.000> rather <sil=0.000> say <sil=1.000> ,COMMA  either <sil=0.000> the <sil=0.000> key <sil=0.000> is <sil=0.000> less <sil=0.000> than <sil=0.000> the <sil=0.000> mid <sil=0.000> element
or <sil=0.000> the <sil=0.000> key <sil=0.000> is <sil=0.000> equal <sil=0.000> to <sil=0.000> the <sil=0.000> mid <sil=0.000> element <sil=0.000> or <sil=0.000> the <sil=0.000> key <sil=0.000> is <sil=0.000> greater <sil=0.000> than <sil=0.000> the <sil=0.000> mid <sil=0.000> element <sil=2.000> .PERIOD  3 <sil=0.000> things
can <sil=0.000> happen <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  if <sil=0.000> the <sil=0.000> key <sil=0.000> is <sil=0.000> equal <sil=0.000> to <sil=0.000> the <sil=0.000> mid <sil=0.000> element <sil=1.000> ,COMMA  then <sil=0.000> my <sil=0.000> search <sil=0.000> immediately
stops <sil=2.000> .PERIOD  Yes <sil=1.000> ,COMMA  I <sil=0.000> found <sil=0.000> it <sil=0.000> and <sil=0.000> where <sil=0.000> did <sil=0.000> I find <sil=0.000> it <sil=0.228> ?QUESTIONMARK  The <sil=0.000> index <sil=0.000> is <sil=0.000> mid <sil=2.000> .PERIOD 
If <sil=0.000> the <sil=0.000> key <sil=0.000> is <sil=0.000> less <sil=0.000> than <sil=0.000> the <sil=0.000> mid <sil=0.000> element <sil=1.000> ,COMMA  as <sil=0.000> is <sil=0.000> the <sil=0.000> case <sil=0.000> here <sil=1.000> ,COMMA  then <sil=0.000> what <sil=0.000> can <sil=0.000> I say <sil=0.228> ?QUESTIONMARK  I <sil=0.000> can
immediately <sil=0.000> say <sil=0.000> that <sil=1.000> ,COMMA  the <sil=0.000> I still <sil=0.000> do <sil=0.000> not <sil=0.000> know <sil=0.000> whether <sil=0.000> the <sil=0.000> key <sil=0.000> is <sil=0.000> there <sil=0.000> in <sil=0.000> this <sil=0.000> array <sil=0.000> or <sil=0.000> not <sil=1.000> ,COMMA 
whether <sil=0.000> the <sil=0.000> key <sil=0.000> is <sil=0.000> here <sil=0.000> or <sil=0.000> not <sil=0.000> I do <sil=0.000> not <sil=0.000> know <sil=0.000> as <sil=0.000> here <sil=2.000> .PERIOD  But <sil=0.000> the <sil=0.000> thing <sil=0.000> that <sil=0.000> I say <sil=0.000> is <sil=1.000> ,COMMA  that <sil=0.000> the
key <sil=1.000> ,COMMA  since <sil=0.000> it <sil=0.000> is <sil=0.000> less <sil=0.000> than <sil=0.000> the <sil=0.000> mid <sil=1.000> ,COMMA  it <sil=0.000> cannot <sil=0.000> be <sil=0.000> on <sil=0.000> this <sil=0.000> side <sil=1.000> ,COMMA  it <sil=0.000> cannot <sil=0.000> be <sil=0.000> on <sil=0.000> this <sil=0.000> side <sil=2.000> .PERIOD  Not
possible <sil=2.000> .PERIOD  It <sil=0.000> must <sil=0.000> be <sil=0.000> if <sil=0.000> at <sil=0.000> all <sil=0.000> on <sil=0.000> this <sil=0.000> side <sil=1.000> ,COMMA  because <sil=1.000> ,COMMA  the <sil=0.000> key <sil=0.000> is <sil=0.000> less <sil=0.000> than <sil=0.000> the <sil=0.000> mid <sil=2.000> .PERIOD 
Therefore <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> restrict <sil=0.000> my <sil=0.000> search <sil=0.000> within <sil=0.000> this <sil=0.000> period <sil=2.000> .PERIOD  Suppose <sil=1.000> ,COMMA  within <sil=0.000> this <sil=0.000> zone <sil=1.000> ,COMMA  now
what <sil=0.000> I will <sil=0.000> do <sil=0.228> ?QUESTIONMARK  I <sil=0.000> will <sil=0.000> again <sil=0.000> take <sil=0.000> the <sil=0.000> middle <sil=0.000> point <sil=0.000> of <sil=0.000> this <sil=0.000> array <sil=1.000> ,COMMA  right <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  between <sil=0.000> here <sil=0.000> it
is <sil=0.000> becoming <sil=0.000> very <sil=0.000> simple <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> middle <sil=0.000> point <sil=0.000> of <sil=0.000> this <sil=0.000> part <sil=0.000> is <sil=0.000> suppose <sil=0.000> 5 <sil=2.000> .PERIOD  I <sil=0.000> could <sil=0.000> have <sil=0.000> had
it <sil=0.000> from <sil=0.000> 1 1 <sil=0.000> to <sil=0.000> 5 <sil=1.000> ,COMMA  but <sil=0.000> I am <sil=0.000> just <sil=0.000> taking <sil=0.000> from <sil=0.000> 1 to <sil=0.000> 7 <sil=2.000> .PERIOD 
I <sil=0.000> come <sil=0.000> at <sil=0.000> this <sil=0.000> point <sil=0.000> and <sil=0.000> again <sil=0.000> now <sil=0.000> I compare <sil=0.000> this <sil=0.000> element <sil=0.000> and <sil=0.000> still <sil=0.000> it <sil=0.000> is <sil=0.000> less <sil=0.000> therefore <sil=1.000> ,COMMA  am
sure <sil=0.000> that <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> in <sil=0.000> this <sil=0.000> area <sil=0.000> it <sil=0.000> must <sil=0.000> be <sil=0.000> in <sil=0.000> this <sil=0.000> zone <sil=2.000> .PERIOD  Now <sil=0.000> I again <sil=1.000> ,COMMA  only <sil=0.000> for <sil=0.000> this <sil=0.000> part  <sil=1.000> ,COMMA  I
apply <sil=0.000> again <sil=1.000> ,COMMA  I <sil=0.000> find <sil=0.000> mid <sil=0.000> element <sil=0.000> and <sil=0.000> this <sil=0.000> is <sil=0.000> here <sil=0.000> and <sil=0.000> I find <sil=0.000> that <sil=0.000> the <sil=0.000> key <sil=0.000> and <sil=0.000> the <sil=0.000> element
are <sil=0.000> matching <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> found <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  how <sil=0.000> many <sil=0.000> comparisons <sil=0.000> I needed <sil=0.000> here <sil=0.228> ?QUESTIONMARK  In <sil=0.000> this <sil=0.000> case <sil=1.000> ,COMMA  I
need <sil=0.000> it <sil=0.000> 1 2 <sil=0.000> 3 comparisons <sil=2.000> .PERIOD  In <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> linear <sil=0.000> search <sil=0.000> of <sil=0.000> course <sil=1.000> ,COMMA  you <sil=0.000> could <sil=0.000> have <sil=0.000> got <sil=0.000> it
luckily <sil=0.000> here <sil=0.000> in <sil=0.000> 2 comparisons <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD 
But <sil=1.000> ,COMMA  what <sil=0.000> would <sil=0.000> have <sil=0.000> happened <sil=0.000> if <sil=0.000> my <sil=0.000> key <sil=0.000> was <sil=0.000> 9 <sil=0.228> ?QUESTIONMARK  In <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> linear <sil=0.000> search <sil=1.000> ,COMMA  suppose <sil=1.000> ,COMMA 
the <sil=0.000> key <sil=0.000> was <sil=0.000> 9 in <sil=0.000> that <sil=0.000> case <sil=1.000> ,COMMA  in <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> linear <sil=0.000> case <sil=0.000> what <sil=0.000> would <sil=0.000> what <sil=0.000> would <sil=0.000> have
happened <sil=0.000> I would <sil=0.000> have <sil=0.000> started <sil=0.000> from <sil=0.000> here <sil=0.000> 1 comparison <sil=1.000> ,COMMA  2 <sil=0.000> comparison <sil=1.000> ,COMMA  3 <sil=0.000> comparison <sil=1.000> ,COMMA  4
comparison <sil=0.000> and <sil=0.000> the <sil=0.000> 5th <sil=0.000> comparison <sil=0.000> I would <sil=0.000> have <sil=0.000> got <sil=0.000> it <sil=0.000> right <sil=1.000> ,COMMA  on <sil=0.000> the <sil=0.000> 5th <sil=0.000> comparison <sil=0.000> I
would <sil=0.000> have <sil=0.000> got <sil=0.000> it <sil=2.000> .PERIOD  But <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> see <sil=0.000> what <sil=0.000> would <sil=0.000> have <sil=0.000> happened <sil=0.000> in <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> the <sil=0.000> new
search <sil=0.000> technique <sil=0.000> that <sil=0.000> we <sil=0.000> are <sil=0.000> looking <sil=0.000> at <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  again <sil=0.000> I have <sil=0.000> 1 2 <sil=0.000> 5 7 <sil=0.000> 9 11 <sil=0.000> and <sil=0.000> my <sil=0.000> key <sil=0.000> is <sil=0.000> 9 <sil=2.000> .PERIOD  I <sil=0.000> know <sil=0.000> that <sil=0.000> in <sil=0.000> case <sil=0.000> of <sil=0.000> linear <sil=0.000> search <sil=1.000> ,COMMA  I
needed <sil=0.000> 5 comparisons <sil=2.000> .PERIOD  What <sil=0.000> will <sil=0.000> happen <sil=0.000> here <sil=0.228> ?QUESTIONMARK  I <sil=0.000> will <sil=0.000> come <sil=0.000> to <sil=0.000> the <sil=0.000> middle <sil=0.000> point <sil=0.000> here <sil=2.000> .PERIOD  I
find <sil=0.000> that <sil=0.000> the <sil=0.000> key <sil=0.000> is <sil=0.000> greater <sil=0.000> than <sil=0.000> mid <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> mid <sil=2.000> .PERIOD  The <sil=0.000> key <sil=0.000> is <sil=0.000> greater <sil=0.000> than <sil=0.000> mid <sil=2.000> .PERIOD  Therefore <sil=1.000> ,COMMA 
I <sil=0.000> know <sil=0.000> that <sil=0.000> the <sil=0.000> key <sil=0.000> if <sil=0.000> at <sil=0.000> all <sil=0.000> cannot <sil=0.000> remain <sil=0.000> in <sil=0.000> this <sil=0.000> zone <sil=2.000> .PERIOD  This <sil=0.000> part <sil=0.000> is <sil=0.000> ruled <sil=0.000> out <sil=0.000> this <sil=0.000> part <sil=0.000> is
ruled <sil=0.000> out <sil=2.000> .PERIOD  It <sil=0.000> must <sil=0.000> be <sil=0.000> in <sil=0.000> this <sil=0.000> zone <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  again <sil=0.000> within <sil=0.000> this <sil=0.000> I find <sil=0.000> the <sil=0.000> new <sil=0.000> mid <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> new
mid <sil=0.000> comes <sil=0.000> here <sil=2.000> .PERIOD  And <sil=0.000> I find <sil=0.000> this <sil=0.000> new <sil=0.000> mid <sil=0.000> mid <sil=0.000> new <sil=0.000> this <sil=0.000> and <sil=0.000> I check <sil=0.000> this <sil=1.000> ,COMMA  now <sil=0.000> I find <sil=0.000> that
the <sil=0.000> key <sil=0.000> is <sil=0.000> equal <sil=0.000> to <sil=0.000> mid <sil=2.000> .PERIOD 
Therefore <sil=1.000> ,COMMA  I <sil=0.000> find <sil=0.000> my <sil=0.000> search <sil=0.000> completes <sil=0.000> here <sil=0.000> with <sil=0.000> this <sil=0.000> index <sil=0.000> as <sil=0.000> output <sil=2.000> .PERIOD  Now <sil=0.000> how <sil=0.000> many
comparisons <sil=0.000> I needed <sil=0.000> here <sil=0.228> ?QUESTIONMARK  1 <sil=0.000> 2 only <sil=0.000> 2 comparisons <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  2 <sil=0.000> comparisons <sil=0.000> verses <sil=0.000> 1 2 <sil=0.000> 3 4 <sil=0.000> 5 comparisons <sil=0.000> in <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> linear <sil=0.000> search <sil=2.000> .PERIOD  Now <sil=0.000> why
was <sil=0.000> it <sil=0.000> reduced <sil=0.228> ?QUESTIONMARK  The <sil=0.000> same <sil=0.000> thing <sil=0.000> would <sil=0.000> have <sil=0.000> happened <sil=0.000> with <sil=0.000> if <sil=0.000> my <sil=0.000> key <sil=0.000> was <sil=0.000> 11 <sil=2.000> .PERIOD  Let <sil=0.000> us
have <sil=0.000> a look <sil=0.000> if <sil=0.000> the <sil=0.000> a key <sil=0.000> was <sil=0.000> 11 <sil=2.000> .PERIOD  In <sil=0.000> that <sil=0.000> case <sil=1.000> ,COMMA  suppose <sil=1.000> ,COMMA  the <sil=0.000> key <sil=0.000> was <sil=0.000> 11 <sil=1.000> ,COMMA  in <sil=0.000> the <sil=0.000> case <sil=0.000> of
linear <sil=0.000> search <sil=1.000> ,COMMA  I <sil=0.000> would <sil=0.000> have <sil=0.000> required <sil=0.000> 6 comparisons <sil=0.000> here <sil=0.000> to <sil=0.000> reach <sil=0.000> at <sil=0.000> 11 <sil=2.000> .PERIOD 
However <sil=1.000> ,COMMA  in <sil=0.000> this <sil=0.000> case <sil=1.000> ,COMMA  I <sil=0.000> would <sil=0.000> I would <sil=0.000> be <sil=0.000> sure <sil=0.000> if <sil=0.000> key <sil=0.000> is <sil=0.000> greater <sil=0.000> than <sil=0.000> is <sil=1.000> ,COMMA  then <sil=0.000> my <sil=0.000> next
iteration <sil=0.000> will <sil=0.000> be <sil=0.000> between <sil=0.000> these <sil=0.000> 2 and <sil=0.000> I would <sil=0.000> have <sil=0.000> found <sil=0.000> mid <sil=0.000> new <sil=0.000> mid <sil=0.000> and <sil=0.000> I would <sil=0.000> have
got <sil=0.000> it <sil=0.000> with <sil=0.000> 3 comparisons <sil=2.000> .PERIOD  Now <sil=0.000> why <sil=0.000> is <sil=0.000> it <sil=0.000> becoming <sil=0.000> so <sil=0.228> ?QUESTIONMARK  Why <sil=0.000> is <sil=0.000> the <sil=0.000> number <sil=0.000> of
comparison <sil=0.000> being <sil=0.000> reduced <sil=0.228> ?QUESTIONMARK  The <sil=0.000> reason <sil=0.000> is <sil=0.000> we <sil=0.000> have <sil=0.000> got <sil=0.000> this <sil=0.000> array <sil=0.000> and <sil=0.000> at <sil=0.000> every <sil=0.000> stage <sil=1.000> ,COMMA  what
I <sil=0.000> am <sil=0.000> doing <sil=0.000> is <sil=1.000> ,COMMA  am <sil=0.000> looking <sil=0.000> at <sil=0.000> the <sil=0.000> key <sil=0.000> and <sil=0.000> depending <sil=0.000> on <sil=0.000> whether <sil=0.000> the <sil=0.000> key <sil=0.000> is <sil=0.000> greater <sil=0.000> than <sil=0.000> the
mid <sil=2.000> .PERIOD 

I <sil=0.000> am <sil=0.000> concentrating <sil=0.000> on <sil=0.000> only <sil=0.000> one <sil=0.000> half <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=0.000> either <sil=0.000> this <sil=0.000> array <sil=0.000> or <sil=0.000> this <sil=0.000> array <sil=2.000> .PERIOD  And <sil=0.000> then <sil=1.000> ,COMMA 
depending <sil=0.000> on <sil=0.000> the <sil=0.000> key <sil=0.000> value <sil=1.000> ,COMMA  I <sil=0.000> take <sil=0.000> suppose <sil=0.000> it <sil=0.000> is <sil=0.000> greater <sil=1.000> ,COMMA  then <sil=0.000> I will <sil=0.000> concentrate <sil=0.000> on <sil=0.000> these
zone <sil=2.000> .PERIOD  If <sil=0.000> it <sil=0.000> is <sil=0.000> less <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> concentrate <sil=0.000> on <sil=0.000> this <sil=0.000> zone <sil=2.000> .PERIOD  And <sil=0.000> iteratively <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> be <sil=0.000> reducing <sil=0.000> my
search <sil=0.000> to <sil=0.000> a smaller <sil=0.000> array <sil=2.000> .PERIOD  Let <sil=0.000> us <sil=0.000> have <sil=0.000> another <sil=0.000> example <sil=2.000> .PERIOD 
Let <sil=0.000> us <sil=0.000> have <sil=0.000> another <sil=0.000> example <sil=2.000> .PERIOD  Let <sil=0.000> us <sil=0.000> have <sil=0.000> it <sil=0.000> a little <sil=0.000> bigger <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD  Let <sil=0.000> us <sil=0.000> have <sil=0.000> 17 <sil=0.000> 19 <sil=0.000> 20
21 <sil=0.000> 25 <sil=0.000> 32 <sil=0.000> 38 <sil=0.000> 40 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  now <sil=0.000> I have <sil=0.000> got <sil=0.000> again <sil=0.000> even <sil=0.000> number <sil=0.000> let <sil=0.000> me <sil=0.000> have <sil=0.000> 42 <sil=2.000> .PERIOD  Say <sil=0.000> odd <sil=0.000> number <sil=0.000> arrays <sil=0.000> 1 2 <sil=0.000> 3 4 <sil=2.000> .PERIOD 
Now <sil=0.000> I have <sil=0.000> got <sil=0.000> 9 elements <sil=0.000> right <sil=2.000> .PERIOD  Now <sil=0.000> I will <sil=0.000> start <sil=0.000> with <sil=0.000> the <sil=0.000> mid <sil=0.000> element <sil=2.000> .PERIOD  What <sil=0.000> is <sil=0.000> the <sil=0.000> mid
element <sil=0.228> ?QUESTIONMARK  Here <sil=1.000> ,COMMA  between <sil=0.000> this <sil=1.000> ,COMMA  the <sil=0.000> mid <sil=0.000> element <sil=0.000> is <sil=0.000> this <sil=2.000> .PERIOD  And <sil=0.000> suppose <sil=0.000> my <sil=0.000> key <sil=0.000> is <sil=0.000> 19  <sil=1.000> ,COMMA  then <sil=0.000> I
know <sil=0.000> that <sil=1.000> ,COMMA  my <sil=0.000> key <sil=0.000> cannot <sil=0.000> lie <sil=1.000> ,COMMA  since <sil=0.000> it <sil=0.000> is <sil=0.000> less <sil=0.000> than <sil=0.000> 19 <sil=1.000> ,COMMA  it <sil=0.000> cannot <sil=0.000> lie <sil=0.000> in <sil=0.000> this <sil=0.000> part <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=2.000> .PERIOD 
If <sil=0.000> at <sil=0.000> all <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> lie <sil=0.000> on <sil=0.000> this <sil=0.000> part <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=2.000> .PERIOD  Why <sil=0.228> ?QUESTIONMARK  Why <sil=0.000> do <sil=0.000> I say <sil=0.000> that <sil=0.228> ?QUESTIONMARK  I <sil=0.000> can <sil=0.000> say <sil=0.000> that
because <sil=1.000> ,COMMA  this <sil=0.000> array <sil=0.000> is <sil=0.000> sorted <sil=2.000> .PERIOD 
Otherwise <sil=1.000> ,COMMA  I <sil=0.000> could <sil=0.000> not <sil=0.000> have <sil=0.000> said <sil=2.000> .PERIOD  Since <sil=0.000> it <sil=0.000> is <sil=0.000> an <sil=0.000> increasing <sil=0.000> order <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> say <sil=0.000> that <sil=1.000> ,COMMA  since <sil=0.000> the
key <sil=0.000> is <sil=0.000> less <sil=0.000> than <sil=0.000> the <sil=0.000> mid <sil=0.000> element <sil=1.000> ,COMMA  therefore <sil=1.000> ,COMMA  it <sil=0.000> must <sil=0.000> be <sil=0.000> in <sil=0.000> this <sil=0.000> zone <sil=2.000> .PERIOD  And <sil=0.000> so <sil=1.000> ,COMMA  I <sil=0.000> come <sil=0.000> to <sil=0.000> this
zone <sil=0.000> and <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> mid <sil=0.000> element <sil=0.000> again <sil=0.000> may <sil=0.000> be <sil=0.000> in <sil=0.000> this <sil=0.000> zone <sil=0.000> or <sil=0.000> up <sil=0.000> to <sil=0.000> this <sil=2.000> .PERIOD  Say <sil=0.000> I come
here <sil=0.000> and <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> mid <sil=0.000> element <sil=0.000> this <sil=0.000> again <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  am <sil=0.000> looking <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> immediately <sil=0.000> reduced
my <sil=0.000> list <sil=0.000> to <sil=0.000> half <sil=1.000> ,COMMA  right <sil=0.228> ?QUESTIONMARK  This <sil=0.000> half <sil=1.000> ,COMMA  it <sil=0.000> could <sil=0.000> have <sil=0.000> been <sil=0.000> if <sil=0.000> my <sil=0.000> key <sil=0.000> was <sil=0.000> 38 <sil=1.000> ,COMMA  then <sil=0.000> I would <sil=0.000> have
restricted <sil=0.000> to <sil=0.000> this <sil=0.000> half <sil=0.000> not <sil=0.000> this <sil=0.000> half <sil=2.000> .PERIOD  But <sil=0.000> for <sil=0.000> 19 <sil=1.000> ,COMMA  am <sil=0.000> restricted <sil=0.000> to <sil=0.000> this <sil=0.000> half <sil=2.000> .PERIOD  Now <sil=0.000> again <sil=1.000> ,COMMA  19 <sil=0.000> is
less <sil=0.000> than <sil=0.000> 20 <sil=1.000> ,COMMA  immediately <sil=0.000> I will <sil=0.000> restrict <sil=0.000> myself <sil=0.000> to <sil=0.000> this <sil=0.000> half <sil=0.000> and <sil=0.000> I will <sil=0.000> not <sil=0.000> consider <sil=0.000> this
part <sil=1.000> ,COMMA  gradually <sil=0.000> am <sil=0.000> going <sil=0.000> to <sil=0.000> the <sil=0.000> lower <sil=0.000> half <sil=0.000> or <sil=0.000> the <sil=0.000> higher <sil=0.000> half <sil=0.000> at <sil=0.000> every <sil=0.000> stage <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> happening <sil=0.000> is <sil=0.000> something <sil=0.000> like <sil=0.000> this <sil=2.000> .PERIOD  Am <sil=0.000> starting <sil=0.000> with <sil=0.000> the <sil=0.000> whole <sil=0.000> array <sil=1.000> ,COMMA  then <sil=0.000> am
concentrating <sil=0.000> either <sil=0.000> in <sil=0.000> the <sil=0.000> left <sil=0.000> half <sil=0.000> or <sil=0.000> on <sil=0.000> the <sil=0.000> right <sil=0.000> half <sil=2.000> .PERIOD  Then <sil=0.000> again <sil=1.000> ,COMMA  depending <sil=0.000> on <sil=0.000> that <sil=1.000> ,COMMA 
either <sil=0.000> on <sil=0.000> the <sil=0.000> left <sil=0.000> half <sil=0.000> or <sil=0.000> on <sil=0.000> the <sil=0.000> right <sil=0.000> half <sil=0.000> if <sil=0.000> it <sil=0.000> is <sil=0.000> in <sil=0.000> the <sil=0.000> right <sil=0.000> half <sil=1.000> ,COMMA  then <sil=0.000> among <sil=0.000> them <sil=1.000> ,COMMA  this
am <sil=0.000> coming <sil=0.000> to <sil=0.000> left <sil=0.000> half <sil=0.000> and <sil=0.000> right <sil=0.000> half <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  at <sil=0.000> every <sil=0.000> stage <sil=1.000> ,COMMA  am <sil=0.000> dividing <sil=0.000> the <sil=0.000> array <sil=0.000> to <sil=0.000> half <sil=2.000> .PERIOD 
That <sil=0.000> is <sil=0.000> why <sil=0.000> this <sil=0.000> is <sil=0.000> called <sil=0.000> binary <sil=0.000> search <sil=2.000> .PERIOD  Either <sil=0.000> it <sil=0.000> is <sil=0.000> here <sil=0.000> or <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> here <sil=0.000> not <sil=0.000> in <sil=0.000> this <sil=0.000> zone <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> way <sil=1.000> ,COMMA  I <sil=0.000> carry <sil=0.000> on <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  con <sil=0.000> consequently <sil=1.000> ,COMMA  the <sil=0.000> number <sil=0.000> of <sil=0.000> elements <sil=0.000> that <sil=0.000> I restrict
my <sil=0.000> search <sil=0.000> to <sil=0.000> gets <sil=0.000> reduced <sil=0.000> at <sil=0.000> every <sil=0.000> iteration <sil=2.000> .PERIOD  Let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=0.000> in <sil=0.000> a little <sil=0.000> more <sil=0.000> detail <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
in <sil=0.000> every <sil=0.000> state <sil=1.000> ,COMMA  we <sil=0.000> reduce <sil=0.000> the <sil=0.000> number <sil=0.000> of <sil=0.000> elements <sil=0.000> by <sil=0.000> half <sil=2.000> .PERIOD  I <sil=0.000> think <sil=0.000> this <sil=0.000> is <sil=0.000> clear <sil=0.000> now <sil=1.000> ,COMMA  that
this <sil=0.000> statement <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  if <sil=0.000> you <sil=0.000> do <sil=0.000> not <sil=0.000> find <sil=0.000> it <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> ignore <sil=0.000> the <sil=0.000> half <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=0.000> and <sil=0.000> repeat
the <sil=0.000> process <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=0.000> basics <sil=0.000> strategy <sil=2.000> .PERIOD  What <sil=0.000> do <sil=0.000> you <sil=0.000> want <sil=0.228> ?QUESTIONMARK  The <sil=0.000> array <sil=0.000> is <sil=0.000> from <sil=0.000> 0 to <sil=0.000> n
minus <sil=0.000> 1 <sil=1.000> ,COMMA  n <sil=0.000> elements <sil=2.000> .PERIOD  Here <sil=1.000> ,COMMA  I <sil=0.000> was <sil=0.000> showing <sil=0.000> mid <sil=0.000> zone <sil=0.000> only <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> the <sil=0.000> mid <sil=0.000> m and <sil=0.000> this <sil=0.000> is
the <sil=0.000> left <sil=0.000> end <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> the <sil=0.000> right <sil=0.000> end <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  there <sil=0.000> are <sil=0.000> 2 indexes <sil=1.000> ,COMMA  indices <sil=0.000> all <sil=0.000> right <sil=0.228> ?QUESTIONMARK  Now <sil=1.000> ,COMMA  am
taking <sil=0.000> the <sil=0.000> key <sil=0.000> and <sil=0.000> I am <sil=0.000> checking <sil=0.000> this <sil=0.000> part <sil=0.000> m <sil=2.000> .PERIOD  The <sil=0.000> element <sil=0.000> m this <sil=0.000> element <sil=0.354> ;SEMICOLON  that <sil=0.000> is <sil=1.000> ,COMMA  xm <sil=2.000> .PERIOD 
And <sil=0.000> depending <sil=0.000> on <sil=0.000> whether <sil=0.000> if <sil=0.000> it <sil=0.000> is <sil=0.000> greater <sil=0.000> than <sil=0.000> the <sil=0.000> key <sil=1.000> ,COMMA  if <sil=0.000> xm <sil=1.000> ,COMMA  if <sil=0.000> the <sil=0.000> key <sil=0.000> is <sil=0.000> greater <sil=0.000> than
xm <sil=1.000> ,COMMA  key <sil=0.000> is <sil=0.000> greater <sil=0.000> than <sil=0.000> xm <sil=0.000> is <sil=0.000> less <sil=1.000> ,COMMA  then <sil=0.000> I will <sil=0.000> be <sil=0.000> concentrating <sil=0.000> here <sil=2.000> .PERIOD  If <sil=0.000> xm <sil=0.000> is <sil=0.000> greater <sil=0.000> than
the <sil=0.000> key <sil=1.000> ,COMMA  then <sil=0.000> I will <sil=0.000> be <sil=0.000> concentrating <sil=0.000> on <sil=0.000> this <sil=0.000> half <sil=0.000> on <sil=0.000> this <sil=0.000> half <sil=0.000> or <sil=0.000> on <sil=0.000> this <sil=0.000> half <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> what <sil=0.000> I
was <sil=0.000> explaining <sil=0.000> till <sil=0.000> now <sil=0.000> ok <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  here <sil=1.000> ,COMMA  if <sil=0.000> it <sil=0.000> is <sil=0.000> no <sil=1.000> ,COMMA  then <sil=0.000> I will <sil=2.000> .PERIOD  If <sil=0.000> it <sil=0.000> xm <sil=0.000> is <sil=0.000> less <sil=0.000> than <sil=0.000> the <sil=0.000> key  <sil=1.000> ,COMMA  then <sil=0.000> the <sil=0.000> I will <sil=0.000> come <sil=0.000> to <sil=0.000> this
half <sil=2.000> .PERIOD  Otherwise <sil=1.000> ,COMMA  if <sil=0.000> it <sil=0.000> is <sil=0.000> less <sil=0.000> I will <sil=0.000> come <sil=0.000> to <sil=0.000> this <sil=0.000> half <sil=0.000> greater <sil=0.000> than <sil=0.000> that <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  will <sil=0.000> first
given <sil=0.000> this <sil=0.000> L and <sil=0.000> r <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> my <sil=0.000> mid <sil=0.000> element <sil=0.228> ?QUESTIONMARK  How <sil=0.000> will <sil=0.000> I compute <sil=0.000> my <sil=0.000> mid <sil=0.000> element <sil=0.000> or <sil=0.000> m <sil=0.228> ?QUESTIONMARK 
This <sil=0.000> L plus <sil=0.000> R divided <sil=0.000> by <sil=0.000> 2 <sil=2.000> .PERIOD  And <sil=0.000> then <sil=1.000> ,COMMA  depending <sil=0.000> on <sil=0.000> whether <sil=0.000> it <sil=0.000> is <sil=0.000> less <sil=0.000> or <sil=0.000> greater <sil=1.000> ,COMMA  we <sil=0.000> will
we <sil=0.000> will <sil=0.000> move <sil=0.000> the <sil=0.000> left <sil=0.000> or <sil=0.000> L or <sil=0.000> R till <sil=0.000> the <sil=0.000> middle <sil=0.000> depending <sil=0.000> on <sil=0.000> the <sil=0.000> test <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  again <sil=0.000> let <sil=0.000> me
show <sil=0.000> it <sil=0.000> with <sil=0.000> a example <sil=0.000> that <sil=0.000> we <sil=0.000> are <sil=0.000> showing <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  something <sil=0.000> like <sil=0.000> this <sil=0.000> 1 2 <sil=0.000> 5 7 <sil=0.000> 9 11 <sil=0.000> what <sil=0.000> is <sil=0.000> being <sil=0.000> said <sil=0.000> is <sil=1.000> ,COMMA  9 <sil=0.000> 11 <sil=0.000> ah <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  L <sil=0.000> is <sil=0.000> L equals <sil=0.000> 0 and
R <sil=0.000> is <sil=0.000> equal <sil=0.000> to <sil=0.000> 1 2 <sil=0.000> 3 4 <sil=0.000> 5 6 <sil=0.000> 0 1 <sil=0.000> 2 3 <sil=0.000> 4 5 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  R <sil=0.000> is <sil=0.000> equal <sil=0.000> to <sil=0.000> 5 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  mid <sil=0.000> is <sil=0.000> L plus <sil=0.000> R divided <sil=0.000> by <sil=0.000> 2 <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> 5 divided <sil=0.000> by <sil=0.000> 2 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> can <sil=0.000> take <sil=0.000> 2 or <sil=0.000> we <sil=0.000> can <sil=0.000> take <sil=0.000> 3 depending <sil=0.000> on <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> I come
to <sil=0.000> if <sil=0.000> I take <sil=0.000> 2 <sil=1.000> ,COMMA  if <sil=0.000> I take <sil=0.000> 3 <sil=1.000> ,COMMA  then <sil=0.000> am <sil=0.000> coming <sil=0.000> to <sil=0.000> mid <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> I will <sil=0.000> do <sil=0.000> is <sil=1.000> ,COMMA  if <sil=0.000> 3 is <sil=0.000> my
midpoint <sil=1.000> ,COMMA  if <sil=0.000> I take <sil=0.000> 5 by <sil=0.000> 2 is <sil=0.000> 3 <sil=1.000> ,COMMA  then <sil=1.000> ,COMMA  that <sil=0.000> means <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> in <sil=0.000> case <sil=0.000> of <sil=0.000> odd <sil=0.000> I will <sil=0.000> add <sil=0.000> 1 to
that <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> move <sil=2.000> .PERIOD  Now <sil=0.000> if <sil=0.000> the <sil=0.000> key <sil=0.000> is <sil=0.000> suppose <sil=1.000> ,COMMA  key <sil=0.000> is <sil=0.000> 9 suppose <sil=0.000> the <sil=0.000> key <sil=0.000> is <sil=0.000> 9 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  my
mid <sil=0.000> was <sil=0.000> the <sil=0.000> 3rd <sil=2.000> .PERIOD 
It <sil=0.000> is <sil=0.000> 0 1 <sil=0.000> 2 3 <sil=0.000> or <sil=0.000> let <sil=0.000> me <sil=0.000> 0 1 <sil=0.000> 2 3 <sil=2.000> .PERIOD  There <sil=0.000> is <sil=0.000> my <sil=0.000> mid <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  since <sil=0.000> the <sil=0.000> key <sil=0.000> is <sil=0.000> key <sil=0.000> is <sil=0.000> greater <sil=0.000> than
the <sil=0.000> element <sil=0.000> x m <sil=0.000> x mid <sil=1.000> ,COMMA  since <sil=0.000> it <sil=0.000> is <sil=0.000> x mid <sil=0.000> is <sil=0.000> less <sil=2.000> .PERIOD  I <sil=0.000> will <sil=0.000> be <sil=0.000> restrict <sil=0.000> my <sil=0.000> search <sil=0.000> in <sil=0.000> this <sil=0.000> area <sil=2.000> .PERIOD 
Therefore <sil=1.000> ,COMMA  what <sil=0.000> I will <sil=0.000> do <sil=0.228> ?QUESTIONMARK  I <sil=0.000> will <sil=0.000> move <sil=0.000> this <sil=0.000> L to <sil=0.000> mid <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> will <sil=0.000> be <sil=0.000> my <sil=0.000> new <sil=0.000> L <sil=2.000> .PERIOD  And <sil=0.000> I
will <sil=0.000> find <sil=0.000> the <sil=0.000> mid <sil=0.000> with <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  next <sil=0.000> mid <sil=0.000> will <sil=0.000> be <sil=0.000> this <sil=0.000> new <sil=0.000> L plus <sil=0.000> R by <sil=0.000> 2 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> this
element <sil=0.000> if <sil=0.000> my <sil=0.000> search <sil=0.000> was <sil=0.000> on <sil=0.000> the <sil=0.000> other <sil=0.000> side <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  if <sil=0.000> the <sil=0.000> key <sil=0.000> was <sil=0.000> not <sil=0.000> 9 <sil=1.000> ,COMMA  but <sil=0.000> the <sil=0.000> key
was <sil=0.000> 2 or <sil=0.000> 1 <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> make <sil=0.000> it <sil=0.000> 1 <sil=2.000> .PERIOD 
Then <sil=1.000> ,COMMA  at <sil=0.000> this <sil=0.000> point <sil=1.000> ,COMMA  I <sil=0.000> find <sil=0.000> that <sil=0.000> the <sil=0.000> key <sil=0.000> is <sil=0.000> less <sil=0.000> than <sil=0.000> x mid <sil=1.000> ,COMMA  then <sil=0.000> I will <sil=0.000> be <sil=0.000> restricting <sil=0.000> my
search <sil=0.000> in <sil=0.000> this <sil=0.000> area <sil=2.000> .PERIOD  In <sil=0.000> that <sil=0.000> case <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> move <sil=0.000> my <sil=0.000> R <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> shift <sil=0.000> this <sil=0.000> R over <sil=0.000> here <sil=1.000> ,COMMA  and <sil=0.000> this
the <sil=0.000> mid <sil=0.000> will <sil=0.000> be <sil=0.000> R <sil=1.000> ,COMMA  R <sil=0.000> will <sil=0.000> be <sil=0.000> the <sil=0.000> mid <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  next <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> be <sil=0.000> restricting <sil=0.000> my <sil=0.000> search <sil=0.000> in <sil=0.000> this <sil=0.000> half
and <sil=0.000> forget <sil=0.000> about <sil=0.000> this <sil=0.000> half <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> how <sil=0.000> we <sil=0.000> at <sil=0.000> every <sil=0.000> iteration <sil=1.000> ,COMMA  we <sil=0.000> break <sil=0.000> down <sil=0.000> the <sil=0.000> entire
array <sil=0.000> into <sil=0.000> halves <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> you <sil=0.000> have <sil=0.000> understood <sil=0.000> this <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> proceed <sil=2.000> .PERIOD  Repeat <sil=0.000> the <sil=0.000> search

operation <sil=0.000> in <sil=0.000> the <sil=0.000> reduced <sil=0.000> interval <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> we <sil=0.000> are <sil=0.000> doing <sil=0.000> is <sil=1.000> ,COMMA  we <sil=0.000> are <sil=0.000> looking <sil=0.000> at <sil=0.000> this <sil=0.000> binary
search <sil=0.000> algorithm <sil=0.000> and <sil=0.000> we <sil=0.000> are <sil=0.000> trying <sil=0.000> to <sil=0.000> design <sil=0.000> a function <sil=2.000> .PERIOD 

And <sil=0.000> finery <sil=0.000> binary <sil=0.000> search <sil=0.000> is <sil=0.000> a function <sil=1.000> ,COMMA  whose <sil=0.000> name <sil=0.000> am <sil=0.000> just <sil=0.000> keeping <sil=0.000> as <sil=0.000> bin <sil=0.000> search <sil=0.000> all
right <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> the <sil=0.000> name <sil=0.000> of <sil=0.000> the <sil=0.000> algorithm <sil=2.000> .PERIOD  And <sil=0.000> what <sil=0.000> are <sil=0.000> the <sil=0.000> parameters <sil=0.228> ?QUESTIONMARK  Let <sil=0.000> us <sil=0.000> see <sil=2.000> .PERIOD  The
parameters <sil=0.000> are <sil=0.000> one <sil=0.000> is <sil=0.000> the <sil=0.000> array <sil=0.000> that <sil=0.000> is <sil=0.000> being <sil=0.000> passed <sil=0.000> the <sil=0.000> list <sil=0.000> that <sil=0.000> have <sil=0.000> to <sil=0.000> search <sil=2.000> .PERIOD  I <sil=0.000> also <sil=0.000> need
the <sil=0.000> size <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=0.000> and <sil=0.000> I need <sil=0.000> the <sil=0.000> key <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  these <sil=0.000> are <sil=0.000> 3 things <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  binary <sil=0.000> search <sil=0.000> is <sil=0.000> a function <sil=2.000> .PERIOD  What <sil=0.000> are <sil=0.000> it <sil=0.000> is <sil=0.000> inputs <sil=0.228> ?QUESTIONMARK  The <sil=0.000> list <sil=0.000> or
the <sil=0.000> array <sil=0.000> which <sil=0.000> is <sil=0.000> x <sil=1.000> ,COMMA  the <sil=0.000> size <sil=0.000> or <sil=0.000> what <sil=0.000> we <sil=0.000> are <sil=0.000> calling <sil=0.000> about <sil=0.000> right <sil=0.000> now <sil=0.000> n and <sil=0.000> the <sil=0.000> key <sil=0.000> and
what <sil=0.000> will <sil=0.000> the <sil=0.000> output <sil=0.000> be <sil=1.000> ,COMMA  bin <sil=0.000> search <sil=0.000> we <sil=0.000> will <sil=0.000> tell <sil=0.000> us <sil=0.000> whether <sil=0.000> it <sil=0.000> has <sil=0.000> been <sil=0.000> found <sil=0.000> or <sil=0.000> not <sil=0.000> ok <sil=2.000> .PERIOD 
But <sil=1.000> ,COMMA  so <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> a 0 <sil=0.000> or <sil=0.000> 1 <sil=2.000> .PERIOD  Found <sil=0.000> or <sil=0.000> not <sil=2.000> .PERIOD  0 <sil=0.000> or <sil=0.000> 1 or <sil=0.000> it <sil=0.000> can <sil=0.000> written <sil=0.000> as <sil=0.000> an <sil=0.000> index <sil=0.000> also <sil=0.000> ok <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
now <sil=1.000> ,COMMA  if <sil=0.000> we <sil=0.000> proceed <sil=0.000> with <sil=0.000> this <sil=0.000> idea <sil=1.000> ,COMMA  then <sil=0.000> let <sil=0.000> us <sil=0.000> develop <sil=0.000> the <sil=0.000> algorithm <sil=0.000> step <sil=0.000> by <sil=0.000> step <sil=0.000> inside
this <sil=0.000> function <sil=2.000> .PERIOD  I <sil=0.000> have <sil=0.000> got <sil=0.000> the <sil=0.000> search <sil=2.000> .PERIOD  I <sil=0.000> have <sil=0.000> got <sil=0.000> the <sil=0.000> list <sil=0.000> the <sil=0.000> list <sil=0.000> is <sil=0.000> given <sil=0.000> to <sil=0.000> me <sil=2.000> .PERIOD 

This <sil=0.000> array <sil=0.000> is <sil=0.000> known <sil=0.000> to <sil=0.000> me <sil=2.000> .PERIOD  I <sil=0.000> declare <sil=0.000> internally <sil=0.000> L R <sil=0.000> and <sil=0.000> I have <sil=0.000> to <sil=0.000> use <sil=0.000> a another <sil=0.000> index
called <sil=0.000> mid <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  this <sil=0.000> has <sil=0.000> got <sil=0.000> no <sil=0.000> meaning <sil=0.000> outside <sil=2.000> .PERIOD  This <sil=0.000> function <sil=0.000> next <sil=0.000> step <sil=0.000> what <sil=0.000> should <sil=0.000> I
do <sil=0.228> ?QUESTIONMARK 

Next <sil=0.000> step <sil=0.000> would <sil=0.000> be <sil=0.000> while <sil=0.000> some <sil=0.000> condition <sil=0.000> mid <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> have <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> L plus <sil=0.000> R by <sil=0.000> 2 <sil=2.000> .PERIOD  As
you <sil=0.000> know <sil=1.000> ,COMMA  if <sil=0.000> this <sil=0.000> is <sil=0.000> the <sil=0.000> array <sil=0.000> x <sil=1.000> ,COMMA  if <sil=0.000> the <sil=0.000> mid <sil=0.000> element <sil=0.000> is <sil=0.000> greater <sil=0.000> than <sil=0.000> the <sil=0.000> keys <sil=0.000> So <sil=1.000> ,COMMA  the <sil=0.000> key <sil=1.000> ,COMMA 
say <sil=0.000> this <sil=0.000> mid <sil=0.000> element <sil=0.000> is <sil=0.000> 7 and <sil=0.000> my <sil=0.000> key <sil=0.000> is <sil=0.000> 9 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> element <sil=0.000> is <sil=0.000> greater <sil=0.000> than <sil=0.000> I know <sil=0.000> that
this <sil=0.000> element <sil=0.000> is <sil=0.000> greater <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> 17 <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> greater <sil=0.000> than <sil=0.000> the <sil=0.000> key <sil=2.000> .PERIOD  Then <sil=0.000> I will <sil=0.000> have <sil=0.000> to

keep <sil=0.000> my <sil=0.000> search <sil=0.000> within <sil=0.000> this <sil=0.000> zone <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> R will <sil=0.000> be <sil=0.000> updated <sil=0.000> and <sil=0.000> the <sil=0.000> R will <sil=0.000> come <sil=0.000> here <sil=2.000> .PERIOD 
Otherwise <sil=1.000> ,COMMA  L <sil=0.000> will <sil=0.000> be <sil=0.000> moved <sil=0.000> here <sil=2.000> .PERIOD  This <sil=0.000> much <sil=0.000> is <sil=0.000> clear <sil=2.000> .PERIOD  You <sil=0.000> think <sil=0.000> over <sil=0.000> this <sil=0.000> and <sil=0.000> build <sil=0.000> upon
this <sil=0.000> algorithm <sil=0.000> we <sil=0.000> will <sil=0.000> take <sil=0.000> it <sil=0.000> up <sil=0.000> in <sil=0.000> next <sil=0.000> step <sil=0.000> again <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> to <sil=0.000> decide <sil=0.000> on <sil=0.000> how <sil=0.000> to <sil=0.000> build
this <sil=0.000> things <sil=0.000> up <sil=2.000> .PERIOD 

We <sil=0.000> were <sil=0.000> discussing <sil=0.000> about <sil=0.000> the <sil=0.000> binary <sil=0.000> search <sil=0.000> function <sil=0.000> or <sil=0.000> binary <sil=0.000> search <sil=0.000> procedure <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> we <sil=0.000> can <sil=0.000> see <sil=0.000> that <sil=0.000> binary <sil=0.000> search <sil=0.000> is <sil=0.000> of <sil=0.000> type <sil=0.000> integer <sil=0.000> is <sil=0.000> a function <sil=0.000> of <sil=0.000> type <sil=0.000> integer <sil=0.000> that
will <sil=0.000> be <sil=0.000> returning <sil=0.000> an <sil=0.000> integer <sil=2.000> .PERIOD  And <sil=0.000> it <sil=0.000> has <sil=0.000> got <sil=0.000> the <sil=0.000> parameters <sil=0.000> the <sil=0.000> list <sil=0.000> or <sil=0.000> the <sil=0.000> array <sil=0.000> which <sil=0.000> is
being <sil=0.000> designated <sil=0.000> as <sil=0.000> x here <sil=1.000> ,COMMA  the <sil=0.000> size <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=0.000> and <sil=0.000> the <sil=0.000> key <sil=2.000> .PERIOD  Now <sil=0.000> if <sil=0.000> the <sil=0.000> key <sil=0.000> appears <sil=0.000> say <sil=1.000> ,COMMA 
the <sil=0.000> array <sil=0.000> is <sil=0.000> here <sil=1.000> ,COMMA  the <sil=0.000> array <sil=0.000> is <sil=0.000> this <sil=1.000> ,COMMA  or <sil=0.000> the <sil=0.000> list <sil=0.000> is <sil=0.000> this <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> called <sil=0.000> x <sil=2.000> .PERIOD  And <sil=0.000> it <sil=0.000> starts <sil=0.000> with <sil=0.000> 0 <sil=1.000> ,COMMA 
and <sil=0.000> the <sil=0.000> last <sil=0.000> one <sil=0.000> is <sil=0.000> therefore <sil=1.000> ,COMMA  whatever <sil=0.000> is <sil=0.000> in <sil=0.000> size <sil=0.000> minus <sil=0.000> 1 <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  if <sil=0.000> the <sil=0.000> key <sil=0.000> there <sil=0.000> is <sil=0.000> a key <sil=1.000> ,COMMA  and <sil=0.000> if <sil=0.000> the <sil=0.000> key <sil=0.000> appears <sil=0.000> anywhere <sil=0.000> here <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> return <sil=0.000> the
position <sil=0.000> of <sil=0.000> the <sil=0.000> point <sil=0.000> where <sil=0.000> the <sil=0.000> key <sil=0.000> is <sil=1.000> ,COMMA  if <sil=0.000> this <sil=0.000> be <sil=0.000> the <sil=0.000> position <sil=0.000> that <sil=0.000> be <sil=0.000> returned <sil=2.000> .PERIOD  And <sil=0.000> if <sil=0.000> not
found <sil=0.000> it <sil=0.000> will <sil=0.000> return <sil=0.000> minus <sil=0.000> 1 <sil=1.000> ,COMMA  so <sil=0.000> either <sil=0.000> it <sil=0.000> will <sil=0.000> find <sil=0.000> the <sil=0.000> position <sil=0.000> send <sil=0.000> the <sil=0.000> position <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that
is <sil=0.000> also <sil=0.000> integer <sil=1.000> ,COMMA  or <sil=0.000> minus <sil=0.000> 1 hence <sil=0.000> the <sil=0.000> height <sil=0.000> is <sil=0.000> integer <sil=1.000> ,COMMA  alright <sil=2.000> .PERIOD  Now <sil=0.000> we <sil=0.000> have <sil=0.000> got <sil=0.000> 2
pointers <sil=1.000> ,COMMA  one <sil=0.000> is <sil=0.000> L the <sil=0.000> left <sil=0.000> pointer <sil=0.000> left <sil=0.000> index <sil=0.000> and <sil=0.000> the <sil=0.000> right <sil=0.000> index <sil=0.000> of <sil=0.000> this <sil=2.000> .PERIOD  And <sil=0.000> from <sil=0.000> there <sil=0.000> we
are <sil=0.000> finding <sil=0.000> out <sil=0.000> the <sil=0.000> middle <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> are <sil=0.000> finding <sil=0.000> out <sil=0.000> midpoint <sil=0.000> by <sil=0.000> this <sil=1.000> ,COMMA  like <sil=1.000> ,COMMA  now <sil=0.000> if <sil=0.000> the <sil=0.000> key <sil=0.000> is
smaller <sil=0.000> than <sil=0.000> the <sil=0.000> middle <sil=0.000> element <sil=2.000> .PERIOD 

If <sil=0.000> the <sil=0.000> key <sil=0.000> is <sil=0.000> smaller <sil=0.000> than <sil=0.000> this <sil=0.000> middle <sil=0.000> element <sil=1.000> ,COMMA  then <sil=0.000> obviously <sil=1.000> ,COMMA  our <sil=0.000> search <sil=0.000> will <sil=0.000> be <sil=0.000> on <sil=0.000> this
side <sil=2.000> .PERIOD  Therefore <sil=1.000> ,COMMA  this <sil=0.000> R will <sil=0.000> be <sil=0.000> moved <sil=0.000> to <sil=0.000> this <sil=0.000> point <sil=2.000> .PERIOD  L <sil=0.000> will <sil=0.000> remain <sil=0.000> here <sil=0.000> and <sil=0.000> my <sil=0.000> search <sil=0.000> will
be <sil=0.000> restricted <sil=0.000> in <sil=0.000> this <sil=0.000> zone <sil=2.000> .PERIOD  Otherwise <sil=0.000> L will <sil=0.000> be <sil=0.000> moved <sil=0.000> here <sil=1.000> ,COMMA  R <sil=0.000> will <sil=0.000> not <sil=0.000> be <sil=0.000> disturbed <sil=0.000> and
the <sil=0.000> search <sil=0.000> will <sil=0.000> be <sil=0.000> restricted <sil=0.000> to <sil=0.000> this <sil=0.000> zone <sil=2.000> .PERIOD  This <sil=0.000> much <sil=0.000> has <sil=0.000> been <sil=0.000> achieved <sil=0.000> by <sil=0.000> this <sil=0.000> piece <sil=0.000> of
code <sil=1.000> ,COMMA  what <sil=0.000> else <sil=0.000> do <sil=0.000> we <sil=0.000> need <sil=0.228> ?QUESTIONMARK  What <sil=0.000> else <sil=0.000> do <sil=0.000> we <sil=0.000> need <sil=0.000> to <sil=0.000> do <sil=0.228> ?QUESTIONMARK  Now <sil=0.000> how <sil=0.000> long <sil=0.000> will <sil=0.000> this <sil=0.000> go <sil=0.000> on <sil=0.228> ?QUESTIONMARK 

So <sil=1.000> ,COMMA  in <sil=0.000> this <sil=0.000> way <sil=1.000> ,COMMA  what <sil=0.000> will <sil=0.000> happen <sil=0.000> is <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> move <sil=0.000> either <sil=0.000> L or <sil=0.000> R <sil=1.000> ,COMMA  either <sil=0.000> this <sil=0.000> or <sil=0.000> this <sil=1.000> ,COMMA  and
when <sil=0.000> will <sil=0.000> this <sil=0.000> be <sil=0.000> completed <sil=1.000> ,COMMA  how <sil=0.000> long <sil=0.000> will <sil=0.000> this <sil=0.000> loop <sil=0.000> go <sil=0.000> on <sil=0.228> ?QUESTIONMARK  If <sil=0.000> you <sil=0.000> think <sil=0.000> a little <sil=0.000> bit <sil=0.000> we
will <sil=0.000> find <sil=0.000> that <sil=0.000> it <sil=0.000> will <sil=0.000> go <sil=0.000> on <sil=0.000> as <sil=0.000> long <sil=0.000> as <sil=0.000> L and <sil=0.000> R are <sil=0.000> not <sil=0.000> crossing <sil=0.000> over <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> I shift <sil=0.000> and
search <sil=0.000> this <sil=0.000> part <sil=0.000> R is <sil=0.000> here <sil=2.000> .PERIOD 

Suppose <sil=0.000> I so <sil=1.000> ,COMMA  I <sil=0.000> initially <sil=0.000> start <sil=0.000> with <sil=0.000> L equal <sil=0.000> to <sil=0.000> be <sil=0.000> minus <sil=0.000> 1 and <sil=0.000> R to <sil=0.000> be <sil=0.000> the <sil=0.000> size <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am
shifting <sil=0.000> from <sil=0.000> so <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> my <sil=0.000> array <sil=0.000> and <sil=0.000> L value <sil=0.000> of <sil=0.000> L is <sil=0.000> minus <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> here <sil=0.000> and <sil=0.000> R is
equal <sil=0.000> to <sil=0.000> size <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  pointing <sil=0.000> here <sil=0.000> size <sil=0.000> plus <sil=0.000> 1 <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  sorry <sil=0.000> this <sil=0.000> point <sil=0.000> is <sil=0.000> size
minus <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> actually <sil=0.000> here <sil=1.000> ,COMMA  and <sil=0.000> while <sil=0.000> as <sil=0.000> I share <sil=1.000> ,COMMA  I <sil=0.000> shift <sil=0.000> L and <sil=0.000> I shift <sil=0.000> between <sil=0.000> this
part <sil=0.000> etcetera <sil=2.000> .PERIOD 
Then <sil=0.000> my <sil=0.000> shift <sil=0.000> L <sil=1.000> ,COMMA  R <sil=0.000> is <sil=0.000> here <sil=0.354> ;SEMICOLON  as <sil=0.000> soon <sil=0.000> as <sil=0.000> L and <sil=0.000> R crosses <sil=0.000> over <sil=1.000> ,COMMA  if <sil=0.000> R will <sil=0.000> R moves <sil=0.000> this <sil=0.000> side
then <sil=0.000> also <sil=0.000> a L <sil=0.000> and <sil=0.000> R can <sil=0.000> cross <sil=0.000> over <sil=2.000> .PERIOD  If <sil=0.000> they <sil=0.000> cross <sil=0.000> over <sil=0.000> then <sil=0.000> that <sil=0.000> is <sil=0.000> the <sil=0.354> ;SEMICOLON  that <sil=0.000> is <sil=0.000> my <sil=0.000> point
where <sil=0.000> I should <sil=0.000> stop <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> initialize <sil=0.000> this <sil=0.354> ;SEMICOLON  so <sil=1.000> ,COMMA  and <sil=0.000> I go <sil=0.000> on <sil=0.000> shifting <sil=0.000> this <sil=1.000> ,COMMA  depending <sil=0.000> on <sil=0.000> either <sil=0.000> L or <sil=0.000> R <sil=2.000> .PERIOD  That <sil=0.000> is
exactly <sil=0.000> what <sil=0.000> we <sil=0.000> are <sil=0.000> doing <sil=0.000> when <sil=0.000> we <sil=0.000> took <sil=0.000> the <sil=0.000> say <sil=0.000> 1 <sil=1.000> ,COMMA  2 <sil=1.000> ,COMMA  5 <sil=1.000> ,COMMA  7 <sil=1.000> ,COMMA  9 <sil=1.000> ,COMMA  13 <sil=0.000> like <sil=0.000> that <sil=0.000> 15 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> start <sil=0.000> it
with <sil=0.000> the <sil=0.000> middle <sil=0.000> number <sil=1.000> ,COMMA  and <sil=0.000> when <sil=0.000> the <sil=0.000> key <sil=0.000> was <sil=0.000> suppose <sil=0.000> my <sil=0.000> key <sil=0.000> is <sil=0.000> 16 <sil=1.000> ,COMMA  all <sil=0.000> right <sil=0.228> ?QUESTIONMARK  Or <sil=0.000> say <sil=2.000> .PERIOD 
Let <sil=0.000> me <sil=0.000> erase <sil=0.000> this <sil=1.000> ,COMMA  my <sil=0.000> key <sil=0.000> is <sil=0.000> say <sil=0.000> 8 <sil=0.354> ;SEMICOLON  12 <sil=2.000> .PERIOD  Suppose <sil=1.000> ,COMMA  my <sil=0.000> key <sil=0.000> is <sil=0.000> 12 <sil=1.000> ,COMMA  what <sil=0.000> will <sil=0.000> happen <sil=0.228> ?QUESTIONMARK  My <sil=0.000> L
is <sil=0.000> here <sil=1.000> ,COMMA  there <sil=0.000> is <sil=0.000> L <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> R <sil=1.000> ,COMMA  I <sil=0.000> start <sil=0.000> with <sil=0.000> mid <sil=0.000> is <sil=0.000> 7 so <sil=1.000> ,COMMA  key <sil=0.000> is <sil=0.000> greater <sil=0.000> than <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> will
have <sil=0.000> to <sil=0.000> restrict <sil=0.000> my <sil=0.000> search <sil=0.000> in <sil=0.000> this <sil=0.000> zone <sil=0.000> I take <sil=0.000> the <sil=0.000> middle <sil=0.000> of <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  R <sil=0.000> becomes <sil=0.000> this <sil=1.000> ,COMMA  this
becomes <sil=0.000> R <sil=1.000> ,COMMA  and <sil=0.000> I am <sil=0.000> sorry <sil=1.000> ,COMMA  am <sil=0.000> sorry <sil=0.000> R remains <sil=0.000> the <sil=0.000> same <sil=2.000> .PERIOD  I <sil=0.000> have <sil=0.000> to <sil=0.000> search <sil=0.000> between <sil=0.000> this
zone <sil=0.354> ;SEMICOLON  so <sil=1.000> ,COMMA  what <sil=0.000> I do <sil=0.228> ?QUESTIONMARK  I <sil=0.000> shift <sil=0.000> L I <sil=0.000> have <sil=0.000> to <sil=0.000> search <sil=0.000> between <sil=0.000> this <sil=0.000> zone <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> shift <sil=0.000> L to <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
this <sil=0.000> is <sil=0.000> my <sil=0.000> 12 <sil=1.000> ,COMMA  and <sil=0.000> this <sil=0.000> is <sil=0.000> R I <sil=0.000> have <sil=0.000> to <sil=0.000> search <sil=0.000> in <sil=0.000> between <sil=0.000> this <sil=2.000> .PERIOD  I <sil=0.000> will <sil=0.000> find <sil=0.000> this <sil=0.000> to <sil=0.000> be <sil=0.000> the <sil=0.000> mid <sil=1.000> ,COMMA 
fine <sil=0.228> ?QUESTIONMARK  And <sil=0.000> I find <sil=0.000> that <sil=0.000> the <sil=0.000> key <sil=0.000> is <sil=0.000> less <sil=0.000> than <sil=0.000> the <sil=0.000> mid <sil=0.354> ;SEMICOLON  so <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> restrict <sil=0.000> my <sil=0.000> search <sil=0.000> within <sil=0.000> this
zone <sil=1.000> ,COMMA  this <sil=0.000> zone <sil=1.000> ,COMMA  within <sil=0.000> this <sil=0.000> zone <sil=0.000> right <sil=2.000> .PERIOD 
Since <sil=0.000> it <sil=0.000> is <sil=0.000> less <sil=0.000> so <sil=1.000> ,COMMA  then <sil=0.000> what <sil=0.000> should <sil=0.000> I do <sil=0.228> ?QUESTIONMARK  If <sil=0.000> since <sil=0.000> am <sil=0.000> moving <sil=0.000> on <sil=0.000> this <sil=0.000> zone <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> shift <sil=0.000> R
keeping <sil=0.000> L fixed <sil=0.000> I will <sil=0.000> shift <sil=0.000> R here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> will <sil=0.000> be <sil=0.000> R now <sil=0.354> ;SEMICOLON  now <sil=0.000> between <sil=0.000> this <sil=0.000> n L <sil=0.000> l and <sil=0.000> R
I <sil=0.000> find <sil=0.000> mid <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> my <sil=0.000> mid <sil=0.000> ok <sil=2.000> .PERIOD  I <sil=0.000> find <sil=0.000> 9 to <sil=0.000> be <sil=0.000> less <sil=0.000> than <sil=0.000> 12 <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  it <sil=0.000> should <sil=0.000> be <sil=0.000> on <sil=0.000> this
side <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> move <sil=0.000> L <sil=1.000> ,COMMA  as <sil=0.000> I move <sil=0.000> L <sil=0.354> ;SEMICOLON  L <sil=0.000> is <sil=0.000> crossing <sil=0.000> R <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  now <sil=0.000> I have <sil=0.000> come <sil=0.000> to <sil=0.000> a
position <sil=0.000> where <sil=0.000> I have <sil=0.000> ex <sil=0.000> exhausted <sil=0.000> everything <sil=1.000> ,COMMA  and <sil=0.000> I could <sil=0.000> not <sil=0.000> find <sil=0.000> the <sil=0.000> key <sil=1.000> ,COMMA  all <sil=0.000> right <sil=0.228> ?QUESTIONMARK 
So <sil=1.000> ,COMMA  if <sil=0.000> L is <sil=0.000> greater <sil=0.000> than <sil=0.000> 0 <sil=1.000> ,COMMA  and <sil=0.000> x L <sil=0.000> is <sil=0.000> equal <sil=0.000> to <sil=0.000> key <sil=1.000> ,COMMA  L <sil=0.000> is <sil=0.000> greater <sil=0.000> than <sil=0.000> equal <sil=0.000> to <sil=0.000> 0 <sil=2.000> .PERIOD  And <sil=0.000> x L <sil=0.000> is
the <sil=0.000> is <sil=0.000> a key <sil=0.000> then <sil=0.000> I return <sil=0.000> to <sil=0.000> the <sil=0.000> point <sil=1.000> ,COMMA  otherwise <sil=0.000> return <sil=0.000> minus <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> the <sil=0.000> binary
search <sil=0.000> algorithm <sil=0.000> ok <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> how <sil=0.000> am <sil=0.000> carrying <sil=0.000> out <sil=0.000> the <sil=0.000> algorithm <sil=0.000> through <sil=0.000> a C <sil=0.000> code <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> an <sil=0.000> example <sil=0.000> am <sil=0.000> writing <sil=0.000> down <sil=0.000> an <sil=0.000> array <sil=2.000> .PERIOD  Suppose <sil=1.000> ,COMMA  sorry <sil=0.000> am <sil=0.000> writing <sil=0.000> down <sil=0.000> a
sorted <sil=0.000> array <sil=1.000> ,COMMA  suppose <sil=0.000> it <sil=0.000> is <sil=0.000> minus <sil=0.000> 17 <sil=1.000> ,COMMA  minus <sil=0.000> 5 <sil=1.000> ,COMMA  3 <sil=1.000> ,COMMA  6 <sil=1.000> ,COMMA  12 <sil=1.000> ,COMMA  21 <sil=1.000> ,COMMA  45 <sil=1.000> ,COMMA  63 <sil=0.000> and <sil=0.000> 50 <sil=2.000> .PERIOD  63 <sil=0.000> it <sil=0.000> cannot <sil=0.000> be
50 <sil=1.000> ,COMMA  say <sil=0.000> this <sil=0.000> one <sil=0.000> is <sil=0.000> say <sil=0.000> this <sil=0.000> up <sil=0.000> to <sil=0.000> 63 <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> my <sil=0.000> array <sil=2.000> .PERIOD 
Now <sil=0.000> if <sil=0.000> I carry <sil=0.000> out <sil=0.000> so <sil=1.000> ,COMMA  the <sil=0.000> size <sil=0.000> is <sil=0.000> 1 <sil=1.000> ,COMMA  2 <sil=1.000> ,COMMA  3 <sil=1.000> ,COMMA  4 <sil=1.000> ,COMMA  5 <sil=1.000> ,COMMA  6 <sil=1.000> ,COMMA  7 <sil=1.000> ,COMMA  8 <sil=2.000> .PERIOD  I <sil=0.000> must <sil=0.000> have <sil=0.000> one <sil=0.000> another <sil=0.000> one <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let
me <sil=0.000> have <sil=0.000> 75 <sil=1.000> ,COMMA  and <sil=0.000> if <sil=0.000> 3 be <sil=0.000> my <sil=0.000> key <sil=0.000> this <sil=0.000> is <sil=0.000> the <sil=0.000> key <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> will <sil=0.000> happen <sil=0.228> ?QUESTIONMARK  I <sil=0.000> will <sil=0.000> start <sil=0.000> L here <sil=1.000> ,COMMA 
R <sil=0.000> here <sil=1.000> ,COMMA  and <sil=0.000> I will <sil=0.000> find <sil=0.000> the <sil=0.000> midpoint <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> midpoint <sil=0.000> will <sil=0.000> be <sil=0.000> here <sil=1.000> ,COMMA  12 <sil=0.000> and <sil=0.000> 12 <sil=0.000> is
greater <sil=0.000> than <sil=0.000> the <sil=0.000> key <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  my <sil=0.000> search <sil=0.000> will <sil=0.000> be <sil=0.000> within <sil=0.000> this <sil=0.000> zone <sil=1.000> ,COMMA  this <sil=0.000> R will <sil=0.000> be <sil=0.000> shifted <sil=0.000> here <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> my <sil=0.000> now <sil=0.000> R <sil=1.000> ,COMMA  and <sil=0.000> this <sil=0.000> is <sil=0.000> L <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> find <sil=0.000> out <sil=0.000> midpoint <sil=0.000> 3 here <sil=0.000> now <sil=2.000> .PERIOD  As <sil=0.000> soon <sil=0.000> as <sil=0.000> I
come <sil=0.000> to <sil=0.000> this <sil=0.000> mid <sil=1.000> ,COMMA  and <sil=0.000> I find <sil=0.000> that <sil=0.000> this <sil=0.000> mid <sil=0.000> is <sil=0.000> matching <sil=0.000> the <sil=0.000> key <sil=0.000> my <sil=0.000> search <sil=0.000> is <sil=0.000> found <sil=1.000> ,COMMA  all
right <sil=0.228> ?QUESTIONMARK  I <sil=0.000> get <sil=0.000> I get <sil=0.000> my <sil=0.000> key <sil=0.000> in <sil=0.000> a particular <sil=0.000> position <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> write <sil=0.000> it <sil=0.000> in <sil=0.000> different <sil=0.000> ways <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  so <sil=1.000> ,COMMA  in <sil=0.000> this <sil=0.000> way <sil=1.000> ,COMMA  if <sil=0.000> I do <sil=0.000> that <sil=1.000> ,COMMA  then <sil=0.000> I will <sil=0.000> get
different <sil=0.000> results <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  minus <sil=0.000> 17 <sil=0.000> I will <sil=0.000> just <sil=0.000> missed <sil=0.000> out <sil=0.000> minus <sil=0.000> 5 <sil=1.000> ,COMMA  3 <sil=1.000> ,COMMA  6 <sil=1.000> ,COMMA  12 <sil=1.000> ,COMMA  21 <sil=1.000> ,COMMA  45 <sil=1.000> ,COMMA  63 <sil=0.000> and <sil=0.000> 75 <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  if <sil=0.000> for <sil=0.000> this <sil=1.000> ,COMMA  my <sil=0.000> L was <sil=0.000> at <sil=0.000> minus <sil=0.000> 1 R <sil=0.000> was <sil=0.000> at <sil=0.000> 9 <sil=1.000> ,COMMA  and <sil=0.000> I my <sil=0.000> mid <sil=0.000> was <sil=0.000> this <sil=0.000> x 4 <sil=0.000> 12 <sil=0.000> ok <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  then
x <sil=0.000> 1 is <sil=0.000> minus <sil=0.000> 5 <sil=2.000> .PERIOD  I <sil=0.000> carry <sil=0.000> on <sil=0.000> doing <sil=0.000> this <sil=2.000> .PERIOD  L <sil=0.000> is <sil=0.000> still <sil=0.000> 1 <sil=1.000> ,COMMA  R <sil=0.000> is <sil=0.000> 4 <sil=1.000> ,COMMA  R <sil=0.000> has <sil=0.000> been <sil=0.000> shifted <sil=0.000> to <sil=0.000> here <sil=2.000> .PERIOD  And <sil=0.000> x
2 <sil=0.000> is <sil=0.000> 3 <sil=1.000> ,COMMA  I <sil=0.000> found <sil=0.000> it <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> my <sil=0.000> result <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> way <sil=0.000> I will <sil=0.000> carry <sil=0.000> out <sil=0.000> and <sil=0.000> you <sil=0.000> can <sil=0.000> find <sil=0.000> out <sil=0.000> that <sil=0.000> L and <sil=0.000> R and
then <sil=0.000> I returned <sil=2.000> .PERIOD  L <sil=0.000> I go <sil=0.000> on <sil=0.000> shifting <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> what <sil=0.000> it <sil=0.000> has <sil=0.000> happened <sil=2.000> .PERIOD  I <sil=0.000> have <sil=0.000> got <sil=0.000> the <sil=0.000> mid
value <sil=1.000> ,COMMA  and <sil=0.000> I have <sil=0.000> got <sil=0.000> the <sil=0.000> value <sil=1.000> ,COMMA  but <sil=0.000> then <sil=0.000> still <sil=0.000> am <sil=0.000> going <sil=0.000> on <sil=0.000> shifting <sil=2.000> .PERIOD  You <sil=0.000> can <sil=0.000> you <sil=0.000> can <sil=0.000> also <sil=1.000> ,COMMA 
what <sil=0.000> I have <sil=0.000> suggesting <sil=0.000> is <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> also <sil=0.000> possible <sil=0.000> to <sil=0.000> check <sil=0.000> the <sil=0.000> equality <sil=0.000> with <sil=0.000> the <sil=0.000> x mid <sil=0.000> as <sil=0.000> soon
as <sil=0.000> I find <sil=0.000> that <sil=0.000> the <sil=0.000> element <sil=0.000> has <sil=0.000> matched <sil=0.000> with <sil=0.000> the <sil=0.000> mid <sil=0.000> then <sil=0.000> it <sil=0.000> is <sil=0.000> found <sil=2.000> .PERIOD 

I <sil=0.000> think <sil=0.000> you <sil=0.000> have <sil=0.000> understood <sil=0.000> it <sil=0.000> you <sil=0.000> can <sil=0.000> try <sil=0.000> writing <sil=0.000> out <sil=0.000> the <sil=0.000> algorithm <sil=0.000> yourself <sil=0.000> these <sil=0.000> are
binary <sil=0.000> search <sil=0.000> we <sil=0.000> will <sil=0.000> see <sil=0.000> later <sil=0.000> that <sil=0.000> it <sil=0.000> can <sil=0.000> be <sil=0.000> also <sil=0.000> done <sil=0.000> through <sil=0.000> recursion <sil=2.000> .PERIOD 
Now <sil=0.000> why <sil=0.000> are <sil=0.000> you <sil=0.000> doing <sil=0.000> so <sil=0.000> much <sil=0.228> ?QUESTIONMARK  Earlier <sil=1.000> ,COMMA  linear <sil=0.000> search <sil=0.000> was <sil=0.000> very <sil=0.000> much <sil=0.000> simple <sil=1.000> ,COMMA  right <sil=0.228> ?QUESTIONMARK 
Here <sil=0.000> suppose <sil=0.000> we <sil=0.000> had <sil=0.000> thousand <sil=0.000> elements <sil=1.000> ,COMMA  if <sil=0.000> we <sil=0.000> had <sil=0.000> thousand <sil=0.000> elements <sil=1.000> ,COMMA  then <sil=0.000> the <sil=0.000> ordinary
search <sil=0.000> if <sil=0.000> a key <sil=0.000> may <sil=0.000> key <sil=0.000> is <sil=0.000> the <sil=0.000> member <sil=0.000> of <sil=0.000> x <sil=1.000> ,COMMA  it <sil=0.000> would <sil=0.000> on <sil=0.000> an <sil=0.000> average <sil=0.000> require <sil=0.000> on <sil=0.000> an <sil=0.000> average
it <sil=0.000> would <sil=0.000> have <sil=0.000> required <sil=0.000> 500 <sil=0.000> comparisons <sil=0.000> on <sil=0.000> an <sil=0.000> average <sil=2.000> .PERIOD  But <sil=0.000> what <sil=0.000> will <sil=0.000> happen <sil=0.000> in <sil=0.000> the <sil=0.000> case
of <sil=0.000> binary <sil=0.000> system <sil=0.000> search <sil=0.228> ?QUESTIONMARK  After <sil=0.000> the <sil=0.000> first <sil=0.000> compare <sil=0.000> 1000 <sil=0.000> elements <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  we <sil=0.000> are <sil=0.000> left <sil=0.000> with <sil=0.000> only <sil=0.000> 500 <sil=0.000> elements <sil=1.000> ,COMMA  because <sil=0.000> I start <sil=0.000> it <sil=0.000> from <sil=0.000> I start <sil=0.000> it <sil=0.000> with <sil=0.000> an <sil=0.000> array <sil=1.000> ,COMMA  and
then <sil=0.000> based <sil=0.000> on <sil=0.000> that <sil=0.000> I have <sil=0.000> either <sil=0.000> gone <sil=0.000> on <sil=0.000> this <sil=0.000> half <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=0.000> or <sil=0.000> this <sil=0.000> half <sil=0.000> of <sil=0.000> the <sil=0.000> array
depending <sil=0.000> on <sil=0.000> whether <sil=0.000> the <sil=0.000> key <sil=0.000> is <sil=0.000> less <sil=0.000> than <sil=0.000> or <sil=0.000> greater <sil=0.000> than <sil=0.000> the <sil=0.000> midpoint <sil=0.000> this <sil=0.000> is <sil=0.000> the <sil=0.000> mid <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
on <sil=0.000> an <sil=0.000> average <sil=0.000> first <sil=0.000> compare <sil=0.000> I am <sil=0.000> left <sil=0.000> with <sil=0.000> 500 <sil=0.000> elements <sil=2.000> .PERIOD  Next <sil=0.000> compare <sil=0.000> this <sil=0.000> part <sil=0.000> is <sil=0.000> again
divided <sil=0.000> if <sil=0.000> it <sil=0.000> is <sil=0.000> on <sil=0.000> this <sil=0.000> side <sil=0.000> am <sil=0.000> left <sil=0.000> with <sil=0.000> 250 <sil=0.000> elements <sil=1.000> ,COMMA  right <sil=2.000> .PERIOD  After <sil=0.000> at <sil=0.000> most <sil=0.000> 10 <sil=0.000> steps <sil=1.000> ,COMMA  we
are <sil=0.000> done <sil=0.000> in <sil=0.000> that <sil=0.000> way <sil=0.000> I go <sil=0.000> on <sil=0.000> dividing <sil=0.000> it <sil=0.000> and <sil=0.000> after <sil=0.000> at <sil=0.000> most <sil=0.000> 10 <sil=0.000> steps <sil=0.000> I am <sil=0.000> done <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> thousand <sil=0.000> elements <sil=0.000> ok <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> so <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> way <sil=0.000> I get <sil=0.000> 250 <sil=0.000> elements <sil=1.000> ,COMMA  and <sil=0.000> 125 <sil=1.000> ,COMMA 
125 <sil=0.354> ;SEMICOLON  then <sil=0.000> half <sil=0.000> of <sil=0.000> that <sil=0.000> 60 <sil=1.000> ,COMMA  65 <sil=0.000> or <sil=0.000> something <sil=0.000> like <sil=0.000> that <sil=2.000> .PERIOD 

In <sil=0.000> that <sil=0.000> way <sil=1.000> ,COMMA  number <sil=0.000> of <sil=0.000> steps <sil=0.000> that <sil=0.000> I will <sil=0.000> be <sil=0.000> following <sil=0.000> will <sil=0.000> be <sil=0.000> around <sil=0.000> 10 <sil=2.000> .PERIOD  In <sil=0.000> general <sil=1.000> ,COMMA  if
there <sil=0.000> are <sil=0.000> n elements <sil=0.000> in <sil=0.000> the <sil=0.000> array <sil=1.000> ,COMMA  number <sil=0.000> of <sil=0.000> searches <sil=0.000> required <sil=0.000> is <sil=0.000> 2 to <sil=0.000> the <sil=0.000> power <sil=0.000> k should
be <sil=0.000> n <sil=1.000> ,COMMA  where <sil=0.000> k is <sil=0.000> number <sil=0.000> of <sil=0.000> steps <sil=0.000> ok <sil=2.000> .PERIOD  For <sil=0.000> n if <sil=0.000> there <sil=0.000> be <sil=0.000> 64 <sil=2.000> .PERIOD  Initially <sil=1.000> ,COMMA  the <sil=0.000> list <sil=0.000> is <sil=0.000> 60 <sil=0.000> the <sil=0.000> size <sil=0.000> is
64 <sil=1.000> ,COMMA  after <sil=0.000> first <sil=0.000> comparison <sil=0.000> list <sil=0.000> is <sil=0.000> 32 <sil=2.000> .PERIOD  After <sil=0.000> second <sil=0.000> it <sil=0.000> is <sil=0.000> 16 <sil=1.000> ,COMMA  then <sil=0.000> 8 <sil=1.000> ,COMMA  then <sil=0.000> 4 <sil=1.000> ,COMMA  then <sil=0.000> 2 and <sil=0.000> then <sil=0.000> 1
so <sil=1.000> ,COMMA  6 <sil=0.000> steps <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  basically <sil=0.000> at <sil=0.000> every <sil=0.000> step <sil=0.000> am <sil=0.000> breaking <sil=0.000> it <sil=0.000> down <sil=0.000> into <sil=0.000> half <sil=2.000> .PERIOD  Therefore <sil=1.000> ,COMMA  if <sil=0.000> I need
the <sil=0.000> k steps <sil=2.000> .PERIOD 

Then <sil=1.000> ,COMMA  if <sil=0.000> I need <sil=0.000> k steps <sil=1.000> ,COMMA  then <sil=0.000> 2 to <sil=0.000> the <sil=0.000> power <sil=0.000> k should <sil=0.000> be <sil=0.000> equal <sil=0.000> to <sil=0.000> n <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  how <sil=0.000> many
steps <sil=0.000> are <sil=0.000> there <sil=0.228> ?QUESTIONMARK  How <sil=0.000> many <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> k if <sil=0.000> I take <sil=0.000> log <sil=0.000> and <sil=0.000> k log <sil=0.000> log <sil=0.000> k k <sil=0.000> log <sil=0.000> 2 is <sil=0.000> equal <sil=0.000> to <sil=0.000> n <sil=2.000> .PERIOD 
Therefore <sil=1.000> ,COMMA  k <sil=0.000> will <sil=0.000> be <sil=0.000> log <sil=0.000> 2 n <sil=0.000> to <sil=0.000> the <sil=0.000> power <sil=0.000> base <sil=0.000> of <sil=0.000> log <sil=0.000> 2 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  log <sil=0.000> 2 <sil=1.000> ,COMMA  log <sil=0.000> 64 <sil=0.000> to <sil=0.000> the <sil=0.000> base <sil=0.000> 2 is
6 <sil=2.000> .PERIOD  We <sil=0.000> will <sil=0.000> be <sil=0.000> completing <sil=0.000> in <sil=0.000> 6 steps <sil=2.000> .PERIOD  Whereas <sil=1.000> ,COMMA  in <sil=0.000> the <sil=0.000> worst <sil=0.000> case <sil=0.000> I would <sil=0.000> have <sil=0.000> needed <sil=0.000> 64
comparisons <sil=0.000> in <sil=0.000> the <sil=0.000> case <sil=0.000> if <sil=0.000> linear <sil=0.000> search <sil=2.000> .PERIOD  Now <sil=0.000> given <sil=0.000> this <sil=0.000> idea <sil=0.000> of <sil=0.000> binary <sil=0.000> search <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  what <sil=0.000> have <sil=0.000> you <sil=0.000> seen <sil=0.228> ?QUESTIONMARK  We <sil=0.000> have <sil=0.000> seen <sil=0.000> binary <sil=0.000> search <sil=0.000> is <sil=0.000> a search <sil=0.000> algorithm <sil=1.000> ,COMMA  that <sil=0.000> enables
us <sil=0.000> to <sil=0.000> search <sil=0.000> for <sil=0.000> an <sil=0.000> element <sil=0.000> much <sil=0.000> faster <sil=1.000> ,COMMA  than <sil=0.000> linear <sil=0.000> search <sil=0.000> the <sil=0.000> approach <sil=0.000> being <sil=0.000> that <sil=0.000> we
divide <sil=0.000> the <sil=0.000> array <sil=0.000> to <sil=0.000> be <sil=0.000> searched <sil=0.000> in <sil=0.000> half <sil=0.000> every <sil=0.000> time <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> divide <sil=0.000> it <sil=0.000> into <sil=0.000> half <sil=0.000> and <sil=0.000> restrict
our <sil=0.000> search <sil=0.000> in <sil=0.000> half <sil=1.000> ,COMMA  and <sil=0.000> in <sil=0.000> the <sil=0.000> next <sil=0.000> step <sil=0.000> I further <sil=0.000> divide <sil=0.000> it <sil=0.000> into <sil=0.000> 2 half <sil=0.000> and <sil=0.000> restrict <sil=0.000> it <sil=0.000> to <sil=0.000> even
a <sil=0.000> smaller <sil=0.000> steps <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  every <sil=0.000> time <sil=0.000> am <sil=0.000> halving <sil=0.000> whatever <sil=0.000> array <sil=0.000> am <sil=0.000> checking <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  2 <sil=0.000> days <sil=0.000> to <sil=0.000> the <sil=0.000> power <sil=0.000> k time
by <sil=0.000> half <sil=0.000> date <sil=0.000> where <sil=0.000> k times <sil=0.000> have <sil=0.000> half <sil=0.000> date <sil=0.000> 2 days <sil=0.000> to <sil=0.000> the <sil=0.000> power <sil=0.000> k should <sil=0.000> cover <sil=0.000> the <sil=0.000> entire <sil=0.000> n <sil=2.000> .PERIOD 
And <sil=0.000> so <sil=1.000> ,COMMA  from <sil=0.000> there <sil=0.000> we <sil=0.000> get <sil=0.000> the <sil=0.000> complexity <sil=0.000> to <sil=0.000> be <sil=0.000> of <sil=0.000> log <sil=0.000> of <sil=0.000> log <sil=0.000> 2 log <sil=0.000> n to <sil=0.000> the <sil=0.000> base <sil=0.000> 2 log <sil=0.000> n to
the <sil=0.000> base <sil=0.000> 2 in <sil=0.000> general <sil=0.000> it <sil=0.000> will <sil=0.000> be <sil=0.000> log <sil=0.000> if <sil=0.000> 64 <sil=0.000> is <sil=0.000> replaced <sil=0.000> with <sil=0.000> n (Refer <sil=0.000> Time: 15:43) then <sil=0.000> it
should <sil=0.000> be <sil=0.000> log <sil=0.000> n to <sil=0.000> the <sil=0.000> base <sil=0.000> 2 <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> my <sil=0.000> time <sil=0.000> complexity <sil=0.000> compared <sil=0.000> to <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> say <sil=0.000> this
order <sil=0.000> of <sil=0.000> log <sil=0.000> n to <sil=0.000> the <sil=0.000> base <sil=0.000> 2 <sil=1.000> ,COMMA  compared <sil=0.000> to <sil=0.000> order <sil=0.000> of <sil=0.000> n <sil=1.000> ,COMMA  that <sil=0.000> was <sil=0.000> the <sil=0.000> case <sil=0.000> in <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> a in
the <sil=0.000> case <sil=0.000> of <sil=0.000> linear <sil=0.000> search <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> move <sil=0.000> to <sil=0.000> another <sil=0.000> very <sil=0.000> fundamental <sil=0.000> problem <sil=0.000> in <sil=0.000> programming <sil=2.000> .PERIOD  We <sil=0.000> often
need <sil=0.000> that <sil=0.000> say <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  here <sil=0.000> we <sil=0.000> have <sil=0.000> done <sil=0.000> one <sil=0.000> thing <sil=0.000> that <sil=0.000> is <sil=1.000> ,COMMA  I <sil=0.000> had <sil=0.000> a array <sil=0.000> like <sil=0.000> say <sil=0.000> 2 <sil=1.000> ,COMMA  3 <sil=1.000> ,COMMA 
7 <sil=1.000> ,COMMA  6 <sil=1.000> ,COMMA  1 <sil=1.000> ,COMMA  9 <sil=2.000> .PERIOD 

Now <sil=0.000> this <sil=0.000> was <sil=0.000> an <sil=0.000> array <sil=1.000> ,COMMA  on <sil=0.000> which <sil=0.000> I cannot <sil=0.000> run <sil=0.000> binary <sil=0.000> search <sil=2.000> .PERIOD  Why <sil=0.000> I cannot <sil=0.000> run <sil=0.000> binary
search <sil=0.228> ?QUESTIONMARK  Because <sil=0.000> binary <sil=0.000> search <sil=0.000> can <sil=0.000> be <sil=0.000> done <sil=0.000> only <sil=0.000> on <sil=0.000> sorted <sil=0.000> array <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> I sort <sil=0.000> it <sil=1.000> ,COMMA  either <sil=0.000> in
increasing <sil=0.000> or <sil=0.000> decreasing <sil=0.000> order <sil=2.000> .PERIOD  Say <sil=1.000> ,COMMA  for <sil=0.000> example <sil=1.000> ,COMMA  it <sil=0.000> becomes <sil=0.000> 1 <sil=1.000> ,COMMA  2 <sil=1.000> ,COMMA  3 <sil=1.000> ,COMMA  6 <sil=1.000> ,COMMA  7 <sil=1.000> ,COMMA  9 <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> a
sorted <sil=0.000> array <sil=1.000> ,COMMA  or <sil=0.000> the <sil=0.000> other <sil=0.000> thing <sil=0.000> could <sil=0.000> be <sil=0.000> 9 <sil=1.000> ,COMMA  7 <sil=1.000> ,COMMA  6 <sil=1.000> ,COMMA  3 <sil=1.000> ,COMMA  2 <sil=1.000> ,COMMA  1 <sil=2.000> .PERIOD  These <sil=0.000> also <sil=0.000> a sorted <sil=0.000> array <sil=2.000> .PERIOD  In <sil=0.000> the
other <sil=0.000> direction <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> descending <sil=0.000> order <sil=0.000> this <sil=0.000> is <sil=0.000> the <sil=0.000> ascending <sil=0.000> order <sil=0.000> ok <sil=2.000> .PERIOD 
So <sil=0.000> now <sil=0.000> another <sil=0.000> problem <sil=0.000> is <sil=1.000> ,COMMA  to <sil=0.000> arrange <sil=0.000> the <sil=0.000> things <sil=0.000> arrange <sil=0.000> the <sil=0.000> objects <sil=1.000> ,COMMA  suppose <sil=0.000> they <sil=0.000> are
number <sil=0.000> of <sil=0.000> numbers <sil=0.000> like <sil=0.000> this <sil=2.000> .PERIOD  We <sil=0.000> have <sil=0.000> to <sil=0.000> arrange <sil=0.000> them <sil=1.000> ,COMMA  sorted <sil=0.000> or <sil=0.000> arranged <sil=0.000> in <sil=0.000> a particular
way <sil=2.000> .PERIOD  The <sil=0.000> question <sil=0.000> is <sil=1.000> ,COMMA  how <sil=0.000> to <sil=0.000> do <sil=0.000> sorting <sil=1.000> ,COMMA  how <sil=0.000> to <sil=0.000> sort <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  suppose <sil=0.000> I have <sil=0.000> given <sil=0.000> this <sil=0.000> array
to <sil=0.000> my <sil=0.000> program <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> the <sil=0.000> input <sil=2.000> .PERIOD  Then <sil=0.000> if <sil=0.000> I want <sil=0.000> to <sil=0.000> apply <sil=0.000> binary <sil=0.000> search <sil=1.000> ,COMMA  then <sil=0.000> I cannot
directly <sil=0.000> apply <sil=0.000> it <sil=0.000> apply <sil=0.000> binary <sil=0.000> search <sil=0.000> on <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> I can <sil=0.000> do <sil=0.228> ?QUESTIONMARK  I <sil=0.000> can <sil=0.000> first <sil=0.000> take <sil=0.000> the <sil=0.000> array
say <sil=0.000> I read <sil=0.000> the <sil=0.000> array <sil=0.000> let <sil=0.000> me <sil=0.000> write <sil=2.000> .PERIOD 

Then <sil=0.000> sort <sil=0.000> the <sil=0.000> array <sil=1.000> ,COMMA  and <sil=0.000> then <sil=0.000> read <sil=0.000> key <sil=0.000> apply <sil=0.000> binary <sil=0.000> search <sil=2.000> .PERIOD  Now <sil=0.000> binary <sil=0.000> search <sil=0.000> takes <sil=0.000> for <sil=0.000> n
number <sil=0.000> of <sil=0.000> elements <sil=0.000> it <sil=0.000> will <sil=0.000> be <sil=0.000> faster <sil=2.000> .PERIOD  But <sil=0.000> how <sil=0.000> do <sil=0.000> we <sil=0.000> sort <sil=0.000> the <sil=0.000> array <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> faster <sil=0.000> than
linear <sil=0.000> search <sil=1.000> ,COMMA  but <sil=0.000> is <sil=0.000> it <sil=0.000> advisable <sil=0.000> to <sil=0.000> approach <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=0.000> if <sil=0.000> the <sil=0.000> array <sil=0.000> is <sil=0.000> not <sil=0.000> sort <sil=1.000> ,COMMA  is <sil=0.000> it
advisable <sil=0.000> to <sil=0.000> sort <sil=0.000> the <sil=0.000> array <sil=0.000> and <sil=0.000> then <sil=0.000> apply <sil=0.000> binary <sil=0.000> search <sil=0.228> ?QUESTIONMARK  In <sil=0.000> order <sil=0.000> to <sil=0.000> understand <sil=0.000> this <sil=1.000> ,COMMA  we
have <sil=0.000> to <sil=0.000> first <sil=0.000> see <sil=0.000> how <sil=0.000> an <sil=0.000> array <sil=0.000> can <sil=0.000> be <sil=0.000> sorted <sil=1.000> ,COMMA  how <sil=0.000> an <sil=0.000> array <sil=0.000> can <sil=0.000> be <sil=0.000> arranged <sil=0.000> in <sil=0.000> either
increasing <sil=0.000> or <sil=0.000> decreasing <sil=0.000> order <sil=2.000> .PERIOD 
That <sil=0.000> is <sil=0.000> also <sil=0.000> a very <sil=0.000> important <sil=0.000> problem <sil=0.000> that <sil=0.000> is <sil=0.000> called <sil=0.000> the <sil=0.000> sorting <sil=0.000> problem <sil=2.000> .PERIOD  And <sil=0.000> this <sil=0.000> has <sil=0.000> got
very <sil=0.000> important <sil=0.000> I mean <sil=0.000> application <sil=1.000> ,COMMA  in <sil=0.000> many <sil=0.000> of <sil=0.000> many <sil=0.000> of <sil=0.000> objects <sil=0.000> whenever <sil=0.000> I so <sil=1.000> ,COMMA  for
example <sil=1.000> ,COMMA  for <sil=0.000> example <sil=1.000> ,COMMA  you <sil=0.000> have <sil=0.000> got <sil=0.000> the <sil=0.000> marks <sil=0.000> of <sil=0.000> the <sil=0.000> students <sil=1.000> ,COMMA  all <sil=0.000> right <sil=0.228> ?QUESTIONMARK  The <sil=0.000> you <sil=0.000> have
got <sil=0.000> a marks <sil=0.000> array <sil=0.000> hm <sil=2.000> .PERIOD 

Say <sil=1.000> ,COMMA  you <sil=0.000> have <sil=0.000> got <sil=0.000> 2-dimensional <sil=0.000> matrix <sil=0.000> may <sil=0.000> be <sil=0.000> where <sil=1.000> ,COMMA  all <sil=0.000> right <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> take <sil=0.000> one
dimensional <sil=0.000> one <sil=0.000> dimensional <sil=0.000> array <sil=0.354> ;SEMICOLON  where <sil=1.000> ,COMMA  the <sil=0.000> roll <sil=0.000> numbers <sil=0.000> are <sil=0.000> here <sil=1.000> ,COMMA  every <sil=0.000> row <sil=0.000> is
corresponding <sil=0.000> to <sil=0.000> a roll <sil=0.000> number <sil=2.000> .PERIOD  And <sil=0.000> here <sil=0.000> I think <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> I will <sil=0.000> just <sil=0.000> do <sil=0.000> it <sil=0.000> again <sil=2.000> .PERIOD  I <sil=0.000> have <sil=0.000> got
the <sil=0.000> marks <sil=0.000> here <sil=0.354> ;SEMICOLON  56 <sil=1.000> ,COMMA  50 <sil=1.000> ,COMMA  65 <sil=1.000> ,COMMA  70 <sil=0.000> etcetera <sil=1.000> ,COMMA  etcetera <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  I <sil=0.000> want <sil=0.000> to <sil=0.000> find <sil=0.000> what <sil=0.000> is <sil=0.000> the <sil=0.000> highest <sil=0.000> marks <sil=2.000> .PERIOD  One <sil=0.000> thing <sil=0.000> is <sil=0.000> that <sil=0.000> I can <sil=0.000> find <sil=0.000> that <sil=1.000> ,COMMA  out <sil=0.000> or <sil=0.000> I
want <sil=0.000> to <sil=0.000> attribute <sil=0.000> ranks <sil=1.000> ,COMMA  first <sil=0.000> second <sil=0.000> third <sil=0.000> like <sil=0.000> that <sil=2.000> .PERIOD  In <sil=0.000> that <sil=0.000> case <sil=0.000> I can <sil=0.000> sort <sil=0.000> this <sil=0.000> array <sil=1.000> ,COMMA  and
from <sil=0.000> here <sil=0.000> I want <sil=0.000> to <sil=0.000> have <sil=0.000> an <sil=0.000> array <sil=0.000> like <sil=0.000> this <sil=0.354> ;SEMICOLON  where <sil=0.000> the <sil=0.000> first <sil=0.000> element <sil=0.000> will <sil=0.000> be <sil=0.000> 7 <sil=1.000> ,COMMA  the <sil=0.000> second
element <sil=0.000> will <sil=0.000> be <sil=0.000> 65 <sil=1.000> ,COMMA  then <sil=0.000> 56 <sil=1.000> ,COMMA  then <sil=0.000> 50 <sil=2.000> .PERIOD  This <sil=0.000> also <sil=0.000> sorting <sil=0.000> the <sil=0.000> marks <sil=2.000> .PERIOD  In <sil=0.000> a decreasing <sil=0.000> order <sil=1.000> ,COMMA 
and <sil=0.000> along <sil=0.000> with <sil=0.000> that <sil=0.000> I can <sil=0.000> also <sil=0.000> sort <sil=0.000> the <sil=0.000> roll <sil=0.000> numbers <sil=1.000> ,COMMA  and <sil=0.000> can <sil=0.000> publish <sil=0.000> which <sil=0.000> roll <sil=0.000> number
got <sil=0.000> marks <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> we <sil=0.000> want <sil=0.000> to <sil=0.000> see <sil=0.000> next <sil=0.000> is <sil=0.000> sorting <sil=2.000> .PERIOD 

Let <sil=0.000> us <sil=0.000> define <sil=0.000> the <sil=0.000> basic <sil=0.000> problem <sil=0.000> first <sil=2.000> .PERIOD  Sorting <sil=0.000> means <sil=0.000> given <sil=0.000> an <sil=0.000> array <sil=0.000> like <sil=0.000> 0 to <sil=0.000> some <sil=0.000> size
minus <sil=0.000> 1 reorder <sil=0.000> the <sil=0.000> entries <sil=0.000> so <sil=0.000> that <sil=0.000> they <sil=0.000> are <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=0.354> ;SEMICOLON  that <sil=0.000> x 1 <sil=0.000> is <sil=0.000> greater <sil=0.000> than <sil=0.000> equal <sil=0.000> to <sil=0.000> x
0 <sil=0.000> x 2 <sil=0.000> greater <sil=0.000> than <sil=0.000> equal <sil=0.000> to <sil=0.000> x 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> it <sil=0.000> be <sil=0.000> this <sil=0.000> sorry <sil=1.000> ,COMMA  why <sil=0.000> is <sil=0.000> this <sil=0.000> greater <sil=0.000> than <sil=0.000> equal <sil=0.000> to
coming <sil=0.000> up <sil=0.228> ?QUESTIONMARK  If <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  2 <sil=1.000> ,COMMA  5 <sil=1.000> ,COMMA  5 <sil=1.000> ,COMMA  6 <sil=1.000> ,COMMA  6 <sil=1.000> ,COMMA  7 <sil=1.000> ,COMMA  9 <sil=0.354> ;SEMICOLON  this <sil=0.000> also <sil=0.000> sorted <sil=0.000> array <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  both <sil=0.000> these
elements <sil=0.000> could <sil=0.000> have <sil=0.000> taken <sil=0.000> any <sil=0.000> order <sil=1.000> ,COMMA  but <sil=0.000> since <sil=0.000> they <sil=0.000> are <sil=0.000> same <sil=0.000> they <sil=0.000> can <sil=0.000> be <sil=0.000> assumed <sil=0.000> to <sil=0.000> be
sorted <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> why <sil=0.000> this <sil=0.000> greater <sil=0.000> than <sil=0.000> equal <sil=0.000> to <sil=0.000> thing <sil=0.000> that <sil=0.000> is <sil=0.000> coming <sil=0.000> up <sil=2.000> .PERIOD 

The <sil=0.000> list <sil=0.000> here <sil=0.000> is <sil=0.000> in <sil=0.000> non-decreasing <sil=0.000> order <sil=1.000> ,COMMA  non-decreasing <sil=2.000> .PERIOD  I <sil=0.000> cannot <sil=0.000> say <sil=0.000> increasing <sil=0.000> order
because <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> increasing <sil=0.000> 2 <sil=1.000> ,COMMA  2 <sil=1.000> ,COMMA  5 <sil=1.000> ,COMMA  5 <sil=1.000> ,COMMA  6 <sil=1.000> ,COMMA  6 <sil=1.000> ,COMMA  7 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> of <sil=0.000> course <sil=1.000> ,COMMA  there <sil=0.000> was <sil=0.000> an <sil=0.000> increase <sil=1.000> ,COMMA 
but <sil=0.000> here <sil=0.000> there <sil=0.000> is <sil=0.000> no <sil=0.000> increase <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> rather <sil=0.000> instead <sil=0.000> of <sil=0.000> calling <sil=0.000> it <sil=0.000> increasing <sil=0.000> order <sil=1.000> ,COMMA  we
can <sil=0.000> call <sil=0.000> it <sil=0.000> non-decreasing <sil=0.000> order <sil=2.000> .PERIOD  A <sil=0.000> list <sil=0.000> of <sil=0.000> elements <sil=0.000> in <sil=0.000> non-increasing <sil=0.000> order <sil=0.000> it <sil=0.000> is <sil=0.000> not
decreasing <sil=0.000> order <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> also <sil=0.000> sort <sil=0.000> it <sil=0.000> in <sil=0.000> the <sil=0.000> other <sil=0.000> way <sil=0.000> as <sil=0.000> it <sil=0.000> shown <sil=0.000> earlier <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> an <sil=0.000> example <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> sorted <sil=0.000> in <sil=0.000> non-decreasing <sil=0.000> order <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> see <sil=0.000> this <sil=0.000> array <sil=2.000> .PERIOD  10 <sil=1.000> ,COMMA 
30 <sil=0.000> now <sil=0.000> this <sil=0.000> original <sil=0.000> list <sil=2.000> .PERIOD  Now <sil=0.000> if <sil=0.000> I sort <sil=0.000> them <sil=0.000> in <sil=0.000> non-decreasing <sil=0.000> order <sil=0.000> it <sil=0.000> will <sil=0.000> 10 <sil=0.000> minus <sil=0.000> 10 <sil=1.000> ,COMMA 
10 <sil=1.000> ,COMMA  20 <sil=1.000> ,COMMA  30 <sil=1.000> ,COMMA  40 <sil=1.000> ,COMMA  60 <sil=1.000> ,COMMA  70 <sil=1.000> ,COMMA  72 <sil=1.000> ,COMMA  70 s <sil=1.000> ,COMMA  80 <sil=2.000> .PERIOD  And <sil=0.000> if <sil=0.000> I do <sil=0.000> it <sil=0.000> in <sil=0.000> a non-increasing <sil=0.000> order <sil=1.000> ,COMMA  then <sil=0.000> minus
80 <sil=1.000> ,COMMA  70 <sil=1.000> ,COMMA  70 <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> not <sil=0.000> increasing <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=1.000> ,COMMA  here <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> increasing <sil=1.000> ,COMMA  all
right <sil=0.228> ?QUESTIONMARK  Here <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> decreasing <sil=0.000> if <sil=0.000> I go <sil=0.000> in <sil=0.000> this <sil=0.000> direction <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  these <sil=0.000> are <sil=0.000> the <sil=0.000> 2 possibilities <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  the <sil=0.000> sorting <sil=0.000> problem <sil=0.000> is <sil=1.000> ,COMMA  if <sil=0.000> we <sil=0.000> have <sil=0.000> an <sil=0.000> array <sil=0.000> from <sil=0.000> 0 to <sil=0.000> size <sil=0.000> minus <sil=0.000> 1 <sil=1.000> ,COMMA  I <sil=0.000> want <sil=0.000> to <sil=0.000> sort <sil=0.000> it
and <sil=0.000> get <sil=0.000> a sorted <sil=0.000> list <sil=1.000> ,COMMA  all <sil=0.000> right <sil=0.228> ?QUESTIONMARK 

That <sil=0.000> is <sil=0.000> what <sil=0.000> I want <sil=0.000> to <sil=0.000> have <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> first <sil=0.000> algorithm <sil=0.000> that <sil=0.000> will <sil=0.000> be <sil=0.000> talking <sil=0.000> about <sil=0.000> is <sil=0.000> selection
sort <sil=2.000> .PERIOD  Selection <sil=0.000> sort <sil=0.000> is <sil=0.000> something <sil=0.000> like <sil=0.000> this <sil=2.000> .PERIOD  That <sil=0.000> suppose <sil=0.000> we <sil=0.000> have <sil=0.000> got <sil=0.000> a list <sil=0.000> here <sil=0.000> and <sil=0.000> this
part <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=0.000> is <sil=0.000> already <sil=0.000> sorted <sil=1.000> ,COMMA  this <sil=0.000> part <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=0.000> is <sil=0.000> sorted <sil=0.000> in <sil=0.000> a non-decreasing
order <sil=2.000> .PERIOD  This <sil=0.000> already <sil=0.000> the <sil=0.000> smallest <sil=0.000> element <sil=0.000> is <sil=0.000> here <sil=1.000> ,COMMA  the <sil=0.000> smallest <sil=0.000> element <sil=0.000> minus <sil=0.000> 10 <sil=1.000> ,COMMA  then <sil=0.000> 10 <sil=1.000> ,COMMA 
then <sil=0.000> 20 <sil=2.000> .PERIOD  This <sil=0.000> part <sil=0.000> is <sil=0.000> somehow <sil=0.000> as <sil=0.000> sorted <sil=2.000> .PERIOD  Now <sil=0.000> am <sil=0.000> less <sil=0.000> left <sil=0.000> with <sil=0.000> sorting <sil=0.000> this <sil=0.000> part <sil=0.000> only <sil=0.000> this

remainder <sil=2.000> .PERIOD  What <sil=0.000> should <sil=0.000> I do <sil=0.228> ?QUESTIONMARK  I <sil=0.000> am <sil=0.000> going <sil=0.000> to <sil=0.000> select <sil=0.000> the <sil=0.000> candidate <sil=0.000> for <sil=0.000> this <sil=0.000> position <sil=1.000> ,COMMA  right <sil=2.000> .PERIOD 
Am <sil=0.000> going <sil=0.000> to <sil=0.000> select <sil=0.000> the <sil=0.000> candidate <sil=0.000> for <sil=0.000> this <sil=0.000> position <sil=2.000> .PERIOD  For <sil=0.000> that <sil=0.000> what <sil=0.000> shall <sil=0.000> I do <sil=0.228> ?QUESTIONMARK  I <sil=0.000> will <sil=0.000> start
since <sil=0.000> part <sil=0.000> is <sil=0.000> sort <sil=1.000> ,COMMA  all <sil=0.000> the <sil=0.000> elements <sil=0.000> of <sil=0.000> this <sil=0.000> side <sil=0.000> or <sil=0.000> either <sil=0.000> equal <sil=0.000> to <sil=0.000> this <sil=0.000> or <sil=0.000> less <sil=0.000> than <sil=0.000> this <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> have <sil=0.000> to <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=0.000> part <sil=1.000> ,COMMA  and <sil=0.000> find <sil=0.000> out <sil=0.000> minimum <sil=0.000> element <sil=0.000> that <sil=0.000> is <sil=0.000> here <sil=2.000> .PERIOD  This
element <sil=0.000> that <sil=0.000> is <sil=0.000> minimum <sil=1.000> ,COMMA  since <sil=0.000> this <sil=0.000> part <sil=0.000> is <sil=0.000> sorted <sil=1.000> ,COMMA  this <sil=0.000> element <sil=0.000> this <sil=0.000> element <sil=0.000> must <sil=0.000> be
greater <sil=0.000> than <sil=0.000> this <sil=0.000> elements <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  among <sil=0.000> these <sil=1.000> ,COMMA  only <sil=0.000> for <sil=0.000> these <sil=0.000> people <sil=0.000> this <sil=0.000> one <sil=0.000> is <sil=0.000> the <sil=0.000> smallest <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> select <sil=0.000> that <sil=0.000> I select <sil=0.000> that <sil=1.000> ,COMMA  and <sil=0.000> put <sil=0.000> it <sil=0.000> in <sil=0.000> this <sil=0.000> position <sil=0.000> I swap <sil=0.000> how <sil=0.000> do <sil=0.000> I do <sil=0.000> that <sil=0.228> ?QUESTIONMARK  Suppose
here <sil=0.000> it <sil=0.000> was <sil=1.000> ,COMMA  it <sil=0.000> was <sil=0.000> minus <sil=0.000> 10 <sil=1.000> ,COMMA  10 <sil=1.000> ,COMMA  20 <sil=1.000> ,COMMA  30 <sil=2.000> .PERIOD  And <sil=0.000> here <sil=0.000> it <sil=0.000> was <sil=0.000> 50 <sil=1.000> ,COMMA  this <sil=0.000> point <sil=1.000> ,COMMA  this <sil=0.000> part <sil=0.000> is <sil=0.000> sorted <sil=2.000> .PERIOD 
50 <sil=1.000> ,COMMA  32 <sil=1.000> ,COMMA  72 <sil=1.000> ,COMMA  31 <sil=2.000> .PERIOD  Now <sil=0.000> I remember <sil=0.000> this <sil=0.000> position <sil=1.000> ,COMMA  and <sil=0.000> search <sil=0.000> from <sil=0.000> here <sil=0.000> and <sil=0.000> find <sil=0.000> out <sil=0.000> the
minimum <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> 31 <sil=0.000> comes <sil=0.000> I swap <sil=0.000> it <sil=0.000> here <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  what <sil=0.000> happens <sil=0.000> to <sil=0.000> my <sil=0.000> array <sil=0.228> ?QUESTIONMARK  This <sil=0.000> part <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> see <sil=0.000> what <sil=0.000> it <sil=0.000> will <sil=0.000> happen <sil=2.000> .PERIOD  It <sil=0.000> will <sil=0.000> now
become <sil=0.000> from <sil=0.000> here <sil=0.000> it <sil=0.000> was <sil=0.000> 30 <sil=0.000> it <sil=0.000> will <sil=0.000> be <sil=0.000> 31 <sil=1.000> ,COMMA  32 <sil=1.000> ,COMMA  72 <sil=1.000> ,COMMA  50 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  up <sil=0.000> to <sil=0.000> this <sil=0.000> part <sil=0.000> it <sil=0.000> is <sil=0.000> sorted <sil=0.000> now <sil=2.000> .PERIOD 
Now <sil=0.000> form <sil=0.000> here <sil=0.000> I will <sil=0.000> try <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> minimum <sil=0.000> element <sil=2.000> .PERIOD  I <sil=0.000> find <sil=0.000> this <sil=0.000> is <sil=0.000> the <sil=0.000> minimum
element <sil=2.000> .PERIOD  And <sil=0.000> I sort <sil=0.000> out <sil=0.000> the <sil=0.000> minimum <sil=0.000> element <sil=2.000> .PERIOD  I <sil=0.000> swap <sil=0.000> this <sil=0.000> minimum <sil=0.000> element <sil=0.000> with <sil=0.000> itself <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  up <sil=0.000> to <sil=0.000> this <sil=0.000> is <sil=0.000> sorted <sil=2.000> .PERIOD  Out <sil=0.000> of <sil=0.000> these <sil=0.000> now <sil=0.000> I have <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> candidate <sil=0.000> for <sil=0.000> this <sil=0.000> position <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> minimum <sil=0.000> I come <sil=0.000> here <sil=0.000> and <sil=0.000> swap <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> becomes <sil=0.000> 50 <sil=1.000> ,COMMA  72 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> in
this <sil=0.000> selection <sil=0.000> sort <sil=0.000> the <sil=0.000> approach <sil=0.000> is <sil=0.000> that <sil=0.000> we <sil=0.000> have <sil=0.000> to <sil=0.000> we <sil=0.000> have <sil=0.000> to <sil=0.000> we <sil=0.000> are <sil=0.000> going <sil=0.000> position <sil=0.000> by
position <sil=2.000> .PERIOD  And <sil=0.000> I am <sil=0.000> selecting <sil=0.000> the <sil=0.000> element <sil=0.000> that <sil=0.000> belongs <sil=0.000> to <sil=0.000> that <sil=0.000> particular <sil=0.000> position <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
whenever <sil=0.000> am <sil=0.000> starting <sil=0.000> with <sil=0.000> the <sil=0.000> search <sil=0.000> then <sil=0.000> at <sil=0.000> the <sil=0.000> beginning <sil=0.000> I am <sil=0.000> having <sil=0.000> am <sil=0.000> starting <sil=0.000> with
the <sil=0.000> if <sil=0.000> this <sil=0.000> be <sil=0.000> my <sil=0.000> array <sil=2.000> .PERIOD 

Then <sil=0.000> am <sil=0.000> first <sil=0.000> searching <sil=0.000> for <sil=0.000> this <sil=0.000> position <sil=2.000> .PERIOD  And <sil=0.000> this <sil=0.000> position <sil=0.000> will <sil=0.000> have <sil=0.000> will <sil=0.000> be <sil=0.000> the
minimum <sil=0.000> of <sil=0.000> all <sil=0.000> these <sil=2.000> .PERIOD  I <sil=0.000> search <sil=0.000> all <sil=0.000> through <sil=0.000> here <sil=1.000> ,COMMA  and <sil=0.000> find <sil=0.000> the <sil=0.000> minimum <sil=0.000> suppose <sil=0.000> the
minimum <sil=0.000> must <sil=0.000> 10 <sil=0.000> was <sil=0.000> here <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> take <sil=0.000> and <sil=0.000> bring <sil=0.000> this <sil=0.000> minus <sil=0.000> 10 <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> becomes <sil=0.000> minus <sil=0.000> 10 <sil=0.000> I know <sil=0.000> this <sil=0.000> is <sil=0.000> the
minimum <sil=2.000> .PERIOD  Now <sil=0.000> am <sil=0.000> sorting <sil=0.000> am <sil=0.000> now <sil=0.000> looking <sil=0.000> for <sil=0.000> this <sil=0.000> position <sil=2.000> .PERIOD  I <sil=0.000> select <sil=0.000> the <sil=0.000> element <sil=1.000> ,COMMA 
minimum <sil=0.000> element <sil=0.000> in <sil=0.000> this <sil=0.000> zone <sil=2.000> .PERIOD  I <sil=0.000> find <sil=0.000> here <sil=0.000> something <sil=0.000> 10 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> part <sil=0.000> is <sil=0.000> done <sil=2.000> .PERIOD  So <sil=0.000> now <sil=1.000> ,COMMA 
10 <sil=0.000> is <sil=0.000> swapped <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  10 <sil=1.000> ,COMMA  10 <sil=0.000> and <sil=0.000> then <sil=0.000> this <sil=0.000> part <sil=0.000> is <sil=0.000> unsorted <sil=2.000> .PERIOD  This <sil=0.000> part <sil=0.000> I will <sil=0.000> sort <sil=2.000> .PERIOD  In <sil=0.000> this
we <sil=0.000> way <sil=0.000> we <sil=0.000> go <sil=0.000> on <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> one <sil=0.000> of <sil=0.000> the <sil=0.000> sorting <sil=0.000> approaches <sil=2.000> .PERIOD  We <sil=0.000> will <sil=0.000> deal <sil=0.000> with <sil=0.000> it <sil=0.000> further <sil=0.000> in
the <sil=0.000> next <sil=0.000> lecture <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  we <sil=0.000> were <sil=0.000> discussing <sil=0.000> about <sil=0.000> sorting <sil=2.000> .PERIOD  And <sil=0.000> in <sil=0.000> particular <sil=0.000> we <sil=0.000> were <sil=0.000> discussing <sil=0.000> about <sil=1.000> ,COMMA  one
sorting <sil=0.000> technique <sil=0.000> which <sil=0.000> is <sil=0.000> a selection <sil=0.000> sort <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  in <sil=0.000> selection <sil=0.000> sort <sil=0.000> what <sil=0.000> do <sil=0.000> we <sil=0.000> do <sil=0.000> we <sil=0.000> have
got <sil=0.000> an <sil=0.000> array <sil=2.000> .PERIOD 

And <sil=0.000> of <sil=0.000> size <sil=1.000> ,COMMA  so <sil=1.000> ,COMMA  that <sil=0.000> means <sil=1.000> ,COMMA  the <sil=0.000> index <sil=0.000> is <sil=0.000> 0 to <sil=0.000> size <sil=0.000> minus <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> we <sil=0.000> do <sil=0.228> ?QUESTIONMARK  We <sil=0.000> some
parts <sil=0.000> we <sil=0.000> assume <sil=0.000> that <sil=0.000> some <sil=0.000> parts <sil=0.000> are <sil=0.000> sorted <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  first <sil=0.000> thing <sil=0.000> that <sil=0.000> we <sil=0.000> do <sil=0.000> is <sil=0.000> find <sil=0.000> the <sil=0.000> smallest
element <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> from <sil=0.000> 0 to <sil=0.000> k is <sil=0.000> sorted <sil=0.000> already <sil=0.000> in <sil=0.000> the <sil=0.000> order <sil=2.000> .PERIOD  Then <sil=0.000> my <sil=0.000> job <sil=0.000> is <sil=0.000> to <sil=0.000> sort <sil=0.000> from <sil=0.000> k to
size <sil=0.000> minus <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> we <sil=0.000> do <sil=0.000> the <sil=0.000> step <sil=0.000> is <sil=1.000> ,COMMA  that <sil=0.000> we <sil=0.000> find <sil=0.000> the <sil=0.000> smallest <sil=0.000> element <sil=0.000> minimum
value <sil=0.000> in <sil=0.000> the <sil=0.000> list <sil=0.000> x from <sil=0.000> k to <sil=0.000> size <sil=0.000> minus <sil=0.000> 1 <sil=1.000> ,COMMA  all <sil=0.000> right <sil=2.000> .PERIOD  I <sil=0.000> find <sil=0.000> the <sil=0.000> minimum <sil=0.000> value <sil=1.000> ,COMMA  and <sil=0.000> then
swap <sil=0.000> the <sil=0.000> that <sil=0.000> minimum <sil=0.000> value <sil=0.000> with <sil=0.000> the <sil=0.000> k th <sil=0.000> position <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  this <sil=0.000> position <sil=1.000> ,COMMA  with <sil=0.000> this
position <sil=0.000> I carry <sil=0.000> out <sil=0.000> here <sil=0.000> in <sil=0.000> this <sil=0.000> position <sil=0.000> I bring <sil=0.000> the <sil=0.000> minimum <sil=0.000> value <sil=2.000> .PERIOD  And <sil=0.000> these <sil=0.000> goes <sil=0.000> on
and <sil=0.000> then <sil=0.000> increase <sil=0.000> k <sil=1.000> ,COMMA  k <sil=0.000> will <sil=0.000> be <sil=0.000> increased <sil=0.000> to <sil=0.000> the <sil=0.000> next <sil=0.000> position <sil=2.000> .PERIOD  And <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> be <sil=0.000> go
going <sil=0.000> on <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  the <sil=0.000> sub <sil=0.000> problem <sil=0.000> is <sil=0.000> the <sil=0.000> sub <sil=0.000> problem <sil=0.000> is <sil=0.000> to <sil=0.000> find <sil=0.000> the <sil=0.000> minimum <sil=0.000> element <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> I go <sil=0.000> here
as <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=0.000> in <sil=0.000> the <sil=1.000> ,COMMA  I <sil=0.000> mean <sil=0.000> in <sil=0.000> this <sil=0.000> array <sil=1.000> ,COMMA  my <sil=0.000> task <sil=0.000> is <sil=0.000> to <sil=0.000> find <sil=0.000> the <sil=0.000> minimum <sil=0.000> position <sil=0.000> ok <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  where <sil=0.000> is <sil=0.000> say <sil=0.000> this <sil=0.000> part <sil=1.000> ,COMMA  this <sil=0.000> part <sil=0.000> is <sil=0.000> already <sil=0.000> sorted <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> sitting <sil=0.000> here <sil=1.000> ,COMMA  and <sil=0.000> this <sil=0.000> is <sil=0.000> my <sil=0.000> k th
position <sil=1.000> ,COMMA  right <sil=2.000> .PERIOD  This <sil=0.000> my <sil=0.000> k th <sil=0.000> position <sil=1.000> ,COMMA  and <sil=0.000> I want <sil=0.000> to <sil=0.000> find <sil=0.000> the <sil=0.000> minimum <sil=0.000> where <sil=0.000> is <sil=0.000> the
minimum <sil=0.000> value <sil=0.000> ok <sil=2.000> .PERIOD  Where <sil=0.000> is <sil=0.000> the <sil=0.000> m value <sil=1.000> ,COMMA  minimum <sil=0.000> value <sil=0.000> where <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  for <sil=0.000> that <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> the
function <sil=0.000> to <sil=0.000> find <sil=0.000> the <sil=0.000> minimum <sil=0.000> location <sil=0.000> in <sil=0.000> the <sil=0.000> array <sil=0.000> x <sil=1.000> ,COMMA  and <sil=0.000> starting <sil=0.000> from <sil=0.000> this <sil=0.000> location <sil=0.000> k <sil=1.000> ,COMMA  up
to <sil=0.000> the <sil=0.000> loc <sil=0.000> up <sil=0.000> to <sil=0.000> the <sil=0.000> location <sil=0.000> size <sil=0.000> minus <sil=0.000> 1 <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> need <sil=0.000> to <sil=0.000> needs <sil=0.000> know <sil=0.000> size <sil=1.000> ,COMMA  I <sil=0.000> need <sil=0.000> to <sil=0.000> need <sil=0.000> need <sil=0.000> to <sil=0.000> know <sil=0.000> k <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> how <sil=0.000> we <sil=0.000> are <sil=0.000> giving
the <sil=0.000> parameters <sil=1.000> ,COMMA  as <sil=0.000> we <sil=0.000> had <sil=0.000> explained <sil=0.000> in <sil=0.000> functions <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  at <sil=0.000> every <sil=0.000> point <sil=1.000> ,COMMA  you <sil=0.000> look <sil=0.000> at <sil=0.000> how <sil=0.000> the
functions <sil=0.000> are <sil=0.000> written <sil=0.000> that <sil=0.000> will <sil=0.000> help <sil=0.000> you <sil=0.000> revising <sil=0.000> this <sil=0.000> ok <sil=2.000> .PERIOD  Now <sil=0.000> the <sil=0.000> body <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=1.000> ,COMMA  x
pos <sil=0.000> will <sil=0.000> be <sil=0.000> the <sil=0.000> smallest <sil=0.000> element <sil=0.000> found <sil=0.000> so <sil=0.000> far <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  initially <sil=0.000> I am <sil=0.000> making <sil=0.000> pos <sil=0.000> to <sil=0.000> be <sil=0.000> k <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  x <sil=0.000> pos <sil=0.000> is <sil=0.000> this <sil=0.000> point <sil=1.000> ,COMMA  now <sil=0.000> from <sil=0.000> k plus <sil=0.000> 1 to <sil=0.000> up <sil=0.000> to <sil=0.000> size <sil=0.000> I go <sil=0.000> on <sil=0.000> checking <sil=1.000> ,COMMA  whether <sil=0.000> this <sil=0.000> x j
this <sil=0.000> position <sil=0.000> is <sil=0.000> less <sil=0.000> than <sil=0.000> this <sil=0.000> position <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> find <sil=0.000> out <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=1.000> ,COMMA  here <sil=0.000> I find <sil=0.000> the <sil=0.000> minimum
right <sil=1.000> ,COMMA  just <sil=0.000> see <sil=0.000> if <sil=0.000> you <sil=0.000> can <sil=0.000> understand <sil=0.000> the <sil=0.000> code <sil=2.000> .PERIOD  And <sil=0.000> find <sil=0.000> the <sil=0.000> minimum <sil=0.000> in <sil=0.000> between <sil=0.000> k plus <sil=0.000> 1
to <sil=0.000> size <sil=0.000> minus <sil=0.000> 1 <sil=2.000> .PERIOD  In <sil=0.000> between <sil=0.000> this <sil=0.000> am <sil=0.000> trying <sil=0.000> to <sil=0.000> find <sil=0.000> the <sil=0.000> minimum <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  whenever <sil=0.000> I get <sil=0.000> the
minimum <sil=0.000> am <sil=0.000> I will <sil=0.000> be <sil=0.000> returning <sil=0.000> that <sil=0.000> particular <sil=0.000> position <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> the <sil=0.000> position <sil=0.000> that <sil=0.000> I will
be <sil=0.000> returning <sil=0.000> this <sil=0.000> position <sil=0.000> ok <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> would <sil=0.000> be <sil=0.000> my <sil=0.000> full <sil=0.000> algorithm <sil=0.000> therefore <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  I <sil=0.000> have
got <sil=0.000> a function <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> this <sil=0.000> function <sil=1.000> ,COMMA  min <sil=0.000> loc <sil=1.000> ,COMMA  which <sil=0.000> will <sil=0.000> return <sil=0.000> with <sil=0.000> the <sil=0.000> minimum
location <sil=2.000> .PERIOD 

Now <sil=0.000> so <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> yield <sil=0.000> with <sil=0.000> the <sil=0.000> location <sil=0.000> of <sil=0.000> the <sil=0.000> smallest <sil=0.000> element <sil=2.000> .PERIOD 

So <sil=0.000> now <sil=0.000> you <sil=0.000> see <sil=0.000> a selection <sil=0.000> sort <sil=1.000> ,COMMA  main <sil=0.000> sorting <sil=0.000> function <sil=0.000> will <sil=0.000> be <sil=0.000> this <sil=2.000> .PERIOD  It <sil=0.000> takes <sil=0.000> the <sil=0.000> array <sil=0.000> and
the <sil=0.000> size <sil=0.000> ok <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> my <sil=0.000> array <sil=0.000> x <sil=1.000> ,COMMA  and <sil=0.000> this <sil=0.000> is <sil=0.000> the <sil=0.000> size <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> have <sil=0.000> to <sil=0.000> work <sil=0.000> between <sil=0.000> 0 to <sil=0.000> size
minus <sil=0.000> 1 <sil=2.000> .PERIOD  I <sil=0.000> have <sil=0.000> got <sil=0.000> 2 intermediate <sil=0.000> variables <sil=0.000> k and <sil=0.000> m <sil=2.000> .PERIOD  For <sil=0.000> k equal <sil=0.000> to <sil=0.000> 0 to <sil=0.000> k size <sil=0.000> minus <sil=0.000> 1 <sil=1.000> ,COMMA 
what <sil=0.000> am <sil=0.000> I doing <sil=0.228> ?QUESTIONMARK  First <sil=0.000> am <sil=0.000> starting <sil=0.000> with <sil=0.000> this <sil=1.000> ,COMMA  this <sil=0.000> element <sil=0.354> ;SEMICOLON  that <sil=0.000> is <sil=0.000> k equal <sil=0.000> to <sil=0.000> 0 <sil=2.000> .PERIOD  And <sil=0.000> what
am <sil=0.000> I doing <sil=0.228> ?QUESTIONMARK  I <sil=0.000> am <sil=0.000> finding <sil=0.000> out <sil=0.000> from <sil=0.000> k in <sil=0.000> the <sil=0.000> array <sil=0.000> x up <sil=0.000> to <sil=0.000> size <sil=0.000> I am <sil=0.000> finding <sil=0.000> the <sil=0.000> minimum

location <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  suppose <sil=0.000> here <sil=0.000> is <sil=0.000> the <sil=0.000> minimum <sil=2.000> .PERIOD  Then <sil=0.000> I am <sil=0.000> what <sil=0.000> am <sil=0.000> I doing <sil=0.000> here <sil=0.228> ?QUESTIONMARK  Temp <sil=0.000> is
going <sil=0.000> to <sil=0.000> ak <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> k is <sil=0.000> going <sil=0.000> to <sil=0.000> temp <sil=2.000> .PERIOD  And <sil=0.000> this <sil=0.000> ak <sil=0.000> is <sil=0.000> being <sil=0.000> returned <sil=0.000> by <sil=0.000> am <sil=0.000> this <sil=0.000> is <sil=0.000> the
minimum <sil=0.000> is <sil=0.000> coming <sil=0.000> here <sil=1.000> ,COMMA  and <sil=0.000> then <sil=0.000> this <sil=0.000> temp <sil=0.000> is <sil=0.000> going <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> what <sil=0.000> am <sil=0.000> I doing <sil=0.000> is <sil=1.000> ,COMMA  I
am <sil=0.000> swapping <sil=0.000> x my <sil=0.000> array <sil=0.000> was <sil=0.000> internally <sil=0.000> I called <sil=0.000> the <sil=0.000> here <sil=0.000> there <sil=0.000> is <sil=0.000> a small <sil=0.000> mistake <sil=0.000> I can
find <sil=2.000> .PERIOD  It <sil=0.000> should <sil=0.000> be <sil=0.000> xk <sil=1.000> ,COMMA  all <sil=0.000> this <sil=0.000> should <sil=0.000> be <sil=0.000> x <sil=1.000> ,COMMA  all <sil=0.000> right <sil=0.000> because <sil=0.000> I am <sil=0.000> dealing <sil=0.000> with <sil=0.000> x <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  xk <sil=0.000> will <sil=0.000> get <sil=0.000> x minimum <sil=0.000> m because <sil=0.000> and <sil=0.000> vice <sil=0.000> versa <sil=0.000> and <sil=0.000> this <sil=0.000> y <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> happening
here <sil=0.000> let <sil=0.000> us <sil=0.000> see <sil=2.000> .PERIOD 

Suppose <sil=0.000> my <sil=0.000> array <sil=0.000> was <sil=0.000> something <sil=0.000> like <sil=0.000> this <sil=0.000> 50 <sil=1.000> ,COMMA  20 <sil=1.000> ,COMMA  70 <sil=1.000> ,COMMA  10 <sil=1.000> ,COMMA  100 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> first <sil=0.000> this <sil=0.000> is <sil=0.000> my <sil=0.000> k
equal <sil=0.000> to <sil=0.000> 1 <sil=2.000> .PERIOD  I <sil=0.000> want <sil=0.000> to <sil=0.000> bring <sil=0.000> the <sil=0.000> minimum <sil=0.000> at <sil=0.000> this <sil=0.000> position <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> I do <sil=0.228> ?QUESTIONMARK  I <sil=0.000> from <sil=0.000> here <sil=0.000> I start
searching <sil=0.000> for <sil=0.000> the <sil=0.000> minimum <sil=2.000> .PERIOD  I <sil=0.000> find <sil=0.000> tenth <sil=0.000> with <sil=0.000> the <sil=0.000> minimum <sil=1.000> ,COMMA  then <sil=0.000> I swap <sil=0.000> here <sil=0.000> is <sil=0.000> this <sil=0.000> piece
of <sil=0.000> code <sil=1.000> ,COMMA  I <sil=0.000> swap <sil=0.000> I bring <sil=0.000> 10 <sil=0.000> here <sil=1.000> ,COMMA  and <sil=0.000> 20 <sil=1.000> ,COMMA  70 <sil=0.000> remains <sil=0.000> and <sil=0.000> 50 <sil=0.000> I take <sil=0.000> here <sil=2.000> .PERIOD  And <sil=0.000> then <sil=0.000> what <sil=0.000> do
I <sil=0.000> do <sil=0.228> ?QUESTIONMARK  K <sil=0.000> is <sil=0.000> incremented <sil=0.000> so <sil=0.000> now <sil=0.000> k is <sil=0.000> here <sil=2.000> .PERIOD  Now <sil=0.000> I find <sil=0.000> min <sil=0.000> loc <sil=0.000> if <sil=0.000> what <sil=0.000> is <sil=0.000> the <sil=0.000> minimum <sil=0.000> here
compared <sil=0.000> less <sil=0.000> than <sil=0.000> this <sil=0.000> or <sil=0.000> not <sil=0.000> there <sil=0.000> is <sil=0.000> none <sil=0.000> so <sil=1.000> ,COMMA  fine <sil=0.000> next <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  this <sil=0.000> remains <sil=0.000> next <sil=0.000> I increment <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> also <sil=0.000> in <sil=0.000> position <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> in <sil=0.000> position <sil=1.000> ,COMMA 
because <sil=0.000> it <sil=0.000> need <sil=0.000> not <sil=0.000> be <sil=0.000> exchanged <sil=0.000> next <sil=0.000> my <sil=0.000> k is <sil=0.000> increased <sil=0.000> here <sil=0.000> at <sil=0.000> this <sil=0.000> step <sil=1.000> ,COMMA  k <sil=0.000> plus <sil=0.000> plus <sil=0.000> it
has <sil=0.000> been <sil=0.000> increased <sil=0.000> here <sil=2.000> .PERIOD  I <sil=0.000> find <sil=0.000> the <sil=0.000> minimum <sil=0.000> in <sil=0.000> this <sil=0.000> area <sil=0.354> ;SEMICOLON  I <sil=0.000> find <sil=0.000> this <sil=0.000> to <sil=0.000> be <sil=0.000> the <sil=0.000> minimum <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> happening <sil=0.228> ?QUESTIONMARK  10 <sil=0.000> was <sil=0.000> in <sil=0.000> place <sil=1.000> ,COMMA  20 <sil=0.000> was <sil=0.000> in <sil=0.000> place <sil=1.000> ,COMMA  I <sil=0.000> swap <sil=0.000> 50 <sil=0.000> and <sil=0.000> 70 <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  50
comes <sil=0.000> here <sil=0.000> I find <sil=0.000> the <sil=0.000> minimum <sil=1.000> ,COMMA  70 <sil=0.000> remains <sil=0.000> here <sil=1.000> ,COMMA  100 <sil=0.000> remains <sil=0.000> here <sil=2.000> .PERIOD  Now <sil=0.000> I change <sil=0.000> my <sil=0.000> k

and <sil=0.000> see <sil=0.000> if <sil=0.000> there <sil=0.000> is <sil=0.000> any <sil=0.000> minimum <sil=0.000> left <sil=0.000> here <sil=0.000> at <sil=0.000> the <sil=0.000> min <sil=0.000> location <sil=0.000> is <sil=0.000> not <sil=0.000> returning <sil=0.000> me
anything <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  therefore <sil=1.000> ,COMMA  I <sil=0.000> get <sil=0.000> this <sil=0.000> to <sil=0.000> be <sil=0.000> my <sil=0.000> sorted <sil=0.000> array <sil=0.000> ok <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> what <sil=0.000> so <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> see <sil=0.000> that <sil=0.000> so <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=0.000> we <sil=0.000> can <sil=1.000> ,COMMA  sorry <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> an <sil=0.000> example <sil=0.000> you
see <sil=0.000> here <sil=2.000> .PERIOD 

The <sil=0.000> example <sil=0.000> you <sil=0.000> see <sil=0.000> here <sil=1.000> ,COMMA  I <sil=0.000> start <sil=0.000> with <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  3 <sil=0.000> is <sil=0.000> the <sil=0.000> minimum <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> see <sil=0.000> here <sil=0.000> 12
minus <sil=0.000> 5 6 <sil=0.000> etcetera <sil=0.000> I can <sil=0.000> see <sil=1.000> ,COMMA  minus <sil=0.000> 17 <sil=0.000> is <sil=0.000> the <sil=0.000> minimum <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> find <sil=0.000> out <sil=0.000> minus <sil=0.000> 17 <sil=0.000> here <sil=0.000> I
swap <sil=0.000> that <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  minus <sil=0.000> 17 <sil=0.000> comes <sil=0.000> here <sil=1.000> ,COMMA  and <sil=0.000> 3 goes <sil=0.000> to <sil=0.000> the <sil=0.000> place <sil=0.000> of <sil=0.000> minus <sil=0.000> 17 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  these <sil=0.000> 2
now <sil=0.000> 12 <sil=1.000> ,COMMA  12 <sil=0.000> and <sil=0.000> I find <sil=0.000> the <sil=0.000> minimum <sil=0.000> from <sil=0.000> 12 <sil=0.000> onwards <sil=1.000> ,COMMA  I <sil=0.000> find <sil=0.000> minus <sil=0.000> 5 to <sil=0.000> be <sil=0.000> the <sil=0.000> minimum <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  that <sil=0.000> one <sil=0.000> will <sil=0.000> come <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  minus <sil=0.000> 5 comes <sil=0.000> here <sil=1.000> ,COMMA  and <sil=0.000> 12 <sil=0.000> is <sil=0.000> swapped <sil=0.000> there <sil=2.000> .PERIOD  Now
within <sil=0.000> this <sil=0.000> part <sil=0.000> I find <sil=0.000> the <sil=0.000> minimum <sil=1.000> ,COMMA  minimum <sil=0.000> is <sil=0.000> 3 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  3 <sil=0.000> will <sil=0.000> be <sil=0.000> swapped <sil=0.000> with <sil=0.000> 12 <sil=1.000> ,COMMA  and
12 <sil=0.000> goes <sil=0.000> there <sil=0.000> in <sil=0.000> the <sil=0.000> place <sil=0.000> of <sil=0.000> 3 you <sil=0.000> see <sil=2.000> .PERIOD  Now <sil=0.000> so <sil=1.000> ,COMMA  I <sil=0.000> start <sil=0.000> with <sil=0.000> 6 <sil=1.000> ,COMMA  I <sil=0.000> start <sil=0.000> finding <sil=0.000> the
minimum <sil=2.000> .PERIOD  6 <sil=0.000> is <sil=0.000> the <sil=0.000> minimum <sil=0.000> fine <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> remains <sil=0.000> I increase <sil=0.000> k <sil=2.000> .PERIOD  So <sil=0.000> now <sil=1.000> ,COMMA  142 <sil=1.000> ,COMMA  in <sil=0.000> this <sil=0.000> way <sil=1.000> ,COMMA  I
go <sil=0.000> on <sil=0.000> from <sil=0.000> here <sil=1.000> ,COMMA  who <sil=0.000> is <sil=0.000> the <sil=0.000> minimum <sil=0.000> for <sil=0.000> starting <sil=0.000> from <sil=0.000> 142 <sil=0.228> ?QUESTIONMARK  12 <sil=0.000> is <sil=0.000> the <sil=0.000> minimum <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  12 <sil=0.000> and <sil=0.000> 142 <sil=0.000> will <sil=0.000> swapped <sil=0.000> 12 <sil=1.000> ,COMMA  and <sil=0.000> 142 <sil=0.000> has <sil=0.000> been <sil=0.000> swapped <sil=2.000> .PERIOD  Next <sil=0.000> 21 <sil=1.000> ,COMMA  21 <sil=0.000> within <sil=0.000> this <sil=0.000> 21 <sil=1.000> ,COMMA 
142 <sil=1.000> ,COMMA  45 <sil=1.000> ,COMMA  21 <sil=0.000> is <sil=0.000> the <sil=0.000> minimum <sil=2.000> .PERIOD  Therefore <sil=1.000> ,COMMA  I <sil=0.000> keep <sil=0.000> it <sil=0.000> in <sil=0.000> place <sil=2.000> .PERIOD  Next <sil=0.000> is <sil=0.000> I take <sil=0.000> 142 <sil=0.000> and <sil=0.000> 45 <sil=1.000> ,COMMA  I
find <sil=0.000> that <sil=0.000> 45 <sil=0.000> is <sil=0.000> minimum <sil=0.000> I swap <sil=0.000> that <sil=1.000> ,COMMA  and <sil=0.000> 142 <sil=0.000> goes <sil=0.000> there <sil=2.000> .PERIOD  Next <sil=0.000> is <sil=0.000> 142 <sil=0.000> is <sil=0.000> the <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> the
sorted <sil=0.000> array <sil=0.000> that <sil=0.000> we <sil=0.000> get <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> what <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> selection <sil=0.000> sort <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> philosophy <sil=0.000> of
selection <sil=0.000> sort <sil=0.000> is <sil=1.000> ,COMMA  that <sil=0.000> am <sil=0.000> selecting <sil=0.000> the <sil=0.000> minimum <sil=0.000> element <sil=0.000> among <sil=0.000> the <sil=0.000> unsorted <sil=0.000> elements

and <sil=0.000> placing <sil=0.000> it <sil=0.000> in <sil=0.000> the <sil=0.000> position <sil=0.000> proper <sil=0.000> position <sil=0.000> where <sil=0.000> that <sil=0.000> minimum <sil=0.000> element <sil=0.000> should <sil=0.000> be <sil=0.354> ;SEMICOLON 
that <sil=0.000> is <sil=0.000> why <sil=0.000> we <sil=0.000> are <sil=0.000> selecting <sil=0.000> and <sil=0.000> putting <sil=0.000> it <sil=0.000> so <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> why <sil=0.000> it <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> selection <sil=0.000> sort <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  how <sil=0.000> many <sil=0.000> steps <sil=0.000> are <sil=0.000> needed <sil=0.000> to <sil=0.000> sort <sil=0.000> n things <sil=0.000> here <sil=0.228> ?QUESTIONMARK  If <sil=0.000> I do <sil=0.000> this <sil=1.000> ,COMMA  how <sil=0.000> many <sil=0.000> steps <sil=0.000> am <sil=0.000> I
taking <sil=2.000> .PERIOD  You <sil=0.000> see <sil=1.000> ,COMMA  how <sil=0.000> many <sil=0.000> steps <sil=0.000> am <sil=0.000> I taking <sil=0.228> ?QUESTIONMARK  All <sil=0.000> through <sil=0.000> here <sil=0.000> if <sil=0.000> you <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=1.000> ,COMMA  how
many <sil=0.000> steps <sil=0.000> am <sil=0.000> I taking <sil=0.228> ?QUESTIONMARK  If <sil=0.000> the <sil=0.000> list <sil=0.000> size <sil=0.000> of <sil=0.000> the <sil=0.000> list <sil=0.000> was <sil=0.000> n then <sil=0.000> the <sil=0.000> total <sil=0.000> number <sil=0.000> of <sil=0.000> steps
that <sil=0.000> are <sil=0.000> required <sil=0.000> is <sil=0.000> proportional <sil=0.000> to <sil=0.000> n square <sil=1.000> ,COMMA  because <sil=0.000> for <sil=0.000> every <sil=0.000> element <sil=0.000> why <sil=0.000> it <sil=0.000> is <sil=0.000> why <sil=0.000> it <sil=0.000> is
so <sil=0.228> ?QUESTIONMARK  Let <sil=0.000> us <sil=0.000> try <sil=0.000> to <sil=0.000> understand <sil=0.000> this <sil=2.000> .PERIOD 
The <sil=0.000> reason <sil=0.000> is <sil=0.000> that <sil=0.000> for <sil=0.000> every <sil=0.000> position <sil=1.000> ,COMMA  how <sil=0.000> many <sil=0.000> positions <sil=0.000> are <sil=0.000> there <sil=0.228> ?QUESTIONMARK  1 <sil=0.000> 2 3 <sil=0.000> like <sil=0.000> that <sil=1.000> ,COMMA  there
are <sil=0.000> n positions <sil=2.000> .PERIOD  Now <sil=0.000> for <sil=0.000> every <sil=0.000> position <sil=1.000> ,COMMA  for <sil=0.000> this <sil=0.000> position <sil=1.000> ,COMMA  how <sil=0.000> many <sil=0.000> comparisons <sil=0.000> I need
to <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> minimum <sil=0.228> ?QUESTIONMARK  N <sil=0.000> minus <sil=0.000> 1 comparisons <sil=0.000> n comparisons <sil=0.000> for <sil=0.000> all <sil=0.000> these <sil=1.000> ,COMMA  next <sil=0.000> I
increment <sil=0.000> it <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  how <sil=0.000> many <sil=0.000> do <sil=0.000> I need <sil=0.228> ?QUESTIONMARK  I <sil=0.000> need <sil=0.000> for <sil=0.000> each <sil=0.000> of <sil=0.000> these <sil=0.000> for <sil=0.000> n <sil=1.000> ,COMMA  for <sil=0.000> n such
elements <sil=0.000> for <sil=0.000> each <sil=0.000> of <sil=0.000> them <sil=0.000> I need <sil=0.000> n comparisons <sil=0.000> then <sil=0.000> n plus <sil=0.000> for <sil=0.000> this <sil=0.000> I need <sil=0.000> n minus <sil=0.000> 1
comparisons <sil=1.000> ,COMMA  then <sil=0.000> I need <sil=0.000> n minus <sil=0.000> 2 comparisons <sil=1.000> ,COMMA  then <sil=0.000> I need <sil=0.000> n minus <sil=0.000> 3 comparisons <sil=0.000> in
this <sil=0.000> way <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  for <sil=0.000> this <sil=0.000> n 1 <sil=0.000> 2 3 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  n <sil=0.000> minus <sil=0.000> 4 comparisons <sil=0.000> I need <sil=0.000> in <sil=0.000> this <sil=0.000> part <sil=1.000> ,COMMA  I
have <sil=0.000> to <sil=0.000> compare <sil=0.000> between <sil=0.000> these <sil=0.000> things <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> way <sil=0.000> I go <sil=0.000> on <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  for <sil=0.000> every <sil=0.000> so <sil=1.000> ,COMMA  for <sil=0.000> each
of <sil=0.000> them <sil=0.000> I need <sil=0.000> to <sil=0.000> compare <sil=0.000> this <sil=1.000> ,COMMA  right <sil=0.000> for <sil=0.000> n such <sil=0.000> things <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> to <sil=0.000> do <sil=0.000> this <sil=1.000> ,COMMA  n <sil=0.000> n plus <sil=0.000> m n
plus <sil=0.000> 1 n <sil=0.000> minus <sil=0.000> times <sil=0.000> n <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> will <sil=0.000> be <sil=0.000> the <sil=0.000> order <sil=0.000> of <sil=0.000> n square <sil=0.000> if <sil=0.000> I find <sil=0.000> the <sil=0.000> product <sil=1.000> ,COMMA  right <sil=2.000> .PERIOD 

And <sil=0.000> number <sil=0.000> of <sil=0.000> comparison <sil=0.000> total <sil=0.000> number <sil=0.000> of <sil=0.000> steps <sil=0.000> and <sil=0.000> number <sil=0.000> of <sil=0.000> comparisons <sil=0.000> is <sil=0.000> again <sil=1.000> ,COMMA  n
into <sil=0.000> n minus <sil=0.000> 1 by <sil=0.000> 2 like <sil=0.000> as <sil=0.000> I said <sil=0.000> n minus <sil=0.000> 1 comparisons <sil=0.000> plus <sil=0.000> n minus <sil=0.000> 2 comparisons <sil=1.000> ,COMMA 
last <sil=0.000> one <sil=0.000> is <sil=0.000> one <sil=0.000> comparison <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> you <sil=0.000> add <sil=0.000> this <sil=0.000> one <sil=0.000> to <sil=0.000> n minus <sil=0.000> 1 is <sil=0.000> n into <sil=0.000> n minus <sil=0.000> 1 by <sil=0.000> 2 <sil=1.000> ,COMMA 
you <sil=0.000> know <sil=0.000> that <sil=1.000> ,COMMA  and <sil=0.000> that <sil=0.000> is <sil=0.000> of <sil=0.000> the <sil=0.000> order <sil=0.000> of <sil=0.000> n square <sil=1.000> ,COMMA  if <sil=0.000> I break <sil=0.000> it <sil=0.000> up <sil=0.000> it <sil=0.000> will <sil=0.000> be <sil=0.000> n square
minus <sil=0.000> n by <sil=0.000> 2 <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> again <sil=0.000> of <sil=0.000> the <sil=0.000> order <sil=0.000> of <sil=0.000> n square <sil=0.000> of <sil=0.000> the <sil=0.000> order <sil=0.000> of <sil=0.000> we <sil=0.000> write <sil=0.000> it <sil=0.000> as <sil=0.000> of <sil=0.000> the <sil=0.000> order <sil=0.000> of <sil=0.000> n
square <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD 

Now <sil=0.000> next <sil=0.000> we <sil=0.000> come <sil=0.000> to <sil=0.000> another <sil=0.000> sorting <sil=0.000> algorithm <sil=1.000> ,COMMA  which <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> insertion <sil=0.000> sort <sil=2.000> .PERIOD  What
is <sil=0.000> the <sil=0.000> general <sil=0.000> situation <sil=0.228> ?QUESTIONMARK  Again <sil=1.000> ,COMMA  just <sil=0.000> like <sil=0.000> the <sil=0.000> selection <sil=0.000> sort <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> got <sil=0.000> the <sil=0.000> smallest
element <sil=0.000> sort <sil=0.354> ;SEMICOLON  it <sil=0.000> from <sil=0.000> 0 to <sil=0.000> this <sil=0.000> point <sil=0.000> is <sil=0.000> sorted <sil=2.000> .PERIOD  The <sil=0.000> remaining <sil=0.000> is <sil=0.000> unsorted <sil=1.000> ,COMMA  all <sil=0.000> right <sil=2.000> .PERIOD  Now
what <sil=0.000> we <sil=0.000> do <sil=0.000> is <sil=0.000> we <sil=0.000> compare <sil=0.000> and <sil=0.000> shift <sil=0.000> till <sil=0.000> xi <sil=0.000> is <sil=0.000> larger <sil=0.000> ok <sil=1.000> ,COMMA  I <sil=0.000> go <sil=0.000> on <sil=0.000> shifting <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  what <sil=0.000> I do <sil=0.000> is <sil=0.000> I start <sil=0.000> with <sil=0.000> this <sil=0.000> element <sil=1.000> ,COMMA  and <sil=0.000> I put <sil=0.000> this <sil=0.000> in <sil=0.000> the <sil=0.000> proper <sil=0.000> position <sil=1.000> ,COMMA  I <sil=0.000> insert <sil=0.000> this
in <sil=0.000> the <sil=0.000> proper <sil=0.000> position <sil=0.000> I <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> move <sil=0.000> this <sil=0.000> in <sil=0.000> this <sil=0.000> side <sil=0.000> or <sil=0.000> in <sil=0.000> this <sil=0.000> side <sil=1.000> ,COMMA  and <sil=0.000> I will <sil=0.000> come <sil=0.000> to <sil=0.000> the
proper <sil=0.000> position <sil=0.000> of <sil=0.000> this <sil=0.000> element <sil=1.000> ,COMMA  this <sil=0.000> element <sil=0.000> is <sil=0.000> being <sil=0.000> put <sil=0.000> since <sil=0.000> it <sil=0.000> is <sil=0.000> smaller <sil=0.000> the <sil=0.000> smallest
elements <sil=0.000> is <sil=0.000> sorted <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> taking <sil=0.000> this <sil=1.000> ,COMMA  and <sil=0.000> I am <sil=0.000> putting <sil=0.000> it <sil=0.000> in <sil=0.000> the <sil=0.000> place <sil=0.000> where <sil=0.000> it <sil=0.000> should
belong <sil=0.000> because <sil=0.000> I have <sil=0.000> not <sil=0.000> seen <sil=0.000> up <sil=0.000> to <sil=0.000> this <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  so <sil=1.000> ,COMMA  insert <sil=0.000> sort <sil=0.000> is <sil=0.000> something <sil=0.000> like <sil=0.000> this <sil=0.000> let <sil=0.000> us <sil=0.000> see <sil=0.000> if <sil=0.000> I can <sil=0.000> show <sil=0.000> you <sil=0.000> a example <sil=0.000> first <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  what <sil=0.000> am <sil=0.000> doing <sil=0.000> is <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> comparing <sil=0.000> and <sil=0.000> shifting <sil=1.000> ,COMMA  till <sil=0.000> xi <sil=0.000> is <sil=0.000> larger <sil=2.000> .PERIOD  I <sil=0.000> am <sil=0.000> continuously
shifting <sil=0.000> the <sil=0.000> elements <sil=1.000> ,COMMA  in <sil=0.000> this <sil=0.000> way <sil=0.000> I go <sil=0.000> on <sil=0.000> shifting <sil=0.000> this <sil=2.000> .PERIOD  Ultimately <sil=0.000> xi <sil=0.000> will <sil=0.000> be <sil=0.000> larger <sil=0.000> than
all <sil=0.000> these <sil=0.000> elements <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  therefore <sil=1.000> ,COMMA  my <sil=0.000> sorted <sil=0.000> position <sil=0.000> will <sil=0.000> be <sil=0.000> up <sil=0.000> to <sil=0.000> this <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> larger <sil=0.000> right <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> sorry <sil=1.000> ,COMMA  I <sil=0.000> just <sil=0.000> went <sil=0.000> the <sil=0.000> other <sil=0.000> side <sil=0.000> other <sil=0.000> way <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> study <sil=0.000> this <sil=0.000> algorithm <sil=2.000> .PERIOD  This
algorithm <sil=0.000> is <sil=0.000> void <sil=1.000> ,COMMA  why <sil=0.000> it <sil=0.000> is <sil=0.000> void <sil=0.228> ?QUESTIONMARK  Because <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> returning <sil=0.000> anything <sil=0.000> it <sil=0.000> is <sil=0.000> taking <sil=0.000> the
array <sil=0.000> and <sil=0.000> is <sil=0.000> sorting <sil=0.000> this <sil=0.000> is <sil=0.000> taking <sil=0.000> this <sil=0.000> array <sil=0.000> and <sil=0.000> this <sil=0.000> sorting <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> type <sil=0.000> is <sil=0.000> void <sil=0.000> it <sil=0.000> is
taking <sil=0.000> a list <sil=0.000> and <sil=0.000> it <sil=0.000> is <sil=0.000> size <sil=2.000> .PERIOD  Now <sil=0.000> for <sil=0.000> I equal <sil=0.000> to <sil=0.000> 1 to <sil=0.000> size <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> taking <sil=0.000> item <sil=0.000> to <sil=0.000> the <sil=0.000> list <sil=0.000> I <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I
have <sil=0.000> got <sil=0.000> elements <sil=0.000> like <sil=0.000> say <sil=0.000> 12 <sil=1.000> ,COMMA  7 <sil=1.000> ,COMMA  5 <sil=1.000> ,COMMA  17 <sil=1.000> ,COMMA  9 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  first <sil=0.000> I am <sil=0.000> taking <sil=0.000> I is <sil=0.000> one <sil=0.000> so <sil=1.000> ,COMMA  am <sil=0.000> taking <sil=0.000> this
element <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> the <sil=0.000> item <sil=2.000> .PERIOD  For <sil=0.000> js <sil=0.000> now <sil=0.000> I am <sil=0.000> looking <sil=0.000> at <sil=0.000> you <sil=0.000> see <sil=0.000> j equals <sil=0.000> I minus <sil=0.000> 1 <sil=1.000> ,COMMA  and <sil=0.000> j is

greater <sil=0.000> than <sil=0.000> 0 and <sil=0.000> list <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> not <sil=0.000> am <sil=0.000> I am <sil=0.000> not <sil=0.000> going <sil=0.000> into <sil=0.000> this <sil=0.000> side <sil=2.000> .PERIOD  I <sil=0.000> will <sil=0.000> have <sil=0.000> to <sil=0.000> go <sil=0.000> in
these <sil=0.000> direction <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> this <sil=0.000> mean <sil=0.228> ?QUESTIONMARK  I <sil=0.000> start <sil=0.000> with <sil=0.000> ji <sil=0.000> minus <sil=0.000> 1 <sil=1.000> ,COMMA  and <sil=0.000> go <sil=0.000> till <sil=0.000> j is <sil=0.000> greater <sil=0.000> than
equal <sil=0.000> to <sil=0.000> 0 <sil=1.000> ,COMMA  and <sil=0.000> the <sil=0.000> list <sil=0.000> is <sil=0.000> greater <sil=0.000> than <sil=0.000> I/ <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  all <sil=0.000> right <sil=0.000> so <sil=1.000> ,COMMA  my <sil=0.000> I is <sil=0.000> here <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> not <sil=0.000> I am <sil=0.000> going <sil=0.000> till <sil=0.000> the <sil=0.000> end <sil=0.000> of <sil=0.000> this <sil=0.000> array <sil=0.000> on
the <sil=0.000> other <sil=0.000> side <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> going <sil=0.000> on <sil=0.000> the <sil=0.000> other <sil=0.000> side <sil=2.000> .PERIOD  And <sil=0.000> I shift <sil=0.000> what <sil=0.000> was <sil=0.000> my <sil=0.000> j here <sil=1.000> ,COMMA  j <sil=0.000> plus <sil=0.000> 1 and
the <sil=0.000> list <sil=0.000> are <sil=0.000> being <sil=0.000> swapped <sil=2.000> .PERIOD  So <sil=0.000> now <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> become <sil=0.000> 7 <sil=1.000> ,COMMA  12 <sil=1.000> ,COMMA  5 <sil=1.000> ,COMMA  17 <sil=1.000> ,COMMA  9 <sil=2.000> .PERIOD  Now <sil=0.000> and <sil=0.000> then <sil=0.000> in <sil=0.000> that
way <sil=0.000> I go <sil=0.000> on <sil=0.000> shifting <sil=1.000> ,COMMA  all <sil=0.000> right <sil=2.000> .PERIOD  So <sil=0.000> now <sil=1.000> ,COMMA  if <sil=0.000> I come <sil=0.000> here <sil=1.000> ,COMMA  I <sil=0.000> increment <sil=0.000> I after <sil=0.000> one <sil=0.000> item <sil=0.000> so <sil=1.000> ,COMMA  I
will <sil=0.000> come <sil=0.000> 5 and <sil=0.000> 5 <sil=2.000> .PERIOD  I <sil=0.000> will <sil=0.000> go <sil=0.000> on <sil=0.000> checking <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> the <sil=0.000> proper <sil=0.000> place <sil=0.000> of <sil=0.000> 5 <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> 5
will <sil=0.000> be <sil=0.000> swapped <sil=0.000> with <sil=0.000> this <sil=0.000> 12 <sil=1.000> ,COMMA  7 <sil=1.000> ,COMMA  17 <sil=1.000> ,COMMA  9 <sil=2.000> .PERIOD  In <sil=0.000> that <sil=0.000> way <sil=0.000> I will <sil=0.000> try <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> every <sil=0.000> each <sil=0.000> of
these <sil=0.000> is <sil=0.000> for <sil=0.000> proper <sil=0.000> position <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> think <sil=0.000> we <sil=0.000> can <sil=0.000> go <sil=0.000> for <sil=0.000> a more <sil=0.000> popular <sil=0.000> sort <sil=2.000> .PERIOD 

Let <sil=0.000> us <sil=0.000> go <sil=0.000> to <sil=0.000> the <sil=0.000> more <sil=0.000> popular <sil=0.000> sort <sil=1.000> ,COMMA  I <sil=0.000> think <sil=0.000> that <sil=0.000> will <sil=0.000> be <sil=0.000> better <sil=0.000> selection <sil=0.000> sort <sil=0.000> you <sil=0.000> have
learnt <sil=0.000> insertion <sil=0.000> sort <sil=0.000> is <sil=0.000> another <sil=0.000> form <sil=2.000> .PERIOD  But <sil=0.000> let <sil=0.000> us <sil=0.000> learn <sil=0.000> the <sil=0.000> more <sil=0.000> popular <sil=0.000> one <sil=0.000> that <sil=0.000> is <sil=0.000> the
bubble <sil=0.000> sort <sil=2.000> .PERIOD  Bubble <sil=0.000> sort <sil=0.000> as <sil=0.000> the <sil=0.000> name <sil=0.000> implies <sil=2.000> .PERIOD  It <sil=0.000> starts <sil=0.000> from <sil=0.000> the <sil=0.000> bottom <sil=1.000> ,COMMA  and <sil=0.000> the <sil=0.000> minimum
element <sil=0.000> is <sil=0.000> pushed <sil=0.000> up <sil=0.000> to <sil=0.000> the <sil=1.000> ,COMMA  how <sil=0.000> is <sil=0.000> that <sil=0.000> done <sil=0.228> ?QUESTIONMARK  Just <sil=0.000> as <sil=0.000> a bubble <sil=0.000> floats <sil=0.000> up <sil=0.000> from <sil=0.000> the <sil=0.000> bottom
and <sil=0.000> goes <sil=0.000> to <sil=0.000> the <sil=0.000> top <sil=0.000> the <sil=0.000> minimum <sil=0.000> element <sil=0.000> should <sil=0.000> be <sil=0.000> pushed <sil=0.000> up <sil=0.000> the <sil=0.000> minimum <sil=0.000> element
should <sil=0.000> be <sil=0.000> pushed <sil=0.000> up <sil=0.000> to <sil=0.000> the <sil=0.000> top <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> see <sil=0.000> how <sil=0.000> it <sil=0.000> happens <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> first <sil=0.000> compare <sil=0.000> between <sil=0.000> these <sil=0.000> 2 elements <sil=1.000> ,COMMA  then <sil=0.000> these <sil=0.000> 2
elements <sil=1.000> ,COMMA  and <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=1.000> ,COMMA  I <sil=0.000> go <sil=0.000> on <sil=0.000> comparing <sil=0.000> between <sil=0.000> each <sil=0.000> of <sil=0.000> them <sil=0.000> and <sil=0.000> push <sil=0.000> it <sil=0.000> up <sil=0.000> ok <sil=2.000> .PERIOD  in
every <sil=0.000> iteration <sil=1.000> ,COMMA  the <sil=0.000> heaviest <sil=0.000> element <sil=0.000> drops <sil=0.000> at <sil=0.000> the <sil=0.000> bottom <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> happening <sil=0.000> is <sil=0.000> so <sil=1.000> ,COMMA  if <sil=0.000> I

go <sil=0.000> here <sil=0.000> from <sil=0.000> the <sil=0.000> top <sil=1.000> ,COMMA  I <sil=0.000> try <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> if <sil=0.000> this <sil=0.000> element <sil=1.000> ,COMMA  if <sil=0.000> this <sil=0.000> particular <sil=0.000> element <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> sorry
this <sil=0.000> particular <sil=0.000> element <sil=0.000> is <sil=0.000> heavier <sil=0.000> than <sil=0.000> this <sil=0.000> particular <sil=0.000> element <sil=2.000> .PERIOD  Then <sil=0.000> this <sil=0.000> particular
element <sil=0.000> should <sil=0.000> go <sil=0.000> at <sil=0.000> the <sil=0.000> top <sil=0.000> and <sil=0.000> this <sil=0.000> should <sil=0.000> come <sil=0.000> down <sil=0.000> here <sil=1.000> ,COMMA  all <sil=0.000> right <sil=0.228> ?QUESTIONMARK  Next <sil=1.000> ,COMMA  I <sil=0.000> compare
sorry <sil=1.000> ,COMMA  next <sil=0.000> I compare <sil=0.000> what <sil=0.000> is <sil=0.000> happening <sil=0.228> ?QUESTIONMARK  Next <sil=1.000> ,COMMA  I <sil=0.000> compare <sil=0.000> between <sil=0.000> this <sil=0.000> so <sil=1.000> ,COMMA  this <sil=0.000> was
shows <sil=0.000> the <sil=0.000> heavy <sil=0.000> element <sil=2.000> .PERIOD  And <sil=0.000> I find <sil=0.000> that <sil=0.000> this <sil=0.000> is <sil=0.000> not <sil=0.000> an <sil=0.000> heavy <sil=0.000> element <sil=2.000> .PERIOD  It <sil=0.000> is <sil=0.000> this <sil=0.000> heavier
than <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> may <sil=0.000> be <sil=0.000> more <sil=0.000> heavier <sil=0.000> if <sil=0.000> much <sil=0.000> heavier <sil=0.000> than <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> not <sil=0.000> pushed
out <sil=0.000> ok <sil=1.000> ,COMMA  remains <sil=2.000> .PERIOD  Now <sil=0.000> next <sil=0.000> I compare <sil=0.000> between <sil=0.000> this <sil=1.000> ,COMMA  and <sil=0.000> every <sil=0.000> time <sil=0.000> I am <sil=0.000> making <sil=0.000> the <sil=0.000> same
mistake <sil=0.000> may <sil=0.000> be <sil=0.000> this <sil=0.000> is <sil=0.000> the <sil=0.000> heavier <sil=1.000> ,COMMA  lighter <sil=0.000> element <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> lighter <sil=0.000> element <sil=0.000> will <sil=0.000> go <sil=0.000> up <sil=1.000> ,COMMA 
and <sil=0.000> this <sil=0.000> heavier <sil=0.000> element <sil=0.000> will <sil=0.000> come <sil=0.000> down <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> something <sil=0.000> like <sil=0.000> this <sil=1.000> ,COMMA  all <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  in <sil=0.000> this <sil=0.000> way <sil=0.000> in <sil=0.000> one <sil=0.000> direction <sil=0.000> ultimately
what <sil=0.000> I will <sil=0.000> do <sil=0.228> ?QUESTIONMARK  I <sil=0.000> will <sil=0.000> have <sil=0.000> the <sil=0.000> heaviest <sil=0.000> element <sil=0.000> at <sil=0.000> the <sil=0.000> bottom <sil=1.000> ,COMMA  and <sil=0.000> all <sil=0.000> the <sil=0.000> elements <sil=0.000> here
are <sil=0.000> lighter <sil=0.000> than <sil=0.000> this <sil=1.000> ,COMMA  this <sil=0.000> element <sil=0.000> lighter <sil=0.000> than <sil=0.000> this <sil=0.000> element <sil=1.000> ,COMMA  but <sil=0.000> these <sil=0.000> elements <sil=0.000> are <sil=0.000> not
sorted <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> I will <sil=0.000> do <sil=0.228> ?QUESTIONMARK  I <sil=0.000> will <sil=0.000> restrict <sil=0.000> my <sil=0.000> next <sil=0.000> iteration <sil=0.000> within <sil=0.000> this <sil=0.000> zone <sil=1.000> ,COMMA  and <sil=0.000> again
start <sil=0.000> between <sil=0.000> this <sil=0.000> elements <sil=1.000> ,COMMA  and <sil=0.000> see <sil=0.000> whichever <sil=0.000> is <sil=0.000> heavier <sil=0.000> that <sil=0.000> will <sil=0.000> be <sil=0.000> pushed <sil=0.000> down <sil=2.000> .PERIOD  Am <sil=0.000> I
clear <sil=0.228> ?QUESTIONMARK 
You <sil=0.000> see <sil=1.000> ,COMMA  every <sil=0.000> time <sil=0.000> I am <sil=0.000> comparing <sil=0.000> between <sil=0.000> these <sil=0.000> and <sil=0.000> am <sil=0.000> pushing <sil=0.000> that <sil=0.000> down <sil=2.000> .PERIOD  I <sil=0.000> think <sil=0.000> it
will <sil=0.000> be <sil=0.000> clearer <sil=0.000> in <sil=0.000> a moment <sil=2.000> .PERIOD  Every <sil=0.000> iteration <sil=0.000> the <sil=0.000> heaviest <sil=0.000> element <sil=0.000> drops <sil=0.000> at <sil=0.000> the <sil=0.000> bottom <sil=0.000> and
the <sil=0.000> bottom <sil=0.000> this <sil=0.000> part <sil=0.000> is <sil=0.000> done <sil=0.000> and <sil=0.000> the <sil=0.000> bottom <sil=0.000> moves <sil=0.000> upward <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  next <sil=0.000> time <sil=0.000> onwards <sil=0.000> my
search <sil=0.000> will <sil=0.000> be <sil=0.000> restricted <sil=0.000> between <sil=0.000> this <sil=0.000> zone <sil=1.000> ,COMMA  this <sil=0.000> zone <sil=0.000> to <sil=0.000> the <sil=0.000> top <sil=0.000> and <sil=0.000> the <sil=0.000> heaviest <sil=0.000> will
come <sil=0.000> to <sil=0.000> the <sil=0.000> next <sil=0.000> time <sil=0.000> my <sil=0.000> search <sil=0.000> will <sil=0.000> be <sil=0.000> restricted <sil=0.000> to <sil=0.000> this <sil=0.000> zone <sil=0.000> like <sil=0.000> that <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> heaviest
here <sil=1.000> ,COMMA  next <sil=0.000> heaviest <sil=0.000> here <sil=1.000> ,COMMA  next <sil=0.000> heaviest <sil=0.000> here <sil=1.000> ,COMMA  heaviest <sil=0.000> here <sil=1.000> ,COMMA  next <sil=0.000> heaviest <sil=0.000> here <sil=1.000> ,COMMA  next
heaviest <sil=0.000> here <sil=1.000> ,COMMA  like <sil=0.000> that <sil=0.000> it <sil=0.000> will <sil=0.000> go <sil=0.000> on <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> want <sil=0.000> to <sil=0.000> see <sil=0.000> if <sil=0.000> I can <sil=0.000> give <sil=0.000> an <sil=0.000> example <sil=0.000> first <sil=2.000> .PERIOD 

Yeah <sil=1.000> ,COMMA  so <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> happening <sil=0.000> here <sil=0.000> is <sil=1.000> ,COMMA  say <sil=0.000> this <sil=0.000> was <sil=0.000> an <sil=0.000> unsorted <sil=0.000> array <sil=2.000> .PERIOD  The <sil=0.000> heaviest <sil=0.000> one <sil=0.000> has
been <sil=0.000> first <sil=0.000> pushed <sil=0.000> down <sil=0.000> this <sil=0.000> 89 <sil=0.000> was <sil=0.000> the <sil=0.000> heaviest <sil=0.000> one <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  by <sil=0.000> piece <sil=0.000> by <sil=0.000> piece <sil=0.000> comparison <sil=0.000> I have <sil=0.000> pushed <sil=0.000> it <sil=0.000> down <sil=2.000> .PERIOD  Next <sil=0.000> time <sil=0.000> I was <sil=0.000> restricted <sil=0.000> to
this <sil=0.000> part <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=0.000> 89 <sil=0.000> has <sil=0.000> been <sil=0.000> pushed <sil=0.000> down <sil=2.000> .PERIOD  So <sil=0.000> and <sil=0.000> let <sil=0.000> me <sil=0.000> try <sil=0.000> to <sil=0.000> show <sil=0.000> you <sil=2.000> .PERIOD 

That <sil=0.000> say <sil=1.000> ,COMMA  suppose <sil=0.000> I have <sil=0.000> got <sil=0.000> an <sil=0.000> array <sil=0.000> like <sil=0.000> this <sil=0.000> 50 <sil=1.000> ,COMMA  16 <sil=1.000> ,COMMA  20 <sil=1.000> ,COMMA  30 <sil=1.000> ,COMMA  40 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  first <sil=0.000> I compare
between <sil=0.000> these <sil=0.000> 2 <sil=1.000> ,COMMA  16 <sil=0.000> 50 <sil=0.000> is <sil=0.000> heavier <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> come <sil=0.000> here <sil=0.000> next <sil=1.000> ,COMMA  I <sil=0.000> compare <sil=0.000> between <sil=0.000> these <sil=0.000> 2 50
and <sil=0.000> 20 <sil=1.000> ,COMMA  50 <sil=0.000> is <sil=0.000> heavier <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  20 <sil=0.000> comes <sil=0.000> here <sil=0.000> 50 <sil=0.000> comes <sil=0.000> here <sil=2.000> .PERIOD  Now <sil=0.000> 50 <sil=0.000> and <sil=0.000> 30 <sil=1.000> ,COMMA  50 <sil=0.000> is <sil=0.000> heavier <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  30 <sil=1.000> ,COMMA  50 <sil=0.000> and <sil=0.000> then <sil=0.000> 50 <sil=0.000> and <sil=0.000> 40 <sil=0.000> so <sil=1.000> ,COMMA  I <sil=0.000> compare <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> becomes <sil=0.000> 450 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  in <sil=0.000> one <sil=0.000> turn
what <sil=0.000> do <sil=0.000> I get <sil=0.000> now <sil=0.000> I get <sil=0.000> 16 <sil=1.000> ,COMMA  20 <sil=1.000> ,COMMA  30 <sil=1.000> ,COMMA  40 <sil=1.000> ,COMMA  50 <sil=0.000> now <sil=0.000> it <sil=0.000> was <sil=0.000> search <sil=0.000> the <sil=0.000> many <sil=0.000> things <sil=0.000> are <sil=0.000> sorted
only <sil=0.000> one <sil=0.000> was <sil=0.000> in <sil=0.000> out <sil=0.000> of <sil=0.000> order <sil=0.000> so <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> been <sil=0.000> done <sil=2.000> .PERIOD  But <sil=0.000> suppose <sil=0.000> this <sil=0.000> was <sil=0.000> let <sil=0.000> me <sil=0.000> let <sil=0.000> me <sil=0.000> just
change <sil=0.000> it <sil=1.000> ,COMMA  it <sil=0.000> becomes <sil=0.000> became <sil=0.000> too <sil=0.000> easy <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  suppose <sil=0.000> it <sil=0.000> is <sil=0.000> 25 <sil=1.000> ,COMMA  then <sil=0.000> after <sil=0.000> this <sil=0.000> swap <sil=1.000> ,COMMA  this
became <sil=0.000> 25 <sil=0.000> and <sil=0.000> 50 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> this <sil=0.000> array <sil=2.000> .PERIOD  Now <sil=0.000> I again <sil=0.000> check <sil=0.000> between <sil=0.000> this <sil=0.000> 2 <sil=2.000> .PERIOD  Heavier <sil=0.000> is <sil=0.000> in
place <sil=1.000> ,COMMA  I <sil=0.000> check <sil=0.000> between <sil=0.000> this <sil=0.000> 2 <sil=1.000> ,COMMA  no <sil=0.000> issue <sil=0.000> heavier <sil=0.000> in <sil=0.000> place <sil=1.000> ,COMMA  I <sil=0.000> check <sil=0.000> between <sil=0.000> this <sil=0.000> 2 <sil=2.000> .PERIOD 
So <sil=0.000> now <sil=0.000> what <sil=0.000> will <sil=0.000> happen <sil=0.228> ?QUESTIONMARK  25 <sil=0.000> will <sil=0.000> come <sil=0.000> here <sil=1.000> ,COMMA  and <sil=0.000> 30 <sil=0.000> being <sil=0.000> heavier <sil=0.000> will <sil=0.000> come <sil=0.000> here <sil=2.000> .PERIOD  And
30 <sil=0.000> and <sil=0.000> I need <sil=0.000> not <sil=0.000> compare <sil=0.000> any <sil=0.000> further <sil=2.000> .PERIOD  I <sil=0.000> can <sil=0.000> because <sil=0.000> this <sil=0.000> is <sil=0.000> this <sil=0.000> I know <sil=0.000> is <sil=0.000> the <sil=0.000> heaviest <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  what <sil=0.000> do <sil=0.000> I have <sil=0.000> now <sil=0.228> ?QUESTIONMARK  16 <sil=1.000> ,COMMA  20 <sil=1.000> ,COMMA  30 <sil=0.000> not <sil=0.000> 30 <sil=1.000> ,COMMA  30 <sil=0.000> has <sil=0.000> been <sil=0.000> swapped <sil=0.000> 25 <sil=1.000> ,COMMA  30 <sil=2.000> .PERIOD  I <sil=0.000> again <sil=0.000> compare
between <sil=0.000> this <sil=0.000> 2 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  there <sil=0.000> is <sil=0.000> no <sil=0.000> change <sil=1.000> ,COMMA  as <sil=0.000> soon <sil=0.000> as <sil=0.000> I find <sil=0.000> that <sil=1.000> ,COMMA  there <sil=0.000> is <sil=0.000> no <sil=0.000> interchange <sil=0.354> ;SEMICOLON  that
means <sil=1.000> ,COMMA  all <sil=0.000> this <sil=0.000> things <sil=0.000> are <sil=0.000> in <sil=0.000> order <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> the <sil=0.000> idea <sil=0.000> of <sil=0.000> the <sil=0.000> selection <sil=0.000> sorry <sil=0.000> the <sil=0.000> bubble <sil=0.000> sort <sil=2.000> .PERIOD 
Every <sil=0.000> time <sil=0.000> the <sil=0.000> minimum <sil=0.000> is <sil=0.000> shifting <sil=0.000> going <sil=0.000> to <sil=0.000> the <sil=0.000> bottom <sil=2.000> .PERIOD  Or <sil=0.000> I could <sil=0.000> have <sil=0.000> done <sil=0.000> it <sil=0.000> in <sil=0.000> the
other <sil=0.000> way <sil=0.000> I could <sil=0.000> have <sil=0.000> justified <sil=0.000> the <sil=0.000> name <sil=0.000> of <sil=0.000> the <sil=0.000> bubble <sil=0.000> sort <sil=1.000> ,COMMA  if <sil=0.000> I had <sil=0.000> taken <sil=0.000> the <sil=0.000> lowest
element <sil=1.000> ,COMMA  and <sil=0.000> pushed <sil=0.000> it <sil=0.000> up <sil=0.000> ok <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  quickly <sil=0.000> if <sil=0.000> we <sil=0.000> look <sil=0.000> at <sil=0.000> the <sil=0.000> algorithm <sil=0.000> a little <sil=0.000> bit <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> got <sil=0.000> this <sil=0.000> is <sil=0.000> a bubble <sil=0.000> sort <sil=0.000> algorithm <sil=2.000> .PERIOD  Let <sil=0.000> us <sil=0.000> see <sil=1.000> ,COMMA  now <sil=0.000> in <sil=0.000> order <sil=0.000> to <sil=0.000> explain <sil=0.000> this <sil=1.000> ,COMMA  I
will <sil=0.000> need <sil=0.000> sometime <sil=1.000> ,COMMA  because <sil=0.000> here <sil=0.000> we <sil=0.000> are <sil=0.000> using <sil=0.000> some <sil=0.000> new <sil=0.000> ideas <sil=1.000> ,COMMA  star <sil=0.000> x and <sil=0.000> star <sil=0.000> y <sil=2.000> .PERIOD  I <sil=0.000> think
I <sil=0.000> will <sil=0.000> take <sil=0.000> it <sil=0.000> up <sil=0.000> in <sil=0.000> separate <sil=0.000> lecture <sil=1.000> ,COMMA  and <sil=0.000> discuss <sil=0.000> this <sil=0.000> separately <sil=1.000> ,COMMA  all <sil=0.000> right <sil=2.000> .PERIOD  But <sil=0.000> just <sil=0.000> as <sil=0.000> I had
explained <sil=0.000> now <sil=1.000> ,COMMA  the <sil=0.000> way <sil=0.000> the <sil=0.000> bubble <sil=0.000> sort <sil=0.000> works <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> just <sil=0.000> give <sil=0.000> you <sil=0.000> one <sil=0.000> more <sil=0.000> example <sil=0.000> to

show <sil=0.000> how <sil=0.000> a bubble <sil=0.000> sort <sil=0.000> works <sil=2.000> .PERIOD  And <sil=0.000> then <sil=0.000> in <sil=0.000> the <sil=0.000> next <sil=0.000> lecture <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> show <sil=0.000> you <sil=0.000> the
algorithm <sil=0.000> because <sil=0.000> that <sil=0.000> will <sil=0.000> require <sil=0.000> some <sil=0.000> more <sil=0.000> explanation <sil=2.000> .PERIOD 

Let <sil=0.000> us <sil=0.000> say <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> this <sil=0.000> 30 <sil=1.000> ,COMMA  20 <sil=1.000> ,COMMA  5 <sil=1.000> ,COMMA  16 <sil=1.000> ,COMMA  2 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> will <sil=0.000> be <sil=0.000> hap <sil=0.000> happening <sil=0.000> in <sil=0.000> the <sil=0.000> first
iteration <sil=0.228> ?QUESTIONMARK  30 <sil=0.000> will <sil=0.000> be <sil=0.000> compared <sil=0.000> with <sil=0.000> 20 <sil=1.000> ,COMMA  30 <sil=0.000> is <sil=0.000> heavier <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> would <sil=0.000> 20 <sil=1.000> ,COMMA  30 <sil=1.000> ,COMMA  5 <sil=1.000> ,COMMA  16 <sil=1.000> ,COMMA  2 <sil=2.000> .PERIOD  Now
30 <sil=0.000> will <sil=0.000> be <sil=0.000> compared <sil=0.000> with <sil=0.000> 5 <sil=1.000> ,COMMA  what <sil=0.000> will <sil=0.000> happen <sil=0.000> and <sil=0.000> this <sil=0.000> will <sil=0.000> be <sil=0.000> swapped <sil=2.000> .PERIOD  30 <sil=1.000> ,COMMA  16 <sil=1.000> ,COMMA  2 <sil=2.000> .PERIOD  30 <sil=0.000> will
be <sil=0.000> compared <sil=0.000> with <sil=0.000> 16 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> will <sil=0.000> happen <sil=0.228> ?QUESTIONMARK  25 <sil=1.000> ,COMMA  16 <sil=1.000> ,COMMA  30 <sil=0.000> 2 and <sil=0.000> 30 <sil=0.000> is <sil=0.000> again <sil=0.000> greater <sil=0.000> than <sil=0.000> 2 <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  25 <sil=1.000> ,COMMA  16 <sil=1.000> ,COMMA  2 <sil=1.000> ,COMMA  30 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  25 <sil=1.000> ,COMMA  16 <sil=1.000> ,COMMA  2 <sil=1.000> ,COMMA  30 <sil=0.000> by <sil=0.000> that <sil=0.000> I get <sil=0.000> this <sil=0.000> 30 <sil=0.000> at <sil=0.000> the <sil=0.000> bottom <sil=1.000> ,COMMA  I <sil=0.000> now <sil=0.000> I start <sil=0.000> with
again <sil=0.354> ;SEMICOLON  25 <sil=1.000> ,COMMA  16 <sil=1.000> ,COMMA  2 <sil=0.000> right <sil=2.000> .PERIOD 

So <sil=0.000> now <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> 30 <sil=0.000> is <sil=0.000> at <sil=0.000> the <sil=0.000> bottom <sil=0.000> 25 <sil=1.000> ,COMMA  16 <sil=1.000> ,COMMA  2 <sil=2.000> .PERIOD  And <sil=0.000> 30 <sil=0.000> is <sil=0.000> already <sil=0.000> in <sil=0.000> proper <sil=0.000> place <sil=1.000> ,COMMA  here <sil=0.000> I
will <sil=0.000> swap <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> will <sil=0.000> happen <sil=0.228> ?QUESTIONMARK  5 <sil=1.000> ,COMMA  20 <sil=1.000> ,COMMA  16 <sil=1.000> ,COMMA  2 <sil=0.000> then <sil=0.000> 20 <sil=0.000> will <sil=0.000> and <sil=0.000> 16 <sil=0.000> so <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> 5 <sil=1.000> ,COMMA  16 <sil=1.000> ,COMMA  20 <sil=1.000> ,COMMA 
2 <sil=1.000> ,COMMA  then <sil=0.000> 5 <sil=1.000> ,COMMA  16 <sil=1.000> ,COMMA  2 <sil=1.000> ,COMMA  20 <sil=1.000> ,COMMA  20 <sil=0.000> is <sil=0.000> in <sil=0.000> the <sil=0.000> proper <sil=0.000> place <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  30 <sil=0.000> and <sil=0.000> 20 <sil=0.000> are <sil=0.000> in <sil=0.000> proper <sil=0.000> place <sil=2.000> .PERIOD  And <sil=0.000> 5 <sil=1.000> ,COMMA 
16 <sil=1.000> ,COMMA  2 <sil=0.000> I will <sil=0.000> have <sil=0.000> to <sil=0.000> handle <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  what <sil=0.000> will <sil=0.000> be <sil=0.000> there <sil=0.228> ?QUESTIONMARK  5 <sil=1.000> ,COMMA  16 <sil=1.000> ,COMMA  2 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  5 <sil=1.000> ,COMMA  16 <sil=1.000> ,COMMA  2 <sil=1.000> ,COMMA  and <sil=0.000> here <sil=0.000> I have <sil=0.000> got <sil=0.000> 20 <sil=1.000> ,COMMA  and <sil=0.000> 30 <sil=0.000> already <sil=0.000> in <sil=0.000> the
proper <sil=0.000> place <sil=0.000> sort <sil=0.000> it <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> 5 and <sil=0.000> 16 <sil=0.000> no <sil=0.000> change <sil=1.000> ,COMMA  16 <sil=0.000> and <sil=0.000> 2 there <sil=0.000> will <sil=0.000> be <sil=0.000> some <sil=0.000> change <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 

5 <sil=1.000> ,COMMA  2 <sil=1.000> ,COMMA  16 <sil=0.000> so <sil=1.000> ,COMMA  16 <sil=0.000> is <sil=0.000> in <sil=0.000> the <sil=0.000> proper <sil=0.000> place <sil=2.000> .PERIOD  So <sil=0.000> now <sil=1.000> ,COMMA  between <sil=0.000> 5 and <sil=0.000> 2 so <sil=1.000> ,COMMA  my <sil=0.000> thing <sil=0.000> will <sil=0.000> be <sil=0.000> 16 <sil=1.000> ,COMMA 
20 <sil=1.000> ,COMMA  30 <sil=0.000> are <sil=0.000> in <sil=0.000> place <sil=2.000> .PERIOD 

16 <sil=1.000> ,COMMA  20 <sil=1.000> ,COMMA  30 <sil=0.000> are <sil=0.000> in <sil=0.000> place <sil=1.000> ,COMMA  and <sil=0.000> 5 and <sil=0.000> 2 I <sil=0.000> have <sil=0.000> to <sil=0.000> deal <sil=0.000> with <sil=1.000> ,COMMA  these <sil=0.000> are <sil=0.000> fine <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  my <sil=0.000> pointers <sil=0.000> are
changing <sil=1.000> ,COMMA  right <sil=1.000> ,COMMA  between <sil=0.000> these <sil=0.000> 2 now <sil=0.000> 5 is <sil=0.000> heavier <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> 2 <sil=1.000> ,COMMA  5 <sil=1.000> ,COMMA  5 <sil=0.000> is <sil=0.000> in <sil=0.000> the <sil=0.000> proper
place <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  2 <sil=0.000> 5 in <sil=0.000> the <sil=0.000> proper <sil=0.000> place <sil=1.000> ,COMMA  16 <sil=0.000> proper <sil=0.000> place <sil=1.000> ,COMMA  20 <sil=0.000> proper <sil=0.000> place <sil=1.000> ,COMMA  30 <sil=0.000> proper <sil=0.000> place <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
only <sil=0.000> 2 there <sil=0.000> is <sil=0.000> no <sil=0.000> question <sil=0.000> of <sil=0.000> swapping <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> get <sil=0.000> the <sil=0.000> complete <sil=0.000> sorted <sil=0.000> file <sil=0.000> ok <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is
the <sil=0.000> principle <sil=0.000> of <sil=0.000> bubble <sil=0.000> sort <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> be <sil=0.000> explaining <sil=0.000> the <sil=0.000> algorithm <sil=0.000> the <sil=0.000> code <sil=0.000> in <sil=0.000> the <sil=0.000> next <sil=0.000> class <sil=2.000> .PERIOD 
In <sil=0.000> the <sil=0.000> meanwhile <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> think <sil=0.000> of <sil=0.000> you <sil=0.000> can <sil=0.000> read <sil=0.000> book <sil=0.000> and <sil=0.000> you <sil=0.000> can <sil=0.000> try <sil=0.000> to <sil=0.000> see <sil=0.000> look <sil=0.000> at <sil=0.000> this
code <sil=0.000> and <sil=0.000> the <sil=0.000> algorithm <sil=0.000> yourself <sil=2.000> .PERIOD  I <sil=0.000> will <sil=0.000> discuss <sil=0.000> it <sil=0.000> in <sil=0.000> the <sil=0.000> next <sil=0.000> week <sil=0.000> lecture <sil=2.000> .PERIOD 
Thank <sil=0.000> you <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  we <sil=0.000> were <sil=0.000> discussing <sil=0.000> about <sil=0.000> the <sil=0.000> Bubble <sil=0.000> Sort <sil=0.000> Algorithm <sil=0.000> and <sil=0.000> the <sil=0.000> approach <sil=0.000> as <sil=0.000> was <sil=0.000> discussed <sil=0.000> in
the <sil=0.000> last <sil=0.000> class <sil=0.000> was <sil=0.000> that <sil=0.000> every <sil=0.000> element <sil=1.000> ,COMMA  every <sil=0.000> iteration <sil=0.000> pushes <sil=0.000> the <sil=0.000> heavier <sil=0.000> element <sil=0.000> at <sil=0.000> the <sil=0.000> bottom
and <sil=0.000> the <sil=0.000> lighter <sil=0.000> elements <sil=0.000> therefore <sil=1.000> ,COMMA  goes <sil=0.000> go <sil=0.000> up <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  we <sil=0.000> had <sil=0.000> shown <sil=0.000> an <sil=0.000> example <sil=0.000> a couple <sil=0.000> of <sil=0.000> examples <sil=0.000> by <sil=0.000> which <sil=0.000> we <sil=0.000> can <sil=0.000> show <sil=0.000> that <sil=0.000> the <sil=0.000> heavier
elements <sil=0.000> go <sil=0.000> down <sil=0.000> and <sil=0.000> the <sil=0.000> other <sil=0.000> lighter <sil=0.000> elements <sil=0.000> go <sil=0.000> up  <sil=1.000> ,COMMA  we <sil=0.000> had <sil=0.000> given <sil=0.000> a number <sil=0.000> of <sil=0.000> examples <sil=0.000> to
that <sil=0.000> effect <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  if <sil=0.000> there <sil=0.000> be <sil=0.000> 50 <sil=0.000> here <sil=0.000> I do <sil=0.000> not <sil=0.000> know <sil=0.000> this <sil=0.000> visible <sil=1.000> ,COMMA  let <sil=0.000> me <sil=0.000> write <sil=0.000> it <sil=0.000> here <sil=0.000> 50 <sil=0.000> here <sil=0.000> and <sil=0.000> 6 here <sil=0.000> and <sil=0.000> say
12 <sil=0.000> here <sil=0.000> and <sil=0.000> 7 here <sil=0.000> then <sil=0.000> what <sil=0.000> will <sil=0.000> happen <sil=0.000> is <sil=0.000> 50 <sil=0.000> will <sil=0.000> be <sil=0.000> swapped <sil=0.000> with <sil=0.000> 6 because <sil=0.000> 50 <sil=0.000> is <sil=0.000> heavier <sil=0.000> than
6 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  larger <sil=0.000> than <sil=0.000> 6 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  first <sil=0.000> it <sil=0.000> will <sil=0.000> be <sil=0.000> 6 and <sil=0.000> 50 <sil=0.000> and <sil=0.000> then <sil=0.000> 50 <sil=0.000> will <sil=0.000> be <sil=0.000> compared <sil=0.000> with <sil=0.000> 12 <sil=0.000> again <sil=0.000> there
will <sil=0.000> be <sil=0.000> a swap <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  there <sil=0.000> will <sil=0.000> be <sil=0.000> 12 <sil=1.000> ,COMMA <sil=0.000> 50 <sil=2.000> .PERIOD  50 <sil=0.000> will <sil=0.000> be <sil=0.000> compared <sil=0.000> with <sil=0.000> 7 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> 7 <sil=1.000> ,COMMA  50 <sil=0.000> in <sil=0.000> that
way <sil=0.000> ultimately <sil=0.000> the <sil=0.000> 50 <sil=0.000> if <sil=0.000> it <sil=0.000> is <sil=0.000> heaviest <sil=0.000> will <sil=0.000> come <sil=0.000> at <sil=0.000> the <sil=0.000> bottom <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  we <sil=0.000> swap <sil=0.000> only <sil=0.000> if <sil=0.000> the <sil=0.000> element <sil=0.000> at <sil=0.000> the <sil=0.000> top <sil=0.000> is <sil=0.000> heavier <sil=0.000> there <sil=0.000> by <sil=0.000> heaviest <sil=0.000> element <sil=0.000> is <sil=0.000> coming <sil=0.000> to <sil=0.000> the
top <sil=0.000> and <sil=0.000> the <sil=0.000> others <sil=0.000> which <sil=0.000> are <sil=0.000> less <sil=0.000> than <sil=0.000> this <sil=0.000> heaviest <sil=0.000> element <sil=0.000> will <sil=0.000> be <sil=0.000> going <sil=0.000> at <sil=0.000> the <sil=0.000> top <sil=1.000> ,COMMA  the <sil=0.000> bottom
moves <sil=0.000> upward <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  we <sil=0.000> are <sil=0.000> going <sil=0.000> to <sil=0.000> write <sil=0.000> the <sil=0.000> algorithm <sil=0.000> for <sil=0.000> this <sil=0.000> or <sil=0.000> the <sil=0.000> program <sil=1.000> ,COMMA  for <sil=0.000> this <sil=0.000> before
writing <sil=0.000> the <sil=0.000> program <sil=0.000> we <sil=0.000> need <sil=0.000> to <sil=0.000> understand <sil=0.000> a very <sil=0.000> interesting <sil=0.000> and <sil=0.000> fundamental <sil=0.000> concept <sil=0.000> of <sil=0.000> C
programming <sil=0.000> that <sil=0.000> is <sil=0.000> pointers <sil=2.000> .PERIOD 

We <sil=0.000> will <sil=0.000> not <sil=0.000> formally <sil=0.000> introduce <sil=0.000> pointers <sil=0.000> here <sil=1.000> ,COMMA  but <sil=0.000> we <sil=0.000> will <sil=0.000> be <sil=0.000> talking <sil=0.000> about <sil=0.000> pointers <sil=0.000> in <sil=0.000> a different
way <sil=0.000> in <sil=0.000> a context <sil=0.000> of <sil=0.000> this <sil=0.000> bubble <sil=0.000> sort <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> a pointer <sil=0.228> ?QUESTIONMARK  Pointer <sil=0.000> is <sil=0.000> something <sil=0.000> that <sil=0.000> points <sil=2.000> .PERIOD 
Now <sil=0.000> suppose <sil=0.000> there <sil=0.000> is <sil=0.000> a variable <sil=0.000> here <sil=1.000> ,COMMA <sil=0.000> suppose <sil=0.000> the <sil=0.000> variable <sil=0.000> is <sil=0.000> named <sil=0.000> v and <sil=0.000> till <sil=0.000> now <sil=0.000> we <sil=0.000> have <sil=0.000> seen
that <sil=0.000> we <sil=0.000> can <sil=0.000> write <sil=0.000> declare <sil=0.000> the <sil=0.000> variable <sil=0.000> as <sil=0.000> int <sil=0.000> v <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  v <sil=0.000> has <sil=0.000> got <sil=0.000> a particular <sil=0.000> address <sil=0.000> may <sil=0.000> be <sil=0.000> that
address <sil=0.000> is <sil=0.000> 1000 <sil=1.000> ,COMMA  1000 <sil=0.000> is <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> v <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  if <sil=0.000> I say <sil=0.000> int <sil=0.000> v equals <sil=0.000> 50 <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  in <sil=0.000> the <sil=0.000> address
1000 <sil=0.000> 50 <sil=0.000> is <sil=0.000> written <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  suppose <sil=0.000> we <sil=0.000> have <sil=0.000> got <sil=0.000> this <sil=0.000> address <sil=0.000> v and <sil=0.000> which <sil=0.000> is <sil=0.000> an <sil=0.000> integer <sil=2.000> .PERIOD 

But <sil=0.000> I am <sil=0.000> not <sil=0.000> declaring <sil=0.000> v as <sil=0.000> such <sil=1.000> ,COMMA  but <sil=0.000> there <sil=0.000> is <sil=0.000> another <sil=0.000> variable <sil=0.000> p <sil=1.000> ,COMMA  which <sil=0.000> will <sil=0.000> always <sil=0.000> point <sil=0.000> to <sil=0.000> some
integer <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  p <sil=0.000> will <sil=0.000> point <sil=0.000> to <sil=0.000> this <sil=0.000> v <sil=2.000> .PERIOD  P <sil=0.000> is <sil=0.000> pointing <sil=0.000> at <sil=0.000> this <sil=0.000> v <sil=2.000> .PERIOD  In <sil=0.000> that <sil=0.000> case <sil=0.000> I can <sil=0.000> say <sil=0.000> p is <sil=0.000> a pointer <sil=0.000> to <sil=0.000> v
now <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  therefore <sil=1.000> ,COMMA  what <sil=0.000> did <sil=0.000> I say <sil=0.228> ?QUESTIONMARK <sil=0.000> I said <sil=0.000> that <sil=0.000> v is <sil=0.000> stored <sil=0.000> in <sil=0.000> the <sil=0.000> location <sil=0.000> 1000 <sil=1.000> ,COMMA  now <sil=0.000> pointer <sil=0.000> p this
variable <sil=0.000> p therefore <sil=1.000> ,COMMA  stores <sil=0.000> the <sil=0.000> value <sil=0.000> 1000 <sil=2.000> .PERIOD 

Now <sil=0.000> this <sil=0.000> v is <sil=0.000> of <sil=0.000> type <sil=0.000> integer <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  v <sil=0.000> is <sil=0.000> a pointer <sil=0.000> to <sil=0.000> an <sil=0.000> integer <sil=0.000> v that <sil=0.000> we <sil=0.000> know <sil=0.000> because <sil=0.000> I have
earlier <sil=0.000> said <sil=0.000> that <sil=0.000> v is <sil=0.000> an <sil=0.000> integer <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> very <sil=0.000> well <sil=0.000> say <sil=0.000> int <sil=0.000> v <sil=1.000> ,COMMA  but <sil=0.000> what <sil=0.000> is <sil=0.000> the <sil=0.000> type <sil=0.000> of <sil=0.000> p  <sil=1.000> ,COMMA  p <sil=0.000> is <sil=0.000> a
pointer <sil=0.000> to <sil=0.000> v <sil=1.000> ,COMMA  which <sil=0.000> is <sil=0.000> an <sil=0.000> integer <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> write <sil=0.000> that <sil=0.000> as <sil=0.000> int <sil=0.000> star <sil=0.000> p <sil=1.000> ,COMMA  what <sil=0.000> does <sil=0.000> it <sil=0.000> mean <sil=0.228> ?QUESTIONMARK  It <sil=0.000> means <sil=0.000> that
p <sil=0.000> is <sil=0.000> a pointer <sil=0.000> to <sil=0.000> an <sil=0.000> integer <sil=1.000> ,COMMA  if <sil=0.000> I write <sil=0.000> it  <sil=1.000> ,COMMA <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> concerned <sil=0.000> with <sil=0.000> v only <sil=2.000> .PERIOD  It <sil=0.000> says <sil=0.000> that <sil=0.000> p is <sil=0.000> a pointer
to <sil=0.000> an <sil=0.000> integer <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> p now <sil=0.228> ?QUESTIONMARK  Value <sil=0.000> of <sil=0.000> p is <sil=0.000> 1000 <sil=2.000> .PERIOD  What <sil=0.000> is <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> p the <sil=0.000> address <sil=0.000> of <sil=0.000> p <sil=0.228> ?QUESTIONMARK 
Now <sil=0.000> where <sil=0.000> is <sil=0.000> this <sil=0.000> p  <sil=0.228> ?QUESTIONMARK <sil=0.000> This <sil=0.000> is <sil=0.000> in <sil=0.000> location <sil=0.000> 1000 <sil=0.000> and <sil=0.000> where <sil=0.000> is <sil=0.000> this  <sil=0.228> ?QUESTIONMARK <sil=0.000> This <sil=0.000> might <sil=0.000> be <sil=0.000> in <sil=0.000> location <sil=0.000> 2000 <sil=2.000> .PERIOD 
Therefore <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> p <sil=0.228> ?QUESTIONMARK  &of <sil=0.000> p is <sil=0.000> 2000 <sil=1.000> ,COMMA  we <sil=0.000> know <sil=0.000> that <sil=0.000> this <sil=0.000> and <sil=0.000> operator <sil=0.000> gives <sil=0.000> us <sil=0.000> the
address <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> encountered <sil=0.000> this <sil=0.000> during <sil=0.000> scan <sil=0.000> f when <sil=0.000> we <sil=0.000> were <sil=0.000> discussing <sil=0.000> about <sil=0.000> scan <sil=0.000> f right <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> have <sil=0.000> this <sil=0.000> diagram <sil=0.000> to <sil=0.000> understand <sil=0.000> the <sil=0.000> concept <sil=0.000> of <sil=0.000> pointer <sil=0.000> suppose <sil=0.000> there <sil=0.000> are <sil=0.000> different
things <sil=0.000> written <sil=0.000> in <sil=0.000> different <sil=0.000> pages <sil=0.000> of <sil=0.000> the <sil=0.000> book <sil=2.000> .PERIOD 

This <sil=0.000> 1 page <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> another <sil=0.000> page  <sil=1.000> ,COMMA <sil=0.000> this <sil=0.000> is <sil=0.000> another <sil=0.000> page <sil=0.000> and <sil=0.000> this <sil=0.000> is <sil=0.000> another <sil=0.000> page <sil=1.000> ,COMMA  each <sil=0.000> of <sil=0.000> these
pages <sil=0.000> have <sil=0.000> got <sil=0.000> a page <sil=0.000> number <sil=2.000> .PERIOD  Now <sil=0.000> I have <sil=0.000> got <sil=0.000> a table <sil=0.000> where <sil=0.000> suppose- this <sil=0.000> has <sil=0.000> got <sil=0.000> some <sil=0.000> content <sil=0.000> a <sil=1.000> ,COMMA  this <sil=0.000> has <sil=0.000> got <sil=0.000> some <sil=0.000> other <sil=0.000> story <sil=0.000> b <sil=1.000> ,COMMA  this <sil=0.000> has <sil=0.000> got <sil=0.000> some <sil=0.000> other <sil=0.000> story <sil=0.000> c <sil=1.000> ,COMMA  this <sil=0.000> has <sil=0.000> got <sil=0.000> some <sil=0.000> other <sil=0.000> story <sil=0.000> d <sil=2.000> .PERIOD 

Therefore <sil=1.000> ,COMMA  the <sil=0.000> content <sil=0.000> of <sil=0.000> each <sil=0.000> of <sil=0.000> this <sil=0.000> pages <sil=0.000> are <sil=0.000> the <sil=0.000> stories <sil=0.000> a <sil=1.000> ,COMMA  b <sil=1.000> ,COMMA  c <sil=1.000> ,COMMA  or <sil=0.000> d <sil=2.000> .PERIOD <sil=0.000> But <sil=0.000> which <sil=0.000> page <sil=0.000> I am
looking <sil=0.000> at  <sil=0.228> ?QUESTIONMARK <sil=0.000> Suppose <sil=0.000> here <sil=0.000> is <sil=0.000> a table <sil=0.000> of <sil=0.000> page <sil=0.000> numbers <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> a 4 <sil=0.000> pages <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> pages <sil=0.000> are <sil=0.000> 1 2 <sil=0.000> 3 4 <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  suppose <sil=0.000> I just <sil=0.000> want <sil=0.000> to <sil=0.000> come <sil=0.000> to <sil=0.000> this <sil=0.000> page <sil=0.000> number <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> page <sil=0.000> number <sil=0.000> does <sil=0.000> not <sil=0.000> tell <sil=0.000> me <sil=0.000> what <sil=0.000> story <sil=0.000> is <sil=0.000> there <sil=1.000> ,COMMA  but <sil=0.000> this <sil=0.000> page <sil=0.000> number <sil=0.000> tells <sil=0.000> me <sil=0.000> that <sil=0.000> I have <sil=0.000> to <sil=0.000> go <sil=0.000> to <sil=0.000> this <sil=0.000> page <sil=2.000> .PERIOD  This <sil=0.000> entry <sil=0.000> is <sil=0.000> telling <sil=0.000> me <sil=1.000> ,COMMA  this <sil=0.000> particular <sil=0.000> page <sil=0.000> number <sil=0.000> is <sil=0.000> telling <sil=0.000> me <sil=0.000> that <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> to <sil=0.000> go <sil=0.000> to <sil=0.000> this <sil=0.000> page <sil=2.000> .PERIOD <sil=0.000> This <sil=0.000> is <sil=0.000> telling <sil=0.000> me <sil=0.000> that <sil=0.000> I have <sil=0.000> to <sil=0.000> go <sil=0.000> to <sil=0.000> this <sil=0.000> page <sil=0.000> and <sil=0.000> this <sil=0.000> is <sil=0.000> telling <sil=0.000> me <sil=0.000> that <sil=0.000> I have <sil=0.000> to <sil=0.000> go <sil=0.000> to <sil=0.000> this <sil=0.000> page <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  what <sil=0.000> are <sil=0.000> these <sil=0.228> ?QUESTIONMARK  What <sil=0.000> are <sil=0.000> these <sil=0.000> things <sil=0.228> ?QUESTIONMARK  These <sil=0.000> are <sil=0.000> nothing <sil=1.000> ,COMMA  but <sil=0.000> pointers <sil=0.000> to <sil=0.000> pages <sil=0.000> and <sil=0.000> what <sil=0.000> is  a  is <sil=0.000> a content <sil=0.000> of <sil=0.000> the <sil=0.000> page <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  a <sil=0.000> b c <sil=0.000> or <sil=0.000> d say <sil=0.000> is <sil=0.000> content <sil=0.000> of <sil=0.000> page <sil=0.000> 4 and <sil=0.000> these <sil=0.000> are <sil=0.000> pointers <sil=0.000> to <sil=0.000> the <sil=0.000> pages <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  if <sil=0.000> I want <sil=0.000> to <sil=0.000> go <sil=0.000> to <sil=0.000> page <sil=0.000> 4- where <sil=0.000> should <sil=0.000> I go <sil=0.228> ?QUESTIONMARK  Because <sil=0.000> this <sil=0.000> page <sil=0.000> may <sil=0.000> be
located <sil=0.000> at <sil=0.000> some <sil=0.000> other <sil=0.000> table <sil=0.000> may <sil=0.000> be <sil=1.000> ,COMMA  suppose <sil=0.000> this <sil=0.000> pages <sil=0.000> of <sil=0.000> a book <sil=0.000> are <sil=0.000> torn <sil=0.000> out <sil=0.000> and <sil=0.000> have <sil=0.000> been <sil=0.000> kept <sil=0.000> on <sil=0.000> different <sil=0.000> tables <sil=0.000> ok <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  page <sil=0.000> number <sil=0.000> 1 is <sil=0.000> giving <sil=0.000> me <sil=0.000> the <sil=0.000> table <sil=0.000> address <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> it <sil=0.000> is <sil=0.000> on <sil=0.000> this <sil=0.000> particular <sil=0.000> table <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> can
be <sil=0.000> on <sil=0.000> table <sil=0.000> t 1 <sil=1.000> ,COMMA  this <sil=0.000> can <sil=0.000> be <sil=0.000> on <sil=0.000> table <sil=0.000> t 2 <sil=1.000> ,COMMA  may <sil=0.000> be <sil=0.000> the <sil=0.000> third <sil=0.000> page <sil=0.000> is <sil=0.000> on <sil=0.000> table <sil=0.000> t 4 <sil=0.000> and <sil=0.000> this <sil=0.000> is <sil=0.000> on <sil=0.000> table <sil=0.000> t 5
it <sil=0.000> is <sil=0.000> possible <sil=2.000> .PERIOD  If <sil=0.000> I want <sil=0.000> to <sil=0.000> read <sil=0.000> the <sil=0.000> first <sil=0.000> page <sil=0.000> I will <sil=0.000> come <sil=0.000> here -the <sil=0.000> first <sil=0.000> entry <sil=0.000> this <sil=0.000> is <sil=0.000> the <sil=0.000> point <sil=0.000> in <sil=0.000> to
table <sil=0.000> t 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  and <sil=0.000> I go <sil=0.000> to <sil=0.000> table <sil=0.000> t 1 <sil=0.000> and <sil=0.000> to <sil=0.000> find <sil=0.000> this <sil=0.000> particular <sil=0.000> page <sil=0.000> and <sil=0.000> read <sil=0.000> the <sil=0.000> content <sil=0.000> in <sil=0.000> that  <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
these <sil=0.000> are <sil=0.000> pointers <sil=0.000> to <sil=0.000> pages <sil=1.000> ,COMMA  but <sil=0.000> these <sil=0.000> pointers <sil=0.000> also <sil=0.000> have <sil=0.000> to <sil=0.000> be <sil=0.000> in <sil=0.000> some <sil=0.000> memory <sil=0.000> location -let <sil=0.000> me
draw <sil=0.000> the <sil=0.000> diagram <sil=0.000> in <sil=0.000> different <sil=0.000> way <sil=0.000> now  <sil=1.000> ,COMMA <sil=0.000> suppose <sil=0.000> this <sil=0.000> is <sil=0.000> my <sil=0.000> memory <sil=0.000> and <sil=0.000> I have <sil=0.000> got <sil=0.000> 4 variables <sil=2.000> .PERIOD 

Suppose <sil=0.000> I have <sil=0.000> got <sil=0.000> 4 integer <sil=0.000> variables <sil=0.000> and <sil=0.000> each <sil=0.000> integer <sil=0.000> variable <sil=0.000> takes <sil=0.000> 2 bytes <sil=2.000> .PERIOD <sil=0.000> I am <sil=0.000> showing <sil=0.000> 2
bytes <sil=0.000> here <sil=0.000> one <sil=0.000> after <sil=0.000> the <sil=0.000> other <sil=0.000> all <sil=0.000> right <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> the <sil=0.000> variable <sil=0.000> v 1 <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> the <sil=0.000> variable <sil=0.000> v 2 <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> the
variable <sil=0.000> v 3 <sil=0.000> and <sil=0.000> this <sil=0.000> is <sil=0.000> the <sil=0.000> variable <sil=0.000> v 4  <sil=2.000> .PERIOD 

Similarly <sil=0.000> let <sil=0.000> me <sil=0.000> just <sil=0.000> change <sil=0.000> the <sil=0.000> colour <sil=2.000> .PERIOD  Let <sil=0.000> this <sil=0.000> be <sil=0.000> in <sil=0.000> locations- v <sil=0.000> 1 is <sil=0.000> in <sil=0.000> location <sil=0.000> 1000 <sil=0.000> assuming
that <sil=0.000> an <sil=0.000> integer <sil=0.000> takes <sil=0.000> 2 bytes <sil=1.000> ,COMMA  this <sil=0.000> one <sil=0.000> is <sil=0.000> in <sil=0.000> location <sil=0.000> 1002 <sil=1.000> ,COMMA  this <sil=0.000> one <sil=0.000> is <sil=0.000> in <sil=0.000> location <sil=0.000> 1004 <sil=0.000> and <sil=0.000> this <sil=0.000> is
in <sil=0.000> location <sil=0.000> 1006 <sil=2.000> .PERIOD 

Let <sil=0.000> me <sil=0.000> extend <sil=0.000> my <sil=0.000> table <sil=0.000> bit <sil=1.000> ,COMMA  now <sil=0.000> suppose <sil=0.000> I have <sil=0.000> got <sil=0.000> here <sil=0.000> 4 integers <sil=2.000> .PERIOD  So <sil=0.000> here <sil=0.000> I have <sil=0.000> got <sil=0.000> p 1 <sil=0.000> is <sil=0.000> a
pointer <sil=0.000> variable- since <sil=0.000> it <sil=0.000> is <sil=0.000> a integer <sil=0.000> let <sil=0.000> me <sil=0.000> say- p <sil=0.000> 2 p <sil=0.000> 3 and <sil=0.000> p 4 <sil=2.000> .PERIOD  I <sil=0.000> am <sil=0.000> not <sil=0.000> bothering <sil=0.000> about <sil=0.000> how
many <sil=0.000> locations <sil=0.000> it <sil=0.000> is <sil=0.000> taking <sil=2.000> .PERIOD 

I <sil=0.000> am <sil=0.000> now <sil=0.000> not <sil=0.000> bothering <sil=0.000> about <sil=0.000> this <sil=0.000> division <sil=0.000> here <sil=0.000> 2 bytes <sil=0.000> am <sil=0.000> just <sil=0.000> showing <sil=0.000> those <sil=0.000> 2 bytes <sil=0.000> together
that <sil=0.000> will <sil=0.000> be <sil=0.000> easier <sil=0.000> for <sil=0.000> me <sil=0.000> to <sil=0.000> write <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> the <sil=0.000> p 1 <sil=0.000> is <sil=0.000> storing <sil=0.000> the <sil=0.000> value <sil=0.000> 1000 <sil=0.000> why <sil=0.228> ?QUESTIONMARK  p <sil=0.000> 1 is
a <sil=0.000> pointer <sil=0.000> to <sil=0.000> this <sil=0.000> variable <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> p 1 <sil=0.000> tells <sil=0.000> me <sil=0.000> not <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> v 1 <sil=1.000> ,COMMA  but <sil=0.000> it <sil=0.000> tells <sil=0.000> me <sil=0.000> where <sil=0.000> is <sil=0.000> v 1
located <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  1000 <sil=0.000> is <sil=0.000> a position <sil=0.000> where <sil=0.000> v 1 <sil=0.000> is <sil=0.000> located <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  p <sil=0.000> 1 is <sil=0.000> storing <sil=0.000> that <sil=0.000> pointer <sil=0.000> and <sil=0.000> p 2 <sil=0.000> is <sil=0.000> say <sil=0.000> 1002 <sil=1.000> ,COMMA  p <sil=0.000> 3
is <sil=0.000> 1004 <sil=0.000> and <sil=0.000> p 4 <sil=0.000> is <sil=0.000> 1006 <sil=2.000> .PERIOD  Now <sil=0.000> these <sil=0.000> locations <sil=0.000> also <sil=0.000> have <sil=0.000> got <sil=0.000> address- suppose <sil=0.000> these <sil=0.000> addresses <sil=0.000> are
5000 <sil=1.000> ,COMMA  5002 <sil=1.000> ,COMMA  5004 <sil=0.000> and <sil=0.000> 5006 <sil=0.000> this <sil=0.000> 5006 <sil=0.000> ok <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  please <sil=0.000> try <sil=0.000> to <sil=0.000> understand <sil=0.000> when <sil=0.000> I say <sil=0.000> p 1- what <sil=0.000> is <sil=0.000> p 1 <sil=0.228> ?QUESTIONMARK  p <sil=0.000> 1 is <sil=0.000> a pointer <sil=0.000> to <sil=0.000> an <sil=0.000> integer <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  int <sil=0.000> star
p <sil=0.000> 1 <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  that <sil=0.000> p 1 <sil=0.000> is <sil=0.000> an <sil=0.000> integer <sil=0.000> all <sil=0.000> right <sil=0.000> and <sil=0.000> p 1 <sil=0.000> is <sil=0.000> a pointer <sil=0.000> to <sil=0.000> an <sil=0.000> integer <sil=0.000> variable  <sil=2.000> .PERIOD  It <sil=0.000> could
be <sil=0.000> a floating <sil=0.000> point <sil=0.000> variable <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  had <sil=0.000> it <sil=0.000> been <sil=0.000> a floating <sil=0.000> point <sil=0.000> number <sil=2.000> .PERIOD 

Now <sil=0.000> suppose <sil=0.000> each <sil=0.000> of <sil=0.000> them <sil=0.000> is <sil=0.000> a float <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  float <sil=0.000> v 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  v <sil=0.000> 1 is <sil=0.000> a floating <sil=0.000> point <sil=0.000> number <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  then <sil=0.000> if
p <sil=0.000> 1 points <sil=0.000> to <sil=0.000> v 1 <sil=1.000> ,COMMA  then <sil=0.000> I should <sil=0.000> write <sil=0.000> float <sil=0.000> star <sil=0.000> p 1 <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  p <sil=0.000> 1 is <sil=0.000> pointing <sil=0.000> to <sil=0.000> a floating <sil=0.000> point
number  <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  since <sil=0.000> it <sil=0.000> is <sil=0.000> a floating <sil=0.000> point <sil=0.000> number  <sil=1.000> ,COMMA <sil=0.000> if <sil=0.000> I say <sil=0.000> now &p1 <sil=0.000> what <sil=0.000> will <sil=0.000> I get <sil=0.228> ?QUESTIONMARK  what <sil=0.000> is <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> p
1 <sil=0.228> ?QUESTIONMARK  what <sil=0.000> is <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> p 1 <sil=0.000> address <sil=0.000> of <sil=0.000> p 1 <sil=0.000> is <sil=0.000> 5000 <sil=0.000> and <sil=0.000> what <sil=0.000> is <sil=0.000> star <sil=0.000> p 1 <sil=0.228> ?QUESTIONMARK  What <sil=0.000> is <sil=0.000> the <sil=0.000> meaning <sil=0.000> of
this <sil=0.228> ?QUESTIONMARK  Please <sil=0.000> do <sil=0.000> not <sil=0.000> be <sil=0.000> confused <sil=2.000> .PERIOD  This <sil=0.000> star <sil=0.000> and <sil=0.000> this <sil=0.000> star <sil=0.000> has <sil=0.000> got <sil=0.000> two <sil=0.000> different <sil=0.000> meanings <sil=1.000> ,COMMA  this <sil=0.000> star

means <sil=0.000> it <sil=0.000> is <sil=0.000> just <sil=0.000> saying <sil=0.000> that <sil=0.000> p 1 <sil=0.000> is <sil=0.000> a pointer <sil=1.000> ,COMMA  pointer <sil=0.000> to <sil=0.000> what <sil=0.000> type <sil=0.000> of <sil=0.000> variable <sil=0.228> ?QUESTIONMARK  Pointer <sil=0.000> to <sil=0.000> a floating
point <sil=0.000> type <sil=0.000> of <sil=0.000> variable <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  for <sil=0.000> v 1 <sil=0.000> am <sil=0.000> just <sil=0.000> writing -float <sil=0.000> v 1 <sil=0.000> so <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  that <sil=0.000> v 1 <sil=0.000> is <sil=0.000> purely <sil=0.000> a floating <sil=0.000> point <sil=0.000> number <sil=0.000> not
a <sil=0.000> pointer <sil=1.000> ,COMMA  but <sil=0.000> when <sil=0.000> I say <sil=0.000> float <sil=0.000> star <sil=0.000> p 1 <sil=1.000> ,COMMA  then <sil=0.000> p 1 <sil=0.000> is <sil=0.000> a pointer <sil=0.000> to <sil=0.000> some <sil=0.000> floating <sil=0.000> number <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  what
is <sil=0.000> star <sil=0.000> p 1 <sil=0.000> in <sil=0.000> this <sil=0.000> case <sil=0.000> what <sil=0.000> is <sil=0.000> a content <sil=0.000> of <sil=0.000> p  <sil=0.228> ?QUESTIONMARK <sil=0.000> Content <sil=0.000> of <sil=0.000> p 1 <sil=0.000> is <sil=0.000> 1000 <sil=0.000> So <sil=1.000> ,COMMA  let <sil=0.000> me <sil=0.000> just <sil=0.000> repeat <sil=0.000> it <sil=0.000> once
again <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> seen <sil=0.000> in <sil=0.000> declaration <sil=0.000> something <sil=0.000> like <sil=0.000> int <sil=0.000> star <sil=0.000> p 1 <sil=0.000> int <sil=0.000> v 1 <sil=2.000> .PERIOD 

Now <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  p <sil=0.000> 1 is <sil=0.000> a pointer  <sil=1.000> ,COMMA <sil=0.000> suppose <sil=0.000> located <sil=0.000> at <sil=0.000> location <sil=0.000> 5000 <sil=0.000> and <sil=0.000> p 1 <sil=0.000> is <sil=0.000> a pointer <sil=0.000> to <sil=0.000> a
variable <sil=0.000> v 1 <sil=1.000> ,COMMA  which <sil=0.000> is <sil=0.000> also <sil=0.000> an <sil=0.000> integer- v <sil=0.000> 1 located <sil=0.000> at <sil=0.000> location <sil=0.000> thousand <sil=2.000> .PERIOD 

This <sil=0.000> two <sil=0.000> lines <sil=0.000> are <sil=0.000> just <sil=0.000> meaning <sil=0.000> these <sil=0.000> two <sil=0.000> things- this <sil=0.000> two <sil=0.000> pictures <sil=1.000> ,COMMA  this <sil=0.000> 5000 <sil=0.000> or <sil=0.000> 1000 <sil=0.000> this <sil=0.000> part <sil=0.000> is
not <sil=0.000> known <sil=0.000> to <sil=0.000> us <sil=1.000> ,COMMA  because <sil=0.000> that <sil=0.000> is <sil=0.000> known <sil=0.000> by <sil=0.000> the <sil=0.000> compiler <sil=0.000> not <sil=0.000> by <sil=0.000> us <sil=1.000> ,COMMA  but <sil=0.000> logically  <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> the
picture <sil=1.000> ,COMMA  leave <sil=0.000> aside <sil=0.000> this <sil=0.000> 5000 <sil=0.000> and <sil=0.000> 1000  <sil=1.000> ,COMMA <sil=0.000> only <sil=0.000> these <sil=0.000> 2 parts <sil=0.000> are <sil=0.000> declared <sil=0.000> by <sil=0.000> this <sil=2.000> .PERIOD  Now <sil=0.000> if <sil=0.000> I say <sil=0.000> star
p <sil=0.000> 1 <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  the <sil=0.000> content <sil=0.000> of <sil=0.000> p 1 <sil=1.000> ,COMMA  whatever <sil=0.000> is <sil=0.000> the <sil=0.000> content <sil=0.000> of <sil=0.000> p 1 -now <sil=0.000> if <sil=0.000> I make <sil=0.000> p 1 <sil=0.000> to <sil=0.000> point <sil=0.000> to <sil=0.000> v
1 <sil=0.000> in <sil=0.000> that <sil=0.000> case <sil=0.000> if <sil=0.000> I make <sil=0.000> p 1 <sil=0.000> point <sil=0.000> to <sil=0.000> v 1 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  what <sil=0.000> will <sil=0.000> that <sil=0.000> be <sil=0.228> ?QUESTIONMARK  Content <sil=0.000> of <sil=0.000> p 1 <sil=0.000> should <sil=0.000> be <sil=0.000> assigned <sil=0.000> to &of <sil=0.000> v 1 <sil=2.000> .PERIOD  The &of <sil=0.000> v 1 <sil=0.000> will <sil=0.000> give <sil=0.000> me
the <sil=0.000> address <sil=0.000> of <sil=0.000> this <sil=0.000> and <sil=0.000> the <sil=0.000> content <sil=0.000> of <sil=0.000> p 1 <sil=0.000> will <sil=0.000> get <sil=0.000> that <sil=2.000> .PERIOD  Therefore <sil=1.000> ,COMMA  this <sil=0.000> 1000 <sil=0.000> will <sil=0.000> be <sil=0.000> written <sil=0.000> over
here <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  this <sil=0.000> pointer <sil=0.000> is <sil=0.000> pointed <sil=0.000> to <sil=0.000> this <sil=0.000> v 1 <sil=2.000> .PERIOD  I <sil=0.000> will <sil=0.000> not <sil=0.000> go <sil=0.000> in <sil=0.000> to <sil=0.000> further <sil=0.000> details <sil=0.000> of <sil=0.000> this <sil=0.000> right
now <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> come <sil=0.000> to <sil=0.000> this <sil=0.000> as <sil=0.000> an <sil=0.000> when <sil=0.000> the <sil=0.000> context <sil=0.000> comes <sil=0.000> later <sil=2.000> .PERIOD  Right <sil=0.000> now <sil=0.000> we <sil=0.000> this <sil=0.000> in <sil=0.000> mind <sil=0.000> let <sil=0.000> us
go <sil=0.000> back <sil=0.000> to <sil=0.000> the <sil=0.000> algorithm <sil=0.000> of <sil=0.000> bubble <sil=0.000> sort <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> being <sil=0.000> done <sil=0.000> on <sil=0.000> the <sil=0.000> algorithm <sil=0.000> of <sil=0.000> bubble <sil=0.000> sort <sil=2.000> .PERIOD 

Let <sil=0.000> us <sil=0.000> try <sil=0.000> to <sil=0.000> understand <sil=0.000> each <sil=0.000> of <sil=0.000> the <sil=0.000> functions -first <sil=0.000> thing <sil=0.000> is <sil=0.000> we <sil=0.000> have <sil=0.000> got <sil=0.000> this <sil=0.000> standard <sil=0.000> equation <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  first <sil=0.000> I will <sil=0.000> start <sil=0.000> with <sil=0.000> this <sil=0.000> function <sil=0.000> void <sil=0.000> bubble <sil=0.000> sort -bubble <sil=0.000> sort <sil=0.000> is <sil=0.000> void <sil=1.000> ,COMMA  because <sil=0.000> it <sil=0.000> is <sil=0.000> not
returning <sil=0.000> any <sil=0.000> value  <sil=1.000> ,COMMA <sil=0.000> it <sil=0.000> is <sil=0.000> just <sil=0.000> sorting <sil=0.000> some <sil=0.000> element -what <sil=0.000> array <sil=0.228> ?QUESTIONMARK  x <sil=0.000> array <sil=0.000> and <sil=0.000> the <sil=0.000> size <sil=0.000> of <sil=0.000> the <sil=0.000> array
is <sil=0.000> n <sil=1.000> ,COMMA  int <sil=0.000> ij <sil=0.000> these <sil=0.000> are <sil=0.000> 2 local <sil=0.000> variable <sil=0.000> because <sil=0.000> they <sil=0.000> are <sil=0.000> using <sil=0.000> used <sil=0.000> as <sil=0.000> indexes <sil=0.000> of <sil=0.000> these <sil=0.000> two <sil=0.000> loop <sil=2.000> .PERIOD  In
this <sil=0.000> loop <sil=0.000> what <sil=0.000> is <sil=0.000> happening <sil=0.228> ?QUESTIONMARK - for <sil=0.000> I assigned <sil=0.000> n minus <sil=0.000> 1 to <sil=0.000> 0 <sil=0.354> ;SEMICOLON  i <sil=0.000> minus <sil=0.000> minus <sil=0.354> ;SEMICOLON  what <sil=0.000> does <sil=0.000> that <sil=0.000> mean <sil=0.228> ?QUESTIONMARK 
That <sil=0.000> means <sil=1.000> ,COMMA  if <sil=0.000> I have <sil=0.000> an <sil=0.000> array <sil=0.000> here <sil=0.000> this <sil=0.000> is <sil=0.000> my <sil=0.000> array <sil=0.000> I have <sil=0.000> got <sil=0.000> I pointing <sil=0.000> here <sil=2.000> .PERIOD 

Because <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> the <sil=0.000> size <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=0.000> minus <sil=0.000> 1 <sil=2.000> .PERIOD <sil=0.000> So <sil=1.000> ,COMMA  i <sil=0.000> is <sil=0.000> pointing <sil=0.000> here <sil=0.000> and <sil=0.000> it <sil=0.000> will <sil=0.000> go <sil=0.000> up <sil=0.000> to <sil=0.000> 0 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
gradually <sil=0.000> it <sil=0.000> will <sil=0.000> go <sil=0.000> in <sil=0.000> this <sil=0.000> direction <sil=0.000> up <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> what <sil=0.000> the <sil=0.000> first <sil=0.000> for <sil=0.000> loop <sil=0.000> is <sil=0.000> saying <sil=2.000> .PERIOD  First <sil=0.000> for <sil=0.000> loop <sil=0.000> is
saying <sil=0.000> that <sil=0.000> I is <sil=0.000> starting <sil=0.000> from <sil=0.000> the <sil=0.000> bottom <sil=0.000> and <sil=0.000> going <sil=0.000> up <sil=0.000> upto <sil=0.000> 0 as <sil=0.000> long <sil=0.000> as <sil=0.000> it <sil=0.000> is <sil=0.000> greater <sil=0.000> than <sil=0.000> 0 and
then <sil=0.000> for <sil=0.000> j equal <sil=0.000> to <sil=0.000> 0 to <sil=0.000> j less <sil=0.000> than <sil=0.000> i  <sil=0.354> ;SEMICOLON <sil=0.000> j plus <sil=0.000> plus <sil=2.000> .PERIOD <sil=0.000> If <sil=0.000> xj <sil=0.000> is <sil=0.000> greater <sil=0.000> than <sil=0.000> xj <sil=0.000> plus <sil=0.000> 1 <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  what <sil=0.000> if
xj <sil=0.000> is <sil=0.000> greater <sil=0.000> than <sil=0.000> xj <sil=0.000> plus <sil=0.000> 1 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> again <sil=0.000> go <sil=0.000> back <sil=0.000> to <sil=0.000> this <sil=0.000> j is <sil=0.000> starting <sil=0.000> from <sil=0.000> 0 and <sil=0.000> I am <sil=0.000> comparing <sil=0.000> this <sil=0.000> value <sil=0.000> 50 <sil=0.000> with <sil=0.000> the
value <sil=0.000> 2 with <sil=0.000> j plus <sil=0.000> 1 <sil=2.000> .PERIOD <sil=0.000> This <sil=0.000> is <sil=0.000> j plus <sil=0.000> 1 if <sil=0.000> xj <sil=0.000> is <sil=0.000> greater <sil=0.000> than <sil=0.000> xj <sil=0.000> plus <sil=0.000> 1 <sil=1.000> ,COMMA  what <sil=0.000> would <sil=0.000> I do <sil=0.000> I would <sil=0.000> swap <sil=2.000> .PERIOD 
Let <sil=0.000> us <sil=0.000> go <sil=0.000> into <sil=0.000> here <sil=0.000> if <sil=0.000> xj <sil=0.000> is <sil=0.000> greater <sil=0.000> than <sil=0.000> xj <sil=0.000> plus <sil=0.000> 1 I <sil=0.000> am <sil=0.000> swapping <sil=0.000> xj <sil=0.000> and <sil=0.000> xj <sil=0.000> plus <sil=0.000> 1 <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> come <sil=0.000> to
the <sil=0.000> swap <sil=0.000> function <sil=0.000> later <sil=0.000> am <sil=0.000> assuming <sil=0.000> that <sil=0.000> the <sil=0.000> swap <sil=0.000> is <sil=0.000> working <sil=0.000> correctly- that <sil=0.000> means <sil=0.000> it <sil=0.000> is
swapping <sil=0.000> them <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> happening <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  this <sil=0.000> loop <sil=0.000> will <sil=0.000> go <sil=0.000> on- j <sil=0.000> equal <sil=0.000> to <sil=0.000> 0 then <sil=0.000> j will <sil=0.000> be <sil=0.000> 1 and <sil=0.000> in <sil=0.000> that <sil=0.000> way <sil=0.000> it
will <sil=0.000> go <sil=0.000> on <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  next <sil=0.000> when <sil=0.000> I swap <sil=0.000> it <sil=0.000> becomes <sil=0.000> 2 and <sil=0.000> 50 <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> other <sil=0.000> values <sil=0.000> now <sil=0.000> j is
being <sil=0.000> incremented <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> becoming <sil=0.000> j and <sil=0.000> this <sil=0.000> is <sil=0.000> becoming <sil=0.000> j plus <sil=0.000> 1- in <sil=0.000> that <sil=0.000> way <sil=0.000> this
swapping <sil=0.000> will <sil=0.000> be <sil=0.000> done <sil=2.000> .PERIOD  Suppose <sil=0.000> this <sil=0.000> is <sil=0.000> 70 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  there <sil=0.000> will <sil=0.000> be <sil=0.000> no <sil=0.000> swap <sil=0.000> no <sil=0.000> swap <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> see <sil=0.000> here <sil=1.000> ,COMMA  if <sil=0.000> this <sil=0.000> condition <sil=0.000> does <sil=0.000> not <sil=0.000> hold -swap <sil=0.000> is <sil=0.000> not <sil=0.000> taking <sil=0.000> place <sil=2.000> .PERIOD <sil=0.000> I am <sil=0.000> going <sil=0.000> back <sil=0.000> to
this <sil=0.000> loop  <sil=2.000> .PERIOD <sil=0.000> Now <sil=1.000> ,COMMA  70 <sil=0.000> remains <sil=0.000> here  <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  j <sil=0.000> changes <sil=0.000> and <sil=0.000> j plus <sil=0.000> 1 is <sil=0.000> pointing <sil=0.000> here <sil=0.000> now <sil=0.000> there <sil=0.000> will
be <sil=0.000> a swap <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> 12 <sil=0.000> say -12 <sil=0.000> and <sil=0.000> 70 <sil=0.000> will <sil=0.000> be <sil=0.000> swapped <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  2 <sil=1.000> ,COMMA <sil=0.000> 50 <sil=1.000> ,COMMA <sil=0.000> 12 <sil=0.000> 70 <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=0.000> I will
go <sil=0.000> on <sil=0.000> up <sil=0.000> to <sil=0.000> this <sil=0.000> point <sil=0.000> and <sil=0.000> next <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  ultimately <sil=0.000> in <sil=0.000> this <sil=0.000> iteration <sil=0.000> ultimately <sil=0.000> I will <sil=0.000> have <sil=0.000> this <sil=0.000> heaviest <sil=0.000> element <sil=0.000> say <sil=0.000> 70 <sil=0.000> is <sil=0.000> the <sil=0.000> heaviest
element <sil=1.000> ,COMMA  then <sil=0.000> I will <sil=0.000> be <sil=0.000> decremented <sil=0.000> and <sil=0.000> I will <sil=0.000> come <sil=0.000> here <sil=0.000> and <sil=0.000> then <sil=0.000> from <sil=0.000> this <sil=0.000> zone <sil=0.000> again <sil=0.000> I will <sil=0.000> do
the <sil=0.000> same <sil=0.000> thing <sil=0.000> as <sil=0.000> I did <sil=0.000> till <sil=0.000> now  <sil=2.000> .PERIOD  Exactly <sil=0.000> that <sil=0.000> is <sil=0.000> being <sil=0.000> done <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> be <sil=0.000> doing <sil=0.000> this <sil=0.000> and <sil=0.000> then
I <sil=0.000> will <sil=0.000> decrement <sil=0.000> n little <sil=0.000> bit <sil=0.000> and <sil=0.000> I will <sil=0.000> go <sil=0.000> on <sil=0.000> doing <sil=0.000> this <sil=2.000> .PERIOD  I <sil=0.000> will <sil=0.000> be <sil=0.000> then <sil=0.000> looping- doing <sil=0.000> the <sil=0.000> same
loop <sil=0.000> again <sil=0.000> for <sil=0.000> 1 level <sil=0.000> less <sil=0.000> I mean <sil=0.000> the <sil=0.000> last <sil=0.000> element <sil=0.000> is <sil=0.000> already <sil=0.000> having <sil=0.000> the <sil=0.000> heaviest <sil=0.000> element <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I
will <sil=0.000> do <sil=0.000> it <sil=0.000> among <sil=0.000> the <sil=0.000> remaining <sil=0.000> part <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> part <sil=0.000> this <sil=0.000> part <sil=0.000> is <sil=0.000> already <sil=0.000> covered <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> decremented <sil=0.000> it <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> be <sil=0.000> now <sil=0.000> playing <sil=0.000> in
this <sil=0.000> zone <sil=0.000> and <sil=0.000> once <sil=0.000> that <sil=0.000> is <sil=0.000> done <sil=0.000> this <sil=0.000> part <sil=0.000> will <sil=0.000> also <sil=0.000> be <sil=0.000> coveredI <sil=0.000> will <sil=0.000> be <sil=0.000> playing <sil=0.000> in <sil=0.000> this <sil=0.000> zone  <sil=2.000> .PERIOD <sil=0.000> Every
time <sil=0.000> am <sil=0.000> deciding <sil=0.000> on <sil=0.000> the <sil=0.000> zone  <sil=1.000> ,COMMA  n <sil=1.000> ,COMMA  n <sil=0.000> minus <sil=0.000> 1 n <sil=0.000> minus <sil=0.000> 2 like <sil=0.000> that <sil=0.000> it <sil=0.000> is <sil=0.000> going <sil=0.000> on <sil=0.000> and <sil=0.000> every <sil=0.000> time <sil=0.000> I am
doing <sil=0.000> this <sil=0.000> loop <sil=0.000> for <sil=0.000> each <sil=0.000> of <sil=0.000> the <sil=0.000> pair <sil=0.000> wise <sil=0.000> element <sil=0.000> comparison <sil=0.000> and <sil=0.000> they <sil=0.000> are <sil=0.000> by <sil=0.000> am <sil=0.000> pushing <sil=0.000> the
heaviest <sil=0.000> element <sil=0.000> at <sil=0.000> the <sil=0.000> bottom <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> the <sil=0.000> code <sil=0.000> for <sil=0.000> bubble <sil=0.000> sort <sil=0.000> how <sil=0.000> it <sil=0.000> works <sil=0.000> this <sil=0.000> swap <sil=0.000> keeps <sil=0.000> a I
have <sil=0.000> not <sil=0.000> saying <sil=0.000> this <sil=0.000> swap <sil=2.000> .PERIOD  Earlier <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=0.000> that <sil=0.000> if <sil=0.000> we <sil=0.000> do <sil=0.000> swap <sil=0.000> in <sil=0.000> any <sil=0.000> arbitrary <sil=0.000> way <sil=2.000> .PERIOD 

For <sil=0.000> example <sil=1.000> ,COMMA  if <sil=0.000> I want <sil=0.000> to <sil=0.000> swap <sil=0.000> 2 variables <sil=0.000> say <sil=0.000> I write <sil=0.000> swap <sil=0.000> int <sil=0.000> a <sil=1.000> ,COMMA  int <sil=0.000> b- let <sil=0.000> me <sil=0.000> do <sil=0.000> it <sil=0.000> here  <sil=1.000> ,COMMA  if <sil=0.000> I just
do <sil=0.000> swap <sil=0.000> int <sil=0.000> a <sil=1.000> ,COMMA  int <sil=0.000> b and <sil=0.000> inside <sil=0.000> I use <sil=0.000> another <sil=0.000> variable <sil=0.000> temp <sil=1.000> ,COMMA  temp <sil=0.000> gets <sil=0.000> a  <sil=1.000> ,COMMA  a <sil=0.000> is <sil=0.000> stored <sil=0.000> here <sil=0.000> a gets <sil=0.000> b
and <sil=0.000> then <sil=0.000> temp <sil=0.000> has <sil=0.000> been <sil=0.000> remembered <sil=0.000> there <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  b <sil=0.000> gets <sil=0.000> temp <sil=0.000> and <sil=0.000> so <sil=1.000> ,COMMA  this <sil=0.000> was <sil=0.000> my <sil=0.000> function <sil=0.000> return <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> suppose <sil=0.000> a (when <sil=0.000> it <sil=0.000> came) it <sil=0.000> was <sil=0.000> called <sil=0.000> with <sil=0.000> x and <sil=0.000> y s <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  main <sil=0.000> program <sil=0.000> called <sil=0.000> swap
with <sil=0.000> x and <sil=0.000> y and <sil=0.000> x was <sil=0.000> 5 <sil=1.000> ,COMMA  y <sil=0.000> was <sil=0.000> 7 right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  x <sil=0.000> was <sil=0.000> a location -here <sil=0.000> 5 and <sil=0.000> y was <sil=0.000> a location <sil=0.000> 7 <sil=2.000> .PERIOD  Now
when <sil=0.000> it <sil=0.000> came <sil=0.000> here  a  was <sil=0.000> a local <sil=0.000> location <sil=0.000> and <sil=0.000> I know <sil=0.000> that <sil=0.000> the <sil=0.000> functions <sil=0.000> are <sil=0.000> called <sil=0.000> by <sil=0.000> value <sil=0.000> so <sil=1.000> ,COMMA  5
was <sil=0.000> copied <sil=0.000> in <sil=0.000> a and <sil=0.000> 7 was <sil=0.000> copied <sil=0.000> in <sil=0.000> b and <sil=0.000> then <sil=0.000> by <sil=0.000> this <sil=0.000> temp <sil=0.000> became <sil=0.000> 5 <sil=1.000> ,COMMA  b <sil=0.000> became <sil=0.000> 5 and <sil=0.000> b was
stored <sil=0.000> in <sil=0.000> a <sil=2.000> .PERIOD  This <sil=0.000> was <sil=0.000> stored <sil=0.000> in <sil=0.000> this -these <sil=0.000> became <sil=0.000> 7 and <sil=0.000> this <sil=0.000> again <sil=0.000> became <sil=0.000> 5 -all <sil=0.000> right <sil=2.000> .PERIOD <sil=0.000> That <sil=0.000> is <sil=0.000> how
it <sil=0.000> was <sil=0.000> done <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  a <sil=0.000> was <sil=0.000> 5 so <sil=1.000> ,COMMA  temp <sil=0.000> was <sil=0.000> 5 <sil=2.000> .PERIOD  7 <sil=0.000> went <sil=0.000> over <sil=0.000> here <sil=0.000> to <sil=0.000> a and <sil=0.000> here <sil=0.000> 5 was <sil=0.000> copied <sil=0.000> again <sil=0.000> here- this <sil=0.000> was
fine <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> swapping <sil=0.000> was <sil=0.000> done <sil=0.000> by <sil=0.000> a by <sil=0.000> b and <sil=0.000> then <sil=0.000> when <sil=0.000> I returned <sil=0.000> no <sil=0.000> change <sil=0.000> is <sil=0.000> reflected <sil=0.000> in <sil=0.000> x
and <sil=0.000> y -that <sil=0.000> was <sil=0.000> the <sil=0.000> problem <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> now <sil=0.000> see <sil=0.000> how <sil=0.000> the <sil=0.000> swap <sil=0.000> function <sil=0.000> can <sil=0.000> be <sil=0.000> implemented <sil=2.000> .PERIOD <sil=0.000> Another <sil=0.000> point <sil=0.000> is <sil=0.000> I have <sil=0.000> just
done <sil=0.000> return <sil=0.000> and <sil=0.000> a function <sil=0.000> can <sil=0.000> return <sil=0.000> only <sil=0.000> 1 value <sil=2.000> .PERIOD  I <sil=0.000> could <sil=0.000> not <sil=0.000> return <sil=0.000> a and <sil=0.000> b to <sil=0.000> the <sil=0.000> main
function <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  how <sil=0.000> can <sil=0.000> the <sil=0.000> thing <sil=0.000> be <sil=0.000> managed <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> after <sil=0.000> the <sil=0.000> swapping <sil=0.000> the <sil=0.000> result <sil=0.000> is <sil=0.000> reflected
back <sil=0.000> in <sil=0.000> the <sil=0.000> main <sil=0.000> function <sil=2.000> .PERIOD  We <sil=0.000> will <sil=0.000> see <sil=0.000> that <sil=0.000> in <sil=0.000> the <sil=0.000> next <sil=0.000> lecture <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  we <sil=0.000> are <sil=0.000> discussing <sil=0.000> about <sil=0.000> bubble <sil=0.000> sort <sil=0.000> and <sil=0.000> we <sil=0.000> had <sil=0.000> looked <sil=0.000> at <sil=0.000> some <sil=0.000> notion <sil=0.000> of <sil=0.000> pointers <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you
have <sil=0.000> now <sil=0.000> got <sil=0.000> the <sil=0.000> preliminary <sil=0.000> idea <sil=0.000> about <sil=0.000> pointers <sil=2.000> .PERIOD 

On <sil=0.000> this <sil=0.000> segment <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=0.000> this <sil=0.000> part <sil=0.000> of <sil=0.000> the <sil=0.000> code <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> seen - this <sil=0.000> is <sil=0.000> the <sil=0.000> bubble <sil=0.000> sort
function <sil=0.000> on <sil=0.000> this <sil=0.000> side <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> got <sil=0.000> a function <sil=0.000> which <sil=0.000> is <sil=0.000> swapping <sil=0.000> 2 variables <sil=2.000> .PERIOD  I <sil=0.000> want <sil=0.000> to <sil=0.000> swap <sil=0.000> x and
y <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> swap <sil=0.000> function <sil=0.000> is <sil=0.000> taking <sil=0.000> x and <sil=0.000> y <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> seen <sil=0.000> earlier <sil=0.000> that <sil=0.000> in <sil=0.000> the <sil=0.000> normal <sil=0.000> case <sil=0.000> if <sil=0.000> we <sil=0.000> if
we <sil=0.000> swap <sil=0.000> in <sil=0.000> a function (suppose <sil=0.000> I have <sil=0.000> got <sil=0.000> a void <sil=0.000> swap <sil=0.000> xy)

(Refer <sil=0.000> Slide <sil=0.000> Time: 01:26)

Then <sil=0.000> we <sil=0.000> are <sil=0.000> shown (we <sil=0.000> used <sil=0.000> another <sil=0.000> variable <sil=0.000> int <sil=0.000> temp) that <sil=0.000> whatever <sil=0.000> swapping <sil=0.000> I am <sil=0.000> doing <sil=0.000> here
that <sil=0.000> is <sil=0.000> not <sil=0.000> being <sil=0.000> reflected <sil=0.000> in <sil=0.000> the <sil=0.000> main <sil=0.000> function <sil=1.000> ,COMMA  that <sil=0.000> we <sil=0.000> saw <sil=2.000> .PERIOD <sil=0.000> Now <sil=0.000> what <sil=0.000> we <sil=0.000> are <sil=0.000> doing <sil=0.000> here <sil=0.000> let <sil=0.000> us
see <sil=0.000> here <sil=0.000> I am <sil=0.000> writing <sil=0.000> void <sil=0.000> swap <sil=1.000> ,COMMA  instead <sil=0.000> of <sil=0.000> writing <sil=0.000> x and <sil=0.000> y I <sil=0.000> am <sil=0.000> writing <sil=0.000> int <sil=0.000> star <sil=0.000> x comma <sil=0.000> int <sil=0.000> star
y <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  what <sil=0.000> I am <sil=0.000> passing <sil=0.000> here <sil=0.000> is <sil=0.000> my <sil=0.000> swap <sil=0.000> function <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> my <sil=0.000> swap <sil=0.000> function <sil=0.000> and <sil=0.000> it <sil=0.000> has
got <sil=0.000> 2 input <sil=0.000> parameters <sil=0.000> a function <sil=0.000> has <sil=0.000> got <sil=0.000> always <sil=0.000> one <sil=0.000> output <sil=1.000> ,COMMA  there <sil=0.000> can <sil=0.000> be <sil=0.000> a number <sil=0.000> of <sil=0.000> input
parameters <sil=0.000> earlier <sil=0.000> it <sil=0.000> was <sil=0.000> x and <sil=0.000> y <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  some <sil=0.000> variables <sil=0.000> x and <sil=0.000> y were <sil=0.000> having <sil=0.000> actual <sil=0.000> parameters <sil=0.000> being <sil=0.000> copied <sil=0.000> into <sil=0.000> them <sil=1.000> ,COMMA  but <sil=0.000> now <sil=0.000> I
have <sil=0.000> not <sil=0.000> used <sil=0.000> x and <sil=0.000> y instead <sil=0.000> I am <sil=0.000> using <sil=0.000> pointer <sil=0.000> to <sil=0.000> x and <sil=0.000> pointer <sil=0.000> to <sil=0.000> y <sil=2.000> .PERIOD 

(Refer <sil=0.000> Slide <sil=0.000> Time: 03:30)

That <sil=0.000> means <sil=1.000> ,COMMA  now <sil=0.000> I am <sil=0.000> in <sil=0.000> my <sil=0.000> main <sil=0.000> function -here <sil=0.000> is <sil=0.000> my <sil=0.000> main <sil=0.000> function <sil=0.000> or <sil=0.000> the <sil=0.000> calling <sil=0.000> function <sil=0.000> not
necessarily <sil=0.000> the <sil=0.000> main <sil=0.000> function <sil=2.000> .PERIOD  In <sil=0.000> this <sil=0.000> case <sil=0.000> it <sil=0.000> was <sil=0.000> called <sil=0.000> from <sil=0.000> bubble <sil=0.000> sort <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> calling <sil=0.000> function
-I <sil=0.000> should <sil=0.000> not <sil=0.000> say <sil=0.000> main <sil=0.000> it <sil=0.000> should <sil=0.000> the <sil=0.000> calling <sil=0.000> function <sil=2.000> .PERIOD  The <sil=0.000> calling <sil=0.000> function <sil=0.000> has <sil=0.000> got <sil=0.000> 2 variables <sil=0.000> x
and <sil=0.000> y <sil=2.000> .PERIOD 

Now <sil=0.000> when <sil=0.000> I am <sil=0.000> calling <sil=0.000> this <sil=0.000> function <sil=0.000> void <sil=0.000> swap <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> actually <sil=0.000> having <sil=0.000> the <sil=0.000> function <sil=0.000> here -the
swap <sil=0.000> function <sil=2.000> .PERIOD  I <sil=0.000> am <sil=0.000> not <sil=0.000> passing <sil=0.000> the <sil=0.000> values <sil=0.000> of <sil=0.000> x and <sil=0.000> y <sil=1.000> ,COMMA  to <sil=0.000> be <sil=0.000> to <sil=0.000> be <sil=0.000> more <sil=0.000> natural <sil=0.000> let <sil=0.000> us <sil=0.000> make <sil=0.000> this
actual <sil=0.000> parameters <sil=0.000> are <sil=0.000> a and <sil=0.000> b <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  somehow <sil=0.000> I am <sil=0.000> calling <sil=0.000> here <sil=0.000> swap <sil=0.000> in <sil=0.000> my <sil=0.000> calling <sil=0.000> function <sil=0.000> I am <sil=0.000> calling <sil=0.000> swap <sil=0.000> a comma <sil=0.000> b <sil=2.000> .PERIOD  If <sil=0.000> I
had <sil=0.000> done <sil=0.000> this <sil=0.000> then <sil=0.000> this <sil=0.000> value <sil=0.000> of <sil=0.000> a and <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> b would <sil=0.000> have <sil=0.000> been <sil=0.000> copied <sil=0.000> there <sil=1.000> ,COMMA  but <sil=0.000> instead
what <sil=0.000> I am <sil=0.000> doing <sil=0.000> now- I <sil=0.000> will <sil=0.000> not <sil=0.000> write <sil=0.000> this <sil=0.000> instead <sil=0.000> I will <sil=0.000> write <sil=0.000> int <sil=0.000> star <sil=0.000> a and <sil=0.000> int <sil=0.000> star <sil=0.000> b <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> can
say <sil=0.000> here <sil=0.000> I am <sil=0.000> passing <sil=0.000> star <sil=0.000> a comma <sil=0.000> star <sil=0.000> b <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  what <sil=0.228> ?QUESTIONMARK  I <sil=0.000> am <sil=0.000> passing <sil=0.000> the <sil=0.000> pointers <sil=2.000> .PERIOD <sil=0.000> I will <sil=0.000> I
will <sil=0.000> do <sil=0.000> it <sil=0.000> again <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=0.000> say <sil=2.000> .PERIOD <sil=0.000> Here <sil=0.000> I am <sil=0.000> passing <sil=0.000> the <sil=0.000> address <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  again <sil=0.000> let <sil=0.000> me <sil=0.000> do <sil=0.000> it <sil=0.000> in <sil=0.000> a
nicer <sil=0.000> way <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> the <sil=0.000> calling <sil=0.000> function <sil=2.000> .PERIOD 

(Refer <sil=0.000> Slide <sil=0.000> Time: 06:09)

The <sil=0.000> calling <sil=0.000> function <sil=0.000> has <sil=0.000> got <sil=0.000> the <sil=0.000> variables <sil=0.000> a and <sil=0.000> b and <sil=0.000> inside <sil=0.000> the <sil=0.000> calling <sil=0.000> function <sil=0.000> I am <sil=0.000> saying
swap- what <sil=0.000> should <sil=0.000> I pass <sil=0.000> on <sil=0.000> I instead <sil=0.000> of <sil=0.000> saying <sil=0.000> a and <sil=0.000> b <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> saying <sil=0.000> and <sil=0.000> a comma <sil=0.000> and <sil=0.000> b  <sil=2.000> .PERIOD <sil=0.000> You
know <sil=0.000> what <sil=0.000> is <sil=0.000> and <sil=0.000> a and <sil=0.000> and <sil=0.000> b <sil=0.228> ?QUESTIONMARK  And <sil=0.000> a means <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> a and <sil=0.000> b means <sil=0.000> address <sil=0.000> of <sil=0.000> b right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
I <sil=0.000> am <sil=0.000> actually <sil=0.000> passing <sil=0.000> the <sil=0.000> addresses <sil=0.000> of <sil=0.000> a and <sil=0.000> b <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> address <sil=0.000> of <sil=0.000> a was <sil=0.000> say <sil=0.000> 1000 <sil=0.000> and <sil=0.000> this <sil=0.000> was
maybe <sil=0.000> 1500  <sil=2.000> .PERIOD 

Now <sil=0.000> here <sil=0.000> is <sil=0.000> my <sil=0.000> called <sil=0.000> function <sil=0.000> void <sil=0.000> swap <sil=0.000> int <sil=1.000> ,COMMA  now <sil=0.000> a and <sil=0.000> b have <sil=0.000> been <sil=0.000> declared- int <sil=0.000> star <sil=0.000> x comma
int <sil=0.000> star <sil=0.000> y <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> happening- what <sil=0.000> is <sil=0.000> being <sil=0.000> passed <sil=0.228> ?QUESTIONMARK  Here <sil=0.000> and <sil=0.000> a is <sil=0.000> being <sil=0.000> passed <sil=0.000> and <sil=0.000> here <sil=0.000> and
b <sil=0.000> is <sil=0.000> being <sil=0.000> passed <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  this <sil=0.000> address <sil=0.000> and <sil=0.000> this <sil=0.000> address <sil=0.000> are <sil=0.000> being <sil=0.000> passed <sil=0.000> 1000 <sil=0.000> and <sil=0.000> 1500 <sil=0.000> are
being <sil=0.000> passed <sil=2.000> .PERIOD 

Also <sil=0.000> I know <sil=0.000> here <sil=0.000> that <sil=0.000> what <sil=0.000> I am <sil=0.000> getting <sil=0.000> are <sil=0.000> the <sil=0.000> pointers <sil=0.000> to <sil=0.000> the <sil=0.000> variables <sil=0.000> that <sil=0.000> had <sil=0.000> to <sil=0.000> be <sil=0.000> swapped <sil=0.000> it <sil=0.000> was <sil=0.000> not <sil=0.000> int <sil=0.000> x or <sil=0.000> int <sil=0.000> y-let <sil=0.000> us <sil=0.000> go <sil=0.000> back <sil=0.000> to <sil=0.000> this <sil=0.000> once <sil=0.000> again <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> you <sil=0.000> see <sil=0.000> I am <sil=0.000> calling <sil=0.000> xj <sil=0.000> and <sil=0.000> xj
plus1 <sil=1.000> ,COMMA  in <sil=0.000> my <sil=0.000> bubble <sil=0.000> sort <sil=0.000> algorithm <sil=2.000> .PERIOD  In <sil=0.000> my <sil=0.000> bubble <sil=0.000> sort <sil=0.000> algorithm <sil=0.000> I had <sil=0.000> the <sil=0.000> array <sil=0.000> and <sil=0.000> j was <sil=0.000> here
and <sil=0.000> j plus <sil=0.000> one <sil=0.000> was <sil=0.000> here- this <sil=0.000> was <sil=0.000> already <sil=0.000> filled <sil=0.000> something <sil=0.000> and <sil=0.000> I am <sil=0.000> comparing <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> my <sil=0.000> i <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> work <sil=0.000> in <sil=0.000> this <sil=0.000> zone <sil=0.000> and <sil=0.000> I am <sil=0.000> looking <sil=0.000> at <sil=0.000> two <sil=0.000> elements <sil=0.000> j and <sil=0.000> j plus <sil=0.000> one <sil=0.000> and <sil=0.000> I want <sil=0.000> to <sil=0.000> swap
them <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  what <sil=0.000> I am <sil=0.000> doing <sil=0.000> is <sil=0.000> I am <sil=0.000> passing <sil=0.000> on <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> this <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  suppose <sil=0.000> this <sil=0.000> address <sil=0.000> was
thousand <sil=0.000> and <sil=0.000> this <sil=0.000> address <sil=0.000> was <sil=0.000> 1002 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> being <sil=0.000> passed <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> 1000 <sil=0.000> and <sil=0.000> this <sil=0.000> is
1002 <sil=2.000> .PERIOD  Now <sil=0.000> what <sil=0.000> is <sil=0.000> happening <sil=0.000> here -temp <sil=0.000> is <sil=0.000> a local <sil=0.000> variable <sil=1.000> ,COMMA  see <sil=0.000> temp <sil=0.000> is <sil=0.000> not <sil=0.000> a pointer <sil=1.000> ,COMMA  temp <sil=0.000> is <sil=0.000> a
local <sil=0.000> variable <sil=2.000> .PERIOD  Suppose <sil=0.000> here <sil=0.000> the <sil=0.000> point <sil=0.000> was <sil=0.000> this <sil=0.000> was <sil=0.000> 50 <sil=0.000> and <sil=0.000> this <sil=0.000> was <sil=0.000> 2 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  temp <sil=0.000> is <sil=0.000> getting <sil=0.000> the <sil=0.000> content <sil=0.000> of <sil=0.000> x right <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  1000s <sil=0.000> content <sil=0.000> thousands <sil=0.000> content <sil=0.000> was <sil=0.000> 50 <sil=1.000> ,COMMA  content <sil=0.000> of <sil=0.000> the <sil=0.000> pointer <sil=1.000> ,COMMA  content <sil=0.000> of <sil=0.000> x <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> 50 <sil=0.000> is <sil=0.000> being <sil=0.000> copied <sil=0.000> here <sil=0.000> and <sil=0.000> then <sil=0.000> what <sil=0.000> is <sil=0.000> happening <sil=0.000> content <sil=0.000> of <sil=0.000> y is <sil=0.000> coming <sil=0.000> to <sil=0.000> content <sil=0.000> of <sil=0.000> x <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  content <sil=0.000> of <sil=0.000> y is <sil=0.000> coming <sil=0.000> to <sil=0.000> content <sil=0.000> of <sil=0.000> x <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> becoming <sil=0.000> 2 <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> being <sil=0.000> swapped <sil=0.000> and <sil=0.000> is <sil=0.000> becoming <sil=0.000> 2 and <sil=0.000> temp <sil=0.000> is <sil=0.000> coming <sil=0.000> as <sil=0.000> the
content <sil=0.000> of <sil=0.000> y <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> becoming <sil=0.000> 50 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> happening <sil=0.000> all <sil=0.000> the <sil=0.000> changes <sil=0.000> were <sil=0.000> reflected <sil=0.000> here
in <sil=0.000> the <sil=0.000> main <sil=0.000> body <sil=0.000> of <sil=0.000> the <sil=0.000> data <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> how <sil=0.000> we <sil=0.000> could <sil=0.000> really <sil=0.000> reflect <sil=0.000> the <sil=0.000> change <sil=0.000> on <sil=0.000> to <sil=0.000> the <sil=0.000> calling
function <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  stated <sil=0.000> in <sil=0.000> another <sil=0.000> way <sil=0.000> it <sil=0.000> would <sil=0.000> be <sil=0.000> like <sil=0.000> this -let <sil=0.000> us <sil=0.000> say <sil=0.000> I have <sil=0.000> got <sil=0.000> a data <sil=0.000> here <sil=0.000> and <sil=0.000> here <sil=0.000> is <sil=0.000> my
calling <sil=0.000> function <sil=0.000> and <sil=0.000> here <sil=0.000> is <sil=0.000> my <sil=0.000> called <sil=0.000> function <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  there <sil=0.000> is <sil=0.000> some <sil=0.000> variable <sil=0.000> that <sil=0.000> is <sil=0.000> being <sil=0.000> used <sil=0.000> by <sil=0.000> the <sil=0.000> calling <sil=0.000> function <sil=0.000> say <sil=0.000> a <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  this <sil=0.000> a is
somewhere <sil=0.000> here <sil=1.000> ,COMMA  this <sil=0.000> a has <sil=0.000> been <sil=0.000> referred <sil=0.000> here <sil=2.000> .PERIOD <sil=0.000> It <sil=0.000> is <sil=0.000> not <sil=0.000> proper <sil=0.000> to <sil=0.000> show <sil=0.000> it <sil=0.000> here <sil=0.000> again <sil=2.000> .PERIOD  Now <sil=0.000> the
calling <sil=0.000> function <sil=0.000> is <sil=0.000> using <sil=0.000> the <sil=0.000> variable <sil=0.000> a somewhere <sil=0.000> here <sil=0.000> alright <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  when <sil=0.000> this <sil=0.000> variable <sil=0.000> is <sil=0.000> being
used <sil=0.000> as <sil=0.000> a parameter <sil=0.000> to <sil=0.000> this <sil=0.000> called <sil=0.000> function <sil=1.000> ,COMMA  instead <sil=0.000> of <sil=0.000> sending <sil=0.000> the <sil=0.000> variable -say <sil=0.000> some <sil=0.000> other
function <sil=0.000> I call <sil=0.000> and <sil=0.000> in <sil=0.000> that <sil=0.000> I pass <sil=0.000> on <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> that <sil=0.000> variable <sil=0.000> a <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  that <sil=0.000> address <sil=0.000> whatever <sil=0.000> this <sil=0.000> address <sil=0.000> is -this <sil=0.000> is <sil=0.000> 1000 <sil=1.000> ,COMMA <sil=0.000> that <sil=0.000> is <sil=0.000> being <sil=0.000> passed <sil=0.000> on <sil=0.000> to <sil=0.000> this <sil=0.000> called
function <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> called <sil=0.000> function <sil=0.000> on <sil=0.000> the <sil=0.000> other <sil=0.000> hand <sil=0.000> knows <sil=0.000> that <sil=0.000> it s <sil=0.000> input <sil=0.000> parameter <sil=0.000> is <sil=0.000> say <sil=0.000> called
function <sil=0.000> is <sil=0.000> f -is <sil=0.000> int <sil=0.000> what <sil=0.000> I am <sil=0.000> getting <sil=0.000> is <sil=0.000> int <sil=0.000> star <sil=0.000> x <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  what <sil=0.000> I am <sil=0.000> accepting <sil=0.000> as <sil=0.000> a called
function <sil=0.000> is <sil=0.000> nothing <sil=0.000> but <sil=0.000> a pointer <sil=0.000> to <sil=0.000> an <sil=0.000> integer <sil=0.000> variable <sil=2.000> .PERIOD 

Now <sil=0.000> so <sil=1.000> ,COMMA  the <sil=0.000> pointer <sil=0.000> to <sil=0.000> the <sil=0.000> integer <sil=0.000> variables -the <sil=0.000> 1000 <sil=0.000> comes <sil=0.000> up <sil=0.000> and <sil=0.000> here <sil=0.000> suppose <sil=0.000> it <sil=0.000> does
something <sil=0.000> with <sil=0.000> the <sil=0.000> content <sil=2.000> .PERIOD  Now <sil=0.000> here <sil=0.000> when <sil=0.000> I take <sil=0.000> this <sil=0.000> say <sil=0.000> star <sil=0.000> x <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  x <sil=0.000> is <sil=0.000> a pointer <sil=0.000> x is <sil=0.000> a
pointer <sil=0.000> to <sil=0.000> an <sil=0.000> integer <sil=0.000> and <sil=0.000> when <sil=0.000> I take <sil=0.000> star <sil=0.000> x asterix <sil=0.000> x <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  it s <sil=0.000> a content <sil=0.000> of <sil=0.000> this <sil=0.000> and
suppose <sil=0.000> I do <sil=0.000> it <sil=0.000> star <sil=0.000> x plus <sil=0.000> 1 <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  the <sil=0.000> content <sil=0.000> of <sil=0.000> this <sil=0.000> address <sil=0.000> same <sil=0.000> address <sil=0.000> x was <sil=0.000> 1000 <sil=0.000> and
the <sil=0.000> content <sil=0.000> of <sil=0.000> that <sil=0.000> 1000 <sil=0.000> is <sil=0.000> being <sil=0.000> added <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> it <sil=0.000> was <sil=0.000> 50 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> being <sil=0.000> added  <sil=1.000> ,COMMA <sil=0.000> where <sil=0.000> it <sil=0.000> is
being <sil=0.000> added <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> changing <sil=0.000> to <sil=0.000> 51 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> if <sil=0.000> you <sil=0.000> recall <sil=0.000> we <sil=0.000> had <sil=0.000> talked <sil=0.000> about <sil=0.000> two <sil=0.000> things <sil=0.000> when <sil=0.000> the <sil=0.000> functions <sil=0.000> are <sil=0.000> called <sil=0.000> we <sil=0.000> said <sil=0.000> that
usually <sil=0.000> c always <sil=0.000> calls <sil=0.000> by <sil=0.000> value <sil=0.000> except <sil=0.000> for <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> arrays <sil=1.000> ,COMMA  but <sil=0.000> here <sil=0.000> is <sil=0.000> an <sil=0.000> example <sil=0.000> where <sil=0.000> I can
also <sil=0.000> say <sil=0.000> this <sil=0.000> has <sil=0.000> been <sil=0.000> called <sil=0.000> by <sil=0.000> value <sil=0.000> of <sil=0.000> the <sil=0.000> pointer <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  in <sil=0.000> this <sil=0.000> case <sil=0.000> it <sil=0.000> is <sil=0.000> an <sil=0.000> example - call <sil=0.000> by
value <sil=0.000> of <sil=0.000> the <sil=0.000> pointer <sil=2.000> .PERIOD  That <sil=0.000> means <sil=1.000> ,COMMA  what <sil=0.000> I have <sil=0.000> copied <sil=0.000> it <sil=0.000> is <sil=0.000> only <sil=0.000> the <sil=0.000> pointer <sil=2.000> .PERIOD  Therefore <sil=1.000> ,COMMA  the <sil=0.000> change
that <sil=0.000> is <sil=0.000> being <sil=0.000> reflected <sil=0.000> is <sil=0.000> being <sil=0.000> reflected <sil=0.000> in <sil=0.000> the <sil=0.000> main <sil=0.000> program <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> way <sil=0.000> it <sil=0.000> is <sil=0.000> also <sil=0.000> a call <sil=0.000> by <sil=0.000> reference <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> way <sil=0.000> we <sil=0.000> can <sil=0.000> reflect <sil=0.000> the <sil=0.000> change <sil=0.000> of <sil=0.000> the
function <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> you <sil=0.000> ever <sil=0.000> faced <sil=0.000> the <sil=0.000> crisis <sil=0.000> that <sil=0.000> well <sil=0.000> I am <sil=0.000> writing <sil=0.000> a function <sil=1.000> ,COMMA  but <sil=0.000> I know <sil=0.000> a function
can <sil=0.000> only <sil=0.000> return <sil=0.000> 1 value <sil=1.000> ,COMMA  but <sil=0.000> I have <sil=0.000> got <sil=0.000> multiple <sil=0.000> values <sil=0.000> to <sil=0.000> return - this <sil=0.000> is <sil=0.000> a nice <sil=0.000> way <sil=0.000> in <sil=0.000> which <sil=0.000> you
can <sil=0.000> do <sil=0.000> it  <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> this <sil=0.000> we <sil=0.000> have <sil=0.000> a new <sil=0.000> concept <sil=0.000> we <sil=0.000> have <sil=0.000> learnt <sil=0.000> the <sil=0.000> use <sil=0.000> of <sil=0.000> pointers <sil=0.000> the <sil=0.000> notion <sil=0.000> of <sil=0.000> pointers
and <sil=0.000> how <sil=0.000> it <sil=0.000> can <sil=0.000> be <sil=0.000> used <sil=0.000> in <sil=0.000> the <sil=0.000> context <sil=0.000> of <sil=0.000> just <sil=0.000> learning <sil=0.000> another <sil=0.000> language <sil=2.000> .PERIOD  There <sil=0.000> is <sil=0.000> a bubble <sil=0.000> sort  <sil=2.000> .PERIOD 
Once <sil=0.000> again <sil=0.000> we <sil=0.000> revise <sil=0.000> the <sil=0.000> bubble <sil=0.000> sort -let <sil=0.000> us <sil=0.000> go <sil=0.000> to <sil=0.000> the <sil=0.000> next <sil=0.000> one <sil=0.000> and <sil=0.000> will <sil=0.000> come <sil=0.000> back <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  the <sil=0.000> main <sil=0.000> program (is <sil=0.000> taking <sil=0.000> a main <sil=0.000> function) is <sil=0.000> reading <sil=0.000> an <sil=0.000> array <sil=2.000> .PERIOD  This <sil=0.000> array <sil=0.000> is <sil=0.000> being <sil=0.000> read <sil=2.000> .PERIOD  I <sil=0.000> is <sil=0.000> an <sil=0.000> integer <sil=2.000> .PERIOD  Now <sil=0.000> for <sil=0.000> i 0 <sil=0.000> to <sil=0.000> less <sil=0.000> than <sil=0.000> 12 <sil=0.000> there <sil=0.000> were <sil=0.000> 12 <sil=0.000> elements <sil=0.000> here- print <sil=0.000> the <sil=0.000> array  <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> calling <sil=0.000> bubble <sil=0.000> sort <sil=0.000> with <sil=0.000> the <sil=0.000> array <sil=0.000> being <sil=0.000> passed <sil=0.000> and <sil=0.000> the <sil=0.000> size <sil=0.000> of <sil=0.000> the <sil=0.000> area <sil=0.000> being <sil=0.000> passed <sil=0.000> here <sil=2.000> .PERIOD  Now <sil=0.000> we <sil=0.000> go <sil=0.000> to <sil=0.000> bubble <sil=0.000> sort <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  I <sil=0.000> go <sil=0.000> to <sil=0.000> the <sil=0.000> earlier <sil=0.000> slide <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> I had <sil=0.000> seen <sil=0.000> earlier <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  there <sil=0.000> we <sil=0.000> go <sil=0.000> and <sil=0.000> call <sil=0.000> the <sil=0.000> bubble <sil=0.000> sort <sil=0.000> and <sil=0.000> the <sil=0.000> bubble <sil=0.000> sort <sil=0.000> in <sil=0.000> turn <sil=0.000> calls <sil=1.000> ,COMMA  swapping <sil=0.000> is <sil=0.000> done <sil=0.000> inside
the <sil=0.000> bubble <sil=0.000> sort <sil=0.000> and <sil=0.000> then <sil=0.000> we <sil=0.000> print <sil=0.000> the <sil=0.000> ultimate <sil=0.000> data <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  what <sil=0.000> will <sil=0.000> be <sil=0.000> the <sil=0.000> time <sil=0.000> complexity <sil=2.000> .PERIOD <sil=0.000> We <sil=0.000> have <sil=0.000> seen <sil=0.000> the <sil=0.000> time <sil=0.000> complexity <sil=0.000> in <sil=0.000> terms <sil=0.000> of <sil=0.000> the <sil=0.000> big <sil=0.000> o
notation <sil=0.000> at <sil=0.000> times <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> the <sil=0.000> worst <sil=0.000> case - let <sil=0.000> us <sil=0.000> once <sil=0.000> again <sil=0.000> recapitulate <sil=0.000> think <sil=0.000> of <sil=0.000> the <sil=0.000> algorithm <sil=0.000> that <sil=0.000> for <sil=0.000> something <sil=0.000> like <sil=0.000> this -first <sil=0.000> I had <sil=0.000> this <sil=0.000> size <sil=0.000> n <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  initially <sil=0.000> the <sil=0.000> number <sil=0.000> of <sil=0.000> comparisons <sil=0.000> were <sil=0.000> 1 then <sil=0.000> worst <sil=0.000> case <sil=0.000> 2 <sil=0.354> ;SEMICOLON  I <sil=0.000> first <sil=0.000> compare <sil=0.000> between <sil=0.000> these
two <sil=1.000> ,COMMA  then <sil=0.000> I compare <sil=0.000> between <sil=0.000> these <sil=0.000> two <sil=1.000> ,COMMA  then <sil=0.000> I compare <sil=0.000> between <sil=0.000> these <sil=0.000> two <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  depending <sil=0.000> on
the <sil=0.000> comparison <sil=0.000> I may <sil=0.000> or <sil=0.000> may <sil=0.000> not <sil=0.000> exchange <sil=0.000> all <sil=0.000> right <sil=0.000> may <sil=0.000> not <sil=0.000> swap <sil=1.000> ,COMMA  but <sil=0.000> I have <sil=0.000> to <sil=0.000> do <sil=0.000> n minus <sil=0.000> one
comparisons <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  first <sil=0.000> I do <sil=0.000> n minus <sil=0.000> one <sil=0.000> comparisons <sil=0.000> and <sil=0.000> if <sil=0.000> along <sil=0.000> with <sil=0.000> that <sil=0.000> I have <sil=0.000> done <sil=0.000> the
swapping <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> first <sil=0.000> position <sil=0.000> is <sil=0.000> now <sil=0.000> filled <sil=0.000> up <sil=0.000> with <sil=0.000> the <sil=0.000> largest <sil=0.000> element <sil=2.000> .PERIOD 

Then <sil=0.000> again <sil=0.000> I have <sil=0.000> to <sil=0.000> start <sil=0.000> from <sil=0.000> here <sil=0.000> compare <sil=0.000> again <sil=0.000> twice <sil=1.000> ,COMMA <sil=0.000> thrice <sil=2.000> .PERIOD <sil=0.000> In <sil=0.000> that <sil=0.000> way <sil=0.000> I go <sil=0.000> on <sil=0.000> comparing
the <sil=0.000> second <sil=0.000> time <sil=0.000> and <sil=0.000> by <sil=0.000> now <sil=0.000> this <sil=0.000> number <sil=0.000> of <sil=0.000> comparisons <sil=0.000> is <sil=0.000> n minus <sil=0.000> 2 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> second <sil=0.000> one <sil=0.000> will
also <sil=0.000> be <sil=0.000> filled <sil=0.000> up <sil=0.000> with <sil=0.000> the <sil=0.000> heaviest <sil=0.000> element <sil=0.000> and <sil=0.000> in <sil=0.000> that <sil=0.000> way <sil=0.000> I will <sil=0.000> go <sil=0.000> on <sil=0.000> ultimately <sil=0.000> last <sil=0.000> time <sil=0.000> is <sil=0.000> 1 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  the <sil=0.000> overall <sil=0.000> if <sil=0.000> I add <sil=0.000> them <sil=0.000> the <sil=0.000> number <sil=0.000> of <sil=0.000> comparisons <sil=0.000> is <sil=0.000> this <sil=0.000> and <sil=0.000> that <sil=0.000> is <sil=0.000> of <sil=0.000> the <sil=0.000> order <sil=0.000> of <sil=0.000> n
square <sil=1.000> ,COMMA  because <sil=0.000> it <sil=0.000> breaks <sil=0.000> down <sil=0.000> to <sil=0.000> n square <sil=0.000> minus <sil=0.000> n etc <sil=2.000> .PERIOD <sil=0.000> What <sil=0.000> is <sil=0.000> the <sil=0.000> best <sil=0.000> case <sil=0.228> ?QUESTIONMARK  What <sil=0.000> will <sil=0.000> be <sil=0.000> the
best <sil=0.000> case <sil=0.228> ?QUESTIONMARK  The <sil=0.000> best <sil=0.000> case <sil=0.000> is <sil=0.000> if <sil=0.000> you <sil=0.000> do <sil=0.000> not <sil=0.000> have <sil=0.000> to <sil=0.000> do <sil=0.000> any <sil=0.000> swap <sil=0.000> it <sil=0.000> is <sil=0.000> already <sil=0.000> sorted <sil=1.000> ,COMMA  but <sil=0.000> still <sil=0.000> you <sil=0.000> do <sil=0.000> not <sil=0.000> know <sil=0.000> that <sil=0.000> it <sil=0.000> is <sil=0.000> sorted <sil=0.000> you <sil=0.000> will <sil=0.000> have <sil=0.000> to <sil=0.000> compare <sil=0.000> them <sil=0.000> anyway <sil=2.000> .PERIOD 

Therefore <sil=1.000> ,COMMA  the <sil=0.000> best <sil=0.000> case <sil=0.000> will <sil=0.000> be <sil=0.000> the <sil=0.000> same <sil=2.000> .PERIOD  Can <sil=0.000> you <sil=0.000> make <sil=0.000> the <sil=0.000> best <sil=0.000> case <sil=0.000> with <sil=0.000> n minus <sil=0.000> 1
comparisons <sil=0.000> only <sil=0.228> ?QUESTIONMARK  That <sil=0.000> we <sil=0.000> can <sil=0.000> think <sil=0.000> of <sil=0.000> later <sil=1.000> ,COMMA  So <sil=0.000> all <sil=0.000> these <sil=0.000> searching <sil=0.000> and <sil=0.000> sorting <sil=0.000> we <sil=0.000> were <sil=0.000> doing
was <sil=0.000> using <sil=0.000> arrays <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  just <sil=0.000> a word <sil=0.000> of <sil=0.000> caution <sil=0.000> about <sil=0.000> some <sil=0.000> common <sil=0.000> pitfalls <sil=0.000> with <sil=0.000> arrays <sil=0.000> in <sil=0.000> C -is <sil=0.000> that <sil=0.000> often <sil=0.000> we <sil=0.000> can
exceed <sil=0.000> the <sil=0.000> array <sil=0.000> bound <sil=0.000> without <sil=0.000> really <sil=0.000> noting <sil=0.000> of <sil=0.000> that <sil=2.000> .PERIOD  For <sil=0.000> example <sil=1.000> ,COMMA  array <sil=0.000> size <sil=0.000> has <sil=0.000> been <sil=0.000> declared
to <sil=0.000> be <sil=0.000> 10 <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  my <sil=0.000> indices <sil=0.000> are <sil=0.000> from <sil=0.000> 0 to <sil=0.000> 9 right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> I write <sil=0.000> a for <sil=0.000> loop <sil=0.000> like <sil=0.000> this <sil=0.000> and <sil=0.000> I try
to <sil=0.000> initialise <sil=0.000> it <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> initialise <sil=0.000> to <sil=0.000> 1 0 <sil=1.000> ,COMMA  then <sil=0.000> 1 <sil=1.000> ,COMMA  then <sil=0.000> 2 <sil=1.000> ,COMMA  then <sil=0.000> 3 <sil=1.000> ,COMMA  till <sil=0.000> it <sil=0.000> is <sil=0.000> less <sil=0.000> than <sil=0.000> equal <sil=0.000> to <sil=0.000> 10 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> tenth
element <sil=0.000> is <sil=0.000> here -that <sil=0.000> will <sil=0.000> also <sil=0.000> be <sil=0.000> put <sil=0.000> to <sil=0.000> 0 <sil=1.000> ,COMMA  but <sil=0.000> that <sil=0.000> may <sil=0.000> be <sil=0.000> destroying <sil=0.000> some <sil=0.000> other <sil=0.000> memory
location <sil=0.000> therefore <sil=1.000> ,COMMA  that <sil=0.000> check <sil=0.000> is <sil=0.000> not <sil=0.000> there <sil=0.000> and <sil=0.000> c does <sil=0.000> not <sil=0.000> support <sil=0.000> array <sil=0.000> declarations <sil=0.000> with <sil=0.000> variable
expressions <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  quickly <sil=0.000> if <sil=0.000> we <sil=0.000> summarise <sil=0.000> what <sil=0.000> we <sil=0.000> learned <sil=0.000> here <sil=2.000> .PERIOD <sil=0.000> We <sil=0.000> are <sil=0.000> not <sil=0.000> talking <sil=0.000> about <sil=0.000> this <sil=0.000> in <sil=0.000> this <sil=0.000> course <sil=1.000> ,COMMA 
but <sil=0.000> what <sil=0.000> we <sil=0.000> have <sil=0.000> learned <sil=0.000> here <sil=0.000> is <sil=0.000> searching- we <sil=0.000> have <sil=0.000> seen <sil=0.000> and <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=0.000> two <sil=0.000> very <sil=0.000> efficient
methods <sil=0.000> of <sil=0.000> searching <sil=2.000> .PERIOD  One <sil=0.000> is <sil=0.000> the <sil=0.000> linear <sil=0.000> search <sil=0.000> which <sil=0.000> is <sil=0.000> simple <sil=0.000> and <sil=0.000> the <sil=0.000> better <sil=0.000> method <sil=0.000> is <sil=0.000> saw <sil=0.000> a
binary <sil=0.000> search <sil=1.000> ,COMMA  but <sil=0.000> binary <sil=0.000> search <sil=0.000> is <sil=0.000> effective <sil=0.000> when <sil=0.000> the <sil=0.000> array <sil=0.000> is <sil=0.000> already <sil=0.000> sorted <sil=2.000> .PERIOD 

We <sil=0.000> have <sil=0.000> learnt <sil=0.000> about <sil=0.000> how <sil=0.000> to <sil=0.000> sort <sil=0.000> an <sil=0.000> array <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> particularly <sil=0.000> looked <sil=0.000> at <sil=0.000> two <sil=0.000> sorting
algorithms- one <sil=0.000> is <sil=0.000> selection <sil=0.000> sort <sil=1.000> ,COMMA  another <sil=0.000> is <sil=0.000> the <sil=0.000> bubble <sil=0.000> sort <sil=0.000> and <sil=0.000> while <sil=0.000> discussing <sil=0.000> about <sil=0.000> bubble
sort <sil=0.000> we <sil=0.000> have <sil=0.000> also <sil=0.000> looked <sil=0.000> at <sil=0.000> a very <sil=0.000> interesting <sil=0.000> way <sil=0.000> of <sil=0.000> communicating <sil=0.000> between <sil=0.000> a function <sil=0.000> a caller
function <sil=0.000> and <sil=0.000> the <sil=0.000> called <sil=0.000> function <sil=1.000> ,COMMA  when <sil=0.000> I have <sil=0.000> to <sil=0.000> communicate <sil=0.000> or <sil=0.000> pass <sil=0.000> on <sil=0.000> or <sil=0.000> return <sil=0.000> more <sil=0.000> than <sil=0.000> 1
variable <sil=0.000> to <sil=0.000> the <sil=0.000> calling <sil=0.000> function <sil=2.000> .PERIOD  There <sil=0.000> we <sil=0.000> are <sil=0.000> using <sil=0.000> the <sil=0.000> pointers <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  we <sil=0.000> introduced <sil=0.000> the <sil=0.000> concept <sil=0.000> of <sil=0.000> pointers <sil=0.000> which <sil=0.000> are <sil=0.000> nothing <sil=1.000> ,COMMA  but <sil=0.000> the <sil=0.000> addresses <sil=0.000> of <sil=0.000> the <sil=0.000> variables <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  instead <sil=0.000> of <sil=0.000> passing <sil=0.000> on <sil=0.000> the <sil=0.000> value <sil=0.000> I am <sil=0.000> passing <sil=0.000> on <sil=0.000> the <sil=0.000> address <sil=0.000> and <sil=0.000> whatever <sil=0.000> I am <sil=0.000> doing <sil=0.000> I am
doing <sil=0.000> on <sil=0.000> the <sil=0.000> address <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> another <sil=0.000> important <sil=0.000> thing <sil=0.000> that <sil=0.000> we <sil=0.000> have <sil=0.000> covered <sil=0.000> in <sil=0.000> this <sil=0.000> lecture <sil=2.000> .PERIOD 
Next <sil=1.000> ,COMMA  I <sil=0.000> think <sil=0.000> we <sil=0.000> will <sil=0.000> go <sil=0.000> to <sil=0.000> some <sil=0.000> other <sil=0.000> concepts <sil=0.000> of <sil=0.000> arrays  <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  just <sil=0.000> to <sil=0.000> mention <sil=0.000> here <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=0.000> that <sil=0.000> the <sil=0.000> complexity <sil=0.000> of <sil=0.000> these <sil=0.000> algorithms <sil=0.000> are <sil=0.000> of <sil=0.000> order <sil=0.000> of <sil=0.000> n
square <sil=0.000> both <sil=0.000> for <sil=0.000> selection <sil=0.000> sort <sil=0.000> and <sil=0.000> for <sil=0.000> bubble <sil=0.000> sort <sil=1.000> ,COMMA  but <sil=0.000> can <sil=0.000> we <sil=0.000> have <sil=0.000> it <sil=0.000> better <sil=0.228> ?QUESTIONMARK  We <sil=0.000> have <sil=0.000> got <sil=0.000> two
very <sil=0.000> nice <sil=0.000> sorting <sil=0.000> algorithms <sil=0.354> ;SEMICOLON  one <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> the <sil=0.000> quick-sort <sil=0.000> another <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> the <sil=0.000> merge <sil=0.000> sort
Quick <sil=0.000> sort <sil=0.000> and <sil=0.000> Merge <sil=0.000> sort <sil=1.000> ,COMMA  which <sil=0.000> reduces <sil=0.000> the <sil=0.000> complexity <sil=0.000> of <sil=0.000> sorting <sil=0.000> and <sil=0.000> are <sil=0.000> very <sil=0.000> popular
algorithms <sil=1.000> ,COMMA  but <sil=0.000> we <sil=0.000> are <sil=0.000> not <sil=0.000> discussing <sil=0.000> it <sil=0.000> in <sil=0.000> this <sil=0.000> course <sil=0.000> for <sil=0.000> those <sil=0.000> of <sil=0.000> you <sil=0.000> interested <sil=0.000> can <sil=0.000> learn <sil=0.000> it <sil=0.000> later <sil=2.000> .PERIOD 

Next <sil=0.000> we <sil=0.000> will <sil=0.000> be <sil=0.000> moving <sil=0.000> in <sil=0.000> the <sil=0.000> next <sil=0.000> lecture <sil=0.000> to <sil=0.000> discuss <sil=0.000> about <sil=0.000> how <sil=0.000> strings <sil=0.000> can <sil=0.000> be <sil=0.000> handled <sil=0.000> as <sil=0.000> arrays -that <sil=0.000> will <sil=0.000> do <sil=0.000> in <sil=0.000> a separate <sil=0.000> lecture <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  up <sil=0.000> to <sil=0.000> this <sil=0.000> for <sil=0.000> now <sil=0.000> and <sil=0.000> will <sil=0.000> continue <sil=0.000> in <sil=0.000> the <sil=0.000> next <sil=0.000> lecture <sil=0.000> ok <sil=2.000> .PERIOD 

Today <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> be <sil=0.000> having <sil=0.000> a look <sil=0.000> at <sil=0.000> how <sil=0.000> the <sil=0.000> techniques <sil=0.000> that <sil=0.000> we <sil=0.000> have <sil=0.000> learnt <sil=0.000> can <sil=0.000> be <sil=0.000> applied
to <sil=0.000> different <sil=0.000> Problem <sil=0.000> Solving <sil=0.000> and <sil=0.000> this <sil=0.000> will <sil=0.000> continue <sil=0.000> from <sil=0.000> this <sil=0.000> lecture <sil=0.000> onwards <sil=0.000> for <sil=0.000> a few
more <sil=0.000> lectures <sil=2.000> .PERIOD  We <sil=0.000> have <sil=0.000> learnt <sil=0.000> quite <sil=0.000> a few <sil=0.000> things <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=0.000> the <sil=0.000> overall <sil=0.000> structure <sil=0.000> of <sil=0.000> the
C <sil=0.000> language <sil=2.000> .PERIOD 
We <sil=0.000> have <sil=0.000> seen <sil=0.000> the <sil=0.000> if <sil=0.000> then <sil=0.000> else <sil=0.000> if <sil=0.000> l structure <sil=0.000> the <sil=0.000> iteration <sil=0.000> structure <sil=1.000> ,COMMA  like <sil=0.000> the <sil=0.000> loops <sil=0.000> we <sil=0.000> also
know <sil=0.000> how <sil=0.000> the <sil=0.000> variables <sil=0.000> are <sil=0.000> defined <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> seen <sil=0.000> arrays <sil=0.000> how <sil=0.000> data <sil=0.000> can <sil=0.000> be <sil=0.000> stored <sil=0.000> in <sil=0.000> 1
dimensional <sil=0.000> array <sil=0.000> and <sil=0.000> 2 dimensional <sil=0.000> arrays <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> also <sil=0.000> seen <sil=0.000> functions <sil=2.000> .PERIOD  And <sil=0.000> the <sil=0.000> most
important <sil=0.000> thing <sil=0.000> about <sil=0.000> functions <sil=0.000> is <sil=0.000> that <sil=0.000> it <sil=0.000> enables <sil=0.000> us <sil=0.000> to <sil=0.000> take <sil=0.000> a complex <sil=0.000> problem <sil=0.000> and
divide <sil=0.000> it <sil=0.000> into <sil=0.000> different <sil=0.000> parts <sil=0.000> and <sil=0.000> solve <sil=0.000> each <sil=0.000> of <sil=0.000> the <sil=0.000> parts <sil=0.000> separately <sil=0.000> using <sil=0.000> functions <sil=2.000> .PERIOD  A
very <sil=0.000> important <sil=0.000> thing <sil=0.000> about <sil=0.000> functions <sil=0.000> is <sil=0.000> passing <sil=0.000> of <sil=0.000> the <sil=0.000> parameters <sil=0.000> and <sil=0.000> how <sil=0.000> the <sil=0.000> function
returns <sil=0.000> of <sil=0.000> value <sil=0.000> returns <sil=0.000> a value <sil=0.000> to <sil=0.000> the <sil=0.000> calling <sil=0.000> function <sil=2.000> .PERIOD 
We <sil=0.000> have <sil=0.000> also <sil=0.000> seen <sil=0.000> that <sil=0.000> there <sil=0.000> are <sil=0.000> two <sil=0.000> ways <sil=0.000> in <sil=0.000> which <sil=0.000> parameters <sil=0.000> can <sil=0.000> be <sil=0.000> passed <sil=0.000> from <sil=0.000> the
calling <sil=0.000> function <sil=0.000> to <sil=0.000> a called <sil=0.000> function <sil=1.000> ,COMMA  one <sil=0.000> is <sil=0.000> called <sil=0.000> by <sil=0.000> value <sil=0.000> another <sil=0.000> one <sil=0.000> is <sil=0.000> called <sil=0.000> by
reference <sil=0.000> in <sil=0.000> c language <sil=0.000> in <sil=0.000> general <sil=0.000> always <sil=0.000> call <sil=0.000> by <sil=0.000> value <sil=0.000> is <sil=0.000> adopted <sil=2.000> .PERIOD 
However <sil=1.000> ,COMMA  in <sil=0.000> call <sil=0.000> by <sil=0.000> value <sil=0.000> we <sil=0.000> have <sil=0.000> to <sil=0.000> copy <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> the <sil=0.000> data <sil=0.000> the <sil=0.000> parameter <sil=0.000> value <sil=0.000> the
parameter <sil=0.000> value <sil=0.000> to <sil=0.000> the <sil=0.000> argument <sil=0.000> value <sil=2.000> .PERIOD  However <sil=1.000> ,COMMA  for <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> arrays <sil=0.000> whenever <sil=0.000> I want
to <sil=0.000> pass <sil=0.000> a particular <sil=0.000> array <sil=0.000> at <sil=0.000> that <sil=0.000> point <sil=0.000> an <sil=0.000> array <sil=0.000> can <sil=0.000> be <sil=0.000> a 100 <sil=0.000> 500 <sil=0.000> array <sil=0.000> or <sil=0.000> 10 <sil=0.000> by <sil=0.000> 10 <sil=0.000> array <sil=0.000> if
it <sil=0.000> be <sil=0.000> a 10 <sil=0.000> by <sil=0.000> 10 <sil=0.000> array <sil=0.000> then <sil=0.000> I will <sil=0.000> have <sil=0.000> to <sil=0.000> copy <sil=0.000> hundred <sil=0.000> values <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> not <sil=0.000> advisable
for <sil=0.000> that <sil=0.000> we <sil=0.000> just <sil=0.000> passed <sil=0.000> the <sil=0.000> array <sil=0.000> name <sil=2.000> .PERIOD 

And <sil=0.000> let <sil=0.000> us <sil=0.000> quickly <sil=0.000> have <sil=0.000> a look <sil=0.000> that <sil=0.000> the <sil=0.000> array <sil=0.000> name <sil=0.000> is <sil=0.000> essentially <sil=0.000> an <sil=0.000> address <sil=0.000> right <sil=0.000> and
array <sil=0.000> whenever <sil=0.000> we <sil=0.000> pass <sil=0.000> suppose <sil=0.000> there <sil=0.000> is <sil=0.000> an <sil=0.000> array <sil=0.000> or <sil=0.000> 2 dimensional <sil=0.000> 10 <sil=0.000> by <sil=0.000> 10 <sil=0.000> array <sil=0.000> all
right <sil=0.000> 2 dimensional <sil=0.000> array <sil=0.000> like <sil=0.000> this <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  all <sil=0.000> the <sil=0.000> elements <sil=0.000> I am <sil=0.000> not <sil=0.000> passing <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> a essentially <sil=0.000> it <sil=0.000> happened <sil=0.000> to <sil=0.000> be <sil=0.000> a 4 <sil=0.000> by <sil=0.000> 4
area <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> all <sil=0.000> the <sil=0.000> 16 <sil=0.000> elements <sil=0.000> I will <sil=0.000> not <sil=0.000> be <sil=0.000> passing <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> my <sil=0.000> called <sil=0.000> function
the <sil=0.000> function <sil=0.000> called <sil=0.000> function <sil=0.000> and <sil=0.000> on <sil=0.000> this <sil=0.000> side <sil=0.000> is <sil=0.000> the <sil=0.000> calling <sil=0.000> function <sil=1.000> ,COMMA  the <sil=0.000> calling <sil=0.000> function

and <sil=0.000> the <sil=0.000> array <sil=0.000> name <sil=0.000> is <sil=0.000> say <sil=0.000> a <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> calling <sil=0.000> function <sil=0.000> refers <sil=0.000> to <sil=0.000> suppose <sil=0.000> let <sil=0.000> this <sil=0.000> function <sil=0.000> be
called <sil=0.000> f <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  in <sil=0.000> from <sil=0.000> the <sil=0.000> body <sil=0.000> of <sil=0.000> the <sil=0.000> calling <sil=0.000> function <sil=0.000> whenever <sil=0.000> I am <sil=0.000> calling <sil=0.000> f <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> passing <sil=0.000> the
array <sil=0.000> say <sil=0.000> if <sil=0.000> it <sil=0.000> be <sil=0.000> an <sil=0.000> integer <sil=0.000> array <sil=0.000> into <sil=0.000> A <sil=2.000> .PERIOD  And <sil=0.000> here <sil=0.000> I just <sil=0.000> passed <sil=0.000> the <sil=0.000> array <sil=0.000> A and <sil=0.000> here <sil=0.000> in
this <sil=0.000> function <sil=0.000> body <sil=0.000> we <sil=0.000> have <sil=0.000> got <sil=0.000> say <sil=0.000> int <sil=0.000> A and <sil=0.000> just <sil=0.000> saying <sil=0.000> that <sil=0.000> the <sil=0.000> size <sil=0.000> of <sil=0.000> the <sil=0.000> or <sil=0.000> if <sil=0.000> it <sil=0.000> may
not <sil=0.000> be <sil=0.000> a it <sil=0.000> can <sil=0.000> be <sil=0.000> x also <sil=1.000> ,COMMA  int <sil=0.000> x something <sil=0.000> and <sil=0.000> the <sil=0.000> size <sil=0.000> of <sil=0.000> that <sil=0.000> and <sil=0.000> here <sil=0.000> int <sil=0.000> A and <sil=0.000> maybe <sil=0.000> n <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  here <sil=0.000> I am <sil=0.000> actually <sil=0.000> passing <sil=0.000> the <sil=0.000> name <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=0.000> and <sil=0.000> the <sil=0.000> name <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=0.000> is <sil=0.000> nothing <sil=1.000> ,COMMA 
but <sil=0.000> the <sil=0.000> beginning <sil=0.000> of <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> the <sil=0.000> first <sil=0.000> element <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> I am <sil=0.000> actually
copying <sil=0.000> the <sil=0.000> address <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> a call <sil=0.000> by <sil=0.000> reference <sil=0.000> in <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> an <sil=0.000> array <sil=2.000> .PERIOD  And <sil=0.000> in <sil=0.000> the <sil=0.000> last <sil=0.000> lecture <sil=0.000> we <sil=0.000> have <sil=0.000> also
seen <sil=0.000> that <sil=0.000> we <sil=0.000> can <sil=0.000> also <sil=0.000> use <sil=0.000> pointers <sil=0.000> to <sil=0.000> sort <sil=0.000> of <sil=0.000> establish <sil=0.000> call <sil=0.000> by <sil=0.000> reference <sil=2.000> .PERIOD  Another <sil=0.000> major
thing <sil=0.000> that <sil=0.000> you <sil=0.000> have <sil=0.000> to <sil=0.000> keep <sil=0.000> in <sil=0.000> mind <sil=0.000> is <sil=0.000> that <sil=0.000> suppose <sil=0.000> this <sil=0.000> array <sil=0.000> is <sil=0.000> 1 2 <sil=0.000> 3 4 <sil=0.000> 5 6 <sil=0.000> 7 8 <sil=0.000> 9 10 <sil=0.000> 11 <sil=0.000> 12
13 <sil=0.000> 14 <sil=0.000> 15 <sil=0.000> 16 <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  these <sil=0.000> are <sil=0.000> organized <sil=0.000> in <sil=0.000> C in <sil=0.000> a row <sil=0.000> major <sil=0.000> form <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> stored <sil=0.000> in <sil=0.000> the
memory <sil=0.000> like <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> rows <sil=0.000> first <sil=0.000> 2 3 <sil=0.000> 4 then <sil=0.000> 5 6 <sil=0.000> like <sil=0.000> that <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  when <sil=0.000> I refer <sil=0.000> to <sil=0.000> the <sil=0.000> array <sil=0.000> A I
actually <sil=0.000> pass <sil=0.000> on <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> the <sil=0.000> first <sil=0.000> location <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=0.000> ok <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  A <sil=0.000> 0 0 <sil=0.000> in <sil=0.000> the <sil=0.000> case <sil=0.000> of
A <sil=0.000> 2 dimensional <sil=0.000> array <sil=0.000> points <sil=0.000> to <sil=0.000> this <sil=0.000> element <sil=0.000> and <sil=0.000> that <sil=0.000> is <sil=0.000> this <sil=0.000> element <sil=0.000> that <sil=0.000> is <sil=0.000> how <sil=0.000> we <sil=0.000> pass
on <sil=0.000> arrays <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  for <sil=0.000> functions <sil=0.000> and <sil=0.000> we <sil=0.000> have <sil=0.000> also <sil=0.000> seen <sil=0.000> some <sil=0.000> applications <sil=0.000> of <sil=0.000> all <sil=0.000> these <sil=0.000> techniques <sil=0.000> that <sil=0.000> we
have <sil=0.000> learnt <sil=0.000> in <sil=0.000> particular <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=0.000> how <sil=0.000> we <sil=0.000> can <sil=0.000> carry <sil=0.000> out <sil=0.000> search <sil=2.000> .PERIOD 

And <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=0.000> two <sil=0.000> search <sil=0.000> techniques <sil=0.000> one <sil=0.000> is <sil=0.000> linear <sil=0.000> search <sil=0.000> another <sil=0.000> is <sil=0.000> binary <sil=0.000> search <sil=2.000> .PERIOD 
Now <sil=0.000> in <sil=0.000> linear <sil=0.000> search <sil=0.000> the <sil=0.000> complexity <sil=0.000> the <sil=0.000> time <sil=0.000> is <sil=0.000> proportional <sil=0.000> to <sil=0.000> the <sil=0.000> number <sil=0.000> of <sil=0.000> elements
whereas <sil=1.000> ,COMMA  in <sil=0.000> binary <sil=0.000> search <sil=0.000> it <sil=0.000> is <sil=0.000> reduced <sil=0.000> it <sil=0.000> is <sil=0.000> faster <sil=0.000> it <sil=0.000> is <sil=0.000> log <sil=0.000> of <sil=0.000> the <sil=0.000> number <sil=0.000> of <sil=0.000> elements <sil=0.000> to
the <sil=0.000> base <sil=0.000> 2 <sil=2.000> .PERIOD  And <sil=0.000> search <sil=0.000> is <sil=0.000> a very <sil=0.000> fundamental <sil=0.000> problem <sil=0.000> solving <sil=0.000> technique <sil=0.000> in <sil=0.000> technique <sil=1.000> ,COMMA 
because <sil=0.000> suppose <sil=0.000> you <sil=0.000> have <sil=0.000> got <sil=0.000> the <sil=0.000> names <sil=0.000> of <sil=0.000> students <sil=0.000> in <sil=0.000> the <sil=0.000> class <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD 
Here <sil=0.000> are <sil=0.000> the <sil=0.000> names <sil=0.000> Atul <sil=1.000> ,COMMA  Shyam <sil=1.000> ,COMMA  Gargi <sil=0.000> in <sil=0.000> that <sil=0.000> way <sil=0.000> the <sil=0.000> names <sil=0.000> are <sil=0.000> there <sil=0.000> and <sil=0.000> each <sil=0.000> of <sil=0.000> them
have <sil=0.000> got <sil=0.000> a roll <sil=0.000> number <sil=0.000> 1 2 <sil=0.000> 3 4 <sil=2.000> .PERIOD  Now <sil=0.000> you <sil=0.000> want <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> how <sil=0.000> many <sil=0.000> Shyams <sil=0.000> are <sil=0.000> there <sil=0.000> in
the <sil=0.000> class <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you <sil=0.000> have <sil=0.000> to <sil=0.000> search <sil=0.000> this <sil=0.000> array <sil=0.000> and <sil=0.000> find <sil=0.000> out <sil=0.000> where <sil=0.000> Shyam <sil=0.000> is <sil=0.000> ok <sil=1.000> ,COMMA  maybe <sil=0.000> here
and <sil=0.000> there <sil=0.000> is <sil=0.000> another <sil=0.000> Shyam <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> searching <sil=0.000> and <sil=0.000> counting <sil=0.000> both <sil=0.000> the <sil=0.000> things <sil=1.000> ,COMMA  but
you <sil=0.000> cannot <sil=0.000> avoid <sil=0.000> searching <sil=0.000> this <sil=0.000> array <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD  It <sil=0.000> may <sil=0.000> be <sil=0.000> that <sil=0.000> along <sil=0.000> with <sil=0.000> that <sil=0.000> there <sil=0.000> is <sil=0.000> an
array <sil=0.000> of <sil=0.000> marks <sil=0.000> obtained <sil=0.000> by <sil=0.000> roll <sil=0.000> number <sil=0.000> 1 roll <sil=0.000> number <sil=0.000> 2 etcetera <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  maybe <sil=0.000> this <sil=0.000> is <sil=0.000> 50 <sil=0.000> this <sil=0.000> is <sil=0.000> 70 <sil=0.000> this <sil=0.000> is <sil=0.000> 30 <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD  Now <sil=0.000> here <sil=0.000> tell <sil=0.000> me <sil=0.000> I want <sil=0.000> to <sil=0.000> say <sil=0.000> now
they <sil=0.000> are <sil=0.000> in <sil=0.000> 2 arrays <sil=0.000> this <sil=0.000> is <sil=0.000> 1 array <sil=0.000> called <sil=0.000> name <sil=0.000> and <sil=0.000> this <sil=0.000> is <sil=0.000> another <sil=0.000> array <sil=0.000> called <sil=0.000> marks <sil=0.000> of
the <sil=0.000> corresponding <sil=0.000> students <sil=2.000> .PERIOD  Now <sil=0.000> I want <sil=0.000> to <sil=0.000> know <sil=0.000> how <sil=0.000> much <sil=0.000> what <sil=0.000> is <sil=0.000> the <sil=0.000> marks <sil=0.000> that <sil=0.000> Gargi
has <sil=0.000> obtained <sil=2.000> .PERIOD  How <sil=0.000> do <sil=0.000> you <sil=0.000> go <sil=0.000> about <sil=0.000> it <sil=0.000> what <sil=0.000> would <sil=0.000> be <sil=0.000> the <sil=0.000> first <sil=0.000> step <sil=0.000> in <sil=0.000> solving <sil=0.000> this
problem <sil=0.000> what <sil=0.000> is <sil=0.000> the <sil=0.000> marks <sil=0.000> that <sil=0.000> Gargi <sil=0.000> has <sil=0.000> opted <sil=1.000> ,COMMA  in <sil=0.000> order <sil=0.000> to <sil=0.000> do <sil=0.000> that <sil=0.000> I have <sil=0.000> to <sil=0.000> first <sil=0.000> I do <sil=0.000> not
know <sil=0.000> what <sil=0.000> is <sil=0.000> Gargi <sil=0.000> is <sil=0.000> roll <sil=0.000> number <sil=2.000> .PERIOD 
If <sil=0.000> I had <sil=0.000> known <sil=0.000> what <sil=0.000> is <sil=0.000> Gargi s <sil=0.000> roll <sil=0.000> number <sil=0.000> suppose <sil=0.000> Gargi s <sil=0.000> roll <sil=0.000> number <sil=0.000> is <sil=0.000> 3 <sil=1.000> ,COMMA  then <sil=0.000> I
could <sil=0.000> have <sil=0.000> gone <sil=0.000> in <sil=0.000> the <sil=0.000> marks <sil=0.000> array <sil=0.000> and <sil=0.000> I could <sil=0.000> have <sil=0.000> taken <sil=0.000> marks <sil=0.000> roll <sil=0.000> number <sil=0.000> what <sil=0.000> if <sil=0.000> I
knew <sil=0.000> the <sil=0.000> roll <sil=0.000> number <sil=1.000> ,COMMA  roll <sil=0.000> number <sil=0.000> minus <sil=0.000> 1 that <sil=0.000> marks <sil=0.000> I could <sil=0.000> have <sil=0.000> taken <sil=0.000> as <sil=0.000> a result <sil=0.000> all
right <sil=1.000> ,COMMA  but <sil=0.000> I do <sil=0.000> not <sil=0.000> know <sil=0.000> the <sil=0.000> roll <sil=0.000> number <sil=0.000> if <sil=0.000> I had <sil=0.000> known <sil=0.000> the <sil=0.000> rule <sil=0.000> number <sil=0.000> 3 then <sil=0.000> I would
have <sil=0.000> gone <sil=0.000> to <sil=0.000> the <sil=0.000> second <sil=0.000> element <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> marks <sil=0.000> 2 would <sil=0.000> have <sil=0.000> been <sil=0.000> would <sil=0.000> have <sil=0.000> given
me <sil=0.000> the <sil=0.000> roll <sil=0.000> number <sil=1.000> ,COMMA  but <sil=0.000> suppose <sil=0.000> I do <sil=0.000> not <sil=0.000> know <sil=0.000> the <sil=0.000> roll <sil=0.000> number <sil=0.000> then <sil=0.000> what <sil=0.000> should <sil=0.000> I do <sil=0.228> ?QUESTIONMARK 
First <sil=0.000> I will <sil=0.000> have <sil=0.000> to <sil=0.000> search <sil=0.000> this <sil=0.000> area <sil=0.000> and <sil=0.000> what <sil=0.000> would <sil=0.000> be <sil=0.000> my <sil=0.000> key <sil=0.000> what <sil=0.000> is <sil=0.000> my <sil=0.000> key <sil=0.000> will <sil=0.000> be <sil=0.000> the
screen <sil=0.000> Gargi <sil=1.000> ,COMMA  because <sil=0.000> I want <sil=0.000> to <sil=0.000> know <sil=0.000> the <sil=0.000> marks <sil=0.000> obtained <sil=0.000> by <sil=0.000> Gargi <sil=0.000> and <sil=0.000> what <sil=0.000> should <sil=0.000> I do
with <sil=0.000> this <sil=0.000> key <sil=0.000> I should <sil=0.000> carry <sil=0.000> out <sil=0.000> a search <sil=1.000> ,COMMA  it <sil=0.000> can <sil=0.000> be <sil=0.000> a linear <sil=0.000> search <sil=0.000> or <sil=0.000> it <sil=0.000> can <sil=0.000> be <sil=0.000> a binary
search <sil=0.000> let <sil=0.000> us <sil=0.000> for <sil=0.000> the <sil=0.000> time <sil=0.000> being <sil=0.000> assume <sil=0.000> that <sil=0.000> it <sil=0.000> is <sil=0.000> a linear <sil=0.000> search <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> be <sil=0.000> searching
and <sil=0.000> I will <sil=0.000> be <sil=0.000> finding <sil=0.000> Gargi <sil=0.000> here <sil=0.000> I am <sil=0.000> assuming <sil=0.000> for <sil=0.000> simplicity <sil=0.000> that <sil=0.000> there <sil=0.000> is <sil=0.000> only <sil=0.000> one <sil=0.000> Gargi
in <sil=0.000> the <sil=0.000> class <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> take <sil=0.000> this <sil=0.000> and <sil=0.000> I find <sil=0.000> what <sil=0.000> will <sil=0.000> the <sil=0.000> search <sil=1.000> ,COMMA  if <sil=0.000> you <sil=0.000> recall <sil=0.000> what <sil=0.000> will <sil=0.000> the <sil=0.000> search
algorithm <sil=0.000> return <sil=0.000> me <sil=0.000> the <sil=0.000> search <sil=0.000> algorithm <sil=0.000> will <sil=0.000> return <sil=0.000> me <sil=0.000> the <sil=0.000> index <sil=0.000> of <sil=0.000> the <sil=0.000> position <sil=0.000> where

Gargi <sil=0.000> is <sil=0.000> located <sil=2.000> .PERIOD  And <sil=0.000> that <sil=0.000> position <sil=0.000> will <sil=0.000> be <sil=0.000> actually <sil=0.000> it <sil=0.000> will <sil=0.000> automatically <sil=0.000> come <sil=0.000> since <sil=0.000> this
positions <sil=0.000> will <sil=0.000> be <sil=0.000> marked <sil=0.000> as <sil=0.000> 0 1 <sil=0.000> 2 I <sil=0.000> will <sil=0.000> get <sil=0.000> this <sil=0.000> 2 returned <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> get <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> get <sil=0.000> the <sil=0.000> key
I <sil=0.000> search <sil=0.000> the <sil=0.000> array <sil=0.000> name <sil=0.000> this <sil=0.000> is <sil=0.000> a character <sil=0.000> array <sil=0.000> A care <sil=0.000> name <sil=0.000> size <sil=0.000> whatever <sil=0.000> size <sil=0.000> is <sil=0.000> say <sil=0.000> n
and <sil=0.000> the <sil=0.000> key <sil=2.000> .PERIOD 
And <sil=0.000> this <sil=0.000> search <sil=0.000> will <sil=0.000> return <sil=0.000> me <sil=0.000> the <sil=0.000> value <sil=0.000> position <sil=0.000> 2 pos <sil=0.000> equal <sil=0.000> to <sil=0.000> 2 <sil=1.000> ,COMMA  then <sil=0.000> I will <sil=0.000> simply <sil=0.000> take
the <sil=0.000> value <sil=0.000> of <sil=0.000> marks <sil=0.000> I go <sil=0.000> to <sil=0.000> the <sil=0.000> array <sil=0.000> marks <sil=0.000> pos <sil=1.000> ,COMMA  which <sil=0.000> will <sil=0.000> be <sil=0.000> my <sil=0.000> result <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you <sil=0.000> see
we <sil=0.000> needed <sil=0.000> the <sil=0.000> searching <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  while <sil=0.000> I was <sil=0.000> talking <sil=0.000> of <sil=0.000> searching <sil=0.000> this <sil=0.000> array <sil=0.000> I said <sil=0.000> that <sil=0.000> the
searching <sil=0.000> I am <sil=0.000> assuming <sil=0.000> this <sil=0.000> searching <sil=0.000> to <sil=0.000> be <sil=0.000> a linear <sil=0.000> search <sil=2.000> .PERIOD 
Would <sil=0.000> it <sil=0.000> be <sil=0.000> possible <sil=0.000> to <sil=0.000> sort <sil=0.000> this <sil=0.000> array <sil=0.000> using <sil=0.000> binary <sil=0.000> search <sil=1.000> ,COMMA  if <sil=0.000> you <sil=0.000> just <sil=0.000> think <sil=0.000> it <sil=0.000> over <sil=0.000> would
it <sil=0.000> be <sil=0.000> possible <sil=0.000> to <sil=0.000> search <sil=1.000> ,COMMA  it <sil=0.000> using <sil=0.000> binary <sil=0.000> search <sil=0.000> what <sil=0.000> does <sil=0.000> binary <sil=0.000> search <sil=0.000> require <sil=0.000> binary
search <sil=0.000> requires <sil=0.000> that <sil=0.000> the <sil=0.000> array <sil=0.000> be <sil=0.000> sorted <sil=0.000> right <sil=0.000> array <sil=0.000> be <sil=0.000> sorted <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  an <sil=0.000> array <sil=0.000> like <sil=0.000> this <sil=1.000> ,COMMA  Atul <sil=1.000> ,COMMA  Amal <sil=1.000> ,COMMA  Gargi <sil=0.000> and <sil=0.000> Joy <sil=0.000> this <sil=0.000> is <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> 4 elements <sil=0.000> can <sil=0.000> I sort
it <sil=0.000> the <sil=0.000> type <sil=0.000> of <sil=0.000> sort <sil=0.000> if <sil=1.000> ,COMMA  I <sil=0.000> want <sil=0.000> to <sil=0.000> sort <sil=0.000> it <sil=0.000> I will <sil=0.000> have <sil=0.000> to <sil=0.000> organize <sil=0.000> it <sil=0.000> in <sil=0.000> increasing <sil=0.000> or <sil=0.000> decreasing
order <sil=0.000> let <sil=0.000> us <sil=0.000> assume <sil=0.000> that <sil=0.000> I am <sil=0.000> trying <sil=0.000> to <sil=0.000> do <sil=0.000> it <sil=0.000> in <sil=0.000> an <sil=0.000> increasing <sil=0.000> order <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  this <sil=0.000> sort <sil=0.000> will <sil=0.000> be
this <sil=0.000> character <sil=0.000> array <sil=0.000> can <sil=0.000> be <sil=0.000> sorted <sil=0.000> in <sil=0.000> an <sil=0.000> way <sil=0.000> which <sil=0.000> is <sil=0.000> called <sil=0.000> the <sil=0.000> lexicographic <sil=0.000> sort <sil=2.000> .PERIOD 
That <sil=0.000> means <sil=0.000> I go <sil=0.000> I sort <sil=0.000> the <sil=0.000> character <sil=0.000> array <sil=0.000> according <sil=0.000> to <sil=0.000> the <sil=0.000> alphabets <sil=0.000> or <sil=0.000> the <sil=0.000> words <sil=0.000> as <sil=0.000> they
written <sil=0.354> ;SEMICOLON  obviously <sil=1.000> ,COMMA  A <sil=0.000> comes <sil=0.000> first <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  therefore <sil=1.000> ,COMMA  A <sil=0.000> character <sil=0.000> A is <sil=0.000> smaller <sil=0.000> than <sil=0.000> character
B <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> between <sil=0.000> these <sil=0.000> two <sil=0.000> elements <sil=0.000> both <sil=0.000> of <sil=0.000> them <sil=0.000> has <sil=0.000> got <sil=0.000> A <sil=1.000> ,COMMA  but <sil=0.000> similarly <sil=0.000> t is <sil=0.000> greater
than <sil=0.000> m <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  in <sil=0.000> this <sil=0.000> sorting <sil=0.000> I will <sil=0.000> first <sil=0.000> check <sil=0.000> between <sil=0.000> these <sil=0.000> say <sil=0.000> a they <sil=0.000> are <sil=0.000> same <sil=0.000> think <sil=0.000> of
bubble <sil=0.000> sort <sil=0.000> I am <sil=0.000> trying <sil=0.000> to <sil=0.000> compare <sil=0.000> them <sil=0.000> in <sil=0.000> normally <sil=0.000> what <sil=0.000> we <sil=0.000> did <sil=0.000> we <sil=0.000> found <sil=0.000> that <sil=0.000> say <sil=0.000> array
x <sil=0.000> xj <sil=0.000> is <sil=0.000> less <sil=0.000> than <sil=0.000> xj <sil=0.000> plus <sil=0.000> 1 and <sil=0.000> then <sil=0.000> we <sil=0.000> did <sil=0.000> something <sil=2.000> .PERIOD 
If <sil=0.000> it <sil=0.000> was <sil=0.000> if <sil=0.000> it <sil=0.000> is <sil=0.000> the <sil=0.000> case <sil=0.000> no <sil=0.000> issue <sil=0.000> if <sil=0.000> it <sil=0.000> was <sil=0.000> the <sil=0.000> other <sil=0.000> way <sil=0.000> round <sil=0.000> I wanted <sil=0.000> to <sil=0.000> do <sil=0.000> a swap <sil=1.000> ,COMMA  but
in <sil=0.000> this <sil=0.000> case <sil=0.000> it <sil=0.000> will <sil=0.000> not <sil=0.000> be <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  simple <sil=0.000> I can <sil=0.000> take <sil=0.000> a string <sil=0.000> and <sil=0.000> compare <sil=0.000> these <sil=0.000> two <sil=0.000> strings <sil=0.000> as
to <sil=0.000> which <sil=0.000> one <sil=0.000> is <sil=0.000> whether <sil=0.000> they <sil=0.000> are <sil=0.000> same <sil=0.000> or <sil=0.000> not <sil=0.000> or <sil=0.000> whichever <sil=0.000> is <sil=0.000> greater <sil=1.000> ,COMMA  but <sil=0.000> another <sil=0.000> way
you <sil=0.000> can <sil=0.000> write <sil=0.000> a small <sil=0.000> function <sil=0.000> to <sil=0.000> compare <sil=0.000> I leave <sil=0.000> it <sil=0.000> to <sil=0.000> you <sil=0.000> I leave <sil=0.000> it <sil=0.000> to <sil=0.000> you <sil=0.000> that <sil=0.000> you <sil=0.000> now
know <sil=0.000> sorting <sil=0.000> techniques <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  you <sil=0.000> should <sil=0.000> try <sil=0.000> to <sil=0.000> write <sil=0.000> a function <sil=0.000> that <sil=0.000> will <sil=0.000> sort <sil=0.000> a string <sil=0.000> of <sil=0.000> characters <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  e
and <sil=0.000> e are <sil=0.000> same <sil=1.000> ,COMMA  if <sil=0.000> they <sil=0.000> are <sil=0.000> same <sil=0.000> the <sil=0.000> function <sil=0.000> what <sil=0.000> will <sil=0.000> do <sil=0.000> it <sil=0.000> will <sil=0.000> now <sil=0.000> look <sil=0.000> at <sil=0.000> t and <sil=0.000> m
now <sil=0.000> m is <sil=0.000> smaller <sil=0.000> than <sil=0.000> t therefore <sil=1.000> ,COMMA  Amal <sil=0.000> is <sil=0.000> smaller <sil=0.000> than <sil=0.000> Atul <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  Amal <sil=0.000> will <sil=0.000> come <sil=0.000> here <sil=0.000> and <sil=0.000> Atul <sil=0.000> will <sil=0.000> come <sil=0.000> here <sil=0.000> now <sil=0.000> between <sil=0.000> Atul <sil=0.000> and <sil=0.000> Gargi <sil=0.000> you <sil=0.000> can
see <sil=0.000> a is <sil=0.000> greater <sil=0.000> than <sil=0.000> smaller <sil=0.000> than <sil=0.000> G <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  Gargi <sil=0.000> is <sil=0.000> in <sil=0.000> a proper <sil=0.000> space <sil=0.000> please <sil=2.000> .PERIOD  Now <sil=0.000> if <sil=0.000> say <sil=0.000> for
example <sil=1.000> ,COMMA  I <sil=0.000> do <sil=0.000> not <sil=0.000> have <sil=0.000> Joy <sil=0.000> here <sil=0.000> I am <sil=0.000> having <sil=0.000> another <sil=0.000> name <sil=0.000> Gautam <sil=0.000> here <sil=2.000> .PERIOD  Now <sil=0.000> when <sil=0.000> I am
comparing <sil=0.000> between <sil=0.000> Gargi <sil=0.000> and <sil=0.000> Gautam <sil=0.000> G and <sil=0.000> G are <sil=0.000> the <sil=0.000> same <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  they <sil=0.000> are <sil=0.000> equal <sil=0.000> no <sil=0.000> change <sil=0.000> next <sil=0.000> a and <sil=0.000> a are <sil=0.000> also <sil=0.000> same <sil=0.000> no <sil=0.000> issue <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  there <sil=0.000> is <sil=0.000> no <sil=0.000> change <sil=1.000> ,COMMA 
but <sil=0.000> r r <sil=0.000> is <sil=0.000> smaller <sil=0.000> than <sil=0.000> u <sil=1.000> ,COMMA  because <sil=0.000> r appears <sil=0.000> earlier <sil=0.000> than <sil=0.000> u <sil=1.000> ,COMMA  but <sil=0.000> in <sil=0.000> terms <sil=0.000> of <sil=0.000> our <sil=0.000> computer
code <sil=0.000> technology <sil=0.000> the <sil=0.000> Ascii <sil=0.000> code <sil=0.000> of <sil=0.000> r is <sil=0.000> less <sil=0.000> than <sil=0.000> the <sil=0.000> ascii <sil=0.000> code <sil=0.000> of <sil=0.000> you <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  in <sil=0.000> both <sil=0.000> the <sil=0.000> ways <sil=0.000> it <sil=0.000> is <sil=0.000> meaningful <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  r <sil=0.000> is <sil=0.000> less <sil=0.000> than <sil=0.000> you <sil=0.000> therefore <sil=1.000> ,COMMA  Gargi <sil=0.000> is <sil=0.000> smaller
than <sil=0.000> Gautam <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> way <sil=0.000> I can <sil=0.000> carry <sil=0.000> out <sil=0.000> with <sil=0.000> another <sil=0.000> small <sil=0.000> function <sil=0.000> compare <sil=0.000> string
is <sil=0.000> greater <sil=0.000> say <sil=0.000> is <sil=0.000> you <sil=0.000> can <sil=0.000> write <sil=0.000> a function <sil=0.000> is <sil=0.000> greater <sil=0.000> 2 strings <sil=0.000> ok <sil=1.000> ,COMMA  care <sil=0.000> S 1 <sil=0.000> comma <sil=0.000> care <sil=0.000> S 2
2 <sil=0.000> strings <sil=0.000> will <sil=0.000> be <sil=0.000> passed <sil=0.000> on <sil=0.000> this <sil=0.000> function <sil=0.000> and <sil=0.000> this <sil=0.000> function <sil=0.000> will <sil=0.000> find <sil=0.000> out <sil=1.000> ,COMMA  which <sil=0.000> character <sil=0.000> if
S <sil=0.000> 1 is <sil=0.000> greater <sil=0.000> than <sil=0.000> is <sil=0.000> 2 <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> just <sil=0.000> return <sil=0.000> if <sil=0.000> S 1 <sil=0.000> is <sil=0.000> greater <sil=0.000> than <sil=0.000> is <sil=0.000> 2 it <sil=0.000> will <sil=0.000> return <sil=0.000> A 1 <sil=0.000> if <sil=0.000> S 1
is <sil=0.000> greater <sil=0.000> than <sil=0.000> S 2 <sil=0.000> try <sil=0.000> to <sil=0.000> write <sil=0.000> such <sil=0.000> a function <sil=0.000> ok <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> that <sil=0.000> I am <sil=0.000> giving <sil=0.000> you <sil=0.000> as <sil=0.000> a
home <sil=0.000> assignment <sil=0.000> all <sil=0.000> of <sil=0.000> you <sil=0.000> should <sil=0.000> try <sil=0.000> to <sil=0.000> do <sil=0.000> that <sil=0.000> and <sil=0.000> with <sil=0.000> a little <sil=0.000> effort <sil=0.000> I am <sil=0.000> sure <sil=0.000> you
will <sil=0.000> be <sil=0.000> able <sil=0.000> to <sil=0.000> do <sil=0.000> that <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> could <sil=0.000> have <sil=0.000> just <sil=0.000> as <sil=0.000> I had <sil=0.000> done <sil=0.000> in <sil=0.000> the <sil=0.000> earlier <sil=0.000> one <sil=1.000> ,COMMA  here <sil=0.000> in <sil=0.000> this <sil=0.000> thing <sil=0.000> I said <sil=0.000> that <sil=0.000> I will <sil=0.000> be
doing <sil=0.000> linear <sil=0.000> search <sil=1.000> ,COMMA  I <sil=0.000> could <sil=0.000> have <sil=0.000> done <sil=0.000> binary <sil=0.000> search <sil=0.000> also <sil=0.000> provided <sil=0.000> I had <sil=0.000> provided <sil=1.000> ,COMMA  I <sil=0.000> had
sorted <sil=0.000> them <sil=0.000> provided <sil=0.000> I had <sil=0.000> sorted <sil=0.000> them <sil=0.000> in <sil=0.000> a proper <sil=0.000> way <sil=0.000> and <sil=0.000> then <sil=0.000> with <sil=0.000> the <sil=0.000> sorted <sil=0.000> array <sil=0.000> I

could <sil=0.000> have <sil=0.000> done <sil=0.000> binary <sil=0.000> search <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  will <sil=0.000> be <sil=0.000> also <sil=0.000> doing <sil=0.000> some <sil=0.000> problem <sil=0.000> solving <sil=0.000> within
this <sil=0.000> course <sil=0.000> will <sil=0.000> be <sil=0.000> doing <sil=0.000> some <sil=0.000> problem <sil=0.000> solving <sil=0.000> in <sil=0.000> the <sil=0.000> field <sil=0.000> of <sil=0.000> numbers <sil=0.000> or <sil=0.000> equations
mathematical <sil=0.000> problem <sil=0.000> solving <sil=1.000> ,COMMA  but <sil=0.000> before <sil=0.000> that <sil=0.000> in <sil=0.000> order <sil=0.000> to <sil=0.000> do <sil=0.000> this <sil=0.000> today <sil=0.000> let <sil=0.000> us <sil=0.000> have <sil=0.000> a
relook <sil=0.000> at <sil=0.000> the <sil=0.000> strings <sil=1.000> ,COMMA  we <sil=0.000> had <sil=0.000> looked <sil=0.000> at <sil=0.000> strings <sil=0.000> earlier <sil=0.000> as <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> characters <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> have <sil=0.000> a relook <sil=0.000> at <sil=0.000> the <sil=0.000> whole <sil=0.000> thing <sil=0.000> today <sil=0.000> how <sil=0.000> can <sil=0.000> I represent <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> strings
like <sil=0.000> the <sil=0.000> one <sil=0.000> that <sil=1.000> ,COMMA  I <sil=0.000> was <sil=0.000> showing <sil=0.000> here <sil=0.000> and <sil=0.000> array <sil=0.000> of <sil=0.000> strings <sil=0.000> all <sil=0.000> these <sil=0.000> names <sil=0.000> Atul <sil=1.000> ,COMMA  Amal <sil=1.000> ,COMMA 
Gargi <sil=1.000> ,COMMA  and <sil=0.000> Gautam <sil=0.000> all <sil=0.000> these <sil=0.000> are <sil=0.000> nothing <sil=1.000> ,COMMA  but <sil=0.000> this <sil=0.000> is <sil=0.000> a string <sil=0.000> this <sil=0.000> is <sil=0.000> a string <sil=0.000> all <sil=0.000> these <sil=0.000> are
different <sil=0.000> strings <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  how <sil=0.000> can <sil=0.000> I represent <sil=0.000> them <sil=0.000> let <sil=0.000> us <sil=0.000> have <sil=0.000> a look <sil=0.000> at <sil=0.000> that <sil=2.000> .PERIOD 

Say <sil=0.000> I can <sil=0.000> I have <sil=0.000> got <sil=0.000> 3 strings <sil=0.000> one <sil=0.000> is <sil=0.000> spike <sil=0.000> and <sil=0.000> there <sil=0.000> is <sil=0.000> tom <sil=0.000> and <sil=0.000> there <sil=0.000> is <sil=0.000> jerry <sil=2.000> .PERIOD  Now <sil=0.000> these <sil=0.000> 3
strings <sil=0.000> I have <sil=0.000> to <sil=0.000> store <sil=0.000> and <sil=0.000> I am <sil=0.000> saying <sil=0.000> that <sil=0.000> each <sil=0.000> string <sil=0.000> can <sil=0.000> be <sil=0.000> at <sil=0.000> best <sil=0.000> 10 <sil=0.000> characters <sil=0.000> at
most <sil=0.000> 10 <sil=0.000> characters <sil=2.000> .PERIOD  And <sil=0.000> I am <sil=0.000> looking <sil=0.000> at <sil=0.000> 3 such <sil=0.000> names <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> an <sil=0.000> array <sil=0.000> 3 rows <sil=0.000> and <sil=0.000> each
row <sil=0.000> having <sil=0.000> 10 <sil=0.000> characters <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> definite <sil=0.000> that <sil=0.000> definition <sil=0.000> would <sil=0.000> be <sil=0.000> I named <sil=0.000> them <sil=0.000> as
char <sil=0.000> I could <sil=0.000> have <sil=0.000> done <sil=0.000> character <sil=0.000> array <sil=0.000> and <sil=0.000> it <sil=0.000> is <sil=0.000> 3 rows <sil=0.000> and <sil=0.000> 10 <sil=0.000> columns <sil=0.000> now <sil=0.000> I can
initialize <sil=0.000> that <sil=0.000> as <sil=0.000> spike <sil=0.000> as <sil=0.000> character <sil=0.000> S character <sil=0.000> p <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  s <sil=0.000> comes <sil=0.000> here <sil=1.000> ,COMMA  p <sil=0.000> comes <sil=0.000> here <sil=1.000> ,COMMA  i <sil=0.000> comes <sil=0.000> here <sil=1.000> ,COMMA  k <sil=0.000> comes <sil=0.000> here <sil=1.000> ,COMMA  e <sil=0.000> comes <sil=0.000> here <sil=0.000> and <sil=0.000> that <sil=0.000> is <sil=0.000> the
end <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> backslash <sil=0.000> 0 I <sil=0.000> also <sil=0.000> put <sil=0.000> that <sil=0.000> and <sil=0.000> so <sil=1.000> ,COMMA  1 <sil=0.000> 2 3 <sil=0.000> 4 5 <sil=0.000> 6 4 <sil=0.000> places <sil=0.000> are <sil=0.000> still <sil=0.000> vacant <sil=0.000> 4
places <sil=0.000> are <sil=0.000> still <sil=0.000> vacant <sil=2.000> .PERIOD  Similarly <sil=0.000> for <sil=0.000> the <sil=0.000> next <sil=0.000> 1 is <sil=0.000> tom <sil=0.000> so <sil=1.000> ,COMMA  t <sil=0.000> o m <sil=0.000> back <sil=0.000> slash <sil=0.000> 0 and <sil=0.000> the <sil=0.000> rest
are <sil=0.000> rest <sil=0.000> 6 are <sil=0.000> all <sil=0.000> free <sil=0.000> all <sil=0.000> right <sil=1.000> ,COMMA  but <sil=0.000> my <sil=0.000> string <sil=0.000> has <sil=0.000> ended <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  1 <sil=0.000> way <sil=0.000> I is <sil=0.000> that <sil=0.000> I can
represent <sil=0.000> them <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=0.000> where <sil=1.000> ,COMMA  I <sil=0.000> specifically <sil=0.000> talk <sil=0.000> about <sil=0.000> the <sil=0.000> characters <sil=0.000> in <sil=0.000> the <sil=0.000> array <sil=0.000> and
terminate <sil=0.000> them <sil=0.000> with <sil=0.000> backslash <sil=0.000> 0 <sil=2.000> .PERIOD  The <sil=0.000> other <sil=0.000> way <sil=0.000> I can <sil=0.000> do <sil=0.000> it <sil=0.000> is <sil=0.000> simply <sil=0.000> I initialize <sil=0.000> them <sil=2.000> .PERIOD 

As <sil=0.000> 3 10 <sil=0.000> the <sil=0.000> same <sil=0.000> array <sil=0.000> with <sil=0.000> 3 strings <sil=0.000> spike <sil=0.000> comma <sil=1.000> ,COMMA  tom <sil=0.000> comma <sil=1.000> ,COMMA  jerry <sil=2.000> .PERIOD  Now <sil=0.000> internally
even <sil=0.000> if <sil=0.000> I do <sil=0.000> that <sil=0.000> it <sil=0.000> is <sil=0.000> essentially <sil=0.000> becoming <sil=0.000> the <sil=0.000> same <sil=0.000> thing <sil=0.000> internally <sil=0.000> it <sil=0.000> is <sil=0.000> being <sil=0.000> stored <sil=0.000> in
the <sil=0.000> same <sil=0.000> way <sil=0.000> with <sil=0.000> 3 rows <sil=0.000> and <sil=0.000> each <sil=0.000> row <sil=0.000> having <sil=0.000> this <sil=0.000> characters <sil=0.000> s p <sil=0.000> i k <sil=0.000> e backslash <sil=0.000> 0 and
so <sil=0.000> and <sil=0.000> so <sil=0.000> forth <sil=1.000> ,COMMA  there <sil=0.000> can <sil=0.000> be <sil=0.000> more <sil=0.000> t o <sil=0.000> m back <sil=0.000> slash <sil=0.000> 0 and <sil=0.000> so <sil=0.000> and <sil=0.000> so <sil=0.000> forth <sil=0.000> here <sil=2.000> .PERIOD 
Also <sil=0.000> j e <sil=0.000> r r <sil=0.000> y and <sil=0.000> so <sil=1.000> ,COMMA  on <sil=0.000> I am <sil=0.000> sorry <sil=0.000> backslash <sil=0.000> 0 and <sil=0.000> so <sil=0.000> and <sil=0.000> so <sil=0.000> forth <sil=0.000> it <sil=0.000> is <sil=0.000> being <sil=0.000> stored <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
both <sil=0.000> of <sil=0.000> them <sil=0.000> are <sil=0.000> equivalent <sil=0.000> I can <sil=0.000> do <sil=0.000> it <sil=0.000> in <sil=0.000> either <sil=0.000> of <sil=0.000> these <sil=0.000> ways <sil=0.000> alright <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  a <sil=0.000> string <sil=0.000> can <sil=0.000> be
represented <sil=0.000> in <sil=0.000> any <sil=0.000> of <sil=0.000> these <sil=0.000> ways <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  we <sil=0.000> already <sil=0.000> know <sil=0.000> this <sil=0.000> again <sil=0.000> the <sil=0.000> name <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=0.000> is <sil=0.000> appointed <sil=0.000> to <sil=0.000> the <sil=0.000> 0th <sil=0.000> element <sil=0.000> of
the <sil=0.000> array <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> I have <sil=0.000> this <sil=0.000> array <sil=0.000> s p <sil=0.000> i k <sil=0.000> e backslash <sil=0.000> 0 <sil=1.000> ,COMMA  t <sil=0.000> o m <sil=0.000> backslash <sil=0.000> 0 <sil=1.000> ,COMMA  j <sil=0.000> e r <sil=0.000> r y
backslash <sil=0.000> 0 when <sil=0.000> I am <sil=0.000> calling <sil=0.000> that <sil=0.000> charr <sil=0.000> the <sil=0.000> name <sil=0.000> itself <sil=0.000> is <sil=0.000> pointing <sil=0.000> to <sil=0.000> the <sil=0.000> first <sil=0.000> element <sil=0.000> of
this <sil=0.000> array <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  ch <sil=0.000> arr <sil=0.000> 0 0 <sil=0.000> it <sil=0.000> is <sil=0.000> pointing <sil=0.000> to <sil=0.000> that <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  this <sil=0.000> and <sil=0.000> ch <sil=0.000> arr <sil=0.000> 0 0 <sil=0.000> are <sil=0.000> the <sil=0.000> same <sil=0.000> they <sil=0.000> mean <sil=0.000> the <sil=0.000> same <sil=0.000> thing <sil=0.000> ok <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> you <sil=0.000> just <sil=0.000> like <sil=0.000> an
array <sil=0.000> this <sil=0.000> is <sil=0.000> also <sil=0.000> true <sil=0.000> here <sil=2.000> .PERIOD 

Therefore <sil=1.000> ,COMMA  if <sil=0.000> ch_arr <sil=0.000> points <sil=0.000> to <sil=0.000> the <sil=0.000> address <sil=0.000> 1000 <sil=0.000> ch_arr <sil=0.000> plus <sil=0.000> 1 will <sil=0.000> point <sil=0.000> to <sil=0.000> address <sil=0.000> 1010 <sil=1.000> ,COMMA 
why <sil=0.000> the <sil=0.000> reason <sil=0.000> is <sil=0.000> again <sil=0.000> I have <sil=0.000> got <sil=0.000> this <sil=0.000> array <sil=2.000> .PERIOD 

And <sil=0.000> ch_arr <sil=0.000> is <sil=0.000> pointing <sil=0.000> ch-ar <sil=0.000> arr <sil=0.000> is <sil=0.000> pointing <sil=0.000> to <sil=0.000> the <sil=0.000> 0 element <sil=0.000> of <sil=0.000> the <sil=0.000> first <sil=0.000> row <sil=1.000> ,COMMA  if <sil=0.000> this <sil=0.000> is
1000 <sil=2.000> .PERIOD  Then <sil=0.000> 1002 <sil=1.000> ,COMMA  1009 <sil=0.000> this <sil=0.000> array <sil=0.000> this <sil=0.000> location <sil=0.000> is <sil=0.000> 1009 <sil=1.000> ,COMMA  because <sil=0.000> the <sil=0.000> size <sil=0.000> is <sil=0.000> 10 <sil=0.000> size <sil=0.000> is <sil=0.000> 10 <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  although <sil=0.000> s p <sil=0.000> i k <sil=0.000> e backslash <sil=0.000> 0 etcetera <sil=0.000> is <sil=0.000> there <sil=1.000> ,COMMA  then <sil=0.000> when <sil=0.000> I go <sil=0.000> to <sil=0.000> the <sil=0.000> next <sil=0.000> one <sil=0.000> ch
underscore <sil=0.000> arr <sil=0.000> plus <sil=0.000> 1 <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  whatever <sil=0.000> this <sil=0.000> pointer <sil=0.000> arrays <sil=0.000> the <sil=0.000> entire <sil=0.000> thing <sil=0.000> is <sil=0.000> taken <sil=0.000> 0
to <sil=0.000> 10 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> taking <sil=0.000> here <sil=0.000> it <sil=0.000> is <sil=0.000> taking <sil=0.000> all <sil=0.000> these <sil=0.000> 10 <sil=0.000> elements <sil=0.000> as <sil=0.000> 1 array <sil=0.000> it <sil=0.000> will <sil=0.000> be <sil=0.000> pointing
to <sil=0.000> the <sil=0.000> next <sil=0.000> one <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> 1010 <sil=0.000> ok <sil=2.000> .PERIOD 
Again <sil=0.000> if <sil=0.000> I make <sil=0.000> it <sil=0.000> ch-arr <sil=0.000> plus <sil=0.000> 2 it <sil=0.000> will <sil=0.000> come <sil=0.000> to <sil=0.000> this <sil=0.000> 1 all <sil=0.000> right <sil=0.000> that <sil=0.000> is <sil=0.000> how <sil=0.000> the <sil=0.000> pointer
works <sil=1.000> ,COMMA  but <sil=0.000> how <sil=0.000> can <sil=0.000> I get <sil=0.000> this <sil=0.000> character <sil=0.000> this <sil=0.000> will <sil=0.000> be <sil=0.000> ch-arr <sil=0.000> 0 1 <sil=0.000> that <sil=0.000> is <sil=0.000> pointing <sil=0.000> to <sil=0.000> this
element <sil=0.000> ok <sil=2.000> .PERIOD  Now <sil=0.000> this <sil=0.000> thing <sil=0.000> must <sil=0.000> be <sil=0.000> clearly <sil=0.000> understood <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  ch-arr <sil=0.000> points <sil=0.000> 0 th <sil=0.000> string <sil=0.000> or
the <sil=0.000> 0 th <sil=0.000> 1 dimensional <sil=0.000> array <sil=0.000> ch-arr <sil=0.000> 1 points <sil=0.000> to <sil=0.000> the <sil=0.000> first <sil=0.000> string <sil=0.000> or <sil=0.000> the <sil=0.000> first <sil=0.000> 1 dimensional
array <sil=0.000> I mean <sil=0.000> number <sil=0.000> 1 0 <sil=0.000> at <sil=0.000> first <sil=0.000> ch-arr <sil=0.000> 2 points <sil=0.000> the <sil=0.000> second <sil=0.000> 1 dimensional <sil=0.000> array <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  each <sil=0.000> of <sil=0.000> them <sil=0.000> are <sil=0.000> 1 dimensional <sil=0.000> arrays <sil=0.000> and <sil=0.000> ch <sil=0.000> ar <sil=0.000> is <sil=0.000> pointing <sil=0.000> to <sil=0.000> each <sil=0.000> of <sil=0.000> these <sil=0.000> 1
dimensional <sil=0.000> arrays <sil=0.000> ch-arr <sil=0.000> is <sil=0.000> pointing <sil=0.000> to <sil=0.000> 1 one <sil=0.000> dimensional <sil=0.000> array <sil=2.000> .PERIOD  And <sil=0.000> as <sil=0.000> I increment <sil=0.000> the
pointer <sil=0.000> this <sil=0.000> pointer <sil=0.000> is <sil=0.000> going <sil=0.000> on <sil=0.000> increasing <sil=0.000> alright <sil=0.000> in <sil=0.000> general <sil=0.000> ch-arr <sil=0.000> I points <sil=0.000> to <sil=0.000> the <sil=0.000> I th
string <sil=0.000> of <sil=0.000> the <sil=0.000> yet <sil=0.000> 1 dimensional <sil=0.000> array <sil=0.000> clear <sil=2.000> .PERIOD 

The <sil=0.000> following <sil=0.000> program <sil=0.000> let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> the <sil=0.000> program <sil=0.000> and <sil=0.000> the <sil=0.000> following <sil=0.000> program
demonstrates <sil=0.000> how <sil=0.000> to <sil=0.000> print <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> strings <sil=0.228> ?QUESTIONMARK  Please <sil=0.000> take <sil=0.000> 1 minute <sil=0.000> to <sil=0.000> read <sil=0.000> this <sil=0.000> array <sil=0.000> a
program <sil=0.000> yourself <sil=0.000> and <sil=0.000> try <sil=0.000> to <sil=0.000> understand <sil=2.000> .PERIOD  It <sil=0.000> you <sil=0.000> can <sil=0.000> see <sil=0.000> here <sil=0.000> that <sil=0.000> I am <sil=0.000> starting <sil=0.000> with <sil=0.000> the
main <sil=0.000> function <sil=0.000> and <sil=0.000> although <sil=0.000> it <sil=0.000> is <sil=0.000> written <sil=0.000> in <sil=0.000> a 1 <sil=0.000> in <sil=0.000> a very <sil=0.000> cryptic <sil=0.000> way <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  my <sil=0.000> program
starts <sil=0.000> from <sil=0.000> this <sil=0.000> point <sil=0.000> and <sil=0.000> ends <sil=0.000> at <sil=0.000> this <sil=0.000> point <sil=1.000> ,COMMA  i <sil=0.000> is <sil=0.000> an <sil=0.000> integer <sil=0.000> ch-arr <sil=0.000> is <sil=0.000> again <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> 3
strings <sil=0.000> and <sil=0.000> each <sil=0.000> can <sil=0.000> be <sil=0.000> of <sil=0.000> maximum <sil=0.000> length <sil=0.000> 10 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  spike <sil=0.000> tom <sil=0.000> and <sil=0.000> jerry <sil=0.000> are <sil=0.000> there <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> print <sil=0.000> I just <sil=0.000> print <sil=0.000> first <sil=0.000> way <sil=0.000> next <sil=0.000> line <sil=0.000> I go <sil=0.000> to <sil=0.000> next <sil=0.000> line <sil=0.000> and <sil=0.000> to <sil=0.000> next <sil=0.000> line <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> just
put <sil=0.000> first <sil=0.000> way <sil=0.000> and <sil=0.000> then <sil=0.000> what <sil=0.000> do <sil=0.000> I do <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> print <sil=0.000> first <sil=0.000> way <sil=0.000> and <sil=0.000> then <sil=0.000> 2 lines <sil=0.000> have <sil=0.000> been
given <sil=0.000> blank <sil=1.000> ,COMMA  then <sil=0.000> for <sil=0.000> i 0 <sil=0.000> 2 less <sil=0.000> than <sil=0.000> 3 i <sil=0.000> plus <sil=0.000> plus <sil=0.000> printf <sil=0.000> string <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> printing <sil=0.000> the <sil=0.000> string <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
what <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=0.000> string <sil=0.000> equals <sil=0.000> a placeholder <sil=0.000> for <sil=0.000> the <sil=0.000> string <sil=0.000> and <sil=0.000> then <sil=0.000> there <sil=0.000> will <sil=0.000> be <sil=0.000> some
tab <sil=0.000> 1 space <sil=0.000> and <sil=0.000> then <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  the <sil=0.000> first <sil=0.000> will <sil=0.000> be <sil=0.000> string <sil=0.000> here <sil=0.000> some <sil=0.000> space <sil=0.000> and <sil=0.000> then <sil=0.000> tab <sil=0.000> this <sil=0.000> is <sil=0.000> tab <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> give <sil=0.000> some <sil=0.000> space <sil=0.000> and <sil=0.000> write <sil=0.000> address <sil=0.000> and <sil=0.000> then <sil=0.000> sorry <sil=0.000> string <sil=0.000> equal <sil=0.000> to <sil=0.000> string <sil=0.000> equal <sil=0.000> to
address <sil=0.000> equal <sil=0.000> to <sil=0.000> and <sil=0.000> there <sil=0.000> should <sil=0.000> be <sil=0.000> some <sil=0.000> space <sil=0.000> for <sil=0.000> the <sil=0.000> address <sil=0.000> and <sil=0.000> that <sil=0.000> format <sil=0.000> is
unsigned <sil=0.000> integer <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> become <sil=0.000> longer <sil=0.000> alright <sil=2.000> .PERIOD 
Because <sil=0.000> unsigned <sil=0.000> and <sil=0.000> signed <sil=0.000> integer <sil=0.000> a whenever <sil=0.000> I am <sil=0.000> putting <sil=0.000> suppose <sil=0.000> I have <sil=0.000> got <sil=0.000> 16 <sil=0.000> bits
for <sil=0.000> representing <sil=0.000> an <sil=0.000> integer <sil=2.000> .PERIOD  If <sil=0.000> it <sil=0.000> be <sil=0.000> assigned <sil=0.000> if <sil=0.000> I distinguish <sil=0.000> between <sil=0.000> plus <sil=0.000> 5 and <sil=0.000> minus <sil=0.000> 5
and <sil=0.000> keep <sil=0.000> 1 bit <sil=0.000> kept <sil=0.000> for <sil=0.000> the <sil=0.000> plus <sil=0.000> or <sil=0.000> minus <sil=0.000> then <sil=0.000> for <sil=0.000> the <sil=0.000> 16 <sil=0.000> bit <sil=0.000> I will <sil=0.000> be <sil=0.000> actually <sil=0.000> having <sil=0.000> 15
bits <sil=0.000> for <sil=0.000> this <sil=0.000> size <sil=1.000> ,COMMA  but <sil=0.000> if <sil=0.000> I make <sil=0.000> it <sil=0.000> unsigned <sil=0.000> then <sil=0.000> I can <sil=0.000> have <sil=0.000> all <sil=0.000> these <sil=0.000> 16 <sil=0.000> bits <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> can
represent <sil=0.000> more <sil=0.000> numbers <sil=0.000> all <sil=0.000> right <sil=0.000> more <sil=0.000> numbers <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  that <sil=0.000> apart <sil=0.000> so <sil=1.000> ,COMMA  string <sil=0.000> and <sil=0.000> address <sil=0.000> and <sil=0.000> then <sil=0.000> what <sil=0.000> am <sil=0.000> I printing <sil=0.000> here <sil=0.000> care <sil=0.000> I care <sil=0.000> plus <sil=0.000> i <sil=0.354> ;SEMICOLON 
that <sil=0.000> means <sil=1.000> ,COMMA  0 <sil=0.000> care <sil=0.000> 0 the <sil=0.000> first <sil=0.000> string <sil=0.000> and <sil=0.000> then <sil=0.000> I am <sil=0.000> again <sil=0.000> putting <sil=0.000> the <sil=0.000> care <sil=0.000> this <sil=1.000> ,COMMA  now <sil=0.000> what <sil=0.000> is
the <sil=0.000> difference <sil=0.000> between <sil=0.000> this <sil=0.000> care <sil=0.000> this <sil=0.000> and <sil=0.000> this <sil=0.000> is <sil=0.000> being <sil=0.000> printed <sil=0.000> in <sil=0.000> percentage <sil=0.000> arrays <sil=0.354> ;SEMICOLON  that
means <sil=1.000> ,COMMA  the <sil=0.000> string <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=0.000> and <sil=0.000> here <sil=0.000> in <sil=0.000> an <sil=0.000> unsigned <sil=0.000> integer <sil=0.000> what <sil=0.000> I am <sil=0.000> printing <sil=0.000> here
is <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> that <sil=0.000> string <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  this <sil=0.000> string <sil=0.000> spike <sil=0.000> was <sil=0.000> here <sil=0.000> when <sil=0.000> I print <sil=0.000> this <sil=0.000> just <sil=0.000> the <sil=0.000> name <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  I
am <sil=0.000> in <sil=0.000> this <sil=0.000> format <sil=0.000> if <sil=0.000> I do <sil=0.000> I am <sil=0.000> printing <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> it <sil=0.000> therefore <sil=1.000> ,COMMA  the <sil=0.000> output <sil=0.000> will <sil=0.000> be
somehow <sil=0.000> like <sil=0.000> this <sil=0.000> ok <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> something <sil=0.000> to <sil=0.000> be <sil=0.000> understood <sil=0.000> very <sil=0.000> clearly <sil=0.000> that <sil=0.000> this <sil=0.000> array

when <sil=0.000> I am <sil=0.000> actually <sil=0.000> looking <sil=0.000> at <sil=0.000> this <sil=0.000> I am <sil=0.000> taking <sil=0.000> the <sil=0.000> content <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=0.000> otherwise <sil=0.000> I am
taking <sil=0.000> the <sil=0.000> array <sil=0.000> itself <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> a program <sil=2.000> .PERIOD 

This <sil=0.000> program <sil=0.000> asks <sil=0.000> the <sil=0.000> user <sil=0.000> to <sil=0.000> enter <sil=0.000> a username <sil=0.000> if <sil=0.000> the <sil=0.000> username <sil=0.000> entered <sil=0.000> is <sil=0.000> one <sil=0.000> of <sil=0.000> the
names <sil=0.000> in <sil=0.000> the <sil=0.000> master <sil=0.000> list <sil=0.000> then <sil=0.000> the <sil=0.000> user <sil=0.000> is <sil=0.000> allowed <sil=0.000> to <sil=0.000> calculate <sil=0.000> the <sil=0.000> factorial <sil=0.000> of <sil=0.000> a number
otherwise <sil=0.000> an <sil=0.000> error <sil=0.000> message <sil=0.000> is <sil=0.000> displayed <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> got <sil=0.000> sorry <sil=0.000> a master <sil=0.000> list <sil=0.000> of <sil=0.000> names <sil=0.000> now <sil=0.000> if <sil=0.000> you <sil=0.000> are <sil=0.000> a valid <sil=0.000> user <sil=0.000> your <sil=0.000> name <sil=0.000> is
there <sil=0.000> in <sil=0.000> the <sil=0.000> list <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  first <sil=0.000> what <sil=0.000> is <sil=0.000> doing <sil=0.000> it <sil=0.000> is <sil=0.000> including <sil=0.000> stdio <sil=0.000> dot <sil=0.000> h it <sil=0.000> is <sil=0.000> including <sil=0.000> string <sil=0.000> dot
h <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  some <sil=0.000> string <sil=0.000> functions <sil=0.000> are <sil=0.000> also <sil=0.000> included <sil=0.000> I am <sil=0.000> defining <sil=0.000> the <sil=0.000> factorial
prototype <sil=0.000> the <sil=0.000> factorial <sil=0.000> function <sil=0.000> has <sil=0.000> been <sil=0.000> written <sil=0.000> later <sil=2.000> .PERIOD  Suppose <sil=0.000> this <sil=0.000> part <sil=0.000> this <sil=0.000> part <sil=0.000> is <sil=0.000> later
than <sil=0.000> the <sil=0.000> main <sil=0.000> function <sil=0.000> ok <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  the <sil=0.000> main <sil=0.000> is <sil=0.000> here <sil=0.000> and <sil=0.000> what <sil=0.000> is <sil=0.000> the <sil=0.000> main <sil=0.000> doing <sil=0.000> it <sil=0.000> has <sil=0.000> got <sil=0.000> some <sil=0.000> integer <sil=0.000> I and <sil=0.000> found <sil=0.000> is <sil=0.000> 0
initially <sil=0.000> the <sil=0.000> name <sil=0.000> is <sil=0.000> not <sil=0.000> found <sil=0.000> here <sil=0.000> and <sil=0.000> some <sil=0.000> n number <sil=0.000> for <sil=0.000> which <sil=0.000> I have <sil=0.000> to <sil=0.000> compute <sil=0.000> the
factorial <sil=1.000> ,COMMA  master <sil=0.000> list <sil=0.000> 5 by <sil=0.000> 20 <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  each <sil=0.000> of <sil=0.000> these <sil=0.000> each <sil=0.000> of <sil=0.000> these <sil=0.000> can <sil=0.000> be <sil=0.000> 20 <sil=0.000> character
long <sil=0.000> and <sil=0.000> there <sil=0.000> are <sil=0.000> 5 search <sil=2.000> .PERIOD  And <sil=0.000> I put <sil=0.000> the <sil=0.000> valid <sil=0.000> names <sil=0.000> as <sil=0.000> admin <sil=0.000> tom <sil=1.000> ,COMMA  bob <sil=1.000> ,COMMA  tim <sil=1.000> ,COMMA  and <sil=0.000> jim <sil=2.000> .PERIOD 
Now <sil=0.000> I am <sil=0.000> asking <sil=0.000> a name <sil=0.000> is <sil=0.000> so <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> and <sil=0.000> I am <sil=0.000> asking <sil=0.000> from <sil=0.000> the <sil=0.000> user <sil=0.000> enter <sil=0.000> user <sil=0.000> name <sil=0.000> now
the <sil=0.000> user <sil=0.000> gives <sil=0.000> the <sil=0.000> name <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  get <sil=0.000> s here <sil=0.000> you <sil=0.000> are <sil=0.000> getting <sil=0.000> a new <sil=0.000> function <sil=0.000> being <sil=0.000> introduced
here <sil=0.000> that <sil=0.000> is <sil=0.000> get <sil=0.000> s what <sil=0.000> is <sil=0.000> get <sil=0.000> s get <sil=0.000> care <sil=0.000> get <sil=0.000> ch <sil=1.000> ,COMMA  you <sil=0.000> know <sil=0.000> and <sil=0.000> here <sil=0.000> the <sil=0.000> get <sil=0.000> s means <sil=0.000> get <sil=0.000> the
string <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  in <sil=0.000> 1 short <sil=0.000> it <sil=0.000> is <sil=0.000> getting <sil=0.000> the <sil=0.000> string <sil=0.000> as <sil=0.000> the <sil=0.000> name <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  name <sil=0.000> I am <sil=0.000> getting <sil=0.000> from <sil=0.000> the <sil=0.000> user <sil=0.000> some <sil=0.000> name <sil=0.000> say <sil=0.000> it <sil=0.000> is <sil=0.000> jim <sil=0.000> suppose <sil=0.000> the <sil=0.000> user <sil=0.000> enters <sil=0.000> jim <sil=2.000> .PERIOD 
Now <sil=0.000> for <sil=0.000> I equals <sil=0.000> to <sil=0.000> 0 to <sil=0.000> 5 why <sil=0.000> 5 there <sil=0.000> are <sil=0.000> all <sil=0.000> the <sil=0.000> 5 names <sil=0.000> are <sil=0.000> here <sil=0.000> if <sil=0.000> string <sil=0.000> compare
name <sil=0.000> and <sil=0.000> master <sil=0.000> list <sil=0.000> I <sil=1.000> ,COMMA  if <sil=0.000> this <sil=0.000> character <sil=0.000> this <sil=0.000> string <sil=0.000> and <sil=0.000> this <sil=0.000> string <sil=0.000> matches <sil=0.000> then <sil=0.000> found <sil=0.000> is <sil=0.000> 1 <sil=1.000> ,COMMA 
otherwise <sil=0.000> I am <sil=0.000> again <sil=0.000> going <sil=0.000> in <sil=0.000> the <sil=0.000> fall <sil=0.000> loop <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  at <sil=0.000> every <sil=0.000> stage <sil=0.000> of <sil=0.000> the <sil=0.000> loop <sil=0.000> I am <sil=0.000> trying <sil=0.000> to <sil=0.000> compare <sil=0.000> this <sil=0.000> name <sil=0.000> with <sil=0.000> this <sil=0.000> string <sil=0.000> here <sil=0.000> there
is <sil=0.000> no <sil=0.000> match <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> come <sil=0.000> here <sil=0.000> no <sil=0.000> match <sil=0.000> no <sil=0.000> match <sil=0.000> in <sil=0.000> that <sil=0.000> way <sil=0.000> I come <sil=0.000> and <sil=0.000> find <sil=0.000> jim <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
here <sil=0.000> ultimately <sil=0.000> I will <sil=0.000> get <sil=0.000> found <sil=0.000> and <sil=0.000> then <sil=0.000> I will <sil=0.000> break <sil=2.000> .PERIOD  Now <sil=0.000> when <sil=0.000> I come <sil=0.000> out <sil=0.000> suppose <sil=0.000> it
was <sil=0.000> not <sil=0.000> jim <sil=1.000> ,COMMA  it <sil=0.000> was <sil=0.000> say <sil=0.000> jimmy <sil=0.000> alright <sil=0.000> then <sil=0.000> I do <sil=0.000> not <sil=0.000> get <sil=0.000> a match <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> come <sil=0.000> out
with <sil=0.000> found <sil=0.000> equal <sil=0.000> to <sil=0.000> 0 or <sil=0.000> found <sil=0.000> equal <sil=0.000> to <sil=0.000> 1 <sil=1.000> ,COMMA  he <sil=0.000> found <sil=0.000> equal <sil=0.000> to <sil=0.000> 1 then <sil=0.000> welcome <sil=0.000> then
welcome <sil=0.000> exclamation <sil=0.000> and <sil=0.000> then <sil=0.000> the <sil=0.000> name <sil=0.000> it <sil=0.000> is <sil=0.000> printing <sil=0.000> welcome <sil=0.000> jim <sil=2.000> .PERIOD 
And <sil=0.000> asking <sil=0.000> please <sil=0.000> enter <sil=0.000> the <sil=0.000> number <sil=0.000> is <sil=0.000> entering <sil=0.000> the <sil=0.000> number <sil=0.000> for <sil=0.000> the <sil=0.000> factorial <sil=0.000> and <sil=0.000> then <sil=0.000> here
you <sil=0.000> see <sil=0.000> in <sil=0.000> this <sil=0.000> printf <sil=0.000> I have <sil=0.000> called <sil=0.000> the <sil=0.000> factorial <sil=1.000> ,COMMA  that <sil=0.000> factorial <sil=0.000> of <sil=0.000> the <sil=0.000> number <sil=0.000> is <sil=0.000> this <sil=0.000> n is
this <sil=0.000> so <sil=1.000> ,COMMA  I <sil=0.000> call <sil=0.000> factorial <sil=0.000> and <sil=0.000> this <sil=0.000> part <sil=0.000> you <sil=0.000> know <sil=2.000> .PERIOD  Now <sil=0.000> that <sil=0.000> this <sil=0.000> n and <sil=0.000> this <sil=0.000> n and <sil=0.000> may <sil=0.000> not <sil=0.000> be
the <sil=0.000> same <sil=0.000> I mean <sil=0.000> they <sil=0.000> are <sil=0.000> two <sil=0.000> different <sil=0.000> locations <sil=1.000> ,COMMA  but <sil=0.000> they <sil=0.000> same <sil=0.000> it <sil=0.000> could <sil=0.000> have <sil=0.000> been <sil=0.000> x also
in <sil=0.000> that <sil=0.000> case <sil=0.000> internally <sil=0.000> had <sil=0.000> it <sil=0.000> had <sil=0.000> to <sil=0.000> be <sil=0.000> x here <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> being <sil=0.000> passed <sil=0.000> over <sil=0.000> here <sil=0.000> and <sil=0.000> the <sil=0.000> factorial <sil=0.000> is <sil=0.000> being <sil=0.000> computed <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD  Once <sil=0.000> the
factorial <sil=0.000> is <sil=0.000> computed <sil=1.000> ,COMMA  now <sil=0.000> how <sil=0.000> the <sil=0.000> factorial <sil=0.000> is <sil=0.000> computed <sil=0.000> I will <sil=0.000> be <sil=0.000> discussing <sil=0.000> that <sil=0.000> later <sil=1.000> ,COMMA 

because <sil=0.000> here <sil=0.000> there <sil=0.000> is <sil=0.000> some <sil=0.000> trick <sil=0.000> forget <sil=0.000> about <sil=0.000> that <sil=0.000> trick <sil=0.000> now <sil=0.000> I will <sil=0.000> be <sil=0.000> discussing <sil=0.000> that <sil=0.000> later
that <sil=0.000> is <sil=0.000> recursion <sil=1.000> ,COMMA  which <sil=0.000> you <sil=0.000> have <sil=0.000> not <sil=0.000> yet <sil=0.000> discussed <sil=0.000> and <sil=0.000> after <sil=0.000> this <sil=0.000> I am <sil=0.000> coming <sil=0.000> back <sil=0.000> here
and <sil=0.000> I am <sil=0.000> printing <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  the <sil=0.000> purpose <sil=0.000> of <sil=0.000> this <sil=0.000> program <sil=0.000> was <sil=0.000> to <sil=0.000> show <sil=0.000> how <sil=0.000> we <sil=0.000> can <sil=0.000> handle <sil=0.000> strings <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  these <sil=0.000> are
very <sil=0.000> common <sil=0.000> very <sil=0.000> common <sil=0.000> thing <sil=0.000> I mean <sil=0.000> you <sil=0.000> try <sil=0.000> to <sil=0.000> login <sil=0.000> in <sil=0.000> a machine <sil=0.000> right <sil=2.000> .PERIOD  And <sil=0.000> you
type <sil=0.000> in <sil=0.000> your <sil=0.000> login <sil=0.000> name <sil=0.000> and <sil=0.000> your <sil=0.000> password <sil=1.000> ,COMMA  if <sil=0.000> they <sil=0.000> do <sil=0.000> not <sil=0.000> match <sil=0.000> the <sil=0.000> system <sil=0.000> says <sil=0.000> login
failure <sil=0.000> now <sil=0.000> how <sil=0.000> does <sil=0.000> it <sil=0.000> do <sil=0.000> it <sil=0.000> internally <sil=2.000> .PERIOD 
Internally <sil=0.000> it <sil=0.000> has <sil=0.000> got <sil=0.000> a list <sil=0.000> of <sil=0.000> just <sil=0.000> like <sil=0.000> this <sil=0.000> it <sil=0.000> has <sil=0.000> got <sil=0.000> a list <sil=0.000> of <sil=0.000> all <sil=0.000> the <sil=0.000> users <sil=0.000> and <sil=0.000> it <sil=0.000> takes <sil=0.000> your
username <sil=0.000> and <sil=0.000> checks <sil=0.000> it <sil=0.000> with <sil=0.000> all <sil=0.000> these <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> a problem <sil=0.000> that <sil=0.000> is <sil=0.000> being <sil=0.000> solved <sil=0.000> a sub
problem <sil=0.000> that <sil=0.000> is <sil=0.000> being <sil=0.000> solved <sil=0.000> in <sil=0.000> the <sil=0.000> operating <sil=0.000> system <sil=0.000> and <sil=0.000> that <sil=0.000> is <sil=0.000> the <sil=0.000> basic <sil=0.000> principle <sil=0.000> is
depicted <sil=0.000> in <sil=0.000> this <sil=0.000> program <sil=0.000> alright <sil=0.000> we <sil=0.000> will <sil=0.000> continue <sil=0.000> with <sil=0.000> other <sil=0.000> problem <sil=0.000> solving <sil=0.000> approaches
in <sil=0.000> the <sil=0.000> future <sil=0.000> lectures <sil=2.000> .PERIOD 

Today <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> be <sil=0.000> looking <sil=0.000> at <sil=0.000> some <sil=0.000> real <sil=0.000> engineering <sil=0.000> applications <sil=0.000> of <sil=0.000> programming <sil=2.000> .PERIOD  We <sil=0.000> will <sil=0.000> see
how <sil=1.000> ,COMMA  whatever <sil=0.000> we <sil=0.000> have <sil=0.000> learnt <sil=0.000> till <sil=0.000> now <sil=0.000> can <sil=0.000> be <sil=0.000> applied <sil=0.000> to <sil=0.000> solve <sil=0.000> some <sil=0.000> interesting <sil=0.000> problems <sil=0.000> like
solving <sil=0.000> equations <sil=2.000> .PERIOD  One <sil=0.000> very <sil=0.000> common <sil=0.000> thing <sil=0.000> that <sil=0.000> we <sil=0.000> need <sil=0.000> in <sil=0.000> any <sil=0.000> engineering <sil=0.000> or <sil=0.000> science <sil=0.000> is <sil=0.000> to
represent <sil=0.000> data <sil=2.000> .PERIOD  One <sil=0.000> way <sil=0.000> of <sil=0.000> representing <sil=0.000> data <sil=0.000> is <sil=0.000> by <sil=0.000> in <sil=0.000> the <sil=0.000> form <sil=0.000> of <sil=0.000> a table <sil=0.000> right <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> always <sil=0.000> represent <sil=0.000> some <sil=0.000> data <sil=0.000> as <sil=0.000> a table <sil=0.000> where <sil=0.000> say <sil=0.000> on <sil=0.000> one <sil=0.000> column <sil=0.000> it <sil=0.000> can <sil=0.000> be <sil=0.000> height <sil=0.000> or
depth <sil=0.000> and <sil=0.000> maybe <sil=0.000> as <sil=0.000> we <sil=0.000> go <sil=0.000> down <sil=1.000> ,COMMA  we <sil=0.000> go <sil=0.000> through <sil=0.000> some <sil=0.000> point <sil=0.000> and <sil=0.000> at <sil=0.000> different <sil=0.000> depths <sil=1.000> ,COMMA  we <sil=0.000> put
some <sil=0.000> sensor <sil=0.000> and <sil=0.000> get <sil=0.000> the <sil=0.000> temperature <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  that <sil=0.000> I can <sil=0.000> represent <sil=0.000> in <sil=0.000> the <sil=0.000> form <sil=0.000> of <sil=0.000> whatever <sil=0.000> is <sil=0.000> a depth- 50 <sil=0.000> meters <sil=1.000> ,COMMA  some <sil=0.000> temperature <sil=1.000> ,COMMA  100
meters <sil=1.000> ,COMMA  some <sil=0.000> temperature <sil=0.000> etcetera <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> we <sil=0.000> need <sil=0.000> to <sil=0.000> represent <sil=0.000> any <sil=0.000> data <sil=0.000> in <sil=0.000> this <sil=0.000> form <sil=0.000> we <sil=0.000> know
how <sil=0.000> to <sil=0.000> do <sil=0.000> it <sil=0.228> ?QUESTIONMARK  We <sil=0.000> know <sil=0.000> that <sil=0.000> as <sil=0.000> it <sil=0.000> looks <sil=0.000> here -we <sil=0.000> can <sil=0.000> immediately <sil=0.000> say <sil=0.000> we <sil=0.000> will <sil=0.000> be <sil=0.000> representing <sil=0.000> it
as <sil=0.000> an <sil=0.000> array <sil=2.000> .PERIOD  Whether <sil=0.000> I will <sil=0.000> be <sil=0.000> representing <sil=0.000> them <sil=0.000> using <sil=0.000> as <sil=0.000> 1 array <sil=0.000> 1 2 <sil=0.000> dimensional <sil=0.000> array <sil=0.000> or <sil=0.000> two
different <sil=0.000> array - will <sil=0.000> depend <sil=0.000> on <sil=0.000> the <sil=0.000> format <sil=0.000> of <sil=0.000> the <sil=0.000> data <sil=0.000> the <sil=0.000> type <sil=0.000> of <sil=0.000> the <sil=0.000> data <sil=2.000> .PERIOD 

For <sil=0.000> example <sil=0.000> if <sil=0.000> the <sil=0.000> depth <sil=0.000> is <sil=0.000> integer <sil=0.000> and <sil=0.000> the <sil=0.000> temperature <sil=0.000> is <sil=0.000> real <sil=1.000> ,COMMA  then <sil=0.000> up <sil=0.000> to <sil=0.000> the <sil=0.000> knowledge <sil=0.000> that <sil=0.000> we
have <sil=0.000> acquired <sil=0.000> till <sil=0.000> now <sil=0.000> will <sil=0.000> be <sil=0.000> representing <sil=0.000> them <sil=0.000> in <sil=0.000> the <sil=0.000> form <sil=0.000> of <sil=0.000> 2 arrays <sil=1.000> ,COMMA  1 <sil=0.000> is <sil=0.000> an <sil=0.000> integer <sil=0.000> array
another <sil=0.000> is <sil=0.000> a separate <sil=0.000> floating <sil=0.000> point <sil=0.000> array  <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> oneway <sil=0.000> of <sil=0.000> representing <sil=0.000> data <sil=0.000> as <sil=0.000> we <sil=0.000> have
done <sil=0.000> also <sil=0.000> in <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> students <sil=0.000> roll <sil=0.000> number <sil=0.000> and <sil=0.000> marks <sil=0.000> earlier <sil=2.000> .PERIOD  Another <sil=0.000> very <sil=0.000> interesting <sil=0.000> and
important <sil=0.000> thing <sil=0.000> is <sil=0.000> representing <sil=0.000> graphs <sil=2.000> .PERIOD 

For <sil=0.000> example <sil=1.000> ,COMMA  I <sil=0.000> want <sil=0.000> to <sil=0.000> represent <sil=0.000> a graph <sil=0.000> say <sil=0.000> this <sil=0.000> is <sil=0.000> some <sil=0.000> pressure <sil=0.000> and <sil=0.000> this <sil=0.000> is <sil=0.000> depth <sil=0.000> and <sil=0.000> as <sil=0.000> this
graph <sil=0.000> shows <sil=0.000> that <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> increasing <sil=0.000> in <sil=0.000> a uniform <sil=0.000> way <sil=0.000> with <sil=0.000> depth <sil=2.000> .PERIOD  There <sil=0.000> could <sil=0.000> be <sil=0.000> some <sil=0.000> graph <sil=1.000> ,COMMA 
which <sil=0.000> would <sil=0.000> be <sil=0.000> just <sil=0.000> linear <sil=2.000> .PERIOD  We <sil=0.000> call <sil=0.000> it <sil=0.000> linear <sil=1.000> ,COMMA  where <sil=0.000> along <sil=0.000> with <sil=0.000> depth <sil=0.000> this <sil=0.000> increases <sil=0.000> in <sil=0.000> a linear
fashion <sil=1.000> ,COMMA <sil=0.000> here <sil=0.000> it <sil=0.000> is <sil=0.000> non-linear  <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  the <sil=0.000> question <sil=0.000> is <sil=0.000> how <sil=0.000> do <sil=0.000> we <sil=0.000> represent <sil=0.000> this <sil=0.000> sort <sil=0.000> of <sil=0.000> graph <sil=0.228> ?QUESTIONMARK  Now <sil=0.000> you <sil=0.000> know <sil=0.000> that <sil=0.000> in <sil=0.000> this <sil=0.000> graph <sil=0.000> I
can <sil=0.000> also <sil=0.000> state <sil=0.000> that <sil=0.000> this <sil=0.000> is <sil=0.000> the <sil=0.000> X axis <sil=0.000> and <sil=0.000> my <sil=0.000> independent <sil=0.000> variable <sil=0.000> is <sil=0.000> x and <sil=0.000> the <sil=0.000> dependent <sil=0.000> variable
is <sil=0.000> y <sil=1.000> ,COMMA  then <sil=0.000> this <sil=0.000> graph <sil=0.000> essentially <sil=0.000> represents <sil=0.000> a function <sil=1.000> ,COMMA  which <sil=0.000> is <sil=0.000> y <sil=1.000> ,COMMA  a <sil=0.000> function <sil=0.000> of <sil=0.000> x <sil=2.000> .PERIOD  Now <sil=0.000> depending
on <sil=0.000> the <sil=0.000> nature <sil=0.000> of <sil=0.000> variation <sil=0.000> of <sil=0.000> the <sil=0.000> dependent <sil=0.000> variable <sil=0.000> with <sil=0.000> the <sil=0.000> independent <sil=0.000> variable <sil=1.000> ,COMMA  the <sil=0.000> nature <sil=0.000> of
the <sil=0.000> function <sil=0.000> will <sil=0.000> vary <sil=2.000> .PERIOD  This <sil=0.000> one <sil=0.000> will <sil=0.000> be <sil=0.000> a linear <sil=0.000> function <sil=0.000> right <sil=2.000> .PERIOD 

For <sil=0.000> example <sil=0.000> it <sil=0.000> can <sil=0.000> be <sil=0.000> y equals <sil=0.000> to <sil=0.000> some <sil=0.000> k x <sil=2.000> .PERIOD  This <sil=0.000> one <sil=0.000> is <sil=0.000> more <sil=0.000> complex <sil=0.000> I could <sil=0.000> have <sil=0.000> had <sil=0.000> a
quadratic <sil=0.000> function <sil=0.000> also <sil=0.000> this <sil=0.000> is <sil=0.000> a linear <sil=0.000> function <sil=2.000> .PERIOD  Now <sil=0.000> the <sil=0.000> question <sil=0.000> that <sil=0.000> we <sil=0.000> would <sil=0.000> like <sil=0.000> to <sil=0.000> first

address <sil=0.000> is <sil=0.000> that <sil=0.000> it <sil=0.000> is <sil=0.000> so <sil=0.000> very <sil=0.000> nice <sil=0.000> to <sil=0.000> draw <sil=0.000> a picture <sil=0.000> on <sil=0.000> a piece <sil=0.000> of <sil=0.000> paper <sil=0.354> ;SEMICOLON  however <sil=1.000> ,COMMA  a <sil=0.000> computer <sil=0.000> will
not <sil=0.000> be <sil=0.000> able <sil=0.000> to <sil=0.000> just <sil=0.000> interpret <sil=0.000> this <sil=0.000> picture <sil=0.000> as <sil=0.000> we <sil=0.000> do <sil=0.000> then <sil=0.000> in <sil=0.000> that <sil=0.000> case <sil=0.000> how <sil=0.000> do <sil=0.000> we <sil=0.000> represent <sil=0.000> this <sil=0.000> graph <sil=0.000> in <sil=0.000> a computer <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> do <sil=0.000> it <sil=0.000> again <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> a graph <sil=0.000> let <sil=0.000> us <sil=0.000> say <sil=0.000> a linear <sil=0.000> graph <sil=0.000> and <sil=0.000> I can <sil=0.000> say <sil=0.000> that <sil=0.000> for <sil=0.000> different <sil=0.000> values <sil=0.000> of <sil=0.000> x what <sil=0.000> is <sil=0.000> the <sil=0.000> corresponding <sil=0.000> value <sil=0.000> of <sil=0.000> y <sil=0.228> ?QUESTIONMARK  Now <sil=0.000> this <sil=0.000> is <sil=0.000> a linear <sil=0.000> one <sil=2.000> .PERIOD  If <sil=0.000> x and <sil=0.000> y are <sil=0.000> the <sil=0.000> same <sil=0.000> type <sil=0.000> I can <sil=0.000> also
represent <sil=0.000> them <sil=0.000> in <sil=0.000> the <sil=0.000> form <sil=0.000> of <sil=0.000> a table <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  a <sil=0.000> 2 dimensional <sil=0.000> array <sil=1.000> ,COMMA  where <sil=0.000> one <sil=0.000> side <sil=1.000> ,COMMA  one
dimension <sil=0.000> is <sil=0.000> the <sil=0.000> variation <sil=0.000> of <sil=0.000> x on <sil=0.000> one <sil=0.000> column <sil=0.000> we <sil=0.000> have <sil=0.000> got <sil=0.000> the <sil=0.000> x and <sil=0.000> the <sil=0.000> corresponding <sil=0.000> y all
right <sil=2.000> .PERIOD 

What <sil=0.000> will <sil=0.000> be <sil=0.000> the <sil=0.000> number <sil=0.000> of <sil=0.000> rows <sil=0.228> ?QUESTIONMARK  The <sil=0.000> number <sil=0.000> of <sil=0.000> data <sil=0.000> points <sil=0.000> of <sil=0.000> x that <sil=0.000> we <sil=0.000> take <sil=0.000> will <sil=0.000> be <sil=0.000> the
number <sil=0.000> of <sil=0.000> rows <sil=2.000> .PERIOD  How <sil=0.000> many <sil=0.228> ?QUESTIONMARK - n <sil=0.000> and <sil=0.000> this <sil=0.000> one <sil=0.000> is <sil=0.000> fixed <sil=0.000> to <sil=0.000> be <sil=0.000> 2 <sil=2.000> .PERIOD  I <sil=0.000> can <sil=0.000> suppose <sil=0.000> that <sil=0.000> this <sil=0.000> is <sil=0.000> 5 <sil=2.000> .PERIOD <sil=0.000> 0 and
this <sil=0.000> is <sil=0.000> 25 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> 5 here <sil=0.000> I have <sil=0.000> 25 <sil=0.000> here - this <sil=0.000> array <sil=0.000> is <sil=0.000> of <sil=0.000> type <sil=0.000> float <sil=0.000> now <sil=0.000> here <sil=0.000> it <sil=0.000> is <sil=0.000> ten <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is
50 <sil=1.000> ,COMMA  it <sil=0.000> may <sil=0.000> be <sil=0.000> 15 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> one <sil=0.000> will <sil=0.000> be <sil=0.000> 30 <sil=1.000> ,COMMA  because <sil=0.000> I am <sil=0.000> talking <sil=0.000> of <sil=0.000> a linear <sil=0.000> curve <sil=0.000> it <sil=0.000> need <sil=0.000> not <sil=0.000> be <sil=0.000> linear <sil=0.000> all <sil=0.000> the <sil=0.000> time <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> also <sil=0.000> have <sil=0.000> a curve <sil=0.000> like <sil=0.000> this <sil=1.000> ,COMMA  say <sil=0.000> something <sil=0.000> like <sil=0.000> this <sil=0.000> and <sil=0.000> here <sil=0.000> again <sil=0.000> I have <sil=0.000> got <sil=0.000> the <sil=0.000> y and
here <sil=0.000> I have <sil=0.000> got <sil=0.000> the <sil=0.000> x <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  with <sil=0.000> a particular <sil=0.000> value <sil=0.000> of <sil=0.000> x say <sil=0.000> 5 <sil=1.000> ,COMMA  maybe <sil=0.000> this <sil=0.000> 1 is <sil=0.000> initially <sil=2.000> .PERIOD  Let <sil=0.000> us <sil=0.000> say <sil=0.000> it
has <sil=0.000> risen <sil=0.000> a little <sil=0.000> sharp <sil=0.000> so <sil=1.000> ,COMMA  maybe <sil=0.000> it <sil=0.000> is <sil=0.000> 7 and <sil=0.000> if <sil=0.000> I go <sil=0.000> here <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  please <sil=0.000> note <sil=0.000> that <sil=0.000> we <sil=0.000> usually <sil=0.000> take <sil=0.000> the
samples <sil=0.000> at <sil=0.000> equal <sil=0.000> distances <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> take <sil=0.000> it <sil=0.000> as <sil=0.000> 10 <sil=1.000> ,COMMA  but <sil=0.000> here <sil=0.000> it <sil=0.000> will <sil=0.000> not <sil=0.000> be <sil=0.000> doubling <sil=2.000> .PERIOD  it <sil=0.000> is <sil=0.000> becoming <sil=0.000> a
little <sil=0.000> more <sil=0.000> than <sil=0.000> that <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  7  <sil=1.000> ,COMMA <sil=0.000> it <sil=0.000> may <sil=0.000> be <sil=0.000> 16 <sil=2.000> .PERIOD  I <sil=0.000> go <sil=0.000> here <sil=0.000> now <sil=1.000> ,COMMA  you <sil=0.000> see <sil=0.000> the <sil=0.000> slope <sil=0.000> of <sil=0.000> this <sil=0.000> curve <sil=0.000> has
reduced <sil=0.000> right <sil=0.000> the <sil=0.000> gradient <sil=0.000> has <sil=0.000> reduced <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  at <sil=0.000> 15 <sil=0.000> it <sil=0.000> will <sil=0.000> not <sil=0.000> increase <sil=0.000> that <sil=0.000> much <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> 18 <sil=1.000> ,COMMA  because <sil=0.000> it <sil=0.000> is <sil=0.000> still <sil=0.000> flattening <sil=0.000> out <sil=0.000> and <sil=0.000> here
there <sil=0.000> is <sil=0.000> a sharp <sil=0.000> change <sil=0.000> etcetera  <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> one <sil=0.000> also <sil=0.000> I can <sil=0.000> represent <sil=0.000> in <sil=0.000> the <sil=0.000> form <sil=0.000> of <sil=0.000> a table <sil=0.000> like <sil=0.000> say <sil=0.000> I have <sil=0.000> a 2 <sil=0.000> dimensional <sil=0.000> table <sil=1.000> ,COMMA  where <sil=0.000> I have <sil=0.000> got <sil=0.000> 5 <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> my <sil=0.000> x and <sil=0.000> this <sil=0.000> is <sil=0.000> my <sil=0.000> y <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  5
corresponding <sil=0.000> to <sil=0.000> that <sil=0.000> 7 first <sil=0.000> row <sil=0.000> that <sil=0.000> is <sil=0.000> the <sil=0.000> first <sil=0.000> point <sil=2.000> .PERIOD  I <sil=0.000> could <sil=0.000> have <sil=0.000> taken <sil=0.000> 0 0 <sil=0.000> also <sil=0.000> that <sil=0.000> would <sil=0.000> be
another <sil=0.000> one <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  10 <sil=0.000> corresponding <sil=0.000> to <sil=0.000> that <sil=0.000> 16 <sil=0.000> then <sil=0.000> 15 <sil=0.000> corresponding <sil=0.000> to <sil=0.000> that <sil=0.000> 18 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> way <sil=0.000> it <sil=0.000> could <sil=0.000> go <sil=0.000> on <sil=0.354> ;SEMICOLON 
that <sil=0.000> means <sil=1.000> ,COMMA  whatever <sil=0.000> is <sil=0.000> this <sil=0.000> function <sil=0.000> f x <sil=1.000> ,COMMA  a <sil=0.000> function <sil=0.000> can <sil=0.000> be <sil=0.000> represented <sil=0.000> as <sil=0.000> an <sil=0.000> array  <sil=1.000> ,COMMA  a <sil=0.000> 2
dimensional <sil=0.000> array <sil=0.000> so <sil=1.000> ,COMMA  that <sil=0.000> all <sil=0.000> as <sil=0.000> a table <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> we <sil=0.000> have <sil=0.000> to <sil=0.000> remember <sil=0.000> either <sil=0.000> as <sil=0.000> 1 array <sil=0.000> or <sil=0.000> as <sil=0.000> 2
arrays <sil=1.000> ,COMMA  because <sil=0.000> if <sil=0.000> this <sil=0.000> was <sil=0.000> integer <sil=0.000> this <sil=0.000> was <sil=0.000> float <sil=0.000> then <sil=0.000> I would <sil=0.000> have <sil=0.000> needed <sil=0.000> 2 different <sil=0.000> arrays <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> a function <sil=0.000> now <sil=0.000> let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> another <sil=0.000> aspect <sil=2.000> .PERIOD 

I <sil=0.000> do <sil=0.000> not <sil=0.000> have <sil=0.000> the <sil=0.000> function <sil=1.000> ,COMMA  but <sil=0.000> I have <sil=0.000> got <sil=0.000> some <sil=0.000> data <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> x and <sil=0.000> here <sil=0.000> is <sil=0.000> y and <sil=0.000> I have <sil=0.000> got
some <sil=0.000> data <sil=0.000> points <sil=0.000> for <sil=0.000> x equal <sil=0.000> to <sil=0.000> this <sil=0.000> is <sil=0.000> the <sil=0.000> y point  <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> I call <sil=0.000> it <sil=0.000> x 0 <sil=0.000> this <sil=0.000> is <sil=0.000> y 0 <sil=2.000> .PERIOD  Next <sil=0.000> one <sil=0.000> could <sil=0.000> be
here - x <sil=0.000> 1 <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> y 1 <sil=2.000> .PERIOD  Here <sil=0.000> maybe <sil=0.000> it <sil=0.000> has <sil=0.000> come <sil=0.000> down <sil=0.000> for <sil=0.000> x 2 <sil=0.000> it <sil=0.000> is <sil=0.000> y 2 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> do <sil=0.000> not <sil=0.000> have <sil=0.000> a function
right <sil=0.000> now <sil=1.000> ,COMMA  but <sil=0.000> I have <sil=0.000> got <sil=0.000> different <sil=0.000> data <sil=0.000> points <sil=0.000> and <sil=0.000> I have <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> function <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> also
another <sil=0.000> very <sil=0.000> interesting <sil=0.000> thing <sil=0.000> finding <sil=0.000> out <sil=0.000> the <sil=0.000> function <sil=0.000> that <sil=0.000> can <sil=0.000> represent <sil=0.000> this <sil=0.000> distribution <sil=0.000> of <sil=0.000> data
points <sil=1.000> ,COMMA  might <sil=0.000> be <sil=0.000> here <sil=0.000> again <sil=0.000> there <sil=0.000> is <sil=0.000> x 3 <sil=0.000> and <sil=0.000> it <sil=0.000> is <sil=0.000> again <sil=0.000> gone <sil=0.000> up <sil=0.000> here <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> not <sil=0.000> a straight <sil=0.000> line <sil=0.000> if <sil=0.000> I want <sil=0.000> to <sil=0.000> fit <sil=0.000> a curve <sil=0.000> to <sil=0.000> meet <sil=0.000> that <sil=0.000> how <sil=0.000> will <sil=0.000> that <sil=0.000> curve <sil=0.000> look <sil=0.000> like <sil=0.228> ?QUESTIONMARK  The
curve <sil=0.000> will <sil=0.000> be <sil=0.000> something <sil=0.000> like <sil=0.000> this <sil=0.000> right <sil=0.000> and <sil=0.000> I have <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> what <sil=0.000> function <sil=0.000> is <sil=0.000> this <sil=0.000> curve <sil=0.000> what <sil=0.000> is
the <sil=0.000> function <sil=2.000> .PERIOD  I <sil=0.000> do <sil=0.000> not <sil=0.000> know <sil=0.000> as <sil=0.000> it <sil=0.000> that <sil=0.000> is <sil=0.000> another <sil=0.000> challenging <sil=0.000> point <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  first <sil=0.000> of <sil=0.000> all <sil=0.000> graphs <sil=0.000> or <sil=0.000> data <sil=0.000> points <sil=0.000> graphs <sil=0.000> can <sil=0.000> be <sil=0.000> represented <sil=0.000> as <sil=0.000> table <sil=0.000> and <sil=0.000> the <sil=0.000> distribution <sil=0.000> of
data <sil=0.000> points <sil=0.000> can <sil=0.000> also <sil=0.000> be <sil=0.000> represented <sil=0.000> as <sil=0.000> table <sil=1.000> ,COMMA  because <sil=0.000> here <sil=0.000> in <sil=0.000> this <sil=0.000> scenario <sil=0.000> I do <sil=0.000> not <sil=0.000> have <sil=0.000> a
function <sil=1.000> ,COMMA  but <sil=0.000> certainly <sil=0.000> I have <sil=0.000> got <sil=0.000> the <sil=0.000> x and <sil=0.000> y values <sil=0.000> known <sil=0.000> to <sil=0.000> me <sil=2.000> .PERIOD  Therefore <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> represent <sil=0.000> that
as <sil=0.000> a table <sil=2.000> .PERIOD  Another <sil=0.000> point <sil=0.000> to <sil=0.000> note <sil=0.000> here <sil=0.000> is <sil=0.000> that <sil=0.000> usually <sil=0.000> this <sil=0.000> independent <sil=0.000> variable <sil=0.000> the <sil=0.000> sampling <sil=0.000> points <sil=0.000> that <sil=0.000> I am <sil=0.000> taking <sil=0.000> our <sil=0.000> usual <sil=0.000> equidistant <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> say <sil=0.000> x 1 <sil=0.000> minus <sil=0.000> x 0 <sil=0.000> is <sil=0.000> some <sil=0.000> value <sil=0.000> h x <sil=0.000> 2 minus <sil=0.000> x 1 <sil=0.000> will <sil=0.000> be <sil=0.000> the <sil=0.000> same <sil=0.000> h <sil=2.000> .PERIOD  Usually <sil=0.000> we
represent <sil=0.000> that <sil=0.000> in <sil=0.000> order <sil=0.000> to <sil=0.000> see <sil=0.000> a fixed <sil=0.000> incremental <sil=0.000> increase <sil=0.000> of <sil=0.000> the <sil=0.000> independent <sil=0.000> variable <sil=1.000> ,COMMA  how <sil=0.000> much
does <sil=0.000> the <sil=0.000> dependent <sil=0.000> variable <sil=0.000> vary <sil=0.228> ?QUESTIONMARK  <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> say <sil=0.000> in <sil=0.000> general <sil=0.000> x i <sil=0.000> plus <sil=0.000> 1 minus <sil=0.000> x i <sil=0.000> is <sil=0.000> equal <sil=0.000> to <sil=0.000> h right <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> typically <sil=0.000> how <sil=0.000> we <sil=0.000> write <sil=0.000> now <sil=2.000> .PERIOD  We <sil=0.000> have <sil=0.000> got <sil=0.000> a number <sil=0.000> of <sil=0.000> problems <sil=0.000> to <sil=0.000> solve <sil=0.000> using <sil=0.000> data <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  for <sil=0.000> example <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> start <sil=0.000> with <sil=0.000> one <sil=0.000> problem <sil=0.000> finding <sil=0.000> the <sil=0.000> root <sil=0.000> of <sil=0.000> a function <sil=0.000> some <sil=0.000> function <sil=0.000> fx <sil=2.000> .PERIOD 
Now <sil=0.000> finding <sil=0.000> the <sil=0.000> root <sil=0.000> means <sil=0.000> essentially <sil=0.000> it <sil=0.000> is <sil=0.000> solving <sil=0.000> the <sil=0.000> equation <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> I have <sil=0.000> got <sil=0.000> a function <sil=0.000> fx <sil=1.000> ,COMMA 
then <sil=0.000> my <sil=0.000> equation <sil=0.000> is <sil=0.000> fx <sil=0.000> equals <sil=0.000> 0 and <sil=0.000> I want <sil=0.000> to <sil=0.000> solve <sil=0.000> this <sil=0.000> right <sil=0.000> and <sil=0.000> I want <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> that <sil=0.000> root <sil=1.000> ,COMMA  at
least <sil=0.000> 1 root <sil=2.000> .PERIOD 

Now <sil=0.000> what <sil=0.000> do <sil=0.000> I mean <sil=0.000> by <sil=0.000> the <sil=0.000> root <sil=0.228> ?QUESTIONMARK  Say <sil=0.000> there <sil=0.000> is <sil=0.000> a function <sil=0.000> like <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  for <sil=0.000> what <sil=0.000> value <sil=0.000> of <sil=0.000> x f <sil=0.000> x
equal <sil=0.000> to <sil=0.000> 0 is <sil=0.000> the <sil=0.000> equation <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  this <sil=0.000> one <sil=0.000> is <sil=0.000> fx <sil=1.000> ,COMMA  y <sil=0.000> or <sil=0.000> fx <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> are <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> for <sil=0.000> what <sil=0.000> value <sil=0.000> of <sil=0.000> x <sil=1.000> ,COMMA 
for <sil=0.000> which <sil=0.000> value <sil=0.000> of <sil=0.000> x <sil=1.000> ,COMMA  f <sil=0.000> x is <sil=0.000> 0 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> the <sil=0.000> root <sil=2.000> .PERIOD  Now <sil=0.000> this <sil=0.000> particular <sil=0.000> function <sil=0.000> if <sil=0.000> this <sil=0.000> be <sil=0.000> an <sil=0.000> fx <sil=1.000> ,COMMA 
then <sil=0.000> it <sil=0.000> has <sil=0.000> got <sil=0.000> 2 distinct <sil=0.000> roots <sil=1.000> ,COMMA  another <sil=0.000> function <sil=0.000> could <sil=0.000> be <sil=0.000> something <sil=0.000> like <sil=0.000> this <sil=0.000> could <sil=0.000> be <sil=0.000> just <sil=0.000> like
this <sil=0.000> where <sil=0.000> I have <sil=0.000> got <sil=0.000> one <sil=0.000> root <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> the <sil=0.000> point <sil=0.000> where <sil=0.000> f x <sil=0.000> equal <sil=0.000> to <sil=0.000> 0 all <sil=0.000> right <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  one <sil=0.000> of <sil=0.000> the <sil=0.000> major <sil=0.000> problems <sil=0.000> is <sil=0.000> finding <sil=0.000> out <sil=0.000> the <sil=0.000> root <sil=0.000> of <sil=0.000> a function <sil=0.000> or <sil=0.000> we <sil=0.000> will <sil=0.000> say <sil=0.000> in <sil=0.000> general <sil=0.000> the
root <sil=0.000> of <sil=0.000> a polynomial <sil=2.000> .PERIOD  Why <sil=0.000> are <sil=0.000> we <sil=0.000> saying <sil=0.000> a polynomial <sil=0.228> ?QUESTIONMARK  Because <sil=0.000> you <sil=0.000> know <sil=0.000> that <sil=0.000> any <sil=0.000> function <sil=0.000> say
fx <sil=0.000> is <sil=0.000> equal <sil=0.000> to <sil=0.000> 3 x <sil=0.000> squared <sil=0.000> plus <sil=0.000> 2 x <sil=0.000> plus <sil=0.000> 3 is <sil=0.000> a polynomial <sil=0.000> of <sil=0.000> degree <sil=0.000> 2 or <sil=0.000> this <sil=0.000> is <sil=0.000> f 1 <sil=0.000> x <sil=2.000> .PERIOD 

I <sil=0.000> could <sil=0.000> have <sil=0.000> another <sil=0.000> f 2 <sil=0.000> x <sil=1.000> ,COMMA  as <sil=0.000> 4 x <sil=0.000> this <sil=0.000> is <sil=0.000> a polynomial <sil=0.000> of <sil=0.000> the <sil=0.000> 4 x <sil=0.000> plus <sil=0.000> 3 maybe <sil=2.000> .PERIOD  Now <sil=0.000> anybody <sil=0.000> who
remembers <sil=0.000> cool <sil=0.000> coordinate <sil=0.000> geometry <sil=0.000> this <sil=0.000> is <sil=0.000> a linear <sil=0.000> equation <sil=1.000> ,COMMA  because <sil=0.000> it <sil=0.000> is <sil=0.000> a polynomial <sil=0.000> of
degree <sil=0.000> 1 <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  if <sil=0.000> we <sil=0.000> say <sil=0.000> this <sil=0.000> to <sil=0.000> be <sil=0.000> y then <sil=0.000> this <sil=0.000> is <sil=0.000> y equals <sil=0.000> m x <sil=0.000> plus <sil=0.000> c <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  m <sil=0.000> this <sil=0.000> 4 is
nothing <sil=1.000> ,COMMA  but <sil=0.000> the <sil=0.000> slope <sil=0.000> of <sil=0.000> this <sil=0.000> straight <sil=0.000> line <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  there <sil=0.000> will <sil=0.000> be <sil=0.000> some <sil=0.000> slope <sil=0.000> of <sil=0.000> this <sil=0.000> straight <sil=0.000> line <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> linear  <sil=2.000> .PERIOD  This <sil=0.000> one <sil=0.000> is <sil=0.000> not <sil=0.000> linear <sil=0.000> this
quadratic <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> have <sil=0.000> the <sil=0.000> different <sil=0.000> functions <sil=0.000> which <sil=0.000> can <sil=0.000> be <sil=0.000> written <sil=0.000> as <sil=0.000> a polynomial <sil=0.000> and <sil=0.000> when
the <sil=0.000> polynomial <sil=0.000> is <sil=0.000> equated <sil=0.000> to <sil=0.000> 0 it <sil=0.000> becomes <sil=0.000> an <sil=0.000> equation <sil=0.000> and <sil=0.000> we <sil=0.000> want <sil=0.000> to <sil=0.000> solve <sil=0.000> that <sil=0.000> equation <sil=2.000> .PERIOD 
Problem <sil=0.000> number <sil=0.000> 2 is <sil=0.000> interpolating <sil=0.000> a function <sil=2.000> .PERIOD  I <sil=0.000> will <sil=0.000> describe <sil=0.000> what <sil=0.000> interpolation <sil=0.000> is <sil=0.000> a little
later <sil=2.000> .PERIOD <sil=0.000> But <sil=1.000> ,COMMA  before <sil=0.000> that <sil=0.000> let <sil=0.000> us <sil=0.000> try <sil=0.000> to <sil=0.000> see <sil=0.000> a very <sil=0.000> simple <sil=0.000> way <sil=0.000> of <sil=0.000> finding <sil=0.000> the <sil=0.000> root <sil=0.000> of <sil=0.000> a function <sil=0.354> ;SEMICOLON  say <sil=0.000> I
have <sil=0.000> got <sil=0.000> a function <sil=0.000> x and <sil=0.000> y alright <sil=0.000> and <sil=0.000> a function <sil=0.000> is <sil=0.000> something <sil=0.000> like <sil=0.000> this <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  I <sil=0.000> want <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> this <sil=0.000> point <sil=2.000> .PERIOD  What <sil=0.000> is <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> x <sil=0.228> ?QUESTIONMARK  This <sil=0.000> value <sil=1.000> ,COMMA  for <sil=0.000> which <sil=0.000> this <sil=0.000> y is <sil=0.000> 0 <sil=2.000> .PERIOD  Now
the <sil=0.000> method <sil=0.000> that <sil=0.000> we <sil=0.000> will <sil=0.000> be <sil=0.000> talking <sil=0.000> about <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> the <sil=0.000> bisection <sil=0.000> method <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> a very
common <sil=0.000> and <sil=0.000> interesting <sil=0.000> approach <sil=1.000> ,COMMA  you <sil=0.000> have <sil=0.000> seen <sil=0.000> in <sil=0.000> binary <sil=0.000> search <sil=0.000> also <sil=0.000> we <sil=0.000> have <sil=0.000> partitioned <sil=0.000> the
array <sil=0.000> into <sil=0.000> 2 halves <sil=0.000> and <sil=0.000> then <sil=0.000> went <sil=0.000> to <sil=0.000> one <sil=0.000> half <sil=2.000> .PERIOD  Very <sil=0.000> similar <sil=0.000> to <sil=0.000> that <sil=0.000> let <sil=0.000> us <sil=0.000> see <sil=0.000> how <sil=0.000> the <sil=0.000> bisection
method <sil=0.000> tries <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> root <sil=2.000> .PERIOD  First <sil=0.000> we <sil=0.000> start <sil=0.000> finding <sil=0.000> 2 arbitrary <sil=0.000> points <sil=0.000> say <sil=0.000> x0 <sil=0.000> and <sil=0.000> x1 <sil=1.000> ,COMMA  such <sil=0.000> that
fx0 <sil=0.000> and <sil=0.000> fx1 <sil=0.000> are <sil=0.000> of <sil=0.000> different <sil=0.000> signs <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> you <sil=0.000> can <sil=0.000> see <sil=0.000> this <sil=0.000> is <sil=0.000> plus <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> minus <sil=2.000> .PERIOD  f <sil=0.000> x1 <sil=0.000> is <sil=0.000> the <sil=0.000> y
value <sil=0.000> corresponding <sil=0.000> to <sil=0.000> x 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> the <sil=0.000> y value <sil=0.000> of <sil=0.000> x0 <sil=0.000> and <sil=0.000> x1 <sil=0.000> are <sil=0.000> opposite <sil=0.000> then <sil=0.000> it <sil=0.000> is <sil=0.000> immediately
understood <sil=0.000> that <sil=0.000> the <sil=0.000> root <sil=0.000> must <sil=0.000> lie <sil=0.000> somewhere <sil=0.000> in <sil=0.000> between  <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> then <sil=0.000> try <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> midpoint <sil=0.000> of <sil=0.000> x0 <sil=0.000> and <sil=0.000> x1 <sil=2.000> .PERIOD  Suppose <sil=0.000> the <sil=0.000> midpoint <sil=0.000> of <sil=0.000> x0 <sil=0.000> and <sil=0.000> x1 <sil=0.000> is
x2 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> x2 <sil=1.000> ,COMMA  fx <sil=0.000> 2 and <sil=0.000> f x0 <sil=0.000> are <sil=0.000> out <sil=0.000> of <sil=0.000> opposite <sil=0.000> sign <sil=1.000> ,COMMA  then <sil=0.000> the <sil=0.000> root <sil=0.000> must <sil=0.000> be <sil=0.000> I have (I <sil=0.000> have <sil=0.000> reduced
my <sil=0.000> space <sil=0.000> right) so <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> between <sil=0.000> x2 <sil=0.000> and <sil=0.000> x0 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> again <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> value <sil=0.000> the <sil=0.000> midpoint <sil=0.000> of <sil=0.000> x2 <sil=0.000> and
x0 <sil=2.000> .PERIOD  Suppose <sil=0.000> that <sil=0.000> midpoint <sil=0.000> is <sil=0.000> here <sil=1.000> ,COMMA  suppose <sil=0.000> this <sil=0.000> is <sil=0.000> x3 <sil=0.000> and <sil=0.000> these <sil=0.000> 2 fx3 <sil=0.000> and <sil=0.000> fx2 <sil=0.000> are <sil=0.000> of <sil=0.000> opposite
signs <sil=2.000> .PERIOD  Therefore <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> find <sil=0.000> the <sil=0.000> mid <sil=0.000> midpoint <sil=0.000> of <sil=0.000> these <sil=0.000> 2 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  suppose <sil=0.000> the <sil=0.000> midpoint <sil=0.000> of <sil=0.000> these <sil=0.000> two <sil=0.000> is
this <sil=0.000> x 4 <sil=0.000> here <sil=2.000> .PERIOD 

Now <sil=0.000> still <sil=0.000> this <sil=0.000> one <sil=0.000> and <sil=0.000> this <sil=0.000> one <sil=0.000> are <sil=0.000> of <sil=0.000> opposite <sil=0.000> sides <sil=0.000> therefore <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> try <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> midpoint
of <sil=0.000> these <sil=0.000> two <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> come <sil=0.000> somewhere <sil=0.000> here <sil=2.000> .PERIOD  In <sil=0.000> that <sil=0.000> way <sil=0.000> we <sil=0.000> approach <sil=0.000> till <sil=0.000> what <sil=0.000> till <sil=0.000> we <sil=0.000> find <sil=0.000> that
the <sil=0.000> value <sil=0.000> of <sil=0.000> y is <sil=0.000> very <sil=0.000> close <sil=0.000> to <sil=0.000> 0 <sil=1.000> ,COMMA  very <sil=0.000> close <sil=0.000> to <sil=0.000> 0 <sil=2.000> .PERIOD  Why <sil=0.000> am <sil=0.000> I saying <sil=0.000> very <sil=0.000> close <sil=0.000> to <sil=0.000> 0 not <sil=0.000> exactly <sil=0.000> 0
there <sil=0.000> are <sil=0.000> reasons <sil=0.000> for <sil=0.000> that <sil=1.000> ,COMMA  reasons <sil=0.000> we <sil=0.000> are <sil=0.000> coming <sil=0.000> to <sil=0.000> that <sil=2.000> .PERIOD  A <sil=0.000> computer <sil=0.000> works <sil=0.000> with <sil=0.000> finite
representation <sil=0.000> of <sil=0.000> numbers <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  we <sil=0.000> may <sil=0.000> not <sil=0.000> get <sil=0.000> exact <sil=0.000> 0 <sil=1.000> ,COMMA  but <sil=0.000> suppose <sil=0.000> I get <sil=0.000> this <sil=0.000> and <sil=0.000> then <sil=0.000> I can <sil=0.000> assume <sil=0.000> that <sil=0.000> to <sil=0.000> be <sil=0.000> 0 because <sil=0.000> it <sil=0.000> is
very <sil=0.000> small <sil=0.000> and <sil=0.000> often <sil=0.000> we <sil=0.000> call <sil=0.000> it <sil=0.000> that <sil=0.000> that <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> fx <sil=0.000> at <sil=0.000> that <sil=0.000> point <sil=0.000> is <sil=0.000> less <sil=0.000> than <sil=0.000> equal <sil=0.000> to <sil=0.000> some
very <sil=0.000> small <sil=0.000> value <sil=0.000> epsilon <sil=0.000> that <sil=0.000> will <sil=0.000> decide <sil=0.000> a prior <sil=2.000> .PERIOD 

So <sil=0.354> ;SEMICOLON  however <sil=0.000> so <sil=1.000> ,COMMA  you <sil=0.000> have <sil=0.000> seen <sil=0.000> this <sil=0.000> approach <sil=2.000> .PERIOD  Now <sil=0.000> one <sil=0.000> thing <sil=0.000> that <sil=0.000> you <sil=0.000> can <sil=0.000> quickly <sil=0.000> think <sil=0.000> of <sil=0.000> that
how <sil=0.000> would <sil=0.000> I know <sil=0.000> that <sil=0.000> these <sil=0.000> 2 are <sil=0.000> of <sil=0.000> opposite <sil=0.000> signs <sil=0.000> fx <sil=0.000> 1 and <sil=0.000> fx <sil=0.000> 0 are <sil=0.000> of <sil=0.000> opposite <sil=0.000> signs <sil=0.228> ?QUESTIONMARK  If <sil=0.000> I take
the <sil=0.000> product <sil=0.000> of <sil=0.000> this <sil=0.000> if <sil=0.000> I take <sil=0.000> the <sil=0.000> product <sil=0.000> of <sil=0.000> this <sil=0.000> then <sil=0.354> ;SEMICOLON  obviously <sil=1.000> ,COMMA  if <sil=0.000> they <sil=0.000> are <sil=0.000> opposite <sil=0.000> signs <sil=0.000> the
product <sil=0.000> will <sil=0.000> be <sil=0.000> negative <sil=0.000> that <sil=0.000> is <sil=0.000> less <sil=0.000> than <sil=0.000> 0 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  at <sil=0.000> every <sil=0.000> point <sil=0.000> we <sil=0.000> check <sil=0.000> whether <sil=0.000> they <sil=0.000> are <sil=0.000> less <sil=0.000> than <sil=0.000> 0 <sil=2.000> .PERIOD  If <sil=0.000> there <sil=0.000> is <sil=0.000> no <sil=0.000> root <sil=1.000> ,COMMA  suppose <sil=0.000> it <sil=0.000> goes <sil=0.000> like
this <sil=0.000> then <sil=0.000> I will <sil=0.000> not <sil=0.000> find <sil=0.000> any <sil=0.000> point <sil=0.000> where <sil=0.000> they <sil=0.000> are <sil=0.000> of <sil=0.000> opposite <sil=0.000> signs <sil=0.000> ok <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> the <sil=0.000> basic <sil=0.000> idea <sil=0.000> of
bisection <sil=0.000> method <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  when <sil=0.000> I carry <sil=0.000> it <sil=0.000> out <sil=0.000> through <sil=0.000> a computer <sil=0.000> such <sil=0.000> attempts <sil=0.000> to <sil=0.000> solve <sil=0.000> such
problems <sil=0.000> known <sil=0.000> as <sil=0.000> programming <sil=0.000> numerical <sil=0.000> methods <sil=2.000> .PERIOD 

We <sil=0.000> will <sil=0.000> start <sil=0.000> with <sil=0.000> some <sil=0.000> representative <sil=1.000> ,COMMA  relatively <sil=0.000> easy <sil=0.000> one <sil=0.000> examples <sil=0.000> of <sil=0.000> those <sil=2.000> .PERIOD  Some <sil=0.000> numerical
methods <sil=1.000> ,COMMA  one <sil=0.000> of <sil=0.000> them <sil=0.000> is <sil=0.000> finding <sil=0.000> the <sil=0.000> root <sil=0.000> of <sil=0.000> a function <sil=1.000> ,COMMA  root <sil=0.000> of <sil=0.000> a polynomial <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  while <sil=0.000> doing
these <sil=0.000> numerical <sil=0.000> methods <sil=0.000> we <sil=0.000> always <sil=0.000> encounter <sil=0.000> errors <sil=0.000> and <sil=0.000> our <sil=0.000> algorithm <sil=0.000> will <sil=0.000> be <sil=0.000> better <sil=1.000> ,COMMA  if <sil=0.000> the <sil=0.000> error
is <sil=0.000> less <sil=2.000> .PERIOD  Now <sil=0.000> what <sil=0.000> do <sil=0.000> I mean <sil=0.000> by <sil=0.000> error <sil=0.228> ?QUESTIONMARK  Say <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> computing <sil=0.000> 4 by <sil=0.000> 3 <sil=2.000> .PERIOD <sil=0.000> Now <sil=0.000> what <sil=0.000> is <sil=0.000> the <sil=0.000> correct
result <sil=1.000> ,COMMA  the <sil=0.000> most <sil=0.000> accurate <sil=0.228> ?QUESTIONMARK  Do <sil=0.000> you <sil=0.000> know <sil=0.000> that <sil=0.000> no <sil=0.000> it <sil=0.000> is <sil=0.000> 1 <sil=2.000> .PERIOD <sil=0.000> 3 3 <sil=0.000> 3 3 <sil=0.000> it <sil=0.000> goes <sil=0.000> on <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  you <sil=0.000> know <sil=0.000> our <sil=0.000> computers <sil=0.000> have <sil=0.000> got <sil=0.000> some <sil=0.000> storage <sil=0.000> locations <sil=0.000> of <sil=0.000> some <sil=0.000> 8 by <sil=0.000> 8 bits <sil=0.000> or <sil=0.000> 16 <sil=0.000> bits
like <sil=0.000> that <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  depending <sil=0.000> on <sil=0.000> that <sil=0.000> I have <sil=0.000> got <sil=0.000> a finite <sil=0.000> capacity <sil=0.000> to <sil=0.000> store <sil=0.000> the <sil=0.000> data <sil=2.000> .PERIOD  Therefore <sil=1.000> ,COMMA  I <sil=0.000> may <sil=0.000> represent
this <sil=0.000> as <sil=0.000> says <sil=0.000> 1 <sil=2.000> .PERIOD <sil=0.000> 3 3 <sil=0.000> 3 3 <sil=1.000> ,COMMA  I <sil=0.000> just <sil=0.000> start <sil=0.000> with <sil=0.000> say <sil=0.000> 6 digits <sil=0.000> all <sil=0.000> right <sil=1.000> ,COMMA  6 <sil=0.000> 7 8 <sil=0.354> ;SEMICOLON  I <sil=0.000> can <sil=0.000> store <sil=0.000> 8 digits <sil=0.000> maximum <sil=2.000> .PERIOD  6
after <sil=0.000> decimal <sil=0.000> 1 decimal <sil=0.000> and <sil=0.000> this <sil=0.000> so <sil=1.000> ,COMMA  6 <sil=0.000> places <sil=2.000> .PERIOD 

Therefore <sil=1.000> ,COMMA  the <sil=0.000> actual <sil=0.000> thing <sil=0.000> was <sil=0.000> much <sil=0.000> more <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> actually <sil=0.000> committing <sil=0.000> some <sil=0.000> error <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the
error <sil=0.000> in <sil=0.000> computation <sil=0.000> is <sil=0.000> the <sil=0.000> exact <sil=0.000> value <sil=1.000> ,COMMA  the <sil=0.000> difference <sil=0.000> of <sil=0.000> the <sil=0.000> exact <sil=0.000> value <sil=1.000> ,COMMA  by <sil=0.000> this <sil=0.000> m and <sil=0.000> the
computed <sil=0.000> value <sil=1.000> ,COMMA  it <sil=0.000> can <sil=0.000> be <sil=0.000> positive <sil=0.000> or <sil=0.000> negative <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD  Suppose <sil=0.000> the <sil=0.000> result <sil=0.000> is <sil=0.000> actually <sil=0.000> 1 <sil=2.000> .PERIOD <sil=0.000> 5 2 <sil=0.000> 3 that
is <sil=0.000> the <sil=0.000> exact <sil=0.000> value <sil=0.000> suppose <sil=0.000> and <sil=0.000> during <sil=0.000> my <sil=0.000> computation <sil=0.000> I got <sil=0.000> 1 <sil=2.000> .PERIOD <sil=0.000> 5 2 <sil=0.000> 2 8 <sil=0.000> 2 3 <sil=0.000> then <sil=0.000> the <sil=0.000> error <sil=0.000> is <sil=0.000> the
difference <sil=0.000> between <sil=0.000> these <sil=0.000> 2 and <sil=0.000> the <sil=0.000> error <sil=0.000> is <sil=0.000> therefore <sil=1.000> ,COMMA  if <sil=0.000> I subtract <sil=0.000> this <sil=0.000> it <sil=0.000> will <sil=0.000> be <sil=0.000> 0 <sil=2.000> .PERIOD <sil=0.000> 0 0 <sil=2.000> .PERIOD <sil=0.000> 0 0 <sil=0.000> 0 1 <sil=0.000> 7 7 -
that <sil=0.000> is <sil=0.000> the <sil=0.000> error <sil=2.000> .PERIOD  Now <sil=0.000> the <sil=0.000> smaller <sil=0.000> this <sil=0.000> error <sil=0.000> is <sil=0.000> more <sil=0.000> accurate <sil=0.000> my <sil=0.000> result <sil=0.000> is <sil=2.000> .PERIOD  I <sil=0.000> think <sil=0.000> it <sil=0.000> is <sil=0.000> very <sil=0.000> clear <sil=2.000> .PERIOD 
Now <sil=0.000> there <sil=0.000> are <sil=0.000> 2 types <sil=0.000> of <sil=0.000> errors <sil=0.000> also <sil=1.000> ,COMMA  one <sil=0.000> is <sil=0.000> a round <sil=0.000> off <sil=0.000> error <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  here <sil=0.000> I could <sil=0.000> have
rounded <sil=0.000> it <sil=0.000> off <sil=0.000> as <sil=0.000> 1 <sil=2.000> .PERIOD <sil=0.000> 5 2 <sil=0.000> 3 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  suppose <sil=0.000> the <sil=0.000> actual <sil=0.000> thing <sil=0.000> was <sil=0.000> this <sil=0.000> and <sil=0.000> I rounded <sil=0.000> it <sil=0.000> to <sil=0.000> 1 <sil=2.000> .PERIOD <sil=0.000> 5 2 <sil=0.000> by <sil=0.000> approximating <sil=0.000> if <sil=0.000> I go <sil=0.000> by <sil=0.000> 2 bits <sil=2.000> .PERIOD 
That <sil=0.000> is <sil=0.000> one <sil=0.000> type <sil=0.000> of <sil=0.000> error <sil=1.000> ,COMMA  other <sil=0.000> type <sil=0.000> of <sil=0.000> error <sil=0.000> is <sil=0.000> truncation <sil=0.000> error -this <sil=0.000> was <sil=0.000> there <sil=0.000> I have <sil=0.000> just <sil=0.000> dropped <sil=0.000> this <sil=0.000> 1 <sil=2.000> .PERIOD <sil=0.000> 5 2 <sil=1.000> ,COMMA  because <sil=0.000> I could <sil=0.000> not <sil=0.000> store <sil=0.000> more <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  there <sil=0.000> are <sil=0.000> two <sil=0.000> types <sil=0.000> of <sil=0.000> errors <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  truncation <sil=0.000> error <sil=0.000> and <sil=0.000> round <sil=0.000> off <sil=0.000> error <sil=2.000> .PERIOD  Another <sil=0.000> term <sil=0.000> that
you <sil=0.000> need <sil=0.000> to <sil=0.000> know <sil=0.000> is <sil=0.000> the <sil=0.000> absolute <sil=0.000> error -absolute <sil=0.000> error <sil=0.000> is <sil=0.000> nothing <sil=1.000> ,COMMA  but <sil=0.000> the <sil=0.000> absolute <sil=0.000> value <sil=0.000> of <sil=0.000> the
error <sil=0.000> and <sil=0.000> relative <sil=0.000> error <sil=0.000> is <sil=0.000> absolute <sil=0.000> error <sil=0.000> divided <sil=0.000> by <sil=0.000> exact <sil=0.000> value <sil=1.000> ,COMMA  the <sil=0.000> absolute <sil=0.000> of <sil=0.000> the <sil=0.000> exact <sil=0.000> value <sil=2.000> .PERIOD 
Absolute <sil=0.000> error <sil=0.000> is <sil=0.000> the <sil=0.000> error s <sil=0.000> absolute <sil=0.000> part <sil=0.000> by <sil=0.000> the <sil=0.000> exact <sil=0.000> value <sil=0.000> and <sil=0.000> percentage <sil=0.000> error <sil=0.000> will <sil=0.000> be <sil=0.000> relative <sil=0.000> error <sil=0.000> times <sil=0.000> 1000 <sil=0.000> relative <sil=0.000> error <sil=0.000> times <sil=0.000> 1000 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  we <sil=0.000> can <sil=0.000> say <sil=0.000> that <sil=0.000> percentage <sil=0.000> error <sil=0.000> is <sil=0.000> relative <sil=0.000> error <sil=0.000> in <sil=0.000> to <sil=0.000> 100  <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  now <sil=0.000> just <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=0.000> have <sil=0.000> a quick <sil=0.000> look <sil=0.000> at <sil=0.000> these <sil=0.000> definitions <sil=2.000> .PERIOD  Absolute <sil=0.000> error <sil=0.000> means <sil=0.000> the <sil=0.000> absolute <sil=0.000> value <sil=0.000> of <sil=0.000> the <sil=0.000> error <sil=1.000> ,COMMA  relative <sil=0.000> error <sil=0.000> is <sil=0.000> absolute <sil=0.000> error <sil=0.000> divided <sil=0.000> by <sil=0.000> the <sil=0.000> exact <sil=0.000> value <sil=0.000> and <sil=0.000> then <sil=0.000> we <sil=0.000> come <sil=0.000> to <sil=0.000> the <sil=0.000> percentage <sil=0.000> error <sil=1.000> ,COMMA  which <sil=0.000> is <sil=0.000> relative <sil=0.000> error <sil=0.000> times <sil=0.000> 100 <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  another <sil=0.000> important <sil=0.000> thing <sil=0.000> that <sil=0.000> we <sil=0.000> have <sil=0.000> to <sil=0.000> consider <sil=0.000> is <sil=0.000> accumulated <sil=0.000> error <sil=1.000> ,COMMA  but <sil=0.000> that <sil=0.000> will
consider <sil=0.000> later <sil=2.000> .PERIOD  In <sil=0.000> the <sil=0.000> next <sil=0.000> lecture <sil=0.000> we <sil=0.000> will <sil=0.000> move <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  whatever <sil=0.000> we <sil=0.000> do <sil=0.000> the <sil=0.000> way <sil=0.000> we <sil=0.000> do <sil=0.000> the <sil=0.000> computation <sil=0.000> we <sil=0.000> must <sil=0.000> be <sil=0.000> very <sil=0.000> careful <sil=0.000> about <sil=0.000> the <sil=0.000> algorithm <sil=0.000> be <sil=0.000> such <sil=0.000> that <sil=0.000> it <sil=0.000> is <sil=0.000> it <sil=0.000> does <sil=0.000> not
accommodate <sil=0.000> too <sil=0.000> much <sil=0.000> error <sil=2.000> .PERIOD 

However <sil=1.000> ,COMMA  discussing <sil=0.000> about <sil=0.000> error <sil=0.000> analysis <sil=0.000> in <sil=0.000> general <sil=0.000> is <sil=0.000> beyond <sil=0.000> the <sil=0.000> scope <sil=0.000> of <sil=0.000> this <sil=0.000> course <sil=0.000> right <sil=0.000> now <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> in <sil=0.000> the <sil=0.000> next <sil=0.000> lecture <sil=0.000> start <sil=0.000> with <sil=0.000> the <sil=0.000> bisection <sil=0.000> method <sil=0.000> as <sil=0.000> I have <sil=0.000> explained <sil=0.000> and <sil=0.000> then <sil=0.000> move
to <sil=0.000> some <sil=0.000> other <sil=0.000> methods <sil=2.000> .PERIOD 

We <sil=0.000> were <sil=0.000> talking <sil=0.000> about <sil=0.000> errors <sil=0.000> and <sil=0.000> round <sil=0.000> off <sil=0.000> errors <sil=0.000> and <sil=0.000> percentage <sil=0.000> errors <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> briefly
show <sil=0.000> you <sil=0.000> that <sil=0.000> if <sil=0.000> we <sil=0.000> commit <sil=0.000> an <sil=0.000> error <sil=0.000> how <sil=0.000> that <sil=0.000> error <sil=0.000> continuously <sil=0.000> gets <sil=0.000> accumulated <sil=0.000> and
ultimately <sil=0.000> has <sil=0.000> a much <sil=0.000> larger <sil=0.000> effect <sil=2.000> .PERIOD 

For <sil=0.000> example <sil=1.000> ,COMMA  suppose <sil=0.000> the <sil=0.000> exact <sil=0.000> value <sil=0.000> is <sil=0.000> 9 <sil=2.000> .PERIOD <sil=0.000> 9 8 <sil=0.000> and <sil=0.000> we <sil=0.000> compute <sil=0.000> 10 <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> inherent <sil=0.000> error <sil=1.000> ,COMMA  first <sil=0.000> the <sil=0.000> error <sil=0.000> actually <sil=0.000> is <sil=0.000> 0 <sil=2.000> .PERIOD <sil=0.000> 0 2 <sil=0.000> right <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  as <sil=0.000> we <sil=0.000> go <sil=0.000> on <sil=0.000> iterating <sil=0.000> suppose <sil=0.000> x 1 <sil=0.000> is <sil=0.000> 10 <sil=0.000> times <sil=0.000> x 0 <sil=1.000> ,COMMA  then <sil=0.000> the <sil=0.000> exact <sil=0.000> value <sil=0.000> should <sil=0.000> be <sil=0.000> 99 <sil=2.000> .PERIOD <sil=0.000> 8 <sil=1.000> ,COMMA  but
here <sil=0.000> we <sil=0.000> will <sil=0.000> get <sil=0.000> 100 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> see <sil=0.000> that <sil=0.000> the <sil=0.000> error <sil=0.000> has <sil=0.000> increased <sil=0.000> to <sil=0.000> how <sil=0.000> much  <sil=0.228> ?QUESTIONMARK <sil=0.000> 0 <sil=2.000> .PERIOD <sil=0.000> 2 <sil=2.000> .PERIOD  Now <sil=0.000> if <sil=0.000> the
next <sil=0.000> iteration <sil=0.000> x 2 <sil=0.000> is <sil=0.000> again <sil=0.000> 10 <sil=0.000> times <sil=0.000> x 1 <sil=0.000> then <sil=0.000> it <sil=0.000> will <sil=0.000> be <sil=0.000> 9 9 <sil=0.000> 8 whereas <sil=1.000> ,COMMA  the <sil=0.000> computed <sil=0.000> value <sil=0.000> will <sil=0.000> be
1000 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> error <sil=0.000> is <sil=0.000> becoming <sil=0.000> 2 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  you <sil=0.000> see <sil=0.000> how <sil=0.000> with <sil=0.000> if <sil=0.000> we <sil=0.000> start <sil=0.000> with <sil=0.000> an <sil=0.000> inherent <sil=0.000> error <sil=0.000> how <sil=0.000> that <sil=0.000> error <sil=0.000> accumulates <sil=0.000> over <sil=0.000> time <sil=0.228> ?QUESTIONMARK 
Ok <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> can <sil=0.000> say <sil=0.000> a very <sil=0.000> important <sil=0.000> term <sil=0.000> is <sil=0.000> relative <sil=0.000> accumulation <sil=0.000> of <sil=0.000> error <sil=1.000> ,COMMA  which <sil=0.000> is <sil=0.000> accumulated
error <sil=0.000> divided <sil=0.000> by <sil=0.000> exact <sil=0.000> value <sil=0.000> for <sil=0.000> that <sil=0.000> iteration <sil=2.000> .PERIOD 

For <sil=0.000> example <sil=0.000> in <sil=0.000> the <sil=0.000> first <sil=0.000> iteration <sil=0.000> the <sil=0.000> accumulated <sil=0.000> error <sil=0.000> was <sil=0.000> 0 <sil=2.000> .PERIOD <sil=0.000> 0 2 <sil=0.000> divided <sil=0.000> by <sil=0.000> the <sil=0.000> exact <sil=0.000> value
which <sil=0.000> was <sil=0.000> 9 <sil=2.000> .PERIOD <sil=0.000> 9 8 <sil=1.000> ,COMMA  but <sil=0.000> later <sil=0.000> on <sil=0.000> it <sil=0.000> became <sil=0.000> 0 <sil=2.000> .PERIOD <sil=0.000> 2 divided <sil=0.000> by <sil=0.000> 99 <sil=2.000> .PERIOD <sil=0.000> 8 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> this <sil=0.000> was <sil=0.000> 0 <sil=2.000> .PERIOD <sil=0.000> 002004 <sil=1.000> ,COMMA  but
whatever <sil=0.000> that <sil=0.000> is <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> that <sil=0.000> important <sil=0.000> I do <sil=0.000> not <sil=0.000> want <sil=0.000> to <sil=0.000> confuse <sil=0.000> with <sil=0.000> you <sil=0.000> with <sil=0.000> this <sil=2.000> .PERIOD 

Now <sil=0.000> there <sil=0.000> are <sil=0.000> some <sil=0.000> cases <sil=0.000> where <sil=0.000> this <sil=0.000> accumulation <sil=0.000> of <sil=0.000> error <sil=0.000> actually <sil=0.000> goes <sil=0.000> on <sil=0.000> increasing <sil=2.000> .PERIOD  If <sil=0.000> the
rate <sil=0.000> of <sil=0.000> accumulation <sil=0.000> error <sil=0.000> decreases <sil=0.000> or <sil=0.000> if <sil=0.000> the <sil=0.000> rate <sil=0.000> of <sil=0.000> accumulated <sil=0.000> error <sil=0.000> increases <sil=1.000> ,COMMA  but <sil=0.000> the <sil=0.000> rate <sil=0.000> of <sil=0.000> relative <sil=0.000> error <sil=0.000> decreases <sil=1.000> ,COMMA  then <sil=0.000> we <sil=0.000> call <sil=0.000> it <sil=0.000> a stable <sil=0.000> algorithm <sil=2.000> .PERIOD 

However <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> not <sil=0.000> going <sil=0.000> into <sil=0.000> the <sil=0.000> details <sil=0.000> and <sil=0.000> the <sil=0.000> intricacies <sil=0.000> of <sil=0.000> this <sil=1.000> ,COMMA  but <sil=0.000> this <sil=0.000> is <sil=0.000> just <sil=0.000> to <sil=0.000> give <sil=0.000> you <sil=0.000> an
idea <sil=0.000> how <sil=0.000> the <sil=0.000> error <sil=0.000> propagates <sil=0.000> through <sil=0.000> iterations <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> must <sil=0.000> be <sil=0.000> very <sil=0.000> conscious <sil=0.000> about <sil=0.000> the <sil=0.000> rate <sil=0.000> of <sil=0.000> increase <sil=0.000> of <sil=0.000> this <sil=0.000> error  <sil=2.000> .PERIOD 

With <sil=0.000> these <sil=0.000> words <sil=0.000> we <sil=0.000> move <sil=0.000> to <sil=0.000> the <sil=0.000> algorithm <sil=0.000> which <sil=0.000> we <sil=0.000> are <sil=0.000> planning <sil=0.000> to <sil=0.000> discuss <sil=0.000> in <sil=0.000> this <sil=0.000> lecture <sil=0.000> that
is <sil=0.000> a bisection <sil=0.000> method <sil=2.000> .PERIOD 

I <sil=0.000> have <sil=0.000> already <sil=0.000> told <sil=0.000> you <sil=0.000> that <sil=0.000> the <sil=0.000> bisection <sil=0.000> method <sil=0.000> is <sil=0.000> given <sil=0.000> a particular <sil=0.000> function <sil=1.000> ,COMMA  some <sil=0.000> function <sil=1.000> ,COMMA  on <sil=0.000> this <sil=0.000> x and <sil=0.000> y axis <sil=2.000> .PERIOD <sil=0.000> If <sil=0.000> I have <sil=0.000> some <sil=0.000> function <sil=0.000> that <sil=0.000> moves <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=0.000> then <sil=0.000> we <sil=0.000> start <sil=0.000> with <sil=0.000> any <sil=0.000> two <sil=0.000> points <sil=0.000> any <sil=0.000> two <sil=0.000> points <sil=1.000> ,COMMA  arbitrary <sil=0.000> points <sil=0.000> here <sil=0.000> and <sil=0.000> maybe <sil=0.000> here <sil=1.000> ,COMMA  now <sil=0.000> these <sil=0.000> two <sil=0.000> points <sil=0.000> will <sil=0.000> not <sil=0.000> do <sil=2.000> .PERIOD 

Because <sil=0.000> if <sil=0.000> I select <sil=0.000> these <sil=0.000> two <sil=0.000> points <sil=0.000> then <sil=0.000> both <sil=0.000> of <sil=0.000> them <sil=0.000> are <sil=0.000> positive <sil=0.000> so <sil=1.000> ,COMMA  that <sil=0.000> if <sil=0.000> I had <sil=0.000> selected <sil=0.000> this
point <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  these <sil=0.000> two <sil=0.000> points <sil=0.000> x 0 <sil=0.000> and <sil=0.000> x 1 <sil=0.000> that <sil=0.000> would <sil=0.000> not <sil=0.000> have <sil=0.000> served <sil=0.000> my <sil=0.000> purpose <sil=0.000> because <sil=0.000> I do <sil=0.000> not <sil=0.000> know <sil=0.000> where <sil=0.000> the <sil=0.000> root <sil=0.000> is <sil=0.000> there <sil=0.000> or <sil=0.000> not <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> would <sil=0.000> rather <sil=0.000> select <sil=0.000> two <sil=0.000> points <sil=1.000> ,COMMA  which <sil=0.000> are <sil=0.000> of <sil=0.000> opposite <sil=0.000> signs <sil=0.000> and <sil=0.000> therefore <sil=1.000> ,COMMA  I <sil=0.000> know <sil=0.000> that
somewhere <sil=0.000> in <sil=0.000> between <sil=0.000> the <sil=0.000> root <sil=0.000> lies <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> take <sil=0.000> the <sil=0.000> midpoint <sil=0.000> of <sil=0.000> this <sil=1.000> ,COMMA  somehow <sil=0.000> here <sil=1.000> ,COMMA  if <sil=0.000> this
point <sil=0.000> is <sil=0.000> negative <sil=0.000> then <sil=0.000> I will <sil=0.000> keep <sil=0.000> the <sil=0.000> positive <sil=0.000> fixed <sil=0.000> and <sil=0.000> I will <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> y <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  these
two <sil=0.000> are <sil=0.000> opposite <sil=0.000> signs <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> root <sil=0.000> must <sil=0.000> be <sil=0.000> somewhere <sil=0.000> here <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> way <sil=0.000> I come <sil=0.000> to <sil=0.000> this <sil=0.000> one <sil=0.000> and <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> the <sil=0.000> root <sil=0.000> here <sil=2.000> .PERIOD  In <sil=0.000> that <sil=0.000> way <sil=0.000> I go <sil=0.000> on
dividing <sil=0.000> it <sil=0.000> till <sil=0.000> I come <sil=0.000> very <sil=0.000> close <sil=0.000> to <sil=0.000> the <sil=0.000> root <sil=0.000> as <sil=0.000> it <sil=0.000> is <sil=0.000> being <sil=0.000> shown <sil=0.000> here <sil=2.000> .PERIOD  It <sil=0.000> is <sil=0.000> very <sil=0.000> close <sil=0.000> to <sil=0.000> the <sil=0.000> root <sil=2.000> .PERIOD 
Now <sil=0.000> how <sil=0.000> close <sil=1.000> ,COMMA  that <sil=0.000> will <sil=0.000> depend <sil=0.000> on <sil=0.000> my <sil=0.000> decision <sil=0.000> that <sil=0.000> is <sil=0.000> the <sil=0.000> basic <sil=0.000> approach <sil=0.000> of <sil=0.000> bisection <sil=0.000> method <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  with <sil=0.000> that <sil=0.000> let <sil=0.000> us <sil=0.000> try <sil=0.000> to <sil=0.000> have <sil=0.000> a look <sil=0.000> at <sil=0.000> the <sil=0.000> algorithm <sil=1.000> ,COMMA  therefore <sil=1.000> ,COMMA  first <sil=0.000> we <sil=0.000> start <sil=1.000> ,COMMA  we <sil=0.000> define <sil=0.000> the
function <sil=0.000> f x <sil=0.000> and <sil=0.000> get <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> the <sil=0.000> interval <sil=0.000> A B <sil=0.000> that <sil=0.000> is <sil=0.000> there <sil=0.000> is <sil=0.000> a function <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> there <sil=0.000> is <sil=0.000> a
function <sil=0.000> and <sil=0.000> the <sil=0.000> function <sil=0.000> can <sil=0.000> be <sil=0.000> long <sil=0.000> enough <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> take <sil=0.000> the <sil=0.000> limits <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> root
within <sil=0.000> this <sil=0.000> interval <sil=0.000> a and <sil=0.000> b and <sil=0.000> I find <sil=0.000> out <sil=0.000> how <sil=0.000> much <sil=0.000> error <sil=0.000> is <sil=0.000> required <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  how <sil=0.000> much <sil=0.000> error <sil=0.000> is
acceptable <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> allowed <sil=0.000> error <sil=0.000> is <sil=0.000> the <sil=0.000> epsilon <sil=0.000> that <sil=0.000> I was <sil=0.000> talking <sil=0.000> of <sil=0.000> and <sil=0.000> also <sil=0.000> the <sil=0.000> number <sil=0.000> of <sil=0.000> iterations <sil=1.000> ,COMMA 
because <sil=0.000> it <sil=0.000> may <sil=0.000> be <sil=0.000> that <sil=0.000> in <sil=0.000> some <sil=0.000> case <sil=0.000> I am <sil=0.000> not <sil=0.000> finding <sil=0.000> the <sil=0.000> root <sil=1.000> ,COMMA  because <sil=0.000> I am <sil=0.000> going <sil=0.000> on <sil=0.000> looking <sil=0.000> at
say <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  this <sil=0.000> sort <sil=0.000> of <sil=0.000> scenario <sil=0.000> and <sil=0.000> my <sil=0.000> a is <sil=0.000> here <sil=0.000> my <sil=0.000> b is <sil=0.000> here <sil=2.000> .PERIOD 

Then <sil=0.354> ;SEMICOLON  obviously <sil=1.000> ,COMMA  the <sil=0.000> root <sil=0.000> does <sil=0.000> not <sil=0.000> lie <sil=0.000> between <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> go <sil=0.000> on <sil=0.000> doing <sil=0.000> this <sil=0.000> bisection <sil=0.000> and
again <sil=0.000> i am <sil=0.000> doing <sil=0.000> this <sil=0.000> bisection <sil=1.000> ,COMMA  for <sil=0.000> how <sil=0.000> long <sil=0.000> will <sil=0.000> I go <sil=0.000> on <sil=0.228> ?QUESTIONMARK  But <sil=0.000> still <sil=0.000> it <sil=0.000> may <sil=0.000> be <sil=0.000> that <sil=0.000> I might <sil=0.000> not <sil=0.000> find
the <sil=0.000> root <sil=0.000> therefore <sil=1.000> ,COMMA  there <sil=0.000> is <sil=0.000> a maximum <sil=0.000> limit <sil=0.000> that <sil=0.000> is <sil=0.000> kept -number <sil=0.000> of <sil=0.000> iterations <sil=2.000> .PERIOD 

Now <sil=0.000> I initialise <sil=0.000> I to <sil=0.000> be <sil=0.000> 1 <sil=1.000> ,COMMA  just <sil=0.000> some <sil=0.000> index <sil=0.000> to <sil=0.000> be <sil=0.000> 1 and <sil=0.000> then <sil=0.000> I call <sil=0.000> a subroutine <sil=0.000> or <sil=0.000> a function <sil=1.000> ,COMMA  bisect
the <sil=0.000> midpoint <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> a sub <sil=0.000> subroutine <sil=1.000> ,COMMA  you <sil=0.000> see <sil=0.000> what <sil=0.000> it <sil=0.000> does <sil=0.228> ?QUESTIONMARK  Or <sil=0.000> a function <sil=1.000> ,COMMA  What <sil=0.000> does <sil=0.000> it <sil=0.000> do
here <sil=0.228> ?QUESTIONMARK  It <sil=0.000> finds <sil=0.000> out <sil=0.000> between <sil=0.000> A and <sil=0.000> B the <sil=0.000> midpoint <sil=0.000> and <sil=0.000> increments <sil=0.000> the <sil=0.000> iteration <sil=0.000> and <sil=0.000> prints <sil=0.000> the <sil=0.000> value
of <sil=0.000> x 1 <sil=2.000> .PERIOD  x <sil=0.000> 1 is <sil=0.000> a middle <sil=0.000> point <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  if <sil=0.000> my <sil=0.000> function <sil=0.000> was <sil=0.000> like <sil=0.000> this <sil=0.000> and <sil=0.000> this <sil=0.000> was <sil=0.000> a this <sil=0.000> was <sil=0.000> b <sil=1.000> ,COMMA  then <sil=0.000> the <sil=0.000> root <sil=0.000> mass <sil=0.000> lies <sil=0.000> somewhere
here <sil=2.000> .PERIOD  I <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> midpoint <sil=0.000> of <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> becomes <sil=0.000> x 1 <sil=2.000> .PERIOD  There <sil=0.000> is <sil=0.000> a next <sil=0.000> one <sil=0.000> and <sil=0.000> what <sil=0.000> is <sil=0.000> the
iteration <sil=0.228> ?QUESTIONMARK  Next <sil=1.000> ,COMMA <sil=0.000> is <sil=0.000> F <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=0.000> F mid <sil=0.000> less <sil=0.000> than <sil=0.000> 0 <sil=0.228> ?QUESTIONMARK 

So <sil=1.000> ,COMMA  there <sil=0.000> can <sil=0.000> be <sil=0.000> 2 things <sil=2.000> .PERIOD  Here <sil=0.000> I select <sil=0.000> this <sil=0.000> to <sil=0.000> be <sil=0.000> my <sil=0.000> b and <sil=0.000> this <sil=0.000> to <sil=0.000> be <sil=0.000> my <sil=0.000> a <sil=2.000> .PERIOD  Now <sil=0.354> ;SEMICOLON  obviously <sil=1.000> ,COMMA  if <sil=0.000> I
take <sil=0.000> the <sil=0.000> midpoint <sil=0.000> then <sil=0.000> the <sil=0.000> midpoint <sil=0.000> will <sil=0.000> be <sil=0.000> somewhere <sil=0.000> here <sil=1.000> ,COMMA  a <sil=0.000> and <sil=0.000> b are <sil=0.000> of <sil=0.000> different <sil=0.000> signs <sil=2.000> .PERIOD  If <sil=0.000> F
mid <sil=0.000> is <sil=0.000> not <sil=0.000> less <sil=0.000> than <sil=0.000> 0 <sil=1.000> ,COMMA  then <sil=0.000> a should <sil=0.000> be <sil=0.000> x <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> now <sil=0.000> move <sil=0.000> it <sil=0.000> on <sil=0.000> this <sil=0.000> side <sil=0.000> and <sil=0.000> this
should <sil=0.000> be <sil=0.000> the <sil=0.000> next <sil=0.000> a and <sil=0.000> between <sil=0.000> these <sil=0.000> two <sil=0.000> I will <sil=0.000> have <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> and <sil=0.000> every <sil=0.000> time <sil=0.000> I am <sil=0.000> trying <sil=0.000> to
find <sil=0.000> out -whatever <sil=0.000> value <sil=0.000> of <sil=0.000> F X <sil=0.000> that <sil=0.000> I compute <sil=1.000> ,COMMA  is <sil=0.000> it <sil=0.000> less <sil=0.000> than <sil=0.000> the <sil=0.000> absolute <sil=0.000> error  <sil=0.228> ?QUESTIONMARK  If <sil=0.000> yes <sil=0.000> then - x  <sil=1.000> ,COMMA 
I <sil=0.000> am <sil=0.000> getting <sil=0.000> my <sil=0.000> solution <sil=0.000> otherwise <sil=0.000> I am <sil=0.000> going <sil=0.000> on <sil=0.000> doing <sil=0.000> this <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> a flow <sil=0.000> chart <sil=0.000> of <sil=0.000> the <sil=0.000> whole <sil=0.000> thing <sil=1.000> ,COMMA  but <sil=0.000> I think <sil=0.000> you <sil=0.000> will <sil=0.000> be <sil=0.000> more <sil=0.000> interested <sil=0.000> in <sil=0.000> looking <sil=0.000> at
the <sil=0.000> algorithm <sil=2.000> .PERIOD  Let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> the <sil=0.000> algorithm <sil=0.000> for <sil=0.000> a second <sil=0.000> and <sil=0.000> the <sil=0.000> program <sil=2.000> .PERIOD  Here <sil=0.000> is <sil=0.000> algorithm <sil=1.000> ,COMMA <sil=0.000> you
see <sil=0.000> this <sil=0.000> is <sil=0.000> much <sil=0.000> more <sil=0.000> understandable <sil=0.000> to <sil=0.000> you <sil=2.000> .PERIOD 

I <sil=0.000> read <sil=0.000> x 1 <sil=1.000> ,COMMA  x <sil=0.000> 2 and <sil=0.000> the <sil=0.000> error <sil=2.000> .PERIOD  Here <sil=0.000> x 1 <sil=0.000> and <sil=0.000> x 2 <sil=0.000> are <sil=0.000> the <sil=0.000> initial <sil=0.000> guesses <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD  Here <sil=0.000> is <sil=0.000> my <sil=0.000> thing <sil=1.000> ,COMMA  I
have <sil=0.000> taken <sil=0.000> this <sil=0.000> is <sil=0.000> x 2 <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> x 1 <sil=2.000> .PERIOD   e  is <sil=0.000> absolute <sil=0.000> error <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  how <sil=0.000> much <sil=0.000> error <sil=0.000> is <sil=0.000> permissible <sil=1.000> ,COMMA  compute <sil=0.000> F 1 <sil=0.000> that <sil=0.000> is <sil=0.000> FX <sil=0.000> 1 <sil=1.000> ,COMMA  compute <sil=0.000> for <sil=0.000> this <sil=0.000> function <sil=0.000> this <sil=0.000> value <sil=0.000> and <sil=0.000> f 2 <sil=1.000> ,COMMA  compute <sil=0.000> this <sil=0.000> value  <sil=2.000> .PERIOD  If <sil=0.000> f 1 <sil=0.000> and <sil=0.000> f 2 <sil=1.000> ,COMMA  the <sil=0.000> product <sil=0.000> of <sil=0.000> these <sil=0.000> two <sil=0.000> is <sil=0.000> greater <sil=0.000> than <sil=0.000> 0  <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  my <sil=0.000> initial <sil=0.000> guesses <sil=0.000> are <sil=0.000> wrong <sil=1.000> ,COMMA  because <sil=0.000> both <sil=0.000> of <sil=0.000> them <sil=0.000> are <sil=0.000> positive <sil=1.000> ,COMMA  then <sil=0.000> I can <sil=0.000> do <sil=0.000> many <sil=0.000> things <sil=0.000> I will <sil=0.000> instead <sil=0.000> of <sil=0.000> going <sil=0.000> to <sil=0.000> 11(my <sil=0.000> initial <sil=0.000> guesses <sil=0.000> are <sil=0.000> wrong) I <sil=0.000> will <sil=0.000> again <sil=0.000> ask <sil=0.000> for <sil=0.000> new <sil=0.000> guess <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> take <sil=0.000> a new <sil=0.000> guess <sil=0.000> and <sil=0.000> I find <sil=0.000> that <sil=0.000> it <sil=0.000> is <sil=0.000> less <sil=0.000> than <sil=0.000> 0 <sil=2.000> .PERIOD  Then <sil=0.000> I take <sil=0.000> in <sil=0.000> this <sil=0.000> step <sil=0.000> x 1 <sil=0.000> plus <sil=0.000> x 2  <sil=1.000> ,COMMA <sil=0.000> mid <sil=0.000> of <sil=0.000> that <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  suppose <sil=0.000> mid <sil=0.000> of <sil=0.000> that <sil=0.000> is <sil=0.000> this <sil=0.000> one <sil=0.000> and <sil=0.000> that <sil=0.000> is <sil=0.000> becoming <sil=0.000> x <sil=1.000> ,COMMA  read <sil=0.000> this <sil=0.000> as <sil=0.000> fx <sil=0.000> 1 minus <sil=0.000> fx <sil=0.000> 2
divided <sil=0.000> by <sil=0.000> x is <sil=0.000> less <sil=0.000> than <sil=0.000> e then <sil=0.000> display <sil=0.000> x <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  if <sil=0.000> my <sil=0.000> error <sil=0.000> between <sil=0.000> these <sil=0.000> 2 points <sil=1.000> ,COMMA  the
difference <sil=0.000> is <sil=0.000> less <sil=0.000> is <sil=0.000> 0 <sil=2.000> .PERIOD <sil=0.000> 0 0 <sil=0.000> 0 2 <sil=0.000> and <sil=0.000> that <sil=0.000> I can <sil=0.000> assume <sil=0.000> as <sil=0.000> 0 then <sil=0.000> I will <sil=0.000> display <sil=0.000> this <sil=0.000> particular <sil=0.000> value <sil=0.000> of <sil=0.000> x <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  right <sil=0.000> now <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> the <sil=0.000> case <sil=0.000> otherwise <sil=0.000> I will <sil=0.000> make <sil=0.000> this <sil=0.000> f to <sil=0.000> be <sil=0.000> fx <sil=0.000> I take <sil=0.000> this <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD  Now
between <sil=0.000> these <sil=0.000> two <sil=0.000> I again <sil=0.000> divide <sil=1.000> ,COMMA  I <sil=0.000> come <sil=0.000> here <sil=0.000> and <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=0.000> I go <sil=0.000> on <sil=0.000> alright <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you <sil=0.000> will <sil=0.000> be
able <sil=0.000> to <sil=0.000> write <sil=0.000> the <sil=0.000> program <sil=0.000> as <sil=0.000> the <sil=0.000> program <sil=0.000> runs <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  just <sil=0.000> to <sil=0.000> show <sil=0.000> you (I <sil=0.000> am <sil=0.000> sure <sil=0.000> you <sil=0.000> can <sil=0.000> write <sil=0.000> the
program <sil=0.000> yourself) how <sil=0.000> can <sil=0.000> you <sil=0.000> translate <sil=0.000> this <sil=0.000> in <sil=0.000> the <sil=0.000> form <sil=0.000> of <sil=0.000> a code <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> you <sil=0.000> see <sil=0.000> let <sil=0.000> us <sil=0.000> try <sil=0.000> to <sil=0.000> understand <sil=0.000> this <sil=0.000> code <sil=0.000> it <sil=0.000> is <sil=0.000> a C <sil=0.000> program <sil=0.000> for <sil=0.000> the <sil=0.000> bisection <sil=0.000> method <sil=1.000> ,COMMA  I
have <sil=0.000> included <sil=0.000> a st <sil=0.000> stdio <sil=0.000> dot <sil=0.000> h <sil=1.000> ,COMMA  math <sil=0.000> dot <sil=0.000> h and <sil=0.000> there <sil=0.000> is <sil=0.000> some <sil=0.000> function <sil=1.000> ,COMMA  because <sil=0.000> I have <sil=0.000> to <sil=0.000> find <sil=0.000> the
root <sil=0.000> of <sil=0.000> a particular <sil=0.000> polynomial <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  for <sil=0.000> example <sil=1.000> ,COMMA  here <sil=0.000> it <sil=0.000> is <sil=0.000> given <sil=1.000> ,COMMA <sil=0.000> this <sil=0.000> is <sil=0.000> a polynomial <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> this <sil=0.000> polynomial <sil=0.000> it <sil=0.000> is <sil=0.000> x cube
minus <sil=0.000> 4 x <sil=0.000> minus <sil=0.000> 9 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> value <sil=0.000> of <sil=0.000> fx <sil=0.000> has <sil=0.000> to <sil=0.000> be <sil=0.000> computed <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> function <sil=0.000> is <sil=0.000> the <sil=0.000> fun <sil=0.354> ;SEMICOLON  fun <sil=0.000> is <sil=0.000> the
name <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=1.000> ,COMMA  then <sil=0.000> there <sil=0.000> is <sil=0.000> another <sil=0.000> function <sil=0.000> bisection <sil=1.000> ,COMMA  this <sil=0.000> function <sil=0.000> performs <sil=0.000> and <sil=0.000> prints
the <sil=0.000> result <sil=0.000> of <sil=0.000> one <sil=0.000> iteration <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> a plus <sil=0.000> b by <sil=0.000> 2 <sil=0.354> ;SEMICOLON  now <sil=0.000> in <sil=0.000> an <sil=0.000> earlier <sil=0.000> lecture <sil=0.000> we <sil=0.000> had <sil=0.000> talked <sil=0.000> about <sil=0.000> this -what <sil=0.000> is <sil=0.000> this  <sil=0.228> ?QUESTIONMARK <sil=0.000> Because
here <sil=0.000> when <sil=0.000> I am <sil=0.000> calling <sil=0.000> this <sil=0.000> function <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> calling <sil=0.000> by <sil=0.000> reference <sil=0.000> how <sil=0.228> ?QUESTIONMARK  I <sil=0.000> am <sil=0.000> just <sil=0.000> passing <sil=0.000> the
address <sil=0.000> x and <sil=0.000> whatever <sil=0.000> I do <sil=0.000> here <sil=0.000> once <sil=0.000> again <sil=0.000> is <sil=0.000> a part <sil=0.000> of <sil=0.000> revision <sil=0.000> you <sil=0.000> can <sil=0.000> see <sil=2.000> .PERIOD  If <sil=0.000> I come <sil=0.000> here -
float <sil=0.000> star <sil=0.000> x <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=0.000> what <sil=0.228> ?QUESTIONMARK  x <sil=0.000> is <sil=0.000> some <sil=0.000> variable <sil=0.000> and <sil=0.000> I have <sil=0.000> just <sil=0.000> passed <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> that <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  star <sil=0.000> x is <sil=0.000> the <sil=0.000> content <sil=0.000> of <sil=0.000> this <sil=0.354> ;SEMICOLON  say <sil=0.000> 50 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> passed <sil=0.000> it <sil=0.000> on <sil=0.000> and <sil=0.000> in <sil=0.000> the <sil=0.000> main <sil=0.000> function <sil=0.000> I am <sil=0.000> passing
on <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> x  <sil=2.000> .PERIOD  This <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=0.000> earlier <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> taking <sil=0.000> the <sil=0.000> midpoint <sil=0.000> and <sil=0.000> incrementing
the <sil=0.000> iteration <sil=0.354> ;SEMICOLON  iteration <sil=0.000> is <sil=0.000> also <sil=0.000> a call <sil=0.000> by <sil=0.000> reference <sil=0.000> and <sil=0.000> float <sil=0.000> a float <sil=0.000> b are <sil=0.000> two <sil=0.000> points <sil=0.000> in <sil=0.000> between
which <sil=0.000> have <sil=0.000> been <sil=0.000> passed <sil=0.000> on <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> being <sil=0.000> done <sil=0.000> in <sil=0.000> the <sil=0.000> main <sil=0.000> function <sil=0.228> ?QUESTIONMARK  In <sil=0.000> the <sil=0.000> main <sil=0.000> function <sil=0.000> I am <sil=0.000> setting <sil=0.000> the <sil=0.000> iteration <sil=0.000> to
be <sil=0.000> 0 and <sil=0.000> here <sil=0.000> I am <sil=0.000> saying <sil=0.000> how <sil=0.000> many <sil=0.000> iterations <sil=0.000> are <sil=0.000> permitted <sil=0.228> ?QUESTIONMARK 

Maximum <sil=0.000> number <sil=0.000> of <sil=0.000> iterations <sil=0.354> ;SEMICOLON  x <sil=1.000> ,COMMA  a <sil=1.000> ,COMMA  b <sil=1.000> ,COMMA  allowed <sil=0.000> error <sil=0.000> and <sil=0.000> some <sil=0.000> x 1 <sil=0.000> value <sil=0.000> is <sil=0.000> given <sil=2.000> .PERIOD  Enter <sil=0.000> the
values <sil=0.000> of <sil=0.000> a <sil=1.000> ,COMMA  b <sil=1.000> ,COMMA  allowed <sil=0.000> error <sil=0.000> and <sil=0.000> maximum <sil=0.000> iterations <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  all <sil=0.000> these <sil=0.000> I read - the <sil=0.000> range <sil=0.000> a and <sil=0.000> b
between <sil=1.000> ,COMMA  which <sil=0.000> points <sil=0.000> I have <sil=0.000> to <sil=0.000> do <sil=1.000> ,COMMA  a <sil=0.000> and <sil=0.000> b and <sil=0.000> how <sil=0.000> much <sil=0.000> is <sil=0.000> the <sil=0.000> allowed <sil=0.000> error <sil=0.000> and <sil=0.000> what <sil=0.000> is <sil=0.000> the
maximum <sil=0.000> number <sil=0.000> of <sil=0.000> iterations <sil=0.228> ?QUESTIONMARK  Then <sil=0.000> with <sil=0.000> this <sil=0.000> I call <sil=0.000> bisection <sil=2.000> .PERIOD  What <sil=0.000> do <sil=0.000> I do <sil=0.228> ?QUESTIONMARK  Bisection <sil=0.000> and <sil=0.000> x <sil=0.354> ;SEMICOLON 
that <sil=0.000> means <sil=1.000> ,COMMA  this <sil=0.000> will <sil=0.000> give <sil=0.000> me <sil=0.000> the <sil=0.000> midpoint <sil=2.000> .PERIOD  I <sil=0.000> will <sil=0.000> call <sil=0.000> bisection <sil=0.000> here - a <sil=1.000> ,COMMA  b <sil=0.000> iterations <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  a <sil=0.000> is <sil=0.000> being <sil=0.000> passed <sil=0.000> here <sil=1.000> ,COMMA  b <sil=0.000> is <sil=0.000> being <sil=0.000> passed <sil=0.000> here <sil=1.000> ,COMMA  and <sil=0.000> the <sil=0.000> number <sil=0.000> of <sil=0.000> iterations <sil=0.000> is <sil=0.000> being <sil=0.000> passed
here <sil=2.000> .PERIOD  Now <sil=0.000> here <sil=0.000> I am <sil=0.000> finding <sil=0.000> the <sil=0.000> midpoint <sil=0.000> and <sil=0.000> that <sil=0.000> midpoint <sil=0.000> is <sil=0.000> being <sil=0.000> returned <sil=0.000> here <sil=0.000> is <sil=0.000> common
and <sil=0.000> then <sil=0.000> here <sil=0.000> at <sil=0.000> this <sil=0.000> point <sil=0.000> I call <sil=0.000> the <sil=0.000> function <sil=0.354> ;SEMICOLON  that <sil=0.000> is <sil=0.000> I am <sil=0.000> computing <sil=0.000> the <sil=0.000> polynomial <sil=2.000> .PERIOD 

If <sil=0.000> the <sil=0.000> polynomial <sil=0.000> ie <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> the <sil=0.000> polynomial <sil=0.000> at <sil=0.000> a <sil=1.000> ,COMMA  and <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> the <sil=0.000> polynomial <sil=0.000> at <sil=0.000> x  <sil=2.000> .PERIOD  there
is <sil=0.000> a midpoint <sil=0.000> that <sil=0.000> is <sil=0.000> less <sil=0.000> than <sil=0.000> 0 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> happened <sil=0.228> ?QUESTIONMARK  This <sil=0.000> was <sil=0.000> my <sil=0.000> scenario <sil=1.000> ,COMMA  here <sil=0.000> was <sil=0.000> a and <sil=0.000> here <sil=0.000> was <sil=0.000> b <sil=1.000> ,COMMA  now <sil=0.000> let <sil=0.000> me <sil=0.000> draw <sil=0.000> it <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> was <sil=0.000> b and <sil=0.000> here <sil=0.000> was <sil=0.000> a <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  what <sil=0.000> I do <sil=0.228> ?QUESTIONMARK  I <sil=0.000> got <sil=0.000> the <sil=0.000> meet <sil=0.000> point <sil=0.000> somewhere <sil=0.000> here <sil=1.000> ,COMMA  then
the <sil=0.000> value <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=0.000> at <sil=0.000> this <sil=0.000> point <sil=0.000> and <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=0.000> at <sil=0.000> this <sil=0.000> point <sil=0.000> is <sil=0.000> a negative <sil=2.000> .PERIOD 
Therefore <sil=1.000> ,COMMA  I <sil=0.000> move <sil=0.000> this <sil=0.000> b to <sil=0.000> x <sil=2.000> .PERIOD  x <sil=0.000> is <sil=0.000> becoming <sil=0.000> b and <sil=0.000> I do <sil=0.000> the <sil=0.000> same <sil=0.000> thing <sil=2.000> .PERIOD 

Otherwise <sil=0.000> if <sil=0.000> it <sil=0.000> was <sil=0.000> on <sil=0.000> the <sil=0.000> other <sil=0.000> side <sil=0.000> I would <sil=0.000> have <sil=0.000> made <sil=0.000> x to <sil=0.000> be <sil=0.000> a <sil=2.000> .PERIOD  Is <sil=0.000> this <sil=0.000> clear <sil=0.228> ?QUESTIONMARK  Then <sil=0.000> again <sil=0.000> I call
bisection <sil=2.000> .PERIOD  After <sil=0.000> calling <sil=0.000> bisection <sil=0.000> I find <sil=0.000> if <sil=0.000> the <sil=0.000> absolute <sil=0.000> error <sil=0.000> of <sil=0.000> x 1 <sil=0.000> minus <sil=0.000> x is <sil=0.000> less <sil=0.000> than <sil=0.000> the
allowed <sil=0.000> error <sil=1.000> ,COMMA  then <sil=0.000> I will <sil=0.000> print <sil=0.000> the <sil=0.000> root <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> will <sil=0.000> go <sil=0.000> on <sil=0.000> until <sil=0.000> I exceed <sil=0.000> the <sil=0.000> maximum <sil=0.000> iteration <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> how <sil=0.000> I code <sil=0.000> and <sil=0.000> all <sil=0.000> of <sil=0.000> you
should <sil=0.000> be <sil=0.000> able <sil=0.000> to <sil=0.000> practice <sil=0.000> this <sil=0.000> yourself <sil=2.000> .PERIOD  Next <sil=0.000> we <sil=0.000> will <sil=0.000> move <sil=0.000> to <sil=0.000> another <sil=0.000> algorithm <sil=1.000> ,COMMA  which <sil=0.000> is <sil=0.000> that
another <sil=0.000> method <sil=1.000> ,COMMA  which <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> the <sil=0.000> Newton-Raphson <sil=0.000> method <sil=2.000> .PERIOD 

This <sil=0.000> method <sil=0.000> adopts <sil=0.000> a different <sil=0.000> approach <sil=0.000> to <sil=0.000> find <sil=0.000> the <sil=0.000> root <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=0.000> let <sil=0.000> us <sil=0.000> try <sil=0.000> to <sil=0.000> understand
this <sil=0.000> briefly <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> a function <sil=0.000> like <sil=0.000> this <sil=0.354> ;SEMICOLON  now <sil=0.000> Newton-Raphson <sil=0.000> method <sil=1.000> ,COMMA  what <sil=0.000> it <sil=0.000> does <sil=0.000> is <sil=1.000> ,COMMA  it <sil=0.000> starts <sil=0.000> at
some <sil=0.000> x 0 <sil=0.000> and <sil=0.000> the <sil=0.000> corresponding <sil=0.000> value <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=0.000> at <sil=0.000> x 0 <sil=0.000> is <sil=0.000> f x <sil=0.000> 0 <sil=2.000> .PERIOD  Now <sil=0.000> what <sil=0.000> it <sil=0.000> does <sil=0.000> it <sil=0.000> finds <sil=0.000> out
the <sil=0.000> tangent <sil=0.000> at <sil=0.000> this <sil=0.000> point <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> would <sil=0.000> that <sil=0.000> tangent <sil=0.000> be <sil=0.228> ?QUESTIONMARK  That <sil=0.000> tangent <sil=0.000> is <sil=0.000> nothing <sil=1.000> ,COMMA  but <sil=0.000> f prime <sil=0.000> x
0  <sil=1.000> ,COMMA  because <sil=0.000> we <sil=0.000> know <sil=0.000> prime <sil=0.000> means <sil=0.000> d y <sil=0.000> dx <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> draw <sil=0.000> the <sil=0.000> tangent <sil=0.000> here <sil=1.000> ,COMMA  the <sil=0.000> tangent <sil=0.000> intersects <sil=0.000> the <sil=0.000> x axis <sil=0.000> at <sil=0.000> some <sil=0.000> point <sil=2.000> .PERIOD  Let <sil=0.000> this <sil=0.000> be <sil=0.000> the <sil=0.000> value <sil=0.000> x
1 <sil=1.000> ,COMMA  I <sil=0.000> drew <sil=0.000> the <sil=0.000> tangent <sil=0.000> and <sil=0.000> got <sil=0.000> the <sil=0.000> value <sil=0.000> x 1 <sil=2.000> .PERIOD  I <sil=0.000> come <sil=0.000> here <sil=0.000> and <sil=0.000> from <sil=0.000> here <sil=0.000> and <sil=0.000> from <sil=0.000> here <sil=0.000> for <sil=0.000> f x <sil=0.000> 1 at
every <sil=0.000> stage <sil=0.000> have <sil=0.000> to <sil=0.000> check <sil=0.000> whether <sil=0.000> the <sil=0.000> value <sil=0.000> is <sil=0.000> close <sil=0.000> to <sil=0.000> 0 or <sil=0.000> not <sil=0.354> ;SEMICOLON  obviously <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> not <sil=0.000> the <sil=0.000> case <sil=2.000> .PERIOD 

Therefore <sil=1.000> ,COMMA  I <sil=0.000> draw <sil=0.000> another <sil=0.000> tangent <sil=0.000> from <sil=0.000> here <sil=0.000> and <sil=0.000> what <sil=0.000> is <sil=0.000> this <sil=0.000> tangent <sil=0.228> ?QUESTIONMARK  This <sil=0.000> tangent <sil=0.000> is <sil=0.000> f dash <sil=0.000> x 1 <sil=0.354> ;SEMICOLON 
derivative <sil=0.000> at <sil=0.000> this <sil=0.000> point <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> becomes <sil=0.000> x 2 <sil=1.000> ,COMMA  now <sil=0.000> I find <sil=0.000> out <sil=0.000> f x <sil=0.000> 2 <sil=2.000> .PERIOD  Now <sil=0.000> I again <sil=0.000> compare <sil=0.000> whether
f <sil=0.000> x 2 <sil=0.000> to <sil=0.000> is <sil=0.000> very <sil=0.000> close <sil=0.000> to <sil=0.000> 0 or <sil=0.000> not <sil=2.000> .PERIOD  Still <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> the <sil=0.000> case <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> draw <sil=0.000> a tangent <sil=0.000> at <sil=0.000> this <sil=0.000> point <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> x 3 <sil=0.000> and <sil=0.000> I find <sil=0.000> out <sil=0.000> if <sil=0.000> x 3 <sil=2.000> .PERIOD  Suppose <sil=0.000> this <sil=0.000> value <sil=0.000> f x <sil=0.000> 3 is <sil=0.000> very <sil=0.000> close <sil=0.000> to <sil=0.000> 0 <sil=2.000> .PERIOD  Suppose <sil=0.000> this <sil=0.000> is
within <sil=0.000> my <sil=0.000> allowed <sil=0.000> error <sil=1.000> ,COMMA  then <sil=0.000> x 3 <sil=0.000> is <sil=0.000> the <sil=0.000> root <sil=2.000> .PERIOD  Otherwise <sil=0.000> if <sil=0.000> it <sil=0.000> was <sil=0.000> not <sil=0.000> there <sil=0.000> from <sil=0.000> here <sil=0.000> again <sil=0.000> I
would <sil=0.000> have <sil=0.000> to <sil=0.000> draw <sil=0.000> a tangent <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=0.000> it <sil=0.000> goes <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> the <sil=0.000> essence <sil=0.000> of <sil=0.000> Newton-Raphsons <sil=0.000> method <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> are <sil=0.000> you <sil=0.000> doing <sil=0.000> here <sil=0.228> ?QUESTIONMARK  We <sil=0.000> are <sil=0.000> taking <sil=0.000> a function <sil=0.000> starting <sil=0.000> with <sil=0.000> a point <sil=0.000> and <sil=0.000> finding <sil=0.000> a tangent <sil=0.000> to <sil=0.000> that <sil=0.000> curve <sil=0.000> to <sil=0.000> the <sil=0.000> function <sil=0.000> at <sil=0.000> that <sil=0.000> point <sil=0.000> and <sil=0.000> see <sil=0.000> where <sil=0.000> that <sil=0.000> tangent <sil=0.000> intersects <sil=0.000> the <sil=0.000> x axis <sil=1.000> ,COMMA  from <sil=0.000> there <sil=0.000> I find <sil=0.000> out <sil=0.000> f x <sil=0.000> 2 and <sil=0.000> then <sil=0.000> I go <sil=0.000> on <sil=0.000> doing <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> think <sil=0.000> this <sil=0.000> geometrical <sil=0.000> exposition <sil=0.000> will <sil=0.000> be <sil=0.000> very <sil=0.000> helpful <sil=0.000> to <sil=0.000> you <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  next <sil=0.000> let <sil=0.000> us <sil=0.000> try <sil=0.000> to <sil=0.000> see <sil=0.000> how <sil=0.000> Newton-Raphson <sil=0.000> method <sil=0.000> works <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  at <sil=0.000> every <sil=0.000> stage <sil=0.000> x n <sil=0.000> plus <sil=0.000> 1 is <sil=0.000> x n <sil=0.000> minus <sil=0.000> f x <sil=0.000> n by <sil=0.000> f dash <sil=0.000> x n <sil=1.000> ,COMMA  why <sil=0.228> ?QUESTIONMARK  Because <sil=0.000> of <sil=0.000> the <sil=0.000> simple <sil=0.000> reason <sil=0.000> that <sil=0.000> I had <sil=0.000> this <sil=0.000> curve <sil=0.000> and <sil=0.000> this <sil=0.000> was <sil=0.000> my <sil=0.000> x n <sil=1.000> ,COMMA  from <sil=0.000> there <sil=0.000> I drew <sil=0.000> the <sil=0.000> tangent <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> was <sil=0.000> f x <sil=0.000> n and <sil=0.000> I drew <sil=0.000> the <sil=0.000> tangent <sil=0.000> here <sil=1.000> ,COMMA  then <sil=0.000> if <sil=0.000> I divide <sil=0.000> this <sil=0.000> and <sil=0.000> subtract <sil=0.000> from <sil=0.000> here <sil=0.000> I will <sil=0.000> get <sil=0.000> this <sil=0.000> x n <sil=0.000> plus <sil=0.000> 1 here <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  you <sil=0.000> see <sil=0.000> it <sil=0.000> is <sil=0.000> coming <sil=0.000> in <sil=0.000> the <sil=0.000> other <sil=0.000> way <sil=0.000> because <sil=0.000> at <sil=0.000> every <sil=0.000> stage <sil=0.000> I am <sil=0.000> computing <sil=0.000> this <sil=2.000> .PERIOD  Next <sil=1.000> ,COMMA  here <sil=0.000> x n <sil=0.000> is <sil=0.000> the <sil=0.000> current <sil=0.000> known <sil=0.000> value <sil=0.000> of <sil=0.000> x <sil=1.000> ,COMMA  f <sil=0.000> x n <sil=0.000> represents <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=1.000> ,COMMA  f <sil=0.000> dashed <sil=0.000> x n <sil=0.000> is <sil=0.000> the <sil=0.000> derivative <sil=0.000> of <sil=0.000> the <sil=0.000> slope <sil=0.000> at <sil=0.000> that <sil=0.000> point <sil=1.000> ,COMMA  x <sil=0.000> n plus <sil=0.000> 1 represents <sil=0.000> the <sil=0.000> next <sil=0.000> x value <sil=0.000> that <sil=0.000> you <sil=0.000> are <sil=0.000> trying <sil=0.000> to <sil=0.000> find <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> expression <sil=0.000> is <sil=0.000> coming <sil=0.000> from <sil=0.000> the <sil=0.000> fact <sil=0.000> that <sil=0.000> f x <sil=0.000> by <sil=0.000> d x <sil=1.000> ,COMMA  where <sil=0.000> d x <sil=0.000> is <sil=0.000> delta <sil=0.000> minus <sil=0.000> x therefore <sil=1.000> ,COMMA 
the <sil=0.000> term <sil=0.000> f x <sil=0.000> by <sil=0.000> f dash <sil=0.000> takes <sil=0.000> is <sil=0.000> actually <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> d x <sil=0.000> that <sil=0.000> means <sil=1.000> ,COMMA  by <sil=0.000> how <sil=0.000> much <sil=0.000> I should <sil=0.000> count
down <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> see <sil=0.000> from <sil=0.000> this <sil=0.000> expression <sil=0.000> f x <sil=0.000> by <sil=0.000> f prime <sil=0.000> x is <sil=0.000> f x <sil=0.000> by <sil=0.000> f x <sil=0.000> by <sil=0.000> delta <sil=0.000> x <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  the <sil=0.000> delta <sil=0.000> x <sil=0.354> ;SEMICOLON  actually <sil=0.000> this <sil=0.000> is <sil=0.000> the <sil=0.000> delta <sil=0.000> x part <sil=0.000> and <sil=0.000> that <sil=0.000> means <sil=1.000> ,COMMA  how <sil=0.000> I am <sil=0.000> shifting <sil=0.000> this <sil=0.000> x <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> x was <sil=0.000> here <sil=0.000> and <sil=0.000> I am <sil=0.000> shifting <sil=0.000> it <sil=0.000> by <sil=0.000> delta <sil=0.000> x and <sil=0.000> coming <sil=0.000> here <sil=1.000> ,COMMA  again <sil=0.000> shifting <sil=0.000> it <sil=0.000> by <sil=0.000> delta <sil=0.000> x and <sil=0.000> coming <sil=0.000> here <sil=0.000> like <sil=0.000> that <sil=0.000> I am <sil=0.000> going <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  suppose <sil=0.000> fx <sil=0.000> was <sil=0.000> x square <sil=0.000> minus <sil=0.000> 4 <sil=1.000> ,COMMA  then <sil=0.000> f prime <sil=0.000> x is <sil=0.000> obviously <sil=0.000> 2 x <sil=0.000> and <sil=0.000> x 0 <sil=0.000> was <sil=0.000> 6 <sil=1.000> ,COMMA  suppose <sil=0.000> I
assumed <sil=0.000> x 0 <sil=0.000> to <sil=0.000> be <sil=0.000> 6 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> how <sil=0.000> it <sil=0.000> goes <sil=2.000> .PERIOD  First <sil=0.000> iteration <sil=0.000> x 0 <sil=0.000> is <sil=0.000> 6 <sil=1.000> ,COMMA  f <sil=0.000> x 0 <sil=0.000> is <sil=0.000> supposed <sil=0.000> 32 <sil=1.000> ,COMMA  32
because <sil=0.000> 6 squared <sil=0.000> 36 <sil=0.000> minus <sil=0.000> 4 <sil=2.000> .PERIOD  f <sil=0.000> prime <sil=0.000> x is <sil=0.000> what <sil=0.228> ?QUESTIONMARK  f <sil=0.000> prime <sil=0.000> x is <sil=0.000> 2 x <sil=0.000> that <sil=0.000> is <sil=0.000> 12 <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> x n <sil=0.000> and <sil=0.000> the
next <sil=0.000> value <sil=0.000> will <sil=0.000> be <sil=0.000> x n <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  6 <sil=0.000> minus <sil=0.000> 32 <sil=0.000> by <sil=0.000> 12 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  whatever <sil=0.000> that <sil=0.000> is <sil=0.000> I subtract <sil=0.000> and <sil=0.000> I get <sil=0.000> the
3 <sil=2.000> .PERIOD <sil=0.000> 3 3 <sil=0.000> next <sil=0.000> iteration <sil=0.000> I come <sil=0.000> to <sil=0.000> 3 <sil=2.000> .PERIOD <sil=0.000> 3 3 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  it <sil=0.000> was <sil=0.000> something <sil=0.000> like <sil=0.000> this <sil=0.000> that <sil=0.000> I started <sil=0.000> with <sil=0.000> 6 and <sil=0.000> then <sil=0.000> I moved <sil=0.000> to <sil=0.000> 3 <sil=2.000> .PERIOD <sil=0.000> 3 3 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you <sil=0.000> see <sil=0.000> it <sil=0.000> is
converging <sil=0.000> very <sil=0.000> fast <sil=0.000> 3 <sil=2.000> .PERIOD <sil=0.000> 3 3 <sil=1.000> ,COMMA  then <sil=0.000> at <sil=0.000> 3 <sil=2.000> .PERIOD <sil=0.000> 3 3 <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> fx <sil=0.000> 1 is <sil=0.000> 7 <sil=2.000> .PERIOD <sil=0.000> 0 9 <sil=1.000> ,COMMA  here <sil=0.000> if <sil=0.000> you <sil=0.000> compute <sil=0.000> this <sil=1.000> ,COMMA  the
derivative <sil=0.000> will <sil=0.000> be <sil=0.000> twice <sil=0.000> of <sil=0.000> this <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> 6 <sil=2.000> .PERIOD <sil=0.000> 6 6 <sil=1.000> ,COMMA  derivative <sil=0.000> is <sil=0.000> 2 x <sil=1.000> ,COMMA  6 <sil=2.000> .PERIOD <sil=0.000> 6 6 <sil=2.000> .PERIOD  If <sil=0.000> I subtract <sil=0.000> this <sil=0.000> 6 <sil=2.000> .PERIOD <sil=0.000> 6 6
divided <sil=0.000> by <sil=0.000> 7 <sil=2.000> .PERIOD <sil=0.000> 0 9 <sil=1.000> ,COMMA  subtract <sil=0.000> it <sil=0.000> from <sil=0.000> 3 <sil=2.000> .PERIOD <sil=0.000> 3 3 <sil=0.000> is <sil=0.000> 2 <sil=2.000> .PERIOD <sil=0.000> 2 7 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  my <sil=0.000> dx <sil=0.000> is <sil=0.000> 1 <sil=2.000> .PERIOD <sil=0.000> 0 6 <sil=2.000> .PERIOD  I <sil=0.000> go <sil=0.000> on <sil=0.000> like <sil=0.000> this <sil=0.000> and
ultimately <sil=0.000> I come <sil=0.000> to <sil=0.000> a dx <sil=0.000> of <sil=0.000> 0 <sil=2.000> .PERIOD <sil=0.000> 01 <sil=1.000> ,COMMA  I <sil=0.000> assume <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  next <sil=0.000> time <sil=0.000> it <sil=0.000> is <sil=0.000> 2 <sil=2.000> .PERIOD <sil=0.000> 2 7 <sil=2.000> .PERIOD  I <sil=0.000> start <sil=0.000> with <sil=0.000> that <sil=0.000> again <sil=0.000> find <sil=0.000> the <sil=0.000> next <sil=0.000> value <sil=0.000> to <sil=0.000> be <sil=0.000> 2 <sil=2.000> .PERIOD <sil=0.000> 2 7 <sil=0.000> so <sil=0.000> it <sil=0.000> will <sil=0.000> be <sil=0.000> 2 <sil=2.000> .PERIOD <sil=0.000> 0 1
and <sil=0.000> with <sil=0.000> 2 <sil=2.000> .PERIOD <sil=0.000> 0 1 <sil=0.000> I compute <sil=0.000> and <sil=0.000> gradually <sil=0.000> you <sil=0.000> see <sil=0.000> the <sil=0.000> dx <sil=0.000> is <sil=0.000> coming <sil=0.000> down <sil=2.000> .PERIOD  As <sil=0.000> the <sil=0.000> dx <sil=0.000> is <sil=0.000> coming

down <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> approaching <sil=0.000> the <sil=0.000> actual <sil=0.000> root <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> Newton-Raphson <sil=0.000> method <sil=0.000> and <sil=0.000> we <sil=0.000> can <sil=0.000> very <sil=0.000> easily <sil=0.000> code <sil=0.000> it <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> an <sil=0.000> example <sil=2.000> .PERIOD  Now <sil=0.000> you <sil=0.000> can <sil=0.000> see <sil=0.000> this <sil=0.000> it <sil=0.000> starts <sil=0.000> with <sil=0.000> 6 goes <sil=0.000> to <sil=0.000> 3 <sil=2.000> .PERIOD <sil=0.000> 3 3 <sil=1.000> ,COMMA  then <sil=0.000> from <sil=0.000> 3 <sil=2.000> .PERIOD <sil=0.000> 3 3 <sil=0.354> ;SEMICOLON  I <sil=0.000> am
coming <sil=0.000> to <sil=0.000> 2 <sil=2.000> .PERIOD <sil=0.000> 2 <sil=2.000> .PERIOD <sil=0.000> 7 then <sil=0.000> from <sil=0.000> 2 <sil=2.000> .PERIOD <sil=0.000> 2 <sil=2.000> .PERIOD <sil=0.000> 7 <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> coming <sil=0.000> here <sil=0.000> and <sil=0.000> gradually <sil=0.000> the <sil=0.000> error <sil=0.000> is <sil=0.000> not <sil=0.000> increasing <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
it <sil=0.000> is <sil=0.000> very <sil=0.000> much <sil=0.000> converging <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> get <sil=0.000> the <sil=0.000> solution <sil=0.000> with <sil=0.000> 2 <sil=2.000> .PERIOD <sil=0.000> 0 1 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  quickly <sil=0.000> the <sil=0.000> algorithm <sil=0.000> will <sil=0.000> look <sil=0.000> like <sil=0.000> this - again <sil=0.000> I will <sil=0.000> read <sil=0.000> x <sil=1.000> ,COMMA  the <sil=0.000> a maximum <sil=0.000> error <sil=0.000> allowed
number <sil=0.000> of <sil=0.000> iterations <sil=0.000> and <sil=0.000> d <sil=2.000> .PERIOD  d <sil=0.000> is <sil=0.000> for <sil=0.000> checking <sil=0.000> the <sil=0.000> slope <sil=1.000> ,COMMA  here <sil=0.000> are <sil=0.000> the <sil=0.000> comments - x <sil=0.000> is <sil=0.000> the <sil=0.000> initial
guess <sil=1.000> ,COMMA  absolutely <sil=0.000> error <sil=0.000> is <sil=0.000> e <sil=1.000> ,COMMA  n <sil=0.000> is <sil=0.000> the <sil=0.000> number <sil=0.000> of <sil=0.000> iterations <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  do <sil=0.000> in <sil=0.000> a loop <sil=1.000> ,COMMA  i <sil=0.000> to <sil=0.000> n in <sil=0.000> steps <sil=0.000> of <sil=0.000> 2 <sil=1.000> ,COMMA  f <sil=0.000> x f <sil=0.000> is <sil=0.000> equal <sil=0.000> to <sil=0.000> f x <sil=0.000> and <sil=0.000> then <sil=0.000> f 1 <sil=0.000> is <sil=0.000> f prime <sil=0.000> x <sil=2.000> .PERIOD  Now <sil=0.000> these <sil=0.000> are <sil=0.000> 2
functions <sil=1.000> ,COMMA  which <sil=0.000> you <sil=0.000> have <sil=0.000> to <sil=0.000> write <sil=0.000> and <sil=0.000> now <sil=0.000> why <sil=0.000> am <sil=0.000> I keeping <sil=0.000> this <sil=0.000> check <sil=0.228> ?QUESTIONMARK  Why <sil=0.000> am <sil=0.000> I keeping
this <sil=0.000> check <sil=0.228> ?QUESTIONMARK  f <sil=0.000> 1 which <sil=0.000> is <sil=0.000> a slope <sil=0.000> if <sil=0.000> f dashed <sil=0.000> x is <sil=0.000> too <sil=0.000> small <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  what <sil=0.000> that <sil=0.000> the <sil=0.000> slope <sil=0.000> is
nearly <sil=0.000> horizontal <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> not <sil=0.000> going <sil=0.000> to <sil=0.000> get <sil=0.000> something <sil=0.000> like <sil=0.000> this <sil=2.000> .PERIOD  If <sil=0.000> I come <sil=0.000> to <sil=0.000> this <sil=0.000> point
and <sil=0.000> try <sil=0.000> to <sil=0.000> find <sil=0.000> a slope <sil=0.000> of <sil=0.000> this <sil=1.000> ,COMMA  the <sil=0.000> slope <sil=0.000> will <sil=0.000> be <sil=0.000> very <sil=0.000> horizontal <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> not <sil=0.000> a good <sil=0.000> choice <sil=2.000> .PERIOD  In <sil=0.000> that <sil=0.000> case <sil=0.000> I have <sil=0.000> to <sil=0.000> reduce <sil=0.000> it <sil=0.000> and <sil=0.000> come <sil=0.000> to <sil=0.000> a point <sil=1.000> ,COMMA  where <sil=0.000> I can <sil=0.000> find <sil=0.000> a slope <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> way <sil=0.000> I go <sil=0.000> on <sil=0.000> and <sil=0.000> find <sil=0.000> the <sil=0.000> whether <sil=0.000> it <sil=0.000> is <sil=0.000> coming <sil=0.000> to <sil=0.000> the <sil=0.000> close <sil=0.000> to <sil=0.000> the <sil=0.000> root <sil=0.000> and <sil=0.000> go <sil=0.000> on <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  if <sil=0.000> it <sil=0.000> goes <sil=0.000> on <sil=0.000> the <sil=0.000> iteration <sil=0.000> goes <sil=0.000> on <sil=0.000> say <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> possible <sil=0.000> that <sil=0.000> I am <sil=0.000> missing <sil=0.000> the <sil=0.000> loop <sil=1.000> ,COMMA  coming <sil=0.000> close <sil=0.000> to <sil=0.000> that- say <sil=0.000> a curve <sil=0.000> like <sil=0.000> this <sil=2.000> .PERIOD 

The <sil=0.000> slope <sil=0.000> of <sil=0.000> the <sil=0.000> curve <sil=0.000> was <sil=0.000> such <sil=0.000> that <sil=0.000> I was <sil=0.000> trying <sil=0.000> to <sil=0.000> come <sil=0.000> here <sil=0.000> and <sil=0.000> somehow <sil=0.000> I miss <sil=0.000> the <sil=0.000> root <sil=1.000> ,COMMA  I <sil=0.000> go <sil=0.000> to <sil=0.000> another <sil=0.000> point <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> another <sil=0.000> special <sil=0.000> case <sil=0.000> I need <sil=0.000> not <sil=0.000> bother <sil=0.000> you <sil=0.000> with <sil=0.000> that <sil=0.000> right <sil=0.000> now <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> have <sil=0.000> a quick <sil=0.000> look <sil=0.000> at <sil=0.000> the <sil=0.000> program <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> we <sil=0.000> are <sil=0.000> trying <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> root <sil=0.000> of <sil=0.000> a function <sil=0.000> x log <sil=0.000> x to <sil=0.000> the <sil=0.000> base <sil=0.000> 10 <sil=0.000> minus <sil=0.000> 1 <sil=2.000> .PERIOD <sil=0.000> 2 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that
is <sil=0.000> the <sil=0.000> function <sil=0.000> that <sil=0.000> function <sil=0.000> is <sil=0.000> embodied <sil=0.000> in <sil=0.000> another <sil=0.000> C function <sil=2.000> .PERIOD  Now <sil=0.000> d f <sil=0.000> is <sil=0.000> nothing <sil=1.000> ,COMMA  but <sil=0.000> f dashed
x <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  if <sil=0.000> this <sil=0.000> function <sil=0.000> is <sil=0.000> given <sil=1.000> ,COMMA  I <sil=0.000> also <sil=0.000> keep <sil=0.000> f dashed <sil=0.000> x written <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> f x <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> f dashed <sil=0.000> x <sil=2.000> .PERIOD  Now
I <sil=0.000> know <sil=0.000> I have <sil=0.000> already <sil=0.000> pre <sil=0.000> coded <sil=0.000> them <sil=0.000> and <sil=0.000> that <sil=0.000> will <sil=0.000> return <sil=0.000> me <sil=0.000> the <sil=0.000> value <sil=0.000> for <sil=0.000> different <sil=0.000> values <sil=0.000> of <sil=0.000> x <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  now <sil=0.000> again <sil=0.000> I read <sil=0.000> as <sil=0.000> scan <sil=0.000> f <sil=1.000> ,COMMA  i <sil=0.000> read <sil=0.000> the <sil=0.000> initial <sil=0.000> x 0 <sil=1.000> ,COMMA  the <sil=0.000> allowed <sil=0.000> error <sil=1.000> ,COMMA  the <sil=0.000> maximum <sil=0.000> iteration <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  then <sil=0.000> in <sil=0.000> this <sil=0.000> loop <sil=0.000> what <sil=0.000> I do <sil=0.000> I find <sil=0.000> fx <sil=0.000> by <sil=0.000> f dashed <sil=0.000> x and <sil=0.000> that <sil=0.000> is <sil=0.000> h -how <sil=0.000> much <sil=0.000> I should <sil=0.000> change
the <sil=0.000> initial <sil=0.000> value <sil=2.000> .PERIOD  The <sil=0.000> initial <sil=0.000> value <sil=0.000> was <sil=0.000> x 0 <sil=0.000> with <sil=0.000> which <sil=0.000> I started <sil=1.000> ,COMMA  I <sil=0.000> subtract <sil=0.000> that <sil=0.000> and <sil=0.000> come <sil=0.000> to <sil=0.000> the
next <sil=0.000> point <sil=2.000> .PERIOD 

If <sil=0.000> absolute <sil=0.000> value <sil=0.000> at <sil=0.000> that <sil=0.000> point <sil=0.000> is <sil=0.000> less <sil=0.000> than <sil=0.000> error <sil=0.000> then <sil=0.000> that <sil=0.000> is <sil=0.000> a solution <sil=2.000> .PERIOD  Otherwise <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> go <sil=0.000> up <sil=0.000> and
repeat <sil=0.000> this <sil=2.000> .PERIOD  Now <sil=0.000> if <sil=0.000> I go <sil=0.000> on <sil=0.000> and <sil=0.000> ultimately <sil=0.000> if <sil=0.000> I overshoot <sil=0.000> the <sil=0.000> maximum <sil=0.000> iteration <sil=1.000> ,COMMA  then <sil=0.000> I can <sil=0.000> say
that <sil=0.000> the <sil=0.000> required <sil=0.000> solution <sil=0.000> does <sil=0.000> not <sil=0.000> converge <sil=0.000> or <sil=0.000> the <sil=0.000> iterations <sil=0.000> are <sil=0.000> inefficient <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  Newton-Raphson <sil=0.000> usually <sil=0.000> gives <sil=0.000> us <sil=0.000> a very <sil=0.000> fast <sil=0.000> way <sil=0.000> of <sil=0.000> finding <sil=0.000> the <sil=0.000> root <sil=1.000> ,COMMA  but <sil=0.000> sometimes <sil=0.000> it <sil=0.000> does
not <sil=0.000> converge <sil=0.000> and <sil=0.000> that <sil=0.000> is <sil=0.000> one <sil=0.000> problem <sil=0.000> of <sil=0.000> that <sil=2.000> .PERIOD  However <sil=1.000> ,COMMA  there <sil=0.000> are <sil=0.000> many <sil=0.000> other <sil=0.000> sophisticated <sil=0.000> ways
of <sil=0.000> finding <sil=0.000> roots <sil=1.000> ,COMMA  just <sil=0.000> to <sil=0.000> summarise <sil=0.000> I would <sil=0.000> like <sil=0.000> to <sil=0.000> say <sil=0.000> that <sil=0.000> what <sil=0.000> we <sil=0.000> have <sil=0.000> learnt <sil=0.000> in <sil=0.000> the <sil=0.000> past <sil=0.000> couple
of <sil=0.000> lectures <sil=0.000> is <sil=0.000> that <sil=0.000> one <sil=0.000> of <sil=0.000> the <sil=0.000> major <sil=0.000> technological <sil=0.000> requirements <sil=1.000> ,COMMA  a <sil=0.000> computational <sil=0.000> requirements <sil=0.000> are
finding <sil=0.000> roots <sil=0.000> of <sil=0.000> polynomials <sil=0.000> for <sil=0.000> many <sil=0.000> solutions <sil=0.000> for <sil=0.000> many <sil=0.000> engineering <sil=0.000> solutions <sil=2.000> .PERIOD  I <sil=0.000> have <sil=0.000> to <sil=0.000> solve
equations <sil=2.000> .PERIOD 

For <sil=0.000> that <sil=0.000> there <sil=0.000> are <sil=0.000> many <sil=0.000> methods <sil=0.000> we <sil=0.000> have <sil=0.000> just <sil=0.000> gone <sil=0.000> through <sil=0.000> to <sil=0.000> simpler <sil=0.000> methods <sil=0.000> one <sil=0.000> is <sil=0.000> the
bisection <sil=0.000> method <sil=0.000> and <sil=0.000> the <sil=0.000> other <sil=0.000> one <sil=0.000> that <sil=0.000> we <sil=0.000> saw <sil=0.000> just <sil=0.000> now <sil=0.000> is <sil=0.000> the <sil=0.000> Newton-Raphson <sil=0.000> method <sil=2.000> .PERIOD  Next
we <sil=0.000> look <sil=0.000> at <sil=0.000> something <sil=0.000> else <sil=0.000> called <sil=0.000> interpolation <sil=0.000> and <sil=0.000> other <sil=0.000> things <sil=2.000> .PERIOD 

Thank <sil=0.000> you <sil=2.000> .PERIOD 

Today <sil=0.000> we <sil=0.000> will <sil=0.000> first <sil=0.000> discuss <sil=0.000> a technique <sil=0.000> called <sil=0.000> interpolation <sil=2.000> .PERIOD  We <sil=0.000> have <sil=0.000> seen <sil=0.000> how <sil=0.000> a function <sil=0.000> can <sil=0.000> be
represented <sil=0.000> in <sil=0.000> a computer <sil=0.000> in <sil=0.000> the <sil=0.000> form <sil=0.000> of <sil=0.000> a table <sil=0.000> or <sil=0.000> a 2 <sil=0.000> 2-dimensional <sil=0.000> array <sil=2.000> .PERIOD  Now <sil=0.000> what <sil=0.000> is
interpolation <sil=0.228> ?QUESTIONMARK  Let <sil=0.000> us <sil=0.000> try <sil=0.000> to <sil=0.000> understand <sil=2.000> .PERIOD 

Say <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> a function <sil=1.000> ,COMMA  where <sil=0.000> I know <sil=0.000> the <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> a function <sil=0.000> which <sil=0.000> is <sil=0.000> something <sil=0.000> like <sil=0.000> this <sil=2.000> .PERIOD 
But <sil=0.000> I do <sil=0.000> not <sil=0.000> know <sil=0.000> the <sil=0.000> function <sil=0.000> before <sil=0.000> that <sil=1.000> ,COMMA  all <sil=0.000> right <sil=0.228> ?QUESTIONMARK  If <sil=0.000> I had <sil=0.000> known <sil=0.000> the <sil=0.000> function <sil=0.000> or <sil=0.000> tje
description <sil=0.000> of <sil=0.000> this <sil=0.000> function <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> case <sil=0.000> given <sil=0.000> any <sil=0.000> x <sil=1.000> ,COMMA  I <sil=0.000> could <sil=0.000> have <sil=0.000> found <sil=0.000> out <sil=0.000> the <sil=0.000> corresponding <sil=0.000> y <sil=1.000> ,COMMA 
right <sil=2.000> .PERIOD 

But <sil=0.000> suppose <sil=0.000> the <sil=0.000> function <sil=0.000> is <sil=0.000> not <sil=0.000> given <sil=1.000> ,COMMA  instead <sil=0.000> what <sil=0.000> is <sil=0.000> given <sil=0.000> to <sil=0.000> us <sil=0.000> are <sil=0.000> for <sil=0.000> some <sil=0.000> specific <sil=0.000> x s (say <sil=0.000> x
1) I <sil=0.000> have <sil=0.000> been <sil=0.000> given <sil=0.000> this <sil=0.000> value <sil=1.000> ,COMMA  all <sil=0.000> right <sil=0.228> ?QUESTIONMARK  This <sil=0.000> value <sil=0.000> of <sil=0.000> y <sil=2.000> .PERIOD  For <sil=0.000> x equal <sil=0.000> to <sil=0.000> 2 <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> been <sil=0.000> given <sil=0.000> this
value <sil=0.000> of <sil=0.000> y <sil=1.000> ,COMMA  all <sil=0.000> right <sil=0.228> ?QUESTIONMARK  This <sil=0.000> particular <sil=0.000> value <sil=0.000> of <sil=0.000> y <sil=2.000> .PERIOD  Similarly <sil=1.000> ,COMMA  for <sil=0.000> 3 <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> given <sil=0.000> a particular <sil=0.000> value <sil=0.000> of

y <sil=1.000> ,COMMA  but <sil=0.000> I do <sil=0.000> not <sil=0.000> know <sil=0.000> what <sil=0.000> is <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> this <sil=0.000> function <sil=0.000> for <sil=0.000> 1 <sil=2.000> .PERIOD <sil=0.000> 5 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> I call <sil=0.000> this <sil=0.000> to <sil=0.000> be <sil=0.000> the <sil=0.000> function <sil=0.000> f
of <sil=0.000> x <sil=1.000> ,COMMA  then <sil=0.000> f of <sil=0.000> 1 <sil=2.000> .PERIOD <sil=0.000> 5 is <sil=0.000> not <sil=0.000> known <sil=2.000> .PERIOD  Although <sil=0.000> I know <sil=0.000> that <sil=0.000> f of <sil=0.000> 1 is <sil=0.000> say <sil=0.000> something <sil=0.000> 2 <sil=2.000> .PERIOD <sil=0.000> 5 <sil=1.000> ,COMMA  I <sil=0.000> know <sil=0.000> f of <sil=0.000> 2
to <sil=0.000> be <sil=0.000> may <sil=0.000> be <sil=0.000> 3 <sil=2.000> .PERIOD <sil=0.000> 2 <sil=1.000> ,COMMA  f <sil=0.000> of <sil=0.000> 3 maybe <sil=0.000> something <sil=0.000> like <sil=0.000> 4 <sil=2.000> .PERIOD 

But <sil=0.000> this <sil=0.000> information <sil=0.000> is <sil=0.000> known <sil=0.000> to <sil=0.000> me <sil=2.000> .PERIOD  Given <sil=0.000> this <sil=0.000> known <sil=0.000> part <sil=1.000> ,COMMA  can <sil=0.000> I find <sil=0.000> out <sil=0.000> what <sil=0.000> are <sil=0.000> the
intermediate <sil=0.000> values <sil=0.000> for <sil=0.000> if <sil=0.000> 1 <sil=2.000> .PERIOD <sil=0.000> 58 <sil=1.000> ,COMMA  1 <sil=2.000> .PERIOD <sil=0.000> 3 <sil=1.000> ,COMMA  2 <sil=2.000> .PERIOD <sil=0.000> 5 <sil=1.000> ,COMMA  2 <sil=2.000> .PERIOD <sil=0.000> 6 <sil=0.228> ?QUESTIONMARK  That <sil=0.000> is <sil=0.000> the <sil=0.000> task <sil=0.000> of <sil=0.000> interpolation <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  given
some <sil=0.000> values <sil=0.000> known <sil=1.000> ,COMMA  I <sil=0.000> want <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=0.000> for <sil=0.000> some <sil=0.000> independent <sil=0.000> value <sil=0.000> of
the <sil=0.000> dependent <sil=0.000> variable <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  for <sil=0.000> a particular <sil=0.000> x <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> the <sil=0.000> part <sil=0.228> ?QUESTIONMARK  What <sil=0.000> is <sil=0.000> the <sil=0.000> y <sil=0.228> ?QUESTIONMARK  That s <sil=0.000> what <sil=0.000> I want
to <sil=0.000> find <sil=2.000> .PERIOD  Now <sil=0.000> you <sil=0.000> see <sil=0.000> you <sil=0.000> can <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=0.000> blue <sil=0.000> line <sil=0.000> and <sil=0.000> say <sil=0.000> that <sil=0.000> it s <sil=0.000> so <sil=1.000> ,COMMA  simply <sil=0.000> you <sil=0.000> draw <sil=0.000> it <sil=0.000> like
this <sil=0.000> and <sil=0.000> you <sil=0.000> will <sil=0.000> find <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> y <sil=2.000> .PERIOD 

But <sil=0.000> unfortunately <sil=1.000> ,COMMA  what <sil=0.000> I have <sil=0.000> is <sil=0.000> not <sil=0.000> the <sil=0.000> blue <sil=0.000> line <sil=2.000> .PERIOD  What <sil=0.000> I have <sil=0.000> is <sil=0.000> only <sil=0.000> the <sil=0.000> rate <sil=0.000> crosses <sil=0.000> and <sil=0.000> this
line <sil=0.000> is <sil=0.000> not <sil=0.000> there <sil=2.000> .PERIOD  I <sil=0.000> do <sil=0.000> not <sil=0.000> know <sil=0.000> these <sil=0.000> 3 points - whether <sil=0.000> the <sil=0.000> curve <sil=0.000> is <sil=0.000> something <sil=0.000> like <sil=0.000> this <sil=0.000> or <sil=0.000> the
curve <sil=0.000> could <sil=0.000> be <sil=0.000> a straight <sil=0.000> line <sil=0.000> through <sil=0.000> this <sil=0.000> points <sil=1.000> ,COMMA  right <sil=0.228> ?QUESTIONMARK  In <sil=0.000> that <sil=0.000> case <sil=0.000> you <sil=0.000> see <sil=1.000> ,COMMA  if <sil=0.000> it <sil=0.000> was <sil=0.000> the <sil=0.000> case <sil=1.000> ,COMMA 
then <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> x <sil=1.000> ,COMMA  this <sil=0.000> particular <sil=0.000> x would <sil=0.000> be <sil=0.000> different <sil=0.000> from <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> to <sil=0.000> actually <sil=0.000> see <sil=0.000> that
what <sil=0.000> is <sil=0.000> the <sil=0.000> curve <sil=0.000> that <sil=0.000> best <sil=0.000> fits <sil=0.000> all <sil=0.000> these <sil=0.000> given <sil=0.000> points <sil=2.000> .PERIOD  This <sil=0.000> problem <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> interpolation <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> extend <sil=0.000> it <sil=0.000> suppose <sil=0.000> some <sil=0.000> table <sil=0.000> is <sil=0.000> given <sil=0.000> to <sil=0.000> you <sil=1.000> ,COMMA  where <sil=0.000> values <sil=0.000> for <sil=0.000> f 1 <sil=1.000> ,COMMA  2 <sil=0.000> and <sil=0.000> 3 are <sil=0.000> given
and <sil=0.000> so <sil=1.000> ,COMMA  the <sil=0.000> range <sil=0.000> is <sil=0.000> from <sil=0.000> one <sil=0.000> to <sil=0.000> 3 <sil=1.000> ,COMMA  but <sil=0.000> you <sil=0.000> are <sil=0.000> asked <sil=0.000> for <sil=0.000> some <sil=0.000> particular <sil=0.000> x prime <sil=1.000> ,COMMA  which <sil=0.000> is
beyond <sil=0.000> this <sil=0.000> range <sil=2.000> .PERIOD  In <sil=0.000> that <sil=0.000> case <sil=0.000> it <sil=0.000> is <sil=0.000> also <sil=0.000> interpolation <sil=0.000> on <sil=0.000> the <sil=0.000> other <sil=0.000> side <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  beyond <sil=0.000> the
boundary <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> extrapolation <sil=1.000> ,COMMA  all <sil=0.000> right <sil=0.228> ?QUESTIONMARK  Right <sil=0.000> now <sil=1.000> ,COMMA  so <sil=1.000> ,COMMA  basically <sil=0.000> the <sil=0.000> concept <sil=0.000> of
extrapolation <sil=0.000> and <sil=0.000> interpolation <sil=0.000> are <sil=0.000> always <sil=0.000> the <sil=0.000> same <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> what <sil=0.000> I will <sil=0.000> try <sil=0.000> to <sil=0.000> see <sil=0.000> is <sil=0.000> given <sil=0.000> some <sil=0.000> values <sil=0.000> of <sil=0.000> fx <sil=1.000> ,COMMA  some <sil=0.000> known <sil=0.000> of <sil=0.000> fx <sil=0.000> for <sil=0.000> some <sil=0.000> particular
x s <sil=1.000> ,COMMA  how <sil=0.000> do <sil=0.000> you <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> fx <sil=0.000> for <sil=0.000> some <sil=0.000> intermediate <sil=0.000> value <sil=0.000> of <sil=0.000> x <sil=0.228> ?QUESTIONMARK  That <sil=0.000> is <sil=0.000> the <sil=0.000> task <sil=0.000> of
interpolation <sil=2.000> .PERIOD <sil=0.000> Now <sil=0.000> here <sil=0.000> I show <sil=0.000> I had <sil=0.000> shown <sil=0.000> a curve <sil=0.000> usually <sil=0.000> you <sil=0.000> can <sil=0.000> also <sil=0.000> start <sil=0.000> with <sil=0.000> a table <sil=0.000> like
this <sil=1.000> ,COMMA  where <sil=0.000> some <sil=0.000> x s <sil=0.000> are <sil=0.000> given (Refer <sil=0.000> Slide <sil=0.000> Time: 06:03)say <sil=0.000> 0 <sil=2.000> .PERIOD <sil=0.000> 1 <sil=1.000> ,COMMA  0 <sil=2.000> .PERIOD <sil=0.000> 2 <sil=1.000> ,COMMA  0 <sil=2.000> .PERIOD <sil=0.000> 3 <sil=1.000> ,COMMA  0 <sil=2.000> .PERIOD <sil=0.000> 4 <sil=1.000> ,COMMA  0 <sil=2.000> .PERIOD <sil=0.000> 5 and <sil=0.000> for <sil=0.000> each <sil=0.000> of
them <sil=0.000> we <sil=0.000> have <sil=0.000> got <sil=0.000> some <sil=0.000> y value <sil=0.000> 2 <sil=2.000> .PERIOD <sil=0.000> 7 <sil=1.000> ,COMMA  3 <sil=2.000> .PERIOD <sil=0.000> 2 <sil=1.000> ,COMMA  1 <sil=2.000> .PERIOD <sil=0.000> 6 comes <sil=0.000> down <sil=0.000> again <sil=1.000> ,COMMA  say <sil=1.000> ,COMMA  0 <sil=2.000> .PERIOD <sil=0.000> 6 <sil=1.000> ,COMMA  and <sil=0.000> again <sil=0.000> it <sil=0.000> goes <sil=0.000> up <sil=0.000> say
3 <sil=2.000> .PERIOD <sil=0.000> 2 <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  if <sil=0.000> this <sil=0.000> be <sil=0.000> the <sil=0.000> table <sil=1.000> ,COMMA  then <sil=0.000> my <sil=0.000> question <sil=0.000> is <sil=0.000> for <sil=0.000> interpolation <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> the <sil=0.000> value <sil=0.228> ?QUESTIONMARK  What <sil=0.000> is <sil=0.000> the
value <sil=0.000> for <sil=0.000> x which <sil=0.000> is <sil=0.000> 0 <sil=2.000> .PERIOD <sil=0.000> 27 <sil=0.228> ?QUESTIONMARK  What <sil=0.000> is <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> this <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> the <sil=0.000> task <sil=0.000> of <sil=0.000> interpretation <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA 
obviously <sil=1.000> ,COMMA  a <sil=0.000> simplest <sil=0.000> possible <sil=0.000> thing <sil=0.000> is <sil=0.000> if <sil=0.000> I can <sil=0.000> fit <sil=0.000> in <sil=0.000> a line <sil=0.000> which <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> a linear
interpolation <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> some <sil=0.000> points <sil=0.000> here <sil=1.000> ,COMMA  all <sil=0.000> right <sil=0.228> ?QUESTIONMARK  I <sil=0.000> try <sil=0.000> to <sil=0.000> fit <sil=0.000> in <sil=0.000> a line <sil=0.000> in <sil=0.000> between <sil=0.000> them <sil=0.000> or <sil=0.000> let <sil=0.000> me <sil=0.000> do <sil=0.000> it <sil=0.000> in <sil=0.000> a
different <sil=0.000> way <sil=0.000> not <sil=0.000> exactly <sil=0.000> this <sil=0.000> line <sil=1.000> ,COMMA  because <sil=0.000> this <sil=0.000> line <sil=0.000> is <sil=0.000> matching <sil=0.000> 2 points <sil=1.000> ,COMMA  but <sil=0.000> not <sil=0.000> the <sil=0.000> others <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> by <sil=0.000> y and <sil=0.000> this <sil=0.000> is <sil=0.000> x <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  there <sil=0.000> could <sil=0.000> be <sil=0.000> some <sil=0.000> points <sil=0.000> like <sil=0.000> this <sil=0.000> something <sil=0.000> here <sil=0.000> and
something <sil=0.000> here <sil=0.000> like <sil=0.000> this <sil=0.000> equidistant <sil=0.000> points <sil=2.000> .PERIOD  Somehow <sil=0.000> I draw <sil=0.000> line <sil=0.000> like <sil=0.000> this <sil=2.000> .PERIOD  It <sil=0.000> is <sil=0.000> a straight <sil=0.000> line <sil=1.000> ,COMMA 
although <sil=0.000> my <sil=0.000> drawing <sil=0.000> is <sil=0.000> a little <sil=0.000> curved <sil=1.000> ,COMMA  but <sil=0.000> it <sil=0.000> is <sil=0.000> a straight <sil=0.000> line <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  one <sil=0.000> way <sil=0.000> is <sil=0.000> that <sil=0.000> I try <sil=0.000> to <sil=0.000> find <sil=0.000> out
a <sil=0.000> line <sil=0.000> such <sil=0.000> that <sil=0.000> I minimise <sil=0.000> the <sil=0.000> error <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  of <sil=0.000> course <sil=1.000> ,COMMA  if <sil=0.000> I assume <sil=0.000> that <sil=0.000> this <sil=0.000> line <sil=0.000> is <sil=0.000> representing <sil=0.000> my
function <sil=1.000> ,COMMA  then <sil=0.000> I can <sil=0.000> see <sil=0.000> there <sil=0.000> is <sil=0.000> some <sil=0.000> error <sil=0.000> here <sil=1.000> ,COMMA  there <sil=0.000> is <sil=0.000> some <sil=0.000> error <sil=0.000> here <sil=0.000> and <sil=0.000> in <sil=0.000> other <sil=0.000> places <sil=2.000> .PERIOD 

I <sil=0.000> could <sil=0.000> have <sil=0.000> fitted <sil=0.000> another <sil=0.000> line <sil=0.000> also <sil=1.000> ,COMMA  I <sil=0.000> could <sil=0.000> have <sil=0.000> changed <sil=0.000> this <sil=0.000> line <sil=0.000> a little <sil=0.000> bit <sil=2.000> .PERIOD  One <sil=0.000> of <sil=0.000> the <sil=0.000> ways <sil=0.000> is
to <sil=0.000> find <sil=0.000> the <sil=0.000> line <sil=0.000> that <sil=0.000> minimises <sil=0.000> the <sil=0.000> error <sil=2.000> .PERIOD  Now <sil=0.000> it <sil=0.000> depends <sil=0.000> on <sil=0.000> how <sil=0.000> you <sil=0.000> define <sil=0.000> the <sil=0.000> error <sil=1.000> ,COMMA  <sil=2.000> .PERIOD  Now <sil=0.000> here
you <sil=0.000> can <sil=0.000> see <sil=0.000> it <sil=0.000> is <sil=0.000> a negative <sil=0.000> error <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> a positive <sil=0.000> error <sil=1.000> ,COMMA  like <sil=0.000> that <sil=0.000> it <sil=0.000> can <sil=0.000> go <sil=0.000> on <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  one <sil=0.000> way <sil=0.000> is <sil=0.000> to
find <sil=0.000> the <sil=0.000> line <sil=0.000> such <sil=0.000> that <sil=0.000> the <sil=0.000> squared <sil=0.000> sum <sil=0.000> of <sil=0.000> squared <sil=0.000> error <sil=0.000> is <sil=0.000> minimised <sil=2.000> .PERIOD  That <sil=0.000> can <sil=0.000> be <sil=0.000> one <sil=0.000> way <sil=0.354> ;SEMICOLON  that
means <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> an <sil=0.000> error <sil=0.000> error <sil=0.228> ?QUESTIONMARK  When <sil=0.000> ei <sil=0.000> is (when <sil=0.000> I take <sil=0.000> whatever <sil=0.000> value <sil=0.000> my <sil=0.000> line <sil=0.000> is <sil=0.000> saying <sil=1.000> ,COMMA  let <sil=0.000> let
me <sil=0.000> call <sil=0.000> it <sil=0.000> li ) whatever <sil=0.000> is <sil=0.000> the <sil=0.000> actual <sil=0.000> value <sil=0.000> minus <sil=0.000> yi <sil=2.000> .PERIOD 

If <sil=0.000> I consider <sil=0.000> that <sil=0.000> to <sil=0.000> be <sil=0.000> the <sil=0.000> error <sil=0.000> or <sil=0.000> the <sil=0.000> other <sil=0.000> way <sil=1.000> ,COMMA  now <sil=0.000> you <sil=0.000> can <sil=0.000> see <sil=0.000> it <sil=0.000> is <sil=0.000> a positive <sil=0.000> or <sil=0.000> negative
when <sil=0.000> I take <sil=0.000> the <sil=0.000> error <sil=0.000> of <sil=0.000> all <sil=0.000> these <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> could <sil=0.000> be <sil=0.000> a sum <sil=0.000> of <sil=0.000> error <sil=2.000> .PERIOD  But <sil=0.000> here <sil=0.000> what <sil=0.000> I am <sil=0.000> saying <sil=0.000> is
that <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> have <sil=0.000> the <sil=0.000> square <sil=0.000> of <sil=0.000> this <sil=0.000> error <sil=1.000> ,COMMA  and <sil=0.000> I can <sil=0.000> try <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> a line <sil=0.000> such <sil=0.000> that <sil=0.000> ei <sil=0.000> square <sil=0.000> is
minimise <sil=0.000> so <sil=0.000> that <sil=0.000> I get <sil=0.000> a very <sil=0.000> good <sil=0.000> line <sil=2.000> .PERIOD  Now <sil=0.000> suppose <sil=0.000> I get <sil=0.000> a very <sil=0.000> good <sil=0.000> line <sil=0.000> like <sil=0.000> this <sil=1.000> ,COMMA  then <sil=0.000> I will
have <sil=0.000> I have <sil=0.000> the <sil=0.000> equation <sil=0.000> of <sil=0.000> that <sil=0.000> line <sil=2.000> .PERIOD  Now <sil=0.000> given <sil=0.000> 2 points <sil=0.000> it <sil=0.000> is <sil=0.000> very <sil=0.000> simple <sil=1.000> ,COMMA  right <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> take <sil=0.000> the
simplest <sil=0.000> case <sil=0.000> first <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  if <sil=0.000> there <sil=0.000> be <sil=0.000> only <sil=0.000> 2 points <sil=0.000> given <sil=1.000> ,COMMA  then <sil=0.000> I can <sil=0.000> certainly <sil=0.000> draw <sil=0.000> a unique <sil=0.000> line <sil=0.000> between <sil=0.000> these <sil=0.000> 2 points <sil=1.000> ,COMMA  right <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> equation <sil=0.000> of <sil=0.000> these <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> x or <sil=0.000> school <sil=0.000> level <sil=0.000> co <sil=0.000> ordinate <sil=0.000> geometry <sil=0.000> x1 <sil=1.000> ,COMMA  y <sil=0.000> 1 <sil=1.000> ,COMMA  x <sil=0.000> 2 <sil=1.000> ,COMMA  y <sil=0.000> 2 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> slope <sil=0.000> of <sil=0.000> this <sil=0.000> line <sil=2.000> .PERIOD  You <sil=0.000> can <sil=0.000> find <sil=0.000> the <sil=0.000> slope <sil=0.000> of <sil=0.000> this <sil=0.000> line <sil=1.000> ,COMMA <sil=0.000> which <sil=0.000> will <sil=0.000> be <sil=0.000> nothing <sil=0.000> but <sil=0.000> y 2 <sil=0.000> minus <sil=0.000> y 1 <sil=0.000> divided <sil=0.000> by <sil=0.000> x 2 <sil=0.000> minus <sil=0.000> x 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  once <sil=0.000> you <sil=0.000> get <sil=0.000> the <sil=0.000> slope <sil=1.000> ,COMMA <sil=0.000> then <sil=0.000> you <sil=0.000> can <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> line <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> school <sil=0.000> level <sil=0.000> equations <sil=0.000> like <sil=0.000> y minus <sil=0.000> y 1 <sil=0.000> is <sil=0.000> equal <sil=0.000> to <sil=0.000> m into <sil=0.000> x minus <sil=0.000> x 1 <sil=1.000> ,COMMA  where <sil=0.000> m is <sil=0.000> this <sil=0.000> m is <sil=0.000> a slope <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> find <sil=0.000> the <sil=0.000> line <sil=0.000> so <sil=1.000> ,COMMA  when <sil=0.000> you <sil=0.000> find <sil=0.000> the <sil=0.000> line <sil=1.000> ,COMMA  then <sil=0.000> your <sil=0.000> problem <sil=0.000> is <sil=0.000> solved <sil=2.000> .PERIOD  Suppose <sil=0.000> you
get <sil=0.000> a line <sil=0.000> of <sil=0.000> the <sil=0.000> equation <sil=0.000> a x <sil=0.000> plus <sil=0.000> c <sil=1.000> ,COMMA  c <sil=0.000> is <sil=0.000> this <sil=0.000> and <sil=0.000> you <sil=0.000> get <sil=0.000> the <sil=0.000> coefficients <sil=0.000> like <sil=0.000> this <sil=2.000> .PERIOD  Now <sil=0.000> given <sil=0.000> any
x <sil=1.000> ,COMMA  I <sil=0.000> give <sil=0.000> x prime <sil=0.000> then <sil=0.000> from <sil=0.000> that <sil=0.000> equation <sil=0.000> I can <sil=0.000> straight <sil=0.000> way <sil=0.000> find <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> y a <sil=0.000> x prime <sil=0.000> plus <sil=0.000> c <sil=1.000> ,COMMA 
right <sil=0.228> ?QUESTIONMARK  That s <sil=0.000> straight <sil=0.000> forward <sil=1.000> ,COMMA  but <sil=0.000> the <sil=0.000> problem <sil=0.000> is <sil=0.000> that <sil=0.000> often <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> only <sil=0.000> 2 points <sil=1.000> ,COMMA  but <sil=0.000> the <sil=0.000> points
are <sil=0.000> rather <sil=0.000> distributed <sil=0.000> as <sil=0.000> I was <sil=0.000> showing <sil=0.000> in <sil=0.000> the <sil=0.000> earlier <sil=0.000> one <sil=0.000> like <sil=0.000> this <sil=2.000> .PERIOD  Where <sil=0.000> I do <sil=0.000> not <sil=0.000> get <sil=0.000> an <sil=0.000> exact
line <sil=0.354> ;SEMICOLON  that <sil=0.000> is <sil=0.000> cutting <sil=0.000> through <sil=0.000> all <sil=0.000> the <sil=0.000> points <sil=2.000> .PERIOD  Here <sil=0.000> I will <sil=0.000> try <sil=0.000> to <sil=0.000> minimise <sil=0.000> the <sil=0.000> error <sil=0.000> and <sil=0.000> I will <sil=0.000> choose
such <sil=0.000> a line <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  when <sil=0.000> I choose <sil=0.000> such <sil=0.000> a line <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> chosen <sil=0.000> an <sil=0.000> equation <sil=2.000> .PERIOD  Therefore <sil=1.000> ,COMMA  again <sil=0.000> from
the <sil=0.000> linear <sil=0.000> equation <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> y for <sil=0.000> any <sil=0.000> given <sil=0.000> x <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> approach <sil=0.000> is <sil=0.000> known <sil=0.000> as
linear <sil=0.000> interpolation <sil=0.354> ;SEMICOLON  however <sil=1.000> ,COMMA  the <sil=0.000> linear <sil=0.000> interpolation <sil=0.000> often <sil=0.000> as <sil=0.000> you <sil=0.000> can <sil=0.000> see <sil=0.000> the <sil=0.000> error <sil=0.000> will <sil=0.000> be <sil=0.000> there <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  people <sil=0.000> try <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> more <sil=0.000> accurate <sil=0.000> solutions <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  first <sil=0.000> of <sil=0.000> all <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=0.000> what <sil=0.000> is <sil=0.000> linear
interpolation <sil=1.000> ,COMMA  the <sil=0.000> basic <sil=0.000> idea <sil=0.000> is <sil=0.000> very <sil=0.000> simple <sil=0.000> we <sil=0.000> try <sil=0.000> to <sil=0.000> fit <sil=0.000> in <sil=0.000> the <sil=0.000> best <sil=0.000> possible <sil=0.000> straight <sil=0.000> line <sil=1.000> ,COMMA  through
all <sil=0.000> the <sil=0.000> points <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> the <sil=0.000> error <sil=0.000> is <sil=0.000> minimised <sil=1.000> ,COMMA  total <sil=0.000> error <sil=0.000> is <sil=0.000> minimised <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  one <sil=0.000> way <sil=0.000> is <sil=0.000> to <sil=0.000> minimise <sil=0.000> the <sil=0.000> sum <sil=0.000> of <sil=0.000> the <sil=0.000> squares <sil=0.000> or <sil=0.000> there <sil=0.000> could <sil=0.000> be <sil=0.000> some <sil=0.000> other <sil=0.000> measures <sil=0.000> you
can <sil=0.000> take <sil=0.000> for <sil=0.000> error <sil=1.000> ,COMMA  that <sil=0.000> should <sil=0.000> be <sil=0.000> minimised <sil=0.000> so <sil=1.000> ,COMMA  you <sil=0.000> get <sil=0.000> a line <sil=0.000> to <sil=0.000> your <sil=0.000> satisfaction <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  once <sil=0.000> you
get <sil=0.000> a line <sil=0.000> to <sil=0.000> your <sil=0.000> satisfaction <sil=1.000> ,COMMA  you <sil=0.000> know <sil=0.000> the <sil=0.000> equation <sil=0.000> of <sil=0.000> the <sil=0.000> line <sil=2.000> .PERIOD  Therefore <sil=1.000> ,COMMA  given <sil=0.000> any <sil=0.000> x you <sil=0.000> can
find <sil=0.000> the <sil=0.000> corresponding <sil=0.000> y <sil=2.000> .PERIOD  Now <sil=0.000> fitting <sil=0.000> this <sil=0.000> line <sil=0.000> always <sil=1.000> ,COMMA  the <sil=0.000> there <sil=0.000> may <sil=0.000> be <sil=0.000> situations <sil=0.000> where <sil=0.000> the
points <sil=0.000> are <sil=0.000> distributed <sil=0.000> in <sil=0.000> such <sil=0.000> a way <sil=0.000> for <sil=0.000> example <sil=0.000> points <sil=0.000> are <sil=0.000> something <sil=0.000> like <sil=0.000> this <sil=1.000> ,COMMA  all <sil=0.000> right <sil=1.000> ,COMMA  is <sil=0.000> very
difficult <sil=0.000> to <sil=0.000> find <sil=0.000> the <sil=0.000> line <sil=0.000> over <sil=0.000> here <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  often <sil=0.000> I I <sil=0.000> would <sil=0.000> like <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> a curve <sil=1.000> ,COMMA  or <sil=0.000> maybe <sil=0.000> another <sil=0.000> curve <sil=0.000> even <sil=0.000> better <sil=1.000> ,COMMA  that <sil=0.000> can <sil=0.000> be <sil=0.000> that
goes <sil=0.000> through <sil=0.000> these <sil=0.000> points <sil=0.000> like <sil=0.000> this <sil=1.000> ,COMMA  where <sil=0.000> I have <sil=0.000> got <sil=0.000> errors <sil=1.000> ,COMMA  but <sil=0.000> I am <sil=0.000> trying <sil=0.000> to <sil=0.000> fit <sil=0.000> in <sil=0.000> a curve <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
that <sil=0.000> is <sil=0.000> not <sil=0.000> a line <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> not <sil=0.000> a linear <sil=0.000> interpolation <sil=1.000> ,COMMA  where <sil=0.000> are <sil=0.000> further <sil=0.000> extensions <sil=0.000> like <sil=0.000> quadratic
interpolation <sil=1.000> ,COMMA  spline <sil=0.000> interpolation <sil=1.000> ,COMMA  cubic <sil=0.000> spline <sil=0.000> and <sil=0.000> all <sil=0.000> those <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> better <sil=0.000> to <sil=0.000> know <sil=0.000> the <sil=0.000> names <sil=1.000> ,COMMA 
spline <sil=0.000> interpolation <sil=1.000> ,COMMA  quadratic <sil=0.000> interpolation <sil=1.000> ,COMMA  where <sil=0.000> I want <sil=0.000> to <sil=0.000> fit <sil=0.000> in <sil=0.000> a quadratic <sil=0.000> curve <sil=0.000> etc <sil=2.000> .PERIOD 

But <sil=0.000> today <sil=0.000> we <sil=0.000> will <sil=0.000> discuss <sil=0.000> another <sil=0.000> interpolation <sil=0.000> technique <sil=0.000> which <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> LaGrange
interpolation <sil=1.000> ,COMMA  in <sil=0.000> the <sil=0.000> name <sil=0.000> of <sil=0.000> the <sil=0.000> mathematician <sil=0.000> who <sil=0.000> invented <sil=0.000> it <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> have <sil=0.000> a look <sil=0.000> at <sil=0.000> the
lagrange <sil=0.000> interpolation <sil=2.000> .PERIOD 

Interpolation <sil=0.000> as <sil=0.000> you <sil=0.000> have <sil=0.000> understood <sil=0.000> is <sil=0.000> given <sil=0.000> a set <sil=0.000> of <sil=0.000> k plus <sil=0.000> 1 data <sil=0.000> points - x <sil=0.000> 0 <sil=1.000> ,COMMA  y <sil=0.000> 0 <sil=1.000> ,COMMA  x <sil=0.000> 1 <sil=1.000> ,COMMA  y <sil=0.000> 1 <sil=1.000> ,COMMA  x <sil=0.000> 2 <sil=1.000> ,COMMA  y <sil=0.000> 2 like <sil=0.000> that <sil=0.000> up <sil=0.000> to <sil=0.000> x k <sil=1.000> ,COMMA <sil=0.000> y k <sil=1.000> ,COMMA  so <sil=0.000> many <sil=0.000> data <sil=0.000> points <sil=0.000> are <sil=0.000> given <sil=2.000> .PERIOD  The <sil=0.000> LaGrange <sil=0.000> polynomial <sil=0.000> is <sil=0.000> this - I
have <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> for <sil=0.000> a particular <sil=0.000> x <sil=1.000> ,COMMA  x <sil=0.000> minus <sil=0.000> xn <sil=0.000> divided <sil=0.000> by <sil=0.000> xj <sil=0.000> minus <sil=0.000> xm <sil=1.000> ,COMMA  where <sil=0.000> m is <sil=0.000> varying <sil=0.000> from
0 <sil=0.000> to <sil=0.000> k <sil=2.000> .PERIOD  For <sil=0.000> all <sil=0.000> these <sil=0.000> m is <sil=0.000> varying <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  x <sil=0.000> 0 <sil=1.000> ,COMMA  x <sil=0.000> 1 <sil=1.000> ,COMMA  x <sil=0.000> 2 <sil=1.000> ,COMMA  x <sil=0.000> 3 for <sil=0.000> all <sil=0.000> these <sil=0.000> I will <sil=0.000> do <sil=0.000> that <sil=0.000> and <sil=0.000> xj <sil=0.000> minus
xm <sil=1.000> ,COMMA  where <sil=0.000> j is <sil=0.000> for <sil=0.000> a particular <sil=0.000> LaGrange <sil=0.000> interpolation <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  you <sil=0.000> see <sil=0.000> it <sil=0.000> is <sil=0.000> for <sil=0.000> l 1 <sil=0.000> x it <sil=0.000> will <sil=0.000> be <sil=0.000> x minus <sil=0.000> x 0 <sil=0.000> by <sil=0.000> x 1 <sil=0.000> minus <sil=0.000> x 0  <sil=1.000> ,COMMA  x <sil=0.000> minus <sil=0.000> x 0 <sil=0.000> by <sil=0.000> x 1 <sil=0.000> minus <sil=0.000> x 0 <sil=1.000> ,COMMA 
like <sil=0.000> that <sil=0.000> it <sil=0.000> will <sil=0.000> go <sil=0.000> on <sil=1.000> ,COMMA  all <sil=0.000> right <sil=1.000> ,COMMA  so <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> the <sil=0.000> LaGrange <sil=0.000> polynomial <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  using <sil=0.000> this <sil=0.000> polynomial <sil=0.000> let
us <sil=0.000> see <sil=0.000> how <sil=0.000> it <sil=0.000> works <sil=1.000> ,COMMA  just <sil=0.000> to <sil=0.000> give <sil=0.000> you <sil=0.000> an <sil=0.000> example <sil=2.000> .PERIOD 

I <sil=0.000> have <sil=0.000> reproduced <sil=0.000> that <sil=0.000> polynomial <sil=1.000> ,COMMA  that <sil=0.000> I had <sil=0.000> shown <sil=0.000> in <sil=0.000> the <sil=0.000> earlier <sil=0.000> slide <sil=0.000> here <sil=0.000> again <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> say
this <sil=2.000> .PERIOD  Now <sil=0.000> suppose <sil=0.000> I have <sil=0.000> got <sil=0.000> the <sil=0.000> points <sil=0.000> given - look <sil=0.000> here <sil=1.000> ,COMMA  the <sil=0.000> points <sil=0.000> at <sil=0.000> a given <sil=0.000> are <sil=0.000> for <sil=0.000> x value <sil=0.000> 1 <sil=1.000> ,COMMA 
fx <sil=0.000> is <sil=0.000> 1 <sil=2.000> .PERIOD  For <sil=0.000> x value <sil=0.000> 2 <sil=1.000> ,COMMA  fx <sil=0.000> is <sil=0.000> 4 <sil=1.000> ,COMMA  3 <sil=0.000> and <sil=0.000> this <sil=0.000> 9 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> to <sil=0.000> fit <sil=0.000> in <sil=0.000> a polynomial <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  my <sil=0.000> polynomial <sil=0.000> is
Lx <sil=1.000> ,COMMA  now <sil=0.000> each <sil=0.000> term <sil=0.000> of <sil=0.000> this <sil=0.000> is <sil=0.000> one <sil=0.000> lx <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> l 1 <sil=0.000> x <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> l 2 <sil=0.000> x <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> l 3 <sil=0.000> x <sil=1.000> ,COMMA  like <sil=0.000> that <sil=0.000> ok <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you
see <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> x is <sil=0.000> 1 <sil=1.000> ,COMMA  1 <sil=0.000> times <sil=0.000> x minus <sil=0.000> x m <sil=2.000> .PERIOD  M <sil=0.000> will <sil=0.000> be <sil=0.000> something <sil=0.000> that <sil=0.000> would <sil=0.000> be <sil=0.000> not <sil=0.000> the <sil=0.000> same <sil=0.000> as <sil=0.000> j <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> I have <sil=0.000> got <sil=0.000> the <sil=0.000> 3 points <sil=0.000> so <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> not <sil=0.000> take <sil=0.000> this <sil=0.000> 1 <sil=1.000> ,COMMA  x <sil=0.000> minus <sil=0.000> 2 divided <sil=0.000> by <sil=0.000> 1 minus <sil=0.000> 2
times <sil=0.000> the <sil=0.000> second <sil=0.000> term <sil=0.000> x minus <sil=0.000> 3 divided <sil=0.000> by <sil=0.000> 1 minus <sil=0.000> 3 plus <sil=0.000> 4 now <sil=0.000> I am <sil=0.000> taking <sil=0.000> this <sil=0.000> one <sil=0.000> so <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> 4
and <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> case <sil=1.000> ,COMMA  I <sil=0.000> leave <sil=0.000> out <sil=0.000> 2 <sil=1.000> ,COMMA  my <sil=0.000> x j <sil=0.000> is <sil=0.000> now <sil=0.000> 2 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  x <sil=0.000> minus <sil=0.000> 1( I <sil=0.000> will <sil=0.000> not <sil=0.000> take <sil=0.000> x minus <sil=0.000> 2 here <sil=2.000> .PERIOD 
Because <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=0.000> m not <sil=0.000> equal <sil=0.000> to <sil=0.000> j <sil=2.000> .PERIOD <sil=0.000> So <sil=1.000> ,COMMA  for <sil=0.000> the <sil=0.000> other <sil=0.000> x s <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> selected <sil=0.000> this <sil=0.000> row <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> only
concentrate <sil=0.000> on <sil=0.000> the <sil=0.000> other <sil=0.000> rows) divided <sil=0.000> by <sil=0.000> 2 minus <sil=0.000> 1 into <sil=0.000> x minus <sil=0.000> 3 the <sil=0.000> other <sil=0.000> row <sil=0.000> divided <sil=0.000> by <sil=0.000> 2
minus <sil=0.000> 3 <sil=2.000> .PERIOD  Here <sil=0.000> I take <sil=0.000> 9 - this <sil=0.000> value <sil=0.000> and <sil=0.000> I am <sil=0.000> taking <sil=0.000> this <sil=0.000> row <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  so <sil=1.000> ,COMMA  now <sil=0.000> I am <sil=0.000> taking <sil=0.000> this <sil=0.000> row <sil=1.000> ,COMMA  right <sil=0.228> ?QUESTIONMARK  I <sil=0.000> have <sil=0.000> taken <sil=0.000> 9 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  x <sil=0.000> minus <sil=0.000> 1 by <sil=0.000> 3 minus <sil=0.000> 1 <sil=1.000> ,COMMA  x <sil=0.000> minus <sil=0.000> 2
by <sil=0.000> 3 minus <sil=0.000> 2 <sil=2.000> .PERIOD  If <sil=0.000> I solve <sil=0.000> this <sil=0.000> I am <sil=0.000> getting <sil=0.000> a polynomial <sil=0.000> x square <sil=2.000> .PERIOD  Possibly <sil=0.000> you <sil=0.000> can <sil=0.000> see <sil=0.000> that <sil=0.000> is <sil=0.000> a
perfect <sil=0.000> fit <sil=0.000> with <sil=0.000> the <sil=0.000> given <sil=0.000> data <sil=0.000> points - x <sil=0.000> 1 <sil=1.000> ,COMMA  fx <sil=0.000> is <sil=0.000> x square <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> 1 <sil=1.000> ,COMMA  2 <sil=0.000> it <sil=0.000> is <sil=0.000> x square <sil=1.000> ,COMMA  4 <sil=1.000> ,COMMA  3 <sil=0.000> it <sil=0.000> is <sil=0.000> x
squared <sil=0.000> 9 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> in <sil=0.000> this <sil=0.000> case <sil=1.000> ,COMMA  there <sil=0.000> is <sil=0.000> no <sil=0.000> it <sil=0.000> is <sil=0.000> absolutely <sil=0.000> a perfect <sil=0.000> fit  <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> how <sil=0.000> I get <sil=0.000> the
polynomial <sil=1.000> ,COMMA  all <sil=0.000> right <sil=0.228> ?QUESTIONMARK  Let <sil=0.000> us <sil=0.000> try <sil=0.000> once <sil=0.000> again <sil=2.000> .PERIOD  For <sil=0.000> these <sil=0.000> data <sil=0.000> value <sil=1.000> ,COMMA  for <sil=0.000> x 0 <sil=0.000> equal <sil=0.000> to <sil=0.000> 1 <sil=1.000> ,COMMA <sil=0.000> the <sil=0.000> fx <sil=0.000> is <sil=0.000> 1 <sil=1.000> ,COMMA 
for <sil=0.000> x equal <sil=0.000> to <sil=0.000> 2 it <sil=0.000> is <sil=0.000> 8 <sil=1.000> ,COMMA  for <sil=0.000> x equal <sil=0.000> to <sil=0.000> 3 it <sil=0.000> is <sil=0.000> 27 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  obviously <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> see <sil=0.000> it <sil=0.000> is <sil=0.000> no <sil=0.000> longer <sil=0.000> x square <sil=1.000> ,COMMA  all <sil=0.000> right <sil=0.228> ?QUESTIONMARK  It <sil=0.000> is <sil=0.000> not <sil=0.000> also <sil=0.000> x cube <sil=1.000> ,COMMA  because <sil=0.000> here <sil=0.000> it <sil=0.000> is <sil=0.000> cube <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> matching <sil=0.000> the <sil=0.000> cube <sil=0.000> it <sil=0.000> is <sil=0.000> actually <sil=0.000> x cube <sil=1.000> ,COMMA  right <sil=0.228> ?QUESTIONMARK  But <sil=0.000> let <sil=0.000> us <sil=0.000> try <sil=0.000> to <sil=0.000> fit <sil=0.000> in <sil=0.000> a polynomial
here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> that <sil=0.000> polynomial <sil=0.000> using <sil=0.000> the <sil=0.000> LaGrange <sil=0.000> method <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> first <sil=0.000> check <sil=0.000> one <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am
taking <sil=0.000> first <sil=0.000> row <sil=1.000> ,COMMA  taking <sil=0.000> this <sil=0.000> value <sil=0.000> one <sil=0.000> here <sil=1.000> ,COMMA  then <sil=0.000> x minus <sil=0.000> 2 <sil=1.000> ,COMMA  1 <sil=0.000> minus <sil=0.000> 2 <sil=2.000> .PERIOD  Times <sil=0.000> x minus <sil=0.000> 3 <sil=1.000> ,COMMA  1 <sil=0.000> minus
3 <sil=0.000> plus <sil=0.000> next <sil=0.000> time <sil=0.000> I take <sil=0.000> the <sil=0.000> second <sil=0.000> row <sil=2.000> .PERIOD  8 <sil=0.000> times <sil=0.000> x minus <sil=0.000> 1 divided <sil=0.000> by <sil=0.000> 2 minus <sil=0.000> 1 <sil=1.000> ,COMMA  because <sil=0.000> here <sil=0.000> it <sil=0.000> is <sil=0.000> the <sil=0.000> value <sil=0.000> is <sil=0.000> 2 <sil=2.000> .PERIOD  For <sil=0.000> the <sil=0.000> third <sil=0.000> row <sil=0.000> it <sil=0.000> will <sil=0.000> be <sil=0.000> again <sil=0.000> x minus <sil=0.000> 1 <sil=1.000> ,COMMA  3 <sil=0.000> minus <sil=0.000> 1 <sil=1.000> ,COMMA  x <sil=0.000> minus <sil=0.000> 2  <sil=1.000> ,COMMA  6 <sil=0.000> minus <sil=0.000> 2 <sil=2.000> .PERIOD 

By <sil=0.000> doing <sil=0.000> this <sil=0.000> I am <sil=0.000> not <sil=0.000> getting <sil=0.000> x cube <sil=0.000> which <sil=0.000> would <sil=0.000> be <sil=0.000> a perfect <sil=0.000> fit <sil=1.000> ,COMMA  but <sil=0.000> I am <sil=0.000> getting <sil=0.000> a close
enough <sil=0.000> polynomial <sil=0.000> which <sil=0.000> is <sil=0.000> 6 x <sil=0.000> square <sil=0.000> minus <sil=0.000> 11 <sil=0.000> x plus <sil=0.000> 6 <sil=1.000> ,COMMA  which <sil=0.000> will <sil=0.000> be <sil=0.000> approximating <sil=0.000> the <sil=0.000> cube
function <sil=0.000> very <sil=0.000> closely <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> see <sil=0.000> that <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> not <sil=0.000> that <sil=0.000> LaGrange <sil=0.000> polynomial <sil=0.000> will <sil=0.000> always <sil=0.000> give
you <sil=0.000> the <sil=0.000> perfect <sil=0.000> fit <sil=1.000> ,COMMA  but <sil=0.000> it <sil=0.000> gives <sil=0.000> you <sil=0.000> a very <sil=0.000> close <sil=0.000> fit <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> what <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> LaGrange

interpolation <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> I want <sil=0.000> to <sil=0.000> write <sil=0.000> a program <sil=0.000> and <sil=0.000> try <sil=0.000> to <sil=0.000> solve <sil=0.000> it <sil=1.000> ,COMMA  I <sil=0.000> left <sil=0.000> to <sil=0.000> implement <sil=0.000> a function <sil=1.000> ,COMMA  I
have <sil=0.000> to <sil=0.000> write <sil=0.000> a function <sil=0.000> that <sil=0.000> will <sil=0.000> implement <sil=0.000> this <sil=0.000> or <sil=0.000> this <sil=1.000> ,COMMA  right <sil=0.228> ?QUESTIONMARK 

Let <sil=0.000> us <sil=0.000> see <sil=0.000> how <sil=0.000> we <sil=0.000> can <sil=0.000> do <sil=0.000> that <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> an <sil=0.000> algorithm <sil=1.000> ,COMMA  scan <sil=0.000> the <sil=0.000> number <sil=0.000> of <sil=0.000> data <sil=0.000> available <sil=0.000> for <sil=0.000> x
and <sil=0.000> y values <sil=2.000> .PERIOD  Now <sil=0.000> here <sil=0.000> there <sil=0.000> is <sil=0.000> the <sil=0.000> how <sil=0.000> many <sil=0.000> data <sil=0.000> points <sil=0.228> ?QUESTIONMARK  This <sil=0.000> is <sil=0.000> telling <sil=0.000> how <sil=0.000> many <sil=0.000> data <sil=0.000> points <sil=1.000> ,COMMA 
you <sil=0.000> are <sil=0.000> finding <sil=0.000> the <sil=0.000> data <sil=2.000> .PERIOD  Now <sil=0.000> here <sil=0.000> loop <sil=0.000> for <sil=0.000> i equal <sil=0.000> to <sil=0.000> number <sil=0.000> of <sil=0.000> data <sil=0.000> factor <sil=1.000> ,COMMA  then <sil=0.000> here <sil=0.000> you <sil=0.000> are
computing <sil=0.000> this <sil=2.000> .PERIOD  Here <sil=0.000> you <sil=0.000> see <sil=0.000> what <sil=0.000> we <sil=0.000> are <sil=0.000> trying <sil=0.000> to <sil=0.000> do <sil=0.228> ?QUESTIONMARK  At <sil=0.000> this <sil=0.000> point <sil=0.000> we <sil=0.000> have <sil=0.000> just <sil=0.000> read <sil=0.000> the <sil=0.000> data <sil=1.000> ,COMMA 
and <sil=0.000> here <sil=0.000> in <sil=0.000> a loop <sil=0.000> we <sil=0.000> are <sil=0.000> trying <sil=0.000> to <sil=0.000> compute <sil=1.000> ,COMMA  here <sil=0.000> we <sil=0.000> are <sil=0.000> finding <sil=0.000> the <sil=0.000> sum <sil=2.000> .PERIOD 

But <sil=0.000> here <sil=0.000> in <sil=0.000> the <sil=0.000> loop <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> finding <sil=0.000> the <sil=0.000> factor <sil=0.000> so <sil=1.000> ,COMMA  if <sil=0.000> you <sil=0.000> go <sil=0.000> to <sil=0.000> the <sil=0.000> earlier <sil=0.000> the <sil=0.000> slide <sil=1.000> ,COMMA  you <sil=0.000> will <sil=0.000> find
that <sil=0.000> I have <sil=0.000> got <sil=0.000> these <sil=0.000> are <sil=0.000> my <sil=0.000> factors <sil=1.000> ,COMMA  right <sil=0.228> ?QUESTIONMARK  I <sil=0.000> am <sil=0.000> finding <sil=0.000> each <sil=0.000> of <sil=0.000> these <sil=0.000> factors <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> multiplying
them <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> a factor <sil=1.000> ,COMMA  this <sil=0.000> whole <sil=0.000> thing <sil=0.000> is <sil=0.000> a factor <sil=1.000> ,COMMA  and <sil=0.000> then <sil=0.000> I multiply <sil=0.000> that <sil=0.000> with <sil=0.000> the <sil=0.000> coefficient <sil=0.000> and
add <sil=0.000> them <sil=0.000> up <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> doing <sil=0.000> the <sil=0.000> summation <sil=0.000> at <sil=0.000> the <sil=0.000> end <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> you <sil=0.000> see <sil=0.000> that <sil=0.000> I am <sil=0.000> taking <sil=0.000> the
factor <sil=0.000> then <sil=0.000> I am <sil=0.000> taking <sil=0.000> whatever <sil=0.000> is <sil=0.000> the <sil=0.000> value (this <sil=0.000> part <sil=0.000> you <sil=0.000> can <sil=0.000> yourself <sil=0.000> compute)

The <sil=0.000> key <sil=0.000> part <sil=0.000> is <sil=0.000> computation <sil=0.000> of <sil=0.000> the <sil=0.000> factor <sil=0.000> part <sil=1.000> ,COMMA  where <sil=0.000> I am <sil=0.000> showing <sil=0.000> this <sil=0.000> part <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> see <sil=0.000> that <sil=0.000> for
I <sil=0.000> 0 to <sil=0.000> data <sil=1.000> ,COMMA  i <sil=0.000> plus <sil=0.000> plus <sil=0.000> I am <sil=0.000> initially <sil=0.000> a factor <sil=0.000> is <sil=0.000> one <sil=2.000> .PERIOD 

Because <sil=0.000> I am <sil=0.000> multiplying <sil=0.000> that <sil=1.000> ,COMMA  then <sil=0.000> if <sil=0.000> i is <sil=0.000> not <sil=0.000> equal <sil=0.000> to <sil=0.000> j <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> take <sil=0.000> factor <sil=0.000> times <sil=0.000> the <sil=0.000> value <sil=0.000> minus
the <sil=0.000> data <sil=2.000> .PERIOD  So <sil=0.000> then <sil=0.000> ultimately <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> printing <sil=0.000> the <sil=0.000> coefficient <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> translate <sil=0.000> that <sil=0.000> into <sil=0.000> in <sil=0.000> the
form <sil=0.000> of <sil=0.000> a c <sil=0.000> function <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> the <sil=0.000> basic <sil=0.000> idea <sil=0.000> of <sil=0.000> LaGrange <sil=0.000> interpolation <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> similarly <sil=0.000> write
programs <sil=0.000> for <sil=0.000> linear <sil=0.000> interpolation <sil=1.000> ,COMMA  and <sil=0.000> other <sil=0.000> interpretation <sil=0.000> techniques <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> point <sil=0.000> of <sil=0.000> this <sil=0.000> course

is <sil=0.000> not <sil=0.000> because <sil=0.000> I assume <sil=0.000> that <sil=0.000> you <sil=0.000> now <sil=0.000> know <sil=0.000> how <sil=0.000> to <sil=0.000> do <sil=0.000> programming <sil=0.000> and <sil=0.000> these <sil=0.000> are <sil=0.000> simple <sil=0.000> loop
type <sil=0.000> of <sil=0.000> programming <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  you <sil=0.000> will <sil=0.000> be <sil=0.000> able <sil=0.000> to <sil=0.000> do <sil=0.000> that <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  whenever <sil=0.000> you <sil=0.000> want <sil=0.000> to <sil=0.000> solve <sil=0.000> apply <sil=0.000> some <sil=0.000> numerical <sil=0.000> methods <sil=1.000> ,COMMA 
you <sil=0.000> will <sil=0.000> have <sil=0.000> to <sil=0.000> first <sil=0.000> look <sil=0.000> at <sil=0.000> the <sil=0.000> technique <sil=0.000> then <sil=0.000> try <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> expression <sil=0.000> and <sil=0.000> you <sil=0.000> will <sil=0.000> have
to <sil=0.000> write <sil=0.000> an <sil=0.000> algorithm <sil=0.000> so <sil=0.000> that <sil=0.000> you <sil=0.000> can <sil=0.000> solve <sil=0.000> it <sil=0.000> ok <sil=2.000> .PERIOD  In <sil=0.000> the <sil=0.000> next <sil=0.000> lecture <sil=0.000> we <sil=0.000> will <sil=0.000> discuss <sil=0.000> 2 other <sil=0.000> very
interesting <sil=0.000> techniques <sil=0.000> for <sil=0.000> integration <sil=0.000> and <sil=0.000> differential <sil=0.000> equation <sil=0.000> solver <sil=2.000> .PERIOD 

Thank <sil=0.000> you <sil=2.000> .PERIOD 

In <sil=0.000> this <sil=0.000> lecture <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> be <sil=0.000> looking <sil=0.000> at <sil=0.000> another <sil=0.000> numerical <sil=0.000> method <sil=0.000> technique <sil=0.354> ;SEMICOLON  we <sil=0.000> will <sil=0.000> actually <sil=0.000> look
at <sil=0.000> two <sil=2.000> .PERIOD  First <sil=1.000> ,COMMA  we <sil=0.000> look <sil=0.000> at <sil=0.000> integration <sil=1.000> ,COMMA  how <sil=0.000> we <sil=0.000> can <sil=0.000> integrate <sil=0.000> a function <sil=1.000> ,COMMA  there <sil=0.000> are <sil=0.000> several <sil=0.000> methods
for <sil=0.000> doing <sil=0.000> that <sil=2.000> .PERIOD  We <sil=0.000> will <sil=0.000> look <sil=0.000> at <sil=0.000> only <sil=0.000> one <sil=0.000> method <sil=0.000> and <sil=0.000> you <sil=0.000> can <sil=0.000> after <sil=0.000> that <sil=0.354> ;SEMICOLON  you <sil=0.000> can <sil=0.000> look <sil=0.000> up <sil=0.000> at <sil=0.000> for
other <sil=0.000> methods <sil=2.000> .PERIOD  Next <sil=0.000> will <sil=0.000> proceed <sil=0.000> to <sil=0.000> see <sil=1.000> ,COMMA  how <sil=0.000> ordinary <sil=0.000> differential <sil=0.000> equation <sil=0.000> can <sil=0.000> be <sil=0.000> solved <sil=0.000> using
numerical <sil=0.000> techniques <sil=0.000> using <sil=0.000> program <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  first <sil=0.000> of <sil=0.000> all <sil=0.000> let <sil=0.000> us <sil=0.000> start <sil=0.000> with <sil=0.000> integration <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  all <sil=0.000> of <sil=0.000> you <sil=0.000> know <sil=0.354> ;SEMICOLON  what <sil=0.000> integration <sil=0.000> means <sil=0.000> given <sil=0.000> a particular <sil=0.000> function <sil=0.000> integration <sil=0.000> is <sil=0.000> say <sil=0.000> I
have <sil=0.000> got <sil=0.000> a function <sil=0.000> like <sil=0.000> this <sil=0.000> and <sil=0.000> I want <sil=0.000> to <sil=0.000> integrate <sil=2.000> .PERIOD  Suppose <sil=0.000> this <sil=0.000> function <sil=0.000> is <sil=0.000> f x <sil=0.000> and <sil=0.000> I want <sil=0.000> to
integrate <sil=0.000> it <sil=0.000> within <sil=0.000> the <sil=0.000> range <sil=0.000> a and <sil=0.000> b <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> write <sil=0.000> that <sil=0.000> as <sil=0.000> integral <sil=0.000> a to <sil=0.000> b of <sil=0.000> f x <sil=0.000> and <sil=0.000> you <sil=0.000> also <sil=0.000> know
that <sil=0.000> this <sil=0.000> integration <sil=0.000> actually <sil=0.000> means <sil=0.000> the <sil=0.000> area <sil=0.000> that <sil=0.000> is <sil=0.000> under <sil=0.000> this <sil=0.000> curve <sil=2.000> .PERIOD  This <sil=0.000> value <sil=0.000> is <sil=0.000> the <sil=0.000> integration <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> look <sil=0.000> at <sil=0.000> how <sil=0.000> we <sil=0.000> can <sil=0.000> solved <sil=0.000> this <sil=0.000> problem <sil=2.000> .PERIOD  The <sil=0.000> simplest <sil=0.000> a very <sil=0.000> simple <sil=0.000> method <sil=0.000> is <sil=0.000> a
trapezoidal <sil=0.000> method <sil=0.000> which <sil=0.000> will <sil=0.000> discuss <sil=0.000> here <sil=2.000> .PERIOD 

Let <sil=0.000> me <sil=0.000> go <sil=0.000> back <sil=0.000> to <sil=0.000> this <sil=0.000> this <sil=0.000> case <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> see <sil=0.000> that <sil=0.000> I can <sil=0.000> approximate <sil=0.000> this <sil=0.000> curve <sil=0.000> in <sil=0.000> a very
simplistic <sil=0.000> case <sil=0.000> using <sil=0.000> a trapezoid <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> a trapezoid <sil=0.000> here <sil=1.000> ,COMMA  let <sil=0.000> me <sil=0.000> draw <sil=0.000> in <sil=0.000> blue <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the
area <sil=0.000> under <sil=0.000> this <sil=0.000> trapezoid <sil=0.000> is <sil=0.000> approximating <sil=0.000> the <sil=0.000> area <sil=0.000> under <sil=0.000> the <sil=0.000> curve <sil=1.000> ,COMMA  but <sil=0.000> that <sil=0.000> is <sil=0.000> becoming <sil=0.000> possible <sil=0.000> here (except <sil=0.000> for <sil=0.000> this <sil=0.000> error) because <sil=0.000> the <sil=0.000> curve <sil=0.000> was <sil=0.000> very <sil=0.000> much <sil=0.000> not <sil=0.000> very <sil=0.000> skewed <sil=0.000> in <sil=0.000> that <sil=0.000> sense <sil=1.000> ,COMMA  but <sil=0.000> if <sil=0.000> the <sil=0.000> curve <sil=0.000> where <sil=0.000> something <sil=0.000> like <sil=0.000> this <sil=2.000> .PERIOD 

If <sil=0.000> it <sil=0.000> was <sil=0.000> something <sil=0.000> like <sil=0.000> this <sil=0.000> and <sil=0.000> I was <sil=0.000> trying <sil=0.000> to <sil=0.000> integrate <sil=0.000> it <sil=0.000> between <sil=0.000> these <sil=0.000> rangers <sil=0.000> then <sil=0.000> if <sil=0.000> I had
fitted <sil=0.000> a trapezoid <sil=0.000> here <sil=1.000> ,COMMA  then <sil=0.000> the <sil=0.000> amount <sil=0.000> of <sil=0.000> error <sil=0.000> would <sil=0.000> be <sil=0.000> much <sil=0.000> more <sil=0.000> because <sil=0.000> I will <sil=0.000> be
committing <sil=0.000> errors <sil=0.000> at <sil=0.000> this <sil=0.000> points <sil=2.000> .PERIOD  I <sil=0.000> am <sil=0.000> not <sil=0.000> considering <sil=0.000> this <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> over <sil=0.000> considering <sil=0.000> this <sil=0.000> points <sil=1.000> ,COMMA  etc <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  the <sil=0.000> error <sil=0.000> will <sil=0.000> be <sil=0.000> more <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> not <sil=0.000> always <sil=0.000> the <sil=0.000> case <sil=0.000> that <sil=0.000> a simple <sil=0.000> trapezoid <sil=1.000> ,COMMA  one <sil=0.000> single
trapezoid <sil=0.000> will <sil=0.000> solve <sil=1.000> ,COMMA  but <sil=0.000> let <sil=0.000> us <sil=0.000> start <sil=0.000> with <sil=0.000> that <sil=0.000> and <sil=0.000> try <sil=0.000> to <sil=0.000> understand <sil=0.000> how <sil=0.000> we <sil=0.000> can <sil=0.000> go <sil=0.000> ahead <sil=0.000> with <sil=0.000> the <sil=0.000> problem <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> area <sil=0.000> under <sil=0.000> the <sil=0.000> curve <sil=0.000> in <sil=0.000> this <sil=0.000> particular <sil=0.000> curve <sil=0.000> as <sil=0.000> you <sil=0.000> can <sil=0.000> see <sil=0.000> here <sil=1.000> ,COMMA  this <sil=0.000> particular <sil=0.000> curve <sil=0.000> that <sil=0.000> has <sil=0.000> gone <sil=0.000> through <sil=0.000> this <sil=0.000> is <sil=0.000> a trapezoid <sil=1.000> ,COMMA  under <sil=0.000> the <sil=0.000> curve <sil=0.000> is <sil=0.000> a trapezoid <sil=2.000> .PERIOD  This <sil=0.000> part <sil=0.000> if <sil=0.000> I assumed <sil=0.000> to <sil=0.000> be <sil=0.000> a trapezoid <sil=0.000> in <sil=0.000> that <sil=0.000> case <sil=0.000> the <sil=0.000> integral <sil=0.000> of <sil=0.000> f x <sil=0.000> d x <sil=0.000> is <sil=0.000> the <sil=0.000> area <sil=0.000> of <sil=0.000> the <sil=0.000> trapezoid <sil=0.000> and <sil=0.000> we <sil=0.000> know <sil=0.000> that <sil=0.000> the <sil=0.000> area <sil=0.000> of <sil=0.000> a trapezoid <sil=0.000> is <sil=0.000> not <sil=0.000> nothing <sil=0.000> but <sil=0.000> half <sil=0.000> the <sil=0.000> sum <sil=0.000> of <sil=0.000> the <sil=0.000> parallel <sil=0.000> sides <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  f <sil=0.000> a plus <sil=0.000> f b <sil=0.000> divided <sil=0.000> by <sil=0.000> the <sil=0.000> height <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  if <sil=0.000> I look <sil=0.000> at <sil=0.000> it <sil=0.000> these <sil=0.000> are <sil=0.000> the <sil=0.000> parallel <sil=0.000> sides <sil=0.000> then <sil=0.000> the <sil=0.000> height <sil=0.000> is <sil=0.000> this - b <sil=0.000> minus <sil=0.000> a <sil=1.000> ,COMMA  this <sil=0.000> amount <sil=1.000> ,COMMA 
right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> a known <sil=0.000> result <sil=0.000> therefore <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> see <sil=0.000> if <sil=0.000> I can <sil=0.000> approximate <sil=0.000> a curve <sil=0.000> by <sil=0.000> a single
trapezoid <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=1.000> ,COMMA  b <sil=0.000> minus <sil=0.000> a times <sil=0.000> f a <sil=1.000> ,COMMA  f <sil=0.000> b plus <sil=0.000> f a <sil=0.000> by <sil=0.000> 2 or <sil=0.000> f a <sil=0.000> plus <sil=0.000> f b <sil=0.000> by <sil=0.000> 2 <sil=1.000> ,COMMA  but <sil=0.000> of <sil=0.000> course <sil=1.000> ,COMMA  we
will <sil=0.000> see <sil=0.000> that <sil=0.000> there <sil=0.000> can <sil=0.000> be <sil=0.000> errors <sil=0.000> due <sil=0.000> to <sil=0.000> this <sil=0.000> approximation <sil=1.000> ,COMMA  but <sil=0.000> this <sil=0.000> is <sil=0.000> a simple <sil=0.000> formula <sil=0.000> which <sil=0.000> we
can <sil=0.000> quickly <sil=0.000> compute <sil=2.000> .PERIOD  It <sil=0.000> is <sil=0.000> very <sil=0.000> easy <sil=0.000> to <sil=0.000> write <sil=0.000> a program <sil=0.000> for <sil=0.000> that <sil=1.000> ,COMMA  you <sil=0.000> have <sil=0.000> got <sil=0.000> a function <sil=0.000> that <sil=0.000> will

compute <sil=0.000> the <sil=0.000> curve <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you <sil=0.000> call <sil=0.000> it <sil=0.000> for <sil=0.000> a and <sil=0.000> call <sil=0.000> it <sil=0.000> for <sil=0.000> b and <sil=0.000> compute <sil=0.000> this <sil=0.000> expression <sil=1.000> ,COMMA  you <sil=0.000> will <sil=0.000> get
the <sil=0.000> integral <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> an <sil=0.000> example <sil=0.000> why <sil=0.000> is <sil=0.000> it <sil=0.000> important <sil=0.000> suppose <sil=0.000> a vertical <sil=0.000> distance <sil=0.000> is <sil=0.000> covered <sil=0.000> by <sil=0.000> a rocket
from <sil=0.000> time <sil=0.000> 8 to <sil=0.000> 30 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  my <sil=0.000> timeline <sil=0.000> is <sil=0.000> from <sil=0.000> 8 seconds <sil=0.000> to <sil=0.000> 30 <sil=0.000> seconds <sil=0.000> is <sil=0.000> given <sil=0.000> by <sil=0.000> this <sil=0.000> formula <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
the <sil=0.000> vertical <sil=0.000> distance <sil=0.000> overall <sil=1.000> ,COMMA  the <sil=0.000> total <sil=0.000> vertical <sil=0.000> distances <sil=0.000> is <sil=0.000> this <sil=0.000> is - a <sil=0.000> complicated <sil=0.000> formula <sil=2.000> .PERIOD  Now
using <sil=0.000> single <sil=0.000> segment <sil=0.000> trapezoidal <sil=0.000> rule <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> try <sil=0.000> to <sil=0.000> find <sil=0.000> the <sil=0.000> distance <sil=0.000> covered <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  we <sil=0.000> know <sil=0.000> for <sil=0.000> 8 and <sil=0.000> for <sil=0.000> 30 <sil=1.000> ,COMMA  if <sil=0.000> I compute <sil=0.000> this <sil=0.000> function (this <sil=0.000> was <sil=0.000> my <sil=0.000> function) <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  for <sil=0.000> f 8 <sil=1.000> ,COMMA  my <sil=0.000> function <sil=0.000> is <sil=0.000> yielding <sil=0.000> this <sil=0.000> value <sil=0.000> and <sil=0.000> for <sil=0.000> f 30 <sil=1.000> ,COMMA  the <sil=0.000> function <sil=0.000> is <sil=0.000> yielding <sil=1.000> ,COMMA  this <sil=0.000> value <sil=2.000> .PERIOD  We
can <sil=0.000> compute <sil=1.000> ,COMMA  using <sil=0.000> your <sil=0.000> calculator <sil=0.000> you <sil=0.000> can <sil=0.000> find <sil=0.000> it <sil=0.000> out <sil=0.000> but <sil=0.000> you <sil=0.000> need <sil=0.000> not <sil=0.000> do <sil=0.000> right <sil=0.000> now <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you
can <sil=0.000> compute <sil=0.000> the <sil=0.000> values <sil=0.000> at <sil=0.000> these <sil=0.000> 2 points <sil=0.000> because <sil=0.000> this <sil=0.000> is <sil=0.000> the <sil=0.000> overall <sil=0.000> function <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> the <sil=0.000> f 8
and <sil=0.000> f 30 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> will <sil=0.000> be <sil=0.000> my <sil=0.000> integral <sil=0.228> ?QUESTIONMARK  My <sil=0.000> integral <sil=0.000> will <sil=0.000> therefore <sil=1.000> ,COMMA  be <sil=0.000> 30 <sil=0.000> minus <sil=0.000> 8 <sil=1.000> ,COMMA  b <sil=0.000> minus <sil=0.000> a  <sil=1.000> ,COMMA  f <sil=0.000> a
plus <sil=0.000> ab <sil=0.000> by <sil=0.000> 2 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> coming <sil=0.000> to <sil=0.000> 11868 <sil=0.000> meter <sil=1.000> ,COMMA  the <sil=0.000> distance <sil=0.000> covered <sil=0.000> is <sil=0.000> this <sil=1.000> ,COMMA  but <sil=0.000> however <sil=1.000> ,COMMA  the <sil=0.000> exact <sil=0.000> value <sil=0.354> ;SEMICOLON  if
you <sil=0.000> computed <sil=0.000> the <sil=0.000> exact <sil=0.000> value <sil=0.000> if <sil=0.000> you <sil=0.000> do <sil=0.000> a detailed <sil=0.000> computation <sil=0.000> will <sil=0.000> be <sil=0.000> 11061 <sil=0.000> meter <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  there <sil=0.000> is
an <sil=0.000> error <sil=0.354> ;SEMICOLON  obviously <sil=1.000> ,COMMA  there <sil=0.000> is <sil=0.000> an <sil=0.000> error <sil=0.000> because <sil=0.000> I have <sil=0.000> approximated <sil=0.000> the <sil=0.000> curve <sil=0.000> using <sil=0.000> a trapezoid <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> see <sil=0.000> how <sil=0.000> great <sil=0.000> is <sil=0.000> the <sil=0.000> error  <sil=2.000> .PERIOD <sil=0.000> So <sil=1.000> ,COMMA  we <sil=0.000> can <sil=0.000> see <sil=0.000> that <sil=0.000> the <sil=0.000> true <sil=0.000> error <sil=0.000> is <sil=0.000> minus <sil=0.000> 807 <sil=0.000> meter <sil=1.000> ,COMMA 
right <sil=0.354> ;SEMICOLON  that <sil=0.000> is <sil=0.000> quite <sil=0.000> significant <sil=0.000> 800 <sil=0.000> meters <sil=0.000> and <sil=0.000> the <sil=0.000> absolute <sil=0.000> relative <sil=0.000> error <sil=0.000> which <sil=0.000> is <sil=0.000> the <sil=0.000> actual <sil=0.000> error
ie <sil=0.000> true <sil=0.000> value <sil=0.000> and <sil=0.000> the <sil=0.000> computed <sil=0.000> value <sil=0.000> and <sil=0.000> divided <sil=0.000> by <sil=0.000> the <sil=0.000> true <sil=0.000> value <sil=0.000> you <sil=0.000> find <sil=0.000> that <sil=0.000> I am <sil=0.000> getting
more <sil=0.000> than <sil=0.000> 7 percent <sil=0.000> error <sil=1.000> ,COMMA  how <sil=0.000> can <sil=0.000> you <sil=0.000> better <sil=0.000> it  <sil=0.228> ?QUESTIONMARK 

So <sil=1.000> ,COMMA  our <sil=0.000> answer <sil=0.000> will <sil=0.000> be <sil=0.000> instead <sil=0.000> of <sil=0.000> fitting <sil=0.000> in <sil=0.000> a single <sil=0.000> trapezoid <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> try <sil=0.000> to <sil=0.000> fit <sil=0.000> in <sil=0.000> more <sil=0.000> than <sil=0.000> one
trapezoid <sil=0.000> here <sil=0.000> like <sil=0.000> something <sil=0.000> like <sil=0.000> this - I <sil=0.000> fit <sil=0.000> in <sil=0.000> one <sil=0.000> trapezoid <sil=0.000> here <sil=1.000> ,COMMA  I <sil=0.000> fit <sil=0.000> in <sil=0.000> another <sil=0.000> trapezoid <sil=0.000> here
and <sil=0.000> hereby <sil=0.000> I can <sil=0.000> approximate <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> minimise <sil=0.000> my <sil=0.000> error <sil=0.000> to <sil=0.000> some <sil=0.000> extent <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.354> ;SEMICOLON  what <sil=0.000> we <sil=0.000> are <sil=0.000> trying <sil=0.000> to <sil=0.000> do <sil=0.000> instead <sil=0.000> of <sil=0.000> taking <sil=0.000> 8 and <sil=0.000> 30 <sil=0.000> and <sil=0.000> fitting <sil=0.000> in <sil=0.000> one <sil=0.000> trapezoid <sil=0.000> for <sil=0.000> the
whole <sil=0.000> thing <sil=0.000> what <sil=0.000> we <sil=0.000> are <sil=0.000> trying <sil=0.000> to <sil=0.000> do <sil=0.000> is <sil=0.000> we <sil=0.000> are <sil=0.000> fitting <sil=0.000> in <sil=0.000> one <sil=0.000> trapezoid <sil=0.000> for <sil=0.000> 8 to <sil=0.000> 19 <sil=0.000> and <sil=0.000> other <sil=0.000> for
19 <sil=0.000> to <sil=0.000> 30 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  again <sil=0.000> using <sil=0.000> the <sil=0.000> same <sil=0.000> formula <sil=0.000> we <sil=0.000> find <sil=0.000> then <sil=0.000> here <sil=0.000> is <sil=0.000> one <sil=0.000> 19 <sil=0.000> to <sil=0.000> 8 to <sil=0.000> 19 <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> the <sil=0.000> integral <sil=0.000> plus <sil=0.000> the <sil=0.000> other <sil=0.000> trapezoid <sil=0.000> is <sil=0.000> giving <sil=0.000> me <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> fitting <sil=0.000> in <sil=0.000> 2 trapezoids <sil=0.000> now <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  if <sil=0.000> I do <sil=0.000> that <sil=0.354> ;SEMICOLON  then <sil=0.000> let <sil=0.000> us <sil=0.000> see <sil=0.000> whether <sil=0.000> the <sil=0.000> result <sil=0.000> is <sil=0.000> being <sil=0.000> bettered <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  I <sil=0.000> compute <sil=0.000> f 8 <sil=0.000> at <sil=0.000> f 30 <sil=0.000> and <sil=0.000> f19 <sil=0.000> and <sil=0.000> compute <sil=0.000> both <sil=0.000> of <sil=0.000> these <sil=0.000> values <sil=1.000> ,COMMA  the <sil=0.000> areas <sil=0.000> under <sil=0.000> the <sil=0.000> curve <sil=0.000> here <sil=0.000> and <sil=0.000> here <sil=0.000> and <sil=0.000> the <sil=0.000> result <sil=0.000> is
11266 <sil=0.000> meters <sil=2.000> .PERIOD  Now <sil=0.000> how <sil=0.000> far <sil=0.000> is <sil=0.000> it <sil=0.000> from <sil=0.000> the <sil=0.000> actual <sil=0.228> ?QUESTIONMARK 

Now <sil=0.000> you <sil=0.000> can <sil=0.000> see <sil=0.000> that <sil=0.000> the <sil=0.000> true <sil=0.000> error <sil=0.000> has <sil=0.000> reduced <sil=0.000> from <sil=0.000> 807 <sil=0.000> meters <sil=0.000> to <sil=0.000> 205 <sil=0.000> meters <sil=2.000> .PERIOD <sil=0.000> So <sil=1.000> ,COMMA  that <sil=0.000> tells <sil=0.000> us
that <sil=0.000> if <sil=0.000> we <sil=0.000> can <sil=0.000> extend <sil=0.000> this <sil=0.000> procedure <sil=0.000> and <sil=0.000> fitting <sil=0.000> more <sil=0.000> and <sil=0.000> smaller <sil=0.000> but <sil=0.000> more <sil=0.000> number <sil=0.000> of <sil=0.000> trapezoids
my <sil=0.000> error <sil=0.000> will <sil=0.000> come <sil=0.000> down <sil=0.000> further <sil=0.000> still <sil=2.000> .PERIOD  (Refer <sil=0.000> Slide <sil=0.000> Time: 09:34)

The <sil=0.000> multiple <sil=0.000> segment <sil=0.000> trapezoidal <sil=0.000> rule <sil=0.354> ;SEMICOLON  therefore <sil=1.000> ,COMMA  is <sil=0.000> that <sil=0.000> we <sil=0.000> divide <sil=0.000> into <sil=0.000> equal <sil=0.000> segments <sil=2.000> .PERIOD  So <sil=0.000> here
is <sil=0.000> one <sil=0.000> trapezoid <sil=0.000> here <sil=0.000> is <sil=0.000> another <sil=0.000> trapezoid <sil=0.000> here <sil=0.000> is <sil=0.000> another <sil=0.000> trapezoid <sil=0.000> and <sil=0.000> here <sil=0.000> is <sil=0.000> another <sil=0.000> trapezoid <sil=2.000> .PERIOD 
I <sil=0.000> am <sil=0.000> getting <sil=0.000> 4 trapezoids <sil=0.000> here <sil=0.000> and <sil=0.000> trying <sil=0.000> to <sil=0.000> formulate <sil=0.000> this <sil=2.000> .PERIOD  I <sil=0.000> can <sil=0.000> do <sil=0.000> that <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the
integral <sil=0.000> is <sil=0.000> this <sil=0.000> whole <sil=0.000> thing <sil=0.000> which <sil=0.000> will <sil=0.000> be <sil=0.000> a sum <sil=0.000> of <sil=0.000> these <sil=0.000> trapezoids <sil=2.000> .PERIOD  Remember <sil=0.000> these <sil=0.000> lines <sil=1.000> ,COMMA  these <sil=0.000> distance <sil=0.000> is <sil=0.000> the <sil=0.000> same <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> dividing <sil=0.000> b minus <sil=0.000> a by <sil=0.000> some <sil=0.000> particular <sil=0.000> value <sil=0.000> n and <sil=0.000> that <sil=0.000> is <sil=0.000> my <sil=0.000> h <sil=2.000> .PERIOD <sil=0.000> So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> h <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> h <sil=1.000> ,COMMA <sil=0.000> this <sil=0.000> is <sil=0.000> h like <sil=0.000> that <sil=0.000> I am <sil=0.000> going <sil=0.000> for <sil=0.000> equidistant <sil=0.000> points <sil=0.000> and <sil=0.000> drawing <sil=0.000> the <sil=0.000> trapezoid <sil=0.000> from <sil=0.000> there <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  therefore <sil=1.000> ,COMMA  if <sil=0.000> I follow <sil=0.000> this <sil=1.000> ,COMMA  as <sil=0.000> is <sil=0.000> shown <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=1.000> ,COMMA  the <sil=0.000> trapezoidal <sil=0.000> rule <sil=0.000> can <sil=0.000> be <sil=0.000> written <sil=0.000> as
integral <sil=0.000> from <sil=0.000> a to <sil=0.000> b is <sil=0.000> sum <sil=0.000> of <sil=0.000> half <sil=0.000> fn <sil=0.000> plus <sil=0.000> fn <sil=0.000> plus <sil=0.000> 1 <sil=0.354> ;SEMICOLON  that <sil=0.000> is <sil=0.000> f a <sil=0.000> plus <sil=0.000> f b <sil=0.000> by <sil=0.000> 2 times <sil=0.000> the <sil=0.000> particular
distance <sil=0.000> that <sil=0.000> is <sil=0.000> there <sil=1.000> ,COMMA  x <sil=0.000> o x <sil=0.000> 1 minus <sil=0.000> a <sil=1.000> ,COMMA  x <sil=0.000> 2 minus <sil=0.000> x 1 <sil=2.000> .PERIOD  Usually <sil=0.000> do <sil=0.000> it <sil=0.000> in <sil=0.000> the <sil=0.000> equidistant <sil=0.000> way <sil=2.000> .PERIOD 

Ok <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  multi <sil=0.000> segment <sil=0.000> trapezoidal <sil=0.000> rule <sil=0.000> is <sil=0.000> therefore <sil=1.000> ,COMMA  an <sil=0.000> integral <sil=0.000> I which <sil=0.000> can <sil=0.000> be <sil=0.000> broken
down <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> simple <sil=2.000> .PERIOD  From <sil=0.000> a to <sil=0.000> a plus <sil=0.000> h <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> have <sil=0.000> f x <sil=0.000> d x <sil=1.000> ,COMMA  a <sil=0.000> plus <sil=0.000> h to <sil=0.000> a plus <sil=0.000> 2 h <sil=0.000> f x <sil=0.000> d x <sil=0.000> plus <sil=0.000> a
plus <sil=0.000> n minus <sil=0.000> 2 h <sil=0.000> to <sil=0.000> a plus <sil=0.000> n minus <sil=0.000> 1 h <sil=0.000> f x <sil=0.000> d x <sil=0.000> a plus <sil=0.000> n minus <sil=0.000> 1 h <sil=0.000> to <sil=0.000> b <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  all <sil=0.000> the <sil=0.000> segment <sil=0.000> serving <sil=0.000> as <sil=0.000> it <sil=0.000> together <sil=2.000> .PERIOD  Applying <sil=0.000> this <sil=0.000> I get <sil=0.000> this <sil=0.000> formula <sil=0.000> b by <sil=0.000> a divided <sil=0.000> by <sil=0.000> 2 n
because <sil=0.000> 2 is <sil=0.000> coming <sil=0.000> n times <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  f <sil=0.000> a plus <sil=0.000> f b <sil=0.000> plus <sil=0.000> 2 into <sil=0.000> f a <sil=0.000> plus <sil=0.000> ih <sil=0.000> because <sil=0.000> that <sil=0.000> is <sil=0.000> coming <sil=0.000> twice
here <sil=0.000> once <sil=0.000> and <sil=0.000> here <sil=0.000> once <sil=1.000> ,COMMA  you <sil=0.000> see <sil=0.000> here <sil=0.000> if <sil=0.000> a plus <sil=0.000> h will <sil=0.000> come <sil=0.000> then <sil=0.000> here <sil=0.000> a plus <sil=0.000> h will <sil=0.000> come <sil=0.000> right  <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  using <sil=0.000> this <sil=0.000> let <sil=0.000> us <sil=0.000> do <sil=0.000> the <sil=0.000> example <sil=0.000> again <sil=0.000> the <sil=0.000> same <sil=0.000> thing <sil=0.000> using <sil=0.000> 2 segment <sil=0.000> Trapezoidal <sil=0.000> rule <sil=1.000> ,COMMA  we
could <sil=0.000> find <sil=0.000> that <sil=0.000> the <sil=0.000> error <sil=0.000> is <sil=0.000> coming <sil=0.000> down <sil=2.000> .PERIOD 

We <sil=0.000> have <sil=0.000> already <sil=0.000> seen <sil=0.000> that <sil=0.000> the <sil=0.000> true <sil=0.000> value <sil=0.000> of <sil=0.000> error <sil=0.000> is <sil=0.000> coming <sil=0.000> down <sil=2.000> .PERIOD 

And <sil=0.000> the <sil=0.000> absolute <sil=0.000> relative <sil=0.000> error <sil=0.000> has <sil=0.000> come <sil=0.000> to <sil=0.000> 1 <sil=2.000> .PERIOD <sil=0.000> 853 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  now <sil=0.000> let <sil=0.000> us <sil=0.000> come <sil=0.000> to <sil=0.000> c programming <sil=1.000> ,COMMA  straightway <sil=0.354> ;SEMICOLON  how <sil=0.000> can <sil=0.000> we <sil=0.000> encode <sil=0.000> it <sil=0.000> using <sil=0.000> a c <sil=0.000> program <sil=1.000> ,COMMA 
you <sil=0.000> see <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> reproducing <sil=0.000> the <sil=0.000> result <sil=0.000> here <sil=0.000> again <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  integral <sil=0.000> of <sil=0.000> f x <sil=0.000> d x <sil=0.000> between <sil=0.000> a and <sil=0.000> b will <sil=0.000> be <sil=0.000> h by <sil=0.000> 2 f <sil=0.000> a plus <sil=0.000> 2 f <sil=0.000> a plus <sil=0.000> h plus <sil=0.000> 2 f <sil=0.000> a plus <sil=0.000> 2 h <sil=1.000> ,COMMA  why
this <sil=0.000> 2 is <sil=0.000> coming <sil=0.000> because <sil=0.000> in <sil=0.000> the <sil=0.000> first <sil=0.000> zone <sil=0.000> f a <sil=0.000> and <sil=0.000> f a <sil=0.000> plus <sil=0.000> h second <sil=0.000> zone <sil=0.000> f a <sil=0.000> plus <sil=0.000> h plus <sil=0.000> f a <sil=0.000> plus <sil=0.000> 2
h <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  each <sil=0.000> of <sil=0.000> these <sil=0.000> intermediate <sil=0.000> points <sil=0.000> are <sil=0.000> coming <sil=0.000> twice <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> why <sil=0.000> this <sil=0.000> is <sil=0.000> 2 and <sil=0.000> I have <sil=0.000> got <sil=0.000> this
formula <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  as <sil=0.000> a c <sil=0.000> programmer <sil=1.000> ,COMMA  your <sil=0.000> task <sil=0.000> is <sil=0.000> very <sil=0.000> simple <sil=0.000> you <sil=0.000> see <sil=0.000> here <sil=0.000> that <sil=0.000> I have <sil=0.000> defined <sil=0.000> n <sil=1.000> ,COMMA  i
whatever <sil=2.000> .PERIOD  I <sil=0.000> am <sil=0.000> asking <sil=0.000> the <sil=0.000> user <sil=0.000> for <sil=0.000> the <sil=0.000> necessary <sil=0.000> inputs <sil=2.000> .PERIOD  how <sil=0.000> many <sil=0.000> number <sil=0.000> of <sil=0.000> subintervals <sil=0.000> that
you <sil=0.000> want <sil=0.000> to <sil=0.000> have <sil=0.228> ?QUESTIONMARK  The <sil=0.000> initial <sil=0.000> limit <sil=0.000> a <sil=1.000> ,COMMA  you <sil=0.000> are <sil=0.000> reading <sil=0.000> the <sil=0.000> initial <sil=0.000> limit <sil=0.000> b <sil=1.000> ,COMMA  all <sil=0.000> those <sil=0.000> things <sil=0.000> you <sil=0.000> are
reading <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  the <sil=0.000> integral <sil=0.000> computation <sil=0.000> is <sil=0.000> done <sil=0.000> here <sil=2.000> .PERIOD  What <sil=0.000> is <sil=0.000> being <sil=0.000> done <sil=0.228> ?QUESTIONMARK  I <sil=0.000> am <sil=0.000> finding <sil=0.000> out <sil=0.000> the <sil=0.000> absolute
value <sil=0.000> of <sil=0.000> b ( b <sil=0.000> minus <sil=0.000> a divided <sil=0.000> by <sil=0.000> n and <sil=0.000> I am <sil=0.000> taking <sil=0.000> the <sil=0.000> absolute <sil=0.000> value <sil=0.000> of <sil=0.000> that) because <sil=0.000> it <sil=0.000> could
have <sil=0.000> gone <sil=0.000> on <sil=0.000> the <sil=0.000> other <sil=0.000> side <sil=0.000> also <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  here <sil=0.000> I am <sil=0.000> just <sil=0.000> computing <sil=0.000> the <sil=0.000> sum <sil=1.000> ,COMMA  what <sil=0.000> sum <sil=0.228> ?QUESTIONMARK  This
part <sil=2.000> .PERIOD  Initially <sil=0.000> x is <sil=0.000> a plus <sil=0.000> i h <sil=1.000> ,COMMA  sum <sil=0.000> is <sil=0.000> sum <sil=0.000> plus <sil=0.000> f x <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  next <sil=0.000> time <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> becoming <sil=0.000> 2 <sil=1.000> ,COMMA <sil=0.000> I am <sil=0.000> adding <sil=0.000> all

those <sil=0.000> things <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> I am <sil=0.000> in <sil=0.000> a loop <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> doing <sil=0.000> a plus <sil=0.000> i h <sil=0.000> initially <sil=0.000> i is <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  1 <sil=0.000> h <sil=1.000> ,COMMA  2 <sil=0.000> h like
that <sil=0.000> I am <sil=0.000> going <sil=0.000> on <sil=2.000> .PERIOD 

Ultimately <sil=0.000> and <sil=0.000> I am <sil=0.000> completing <sil=0.000> the <sil=0.000> sum <sil=0.000> here <sil=1.000> ,COMMA  some <sil=0.000> plus <sil=0.000> f x <sil=0.000> and <sil=0.000> note <sil=0.000> that <sil=0.000> f x <sil=0.000> is <sil=0.000> a separate
function <sil=0.000> that <sil=0.000> is <sil=0.000> being <sil=0.000> kept <sil=0.000> somewhere <sil=0.000> here <sil=0.000> and <sil=0.000> then <sil=0.000> ultimately <sil=0.000> I find <sil=0.000> the <sil=0.000> sum <sil=0.354> ;SEMICOLON  sum <sil=0.000> is <sil=0.000> these
things - a <sil=0.000> plus <sil=0.000> h these <sil=0.000> points <sil=2.000> .PERIOD  Now <sil=0.000> integral <sil=0.000> is <sil=0.000> h by <sil=0.000> 2- this <sil=0.000> part <sil=1.000> ,COMMA  f <sil=0.000> a plus <sil=0.000> f b <sil=0.000> plus <sil=0.000> f a <sil=0.000> plus <sil=0.000> f b <sil=0.000> plus
twice <sil=0.000> the <sil=0.000> sum <sil=0.000> a plus <sil=0.000> a h <sil=1.000> ,COMMA  a <sil=0.000> plus <sil=0.000> 2 h <sil=1.000> ,COMMA  a <sil=0.000> plus <sil=0.000> k h <sil=0.000> like <sil=0.000> that <sil=0.000> t a <sil=0.000> plus <sil=0.000> i h <sil=0.000> has <sil=0.000> been <sil=0.000> completed <sil=0.000> inside <sil=0.000> this <sil=0.000> loop <sil=0.000> and <sil=0.000> that <sil=0.000> I had <sil=0.000> with <sil=0.000> 2 here <sil=0.000> and <sil=0.000> here <sil=0.000> is <sil=0.000> my <sil=0.000> integral <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> the <sil=0.000> trapezoidal <sil=0.000> rule <sil=2.000> .PERIOD 

The <sil=0.000> program <sil=0.000> is <sil=0.000> so <sil=0.000> simple <sil=1.000> ,COMMA  if <sil=0.000> you <sil=0.000> understand <sil=0.000> the <sil=0.000> concep <sil=2.000> .PERIOD  Next <sil=0.000> we <sil=0.000> will <sil=0.000> move <sil=0.000> to <sil=0.000> another <sil=0.000> very
important <sil=0.000> engineering <sil=0.000> computation <sil=0.000> that <sil=0.000> is <sil=0.000> needed <sil=0.000> in <sil=0.000> solving <sil=0.000> ordinary <sil=0.000> differential <sil=0.000> equations <sil=2.000> .PERIOD 
Quickly <sil=0.000> lets <sil=0.000> all <sil=0.000> of <sil=0.000> you <sil=0.000> know <sil=0.000> what <sil=0.000> a differential <sil=0.000> equation <sil=0.000> is <sil=2.000> .PERIOD 

We <sil=0.000> will <sil=0.000> in <sil=0.000> particular <sil=0.000> look <sil=0.000> at <sil=0.000> Runge <sil=0.000> Kutta <sil=0.000> fourth <sil=0.000> order <sil=0.000> method <sil=0.000> and <sil=0.000> here <sil=0.000> I will <sil=0.000> show <sil=0.000> examples
that <sil=0.000> you <sil=0.000> can <sil=0.000> also <sil=0.000> find <sil=0.000> in <sil=0.000> this <sil=0.000> site <sil=0.000> of <sil=0.000> University <sil=0.000> of <sil=0.000> South <sil=0.000> Florida <sil=1.000> ,COMMA  numerical <sil=0.000> methods <sil=0.000> and <sil=0.000> I have

taken <sil=0.000> the <sil=0.000> slides <sil=0.000> from <sil=0.000> them <sil=0.000> with <sil=0.000> the <sil=0.000> permission <sil=2.000> .PERIOD  Now <sil=0.000> you <sil=0.000> see <sil=0.000> how <sil=0.000> to <sil=0.000> write <sil=0.000> an <sil=0.000> ordinary
differential <sil=0.000> equation <sil=2.000> .PERIOD  Now <sil=0.000> an <sil=0.000> ordinary <sil=0.000> differential <sil=0.000> equation <sil=0.000> you <sil=0.000> know -it <sil=0.000> is <sil=0.000> d y <sil=0.000> d x <sil=0.000> f x <sil=0.000> y  <sil=2.000> .PERIOD 

So <sil=0.000> how <sil=0.000> do <sil=0.000> I write <sil=0.000> it <sil=0.228> ?QUESTIONMARK  I <sil=0.000> write <sil=0.000> it <sil=0.000> as <sil=0.000> suppose <sil=0.000> this <sil=0.000> is <sil=0.000> something <sil=0.000> that <sil=0.000> is <sil=0.000> given <sil=1.000> ,COMMA  d <sil=0.000> y d <sil=0.000> x plus <sil=0.000> 2 y <sil=0.000> is <sil=0.000> 1 <sil=2.000> .PERIOD <sil=0.000> 3
into <sil=0.000> e power <sil=0.000> minus <sil=0.000> x and <sil=0.000> what <sil=0.000> is <sil=0.000> this <sil=0.000> part <sil=0.228> ?QUESTIONMARK  This <sil=0.000> is <sil=0.000> the <sil=0.000> initial <sil=0.000> condition <sil=2.000> .PERIOD  Now <sil=0.000> this <sil=0.000> can <sil=0.000> be
rewritten <sil=0.000> as (just <sil=0.000> by <sil=0.000> changing <sil=0.000> the <sil=0.000> directions <sil=0.000> because <sil=0.000> I have <sil=0.000> to <sil=0.000> bring <sil=0.000> it <sil=0.000> to <sil=0.000> this <sil=0.000> form) d <sil=0.000> y d <sil=0.000> x is <sil=0.000> 1 <sil=2.000> .PERIOD <sil=0.000> 3
e <sil=0.000> minus <sil=0.000> x minus <sil=0.000> 2 y <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  in <sil=0.000> this <sil=0.000> case <sil=0.000> we <sil=0.000> will <sil=0.000> assume <sil=0.000> that <sil=0.000> our <sil=0.000> f x <sil=0.000> y  <sil=1.000> ,COMMA  there <sil=0.000> is <sil=0.000> a d <sil=0.000> y d <sil=0.000> x which <sil=0.000> is <sil=0.000> 1 <sil=2.000> .PERIOD <sil=0.000> 3
- this <sil=0.000> thing <sil=0.000> ten <sil=0.000> e to <sil=0.000> the <sil=0.000> power <sil=0.000> minus <sil=0.000> x minus <sil=0.000> 2 y <sil=0.000> this <sil=0.000> is <sil=0.000> our <sil=0.000> differential <sil=0.000> equation <sil=0.000> that <sil=0.000> we <sil=0.000> will
have <sil=0.000> to <sil=0.000> solve <sil=2.000> .PERIOD  (Refer <sil=0.000> Slide <sil=0.000> Time: 17:18)

So <sil=1.000> ,COMMA  for <sil=0.000> d y <sil=0.000> d x <sil=1.000> ,COMMA  the <sil=0.000> Runge <sil=0.000> Kutta <sil=0.000> fourth <sil=0.000> order <sil=0.000> method <sil=1.000> ,COMMA ( I <sil=0.000> am <sil=0.000> not <sil=0.000> going <sil=0.000> into <sil=0.000> the <sil=0.000> derivation <sil=0.000> of <sil=0.000> it <sil=0.000> for
positive <sil=0.000> of <sil=0.000> time <sil=0.000> and <sil=0.000> you <sil=0.000> can <sil=0.000> always <sil=0.000> look <sil=0.000> at <sil=0.000> look <sil=0.000> into <sil=0.000> this <sil=0.000> at <sil=0.000> any <sil=0.000> website <sil=0.000> or <sil=0.000> you <sil=0.000> can <sil=0.000> look <sil=0.000> at <sil=0.000> any
numerical <sil=0.000> method <sil=0.000> textbook) takes <sil=0.000> 4 terms <sil=0.000> and <sil=0.000> if <sil=0.000> this <sil=0.000> is <sil=0.000> the <sil=0.000> expression <sil=1.000> ,COMMA  given <sil=0.000> this <sil=0.000> d y <sil=0.000> d x <sil=0.000> my <sil=0.000> task
of <sil=0.000> solving <sil=0.000> a differential <sil=0.000> equation <sil=0.000> is <sil=0.000> to <sil=0.000> find <sil=0.000> a particular <sil=0.000> y <sil=1.000> ,COMMA  right <sil=0.228> ?QUESTIONMARK <sil=0.000> So <sil=1.000> ,COMMA  what <sil=0.000> we <sil=0.000> are <sil=0.000> trying <sil=0.000> to <sil=0.000> do <sil=0.000> y i
plus <sil=0.000> 1 is <sil=0.000> y i <sil=0.354> ;SEMICOLON  some <sil=0.000> particular <sil=0.000> y i <sil=0.000> plus <sil=0.000> 1 by <sil=0.000> 6 followed <sil=0.000> by <sil=0.000> a term <sil=0.000> and <sil=0.000> what <sil=0.000> is <sil=0.000> that <sil=0.000> term <sil=0.000> k 1 <sil=0.000> plus <sil=0.000> 2 k
2 <sil=0.000> plus <sil=0.000> 2 k <sil=0.000> 3 plus <sil=0.000> k 4 - this <sil=0.000> whole <sil=0.000> thing <sil=0.000> multiplied <sil=0.000> by <sil=0.000> h <sil=2.000> .PERIOD  H <sil=0.000> is <sil=0.000> the <sil=0.000> again <sil=0.000> the <sil=0.000> sampling <sil=0.000> that <sil=0.000> is <sil=0.000> the
distance <sil=0.000> between <sil=0.000> the <sil=0.000> individual <sil=0.000> points <sil=0.000> that <sil=0.000> we <sil=0.000> looked <sil=0.000> at <sil=0.354> ;SEMICOLON  now <sil=0.000> what <sil=0.000> is <sil=0.000> k 1 <sil=0.228> ?QUESTIONMARK 

When <sil=0.000> I am <sil=0.000> taking <sil=0.000> for <sil=0.000> y i <sil=1.000> ,COMMA  f <sil=0.000> x i <sil=0.000> y i - that <sil=0.000> particular <sil=0.000> function <sil=0.000> is <sil=0.000> k 1 <sil=2.000> .PERIOD  What <sil=0.000> is <sil=0.000> k 2  <sil=0.228> ?QUESTIONMARK  Suppose <sil=0.000> there
is <sil=0.000> a curve <sil=2.000> .PERIOD  Now <sil=0.000> I have <sil=0.000> been <sil=0.000> given <sil=0.000> the <sil=0.000> slope <sil=1.000> ,COMMA  I <sil=0.000> do <sil=0.000> not <sil=0.000> know <sil=0.000> the <sil=0.000> curve <sil=2.000> .PERIOD  If <sil=0.000> know <sil=0.000> the <sil=0.000> curve <sil=0.000> then <sil=0.000> I
can <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> any <sil=0.000> particular <sil=0.000> y i <sil=0.000> plus <sil=0.000> 1 given <sil=0.000> any <sil=0.000> y i <sil=2.000> .PERIOD  Now <sil=0.000> given <sil=0.000> any <sil=0.000> y i <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> trying <sil=0.000> to
guess <sil=0.000> the <sil=0.000> curve <sil=1.000> ,COMMA  right <sil=0.228> ?QUESTIONMARK  I <sil=0.000> am <sil=0.000> trying <sil=0.000> to <sil=0.000> solve <sil=0.000> the <sil=0.000> curve <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  x <sil=0.000> i was <sil=0.000> here <sil=1.000> ,COMMA  x <sil=0.000> i plus <sil=0.000> half <sil=0.000> h <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> taking
whatever <sil=0.000> was <sil=0.000> my <sil=0.000> h <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> taking <sil=0.000> half <sil=0.000> of <sil=0.000> h and <sil=0.000> what <sil=0.000> is <sil=0.000> the <sil=0.000> y part <sil=0.000> of <sil=0.000> this <sil=0.000> function <sil=0.000> y i <sil=0.000> plus <sil=0.000> half <sil=0.000> of <sil=0.000> k
1 <sil=0.000> h <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  because <sil=0.000> k 1 <sil=0.000> was <sil=0.000> f i <sil=1.000> ,COMMA  k <sil=0.000> 1 was <sil=0.000> the <sil=0.000> function <sil=0.000> that <sil=0.000> was <sil=0.000> giving <sil=0.000> y given <sil=0.000> an <sil=0.000> x <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> taking <sil=0.000> this <sil=2.000> .PERIOD 
What <sil=0.000> is <sil=0.000> k 3 <sil=0.228> ?QUESTIONMARK  This <sil=0.000> part <sil=0.000> is <sil=0.000> same <sil=1.000> ,COMMA  x <sil=0.000> i plus <sil=0.000> half <sil=0.000> h <sil=1.000> ,COMMA  but <sil=0.000> this <sil=0.000> part <sil=0.000> is <sil=0.000> now <sil=0.000> becoming <sil=0.000> much <sil=0.000> more

predictive <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> half <sil=0.000> of <sil=0.000> k 2 <sil=0.000> h  <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  whatever <sil=0.000> has <sil=0.000> been <sil=0.000> completed <sil=0.000> here <sil=0.000> times <sil=0.000> h and <sil=0.000> k 4 <sil=0.000> is <sil=0.000> x i <sil=0.000> plus <sil=0.000> h <sil=1.000> ,COMMA  the <sil=0.000> last <sil=0.000> one <sil=0.000> is <sil=0.000> x i <sil=0.000> plus <sil=0.000> h because <sil=0.000> I am <sil=0.000> trying <sil=0.000> to <sil=0.000> solve <sil=0.000> the <sil=0.000> equation <sil=0.000> within <sil=0.000> this <sil=0.000> zone <sil=0.000> h <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  x <sil=0.000> i plus <sil=0.000> h <sil=1.000> ,COMMA  i <sil=0.000> start <sil=0.000> with <sil=0.000> x i <sil=0.000> and <sil=0.000> this <sil=0.000> is <sil=0.000> x i <sil=0.000> plus <sil=0.000> h times <sil=0.000> k 3 <sil=0.000> h <sil=2.000> .PERIOD  Here <sil=0.000> there <sil=0.000> is <sil=0.000> no <sil=0.000> half <sil=2.000> .PERIOD  Now <sil=0.000> this
derivation <sil=0.000> you <sil=0.000> can <sil=0.000> look <sil=0.000> at <sil=1.000> ,COMMA  but <sil=0.000> ultimately <sil=0.000> I multiply <sil=0.000> it <sil=0.000> with <sil=0.000> 1 by <sil=0.000> 6 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  given <sil=0.000> this <sil=0.000> Runge <sil=0.000> Kutta <sil=0.000> formula <sil=0.000> let <sil=0.000> us <sil=0.000> quickly <sil=0.000> look <sil=0.000> at <sil=0.000> an <sil=0.000> example <sil=1.000> ,COMMA  that <sil=0.000> we <sil=0.000> have <sil=0.000> a nice <sil=0.000> thing
to <sil=0.000> look <sil=0.000> at <sil=2.000> .PERIOD 

Suppose <sil=0.000> a ball <sil=0.000> is <sil=0.000> at <sil=0.000> 1200 <sil=0.000> Kelvin <sil=0.000> and <sil=0.000> is <sil=0.000> allowed <sil=0.000> to <sil=0.000> cool <sil=0.000> down <sil=0.000> in <sil=0.000> air <sil=0.000> in <sil=0.000> an <sil=0.000> ambient <sil=0.000> temperature <sil=0.000> of
300 <sil=0.000> Kelvin <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> the <sil=0.000> ball <sil=0.000> was <sil=0.000> heated <sil=0.000> and <sil=0.000> the <sil=0.000> air <sil=0.000> is <sil=0.000> cooling <sil=0.000> it <sil=0.000> down <sil=2.000> .PERIOD  Assuming <sil=0.000> that <sil=0.000> the <sil=0.000> heat <sil=0.000> is
lost <sil=0.000> only <sil=0.000> due <sil=0.000> to <sil=0.000> radiation <sil=0.000> the <sil=0.000> differential <sil=0.000> equation <sil=0.000> for <sil=0.000> the <sil=0.000> temperature <sil=0.000> is <sil=0.000> given <sil=0.000> here <sil=2.000> .PERIOD  This <sil=0.000> one <sil=1.000> ,COMMA 
where <sil=0.000> theta <sil=0.000> 0 <sil=0.354> ;SEMICOLON  we <sil=0.000> know <sil=0.000> the <sil=0.000> initial <sil=0.000> condition <sil=0.000> is <sil=0.000> 1200 <sil=0.000> Kelvin <sil=2.000> .PERIOD  Find <sil=0.000> the <sil=0.000> temperature <sil=0.000> at <sil=0.000> t 480 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
what <sil=0.000> is <sil=0.000> my <sil=0.000> x i <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  if <sil=0.000> I assume <sil=0.000> a step <sil=0.000> size <sil=0.000> of <sil=0.000> 240 <sil=1.000> ,COMMA  I <sil=0.000> want <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> temperature <sil=0.000> at <sil=0.000> 480 <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  suppose <sil=0.000> it <sil=0.000> was <sil=0.000> at <sil=0.000> a particular <sil=0.000> temperature <sil=0.000> after <sil=0.000> 480 <sil=0.000> seconds <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> the <sil=0.000> time <sil=1.000> ,COMMA  it <sil=0.000> was <sil=0.000> at <sil=0.000> 1200 <sil=0.000> and <sil=0.000> I have <sil=0.000> got <sil=0.000> some <sil=0.000> radiation <sil=0.000> formula <sil=0.000> using <sil=0.000> which <sil=0.000> it <sil=0.000> is
coming <sil=0.000> down <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> want <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> what <sil=0.000> would <sil=0.000> the <sil=0.000> temperature <sil=0.000> be <sil=0.000> at <sil=0.000> 480 <sil=0.000> seconds <sil=0.000> from <sil=0.000> the
starting <sil=0.000> point <sil=0.000> where <sil=0.000> it <sil=0.000> was <sil=0.000> at <sil=0.000> 1200 <sil=0.000> degree <sil=0.000> Kelvin <sil=2.000> .PERIOD  I <sil=0.000> want <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> this <sil=0.000> temperature <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> the
y <sil=0.000> i I <sil=0.000> want <sil=0.000> to <sil=0.000> find <sil=0.000> out  <sil=1.000> ,COMMA <sil=0.000> given <sil=0.000> the <sil=0.000> slope <sil=0.000> of <sil=0.000> this <sil=0.000> differential <sil=0.000> equation <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  assuming <sil=0.000> a step <sil=0.000> size <sil=0.000> of <sil=0.000> each <sil=0.000> to <sil=0.000> be <sil=0.000> 240 <sil=1.000> ,COMMA  if <sil=0.000> I take <sil=0.000> half <sil=0.000> of <sil=0.000> this <sil=0.000> then <sil=0.000> 240 <sil=0.000> then <sil=0.000> d theta <sil=0.000> d t <sil=1.000> ,COMMA  you <sil=0.000> can
compute <sil=0.000> that <sil=1.000> ,COMMA  here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  my <sil=0.000> formula <sil=0.000> will <sil=0.000> be <sil=0.000> theta <sil=0.000> i plus <sil=0.000> k 1 <sil=0.000> plus <sil=0.000> 2 k <sil=0.000> 2 plus <sil=0.000> 2 k <sil=0.000> 3 plus <sil=0.000> k 4 <sil=0.000> divided
by <sil=0.000> 6 times <sil=0.000> h <sil=0.354> ;SEMICOLON  that <sil=0.000> is <sil=0.000> the <sil=0.000> Runge <sil=0.000> Kutta <sil=0.000> formula <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> what <sil=0.000> I want <sil=0.000> to <sil=0.000> find <sil=0.000> out  <sil=2.000> .PERIOD 

So <sil=0.000> step <sil=0.000> 1 - you <sil=0.000> see <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> not <sil=0.000> going <sil=0.000> into <sil=0.000> all <sil=0.000> these <sil=0.000> calculations <sil=1.000> ,COMMA  but <sil=0.000> I am <sil=0.000> finding <sil=0.000> out <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> k
1 <sil=2.000> .PERIOD  I <sil=0.000> am <sil=0.000> finding <sil=0.000> out <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> k 2 <sil=0.000> using <sil=0.000> this <sil=0.000> value <sil=0.000> of <sil=0.000> k 1 <sil=1.000> ,COMMA  k <sil=0.000> 1 is <sil=0.000> being <sil=0.000> used <sil=0.000> here <sil=0.000> and <sil=0.000> I find <sil=0.000> out
the <sil=0.000> value <sil=0.000> of <sil=0.000> k 2 <sil=2.000> .PERIOD  Again <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> k 2 <sil=0.000> is <sil=0.000> being <sil=0.000> used <sil=0.000> here <sil=1.000> ,COMMA  I <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> k 3 <sil=0.000> and <sil=0.000> k 3 <sil=0.000> is
being <sil=0.000> used <sil=0.000> here <sil=0.000> I find <sil=0.000> out <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> k 4 <sil=1.000> ,COMMA  I <sil=0.000> find <sil=0.000> out <sil=0.000> those <sil=0.000> values <sil=0.000> manually

So <sil=1.000> ,COMMA  the <sil=0.000> solution <sil=0.000> therefore <sil=1.000> ,COMMA  the <sil=0.000> theta <sil=0.000> 0 was <sil=0.000> 1200 <sil=0.354> ;SEMICOLON  initial <sil=0.000> condition <sil=0.000> and <sil=0.000> here <sil=0.000> I put <sil=0.000> in <sil=0.000> the <sil=0.000> values <sil=0.000> of
this <sil=0.000> times <sil=0.000> h <sil=0.354> ;SEMICOLON  h <sil=0.000> was <sil=0.000> 240 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> taken <sil=0.000> it <sil=0.000> at <sil=0.000> the <sil=0.000> midpoint <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> find <sil=0.000> that <sil=0.000> the <sil=0.000> temperature <sil=0.000> that
would <sil=0.000> be <sil=0.000> would <sil=0.000> be <sil=0.000> 675 <sil=2.000> .PERIOD <sil=0.000> 65 <sil=0.354> ;SEMICOLON  that <sil=0.000> is <sil=0.000> the <sil=0.000> approximate <sil=0.000> temperature <sil=0.000> at <sil=0.000> 240 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> will <sil=0.000> be <sil=0.000> the <sil=0.000> value
at <sil=0.000> 240 <sil=2.000> .PERIOD  Next <sil=0.000> I have <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> at <sil=0.000> 480 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> would <sil=0.000> I do <sil=0.228> ?QUESTIONMARK 

Step <sil=0.000> 2 <sil=0.354> ;SEMICOLON  I <sil=0.000> have <sil=0.000> taken <sil=0.000> had <sil=0.000> half <sil=0.000> point <sil=1.000> ,COMMA  I <sil=0.000> found <sil=0.000> out <sil=0.000> now <sil=0.000> my <sil=0.000> initial <sil=0.000> value <sil=0.000> theta <sil=0.000> 0 is <sil=0.000> changing <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  again <sil=0.000> do <sil=0.000> the <sil=0.000> same <sil=0.000> thing - find <sil=0.000> out <sil=0.000> k 1 <sil=1.000> ,COMMA <sil=0.000> find <sil=0.000> out <sil=0.000> k 2 <sil=1.000> ,COMMA  find <sil=0.000> out <sil=0.000> k 3 <sil=1.000> ,COMMA  find <sil=0.000> out <sil=0.000> k 4 <sil=2.000> .PERIOD  Now <sil=0.000> with <sil=0.000> this
initial <sil=0.000> condition (using <sil=0.000> the <sil=0.000> same <sil=0.000> function ) what <sil=0.000> will <sil=0.000> be <sil=0.000> h <sil=0.354> ;SEMICOLON  h <sil=0.000> will <sil=0.000> be <sil=0.000> again <sil=0.000> 240 <sil=0.000> because <sil=0.000> I have <sil=0.000> to
find <sil=0.000> it <sil=0.000> out <sil=0.000> at <sil=0.000> 480 <sil=0.000> degree <sil=0.000> temperature <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  I <sil=0.000> find <sil=0.000> out <sil=0.000> that <sil=0.000> using <sil=0.000> theta <sil=0.000> on <sil=0.000> is <sil=0.000> now <sil=0.000> 675 <sil=2.000> .PERIOD <sil=0.000> 65 <sil=0.000> that <sil=0.000> is <sil=0.000> approximate <sil=0.000> value <sil=0.000> that <sil=0.000> I got <sil=0.000> earlier
and <sil=0.000> I compute <sil=0.000> this <sil=2.000> .PERIOD  I <sil=0.000> find <sil=0.000> out <sil=0.000> using <sil=0.000> the <sil=0.000> same <sil=0.000> Runge <sil=0.000> Kutta <sil=0.000> method <sil=0.000> that <sil=0.000> this <sil=0.000> is <sil=0.000> the <sil=0.000> approximate
temperature <sil=0.000> at <sil=0.000> at <sil=0.000> 480 <sil=0.000> seconds <sil=0.000> which <sil=0.000> is <sil=0.000> 594 <sil=2.000> .PERIOD <sil=0.000> 91 <sil=0.000> degree <sil=0.000> Kelvin  <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> how <sil=0.000> we <sil=0.000> apply <sil=0.000> Runge
Kutta <sil=0.000> method <sil=0.000> and <sil=0.000> it s <sil=0.000> very <sil=0.000> useful <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  the <sil=0.000> exact <sil=0.000> solution <sil=0.000> of <sil=0.000> the <sil=0.000> differential <sil=0.000> equation <sil=0.000> is <sil=0.000> 647 <sil=2.000> .PERIOD <sil=0.000> 57 <sil=1.000> ,COMMA  if <sil=0.000> I solve <sil=0.000> it <sil=0.000> now <sil=1.000> ,COMMA  we <sil=0.000> got <sil=0.000> it <sil=1.000> ,COMMA  it <sil=0.000> was
how <sil=0.000> much <sil=0.000> 594 <sil=2.000> .PERIOD <sil=0.000> 91 <sil=0.000> and <sil=0.000> 594 <sil=2.000> .PERIOD <sil=0.000> 91 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  it <sil=0.000> was <sil=0.000> not <sil=0.000> very <sil=0.000> far <sil=2.000> .PERIOD  It <sil=0.000> around <sil=0.000> 50 <sil=0.000> degree <sil=0.000> Kelvin <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> certainly <sil=0.000> an <sil=0.000> approximation <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  now <sil=0.000> we <sil=0.000> have <sil=0.000> understood <sil=0.354> ;SEMICOLON  what <sil=0.000> is <sil=0.000> Runge <sil=0.000> Kutta <sil=0.000> method <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  I <sil=0.000> want <sil=0.000> to <sil=0.000> write <sil=0.000> a c <sil=0.000> program <sil=0.000> for <sil=0.000> it <sil=2.000> .PERIOD  Again <sil=0.000> you <sil=0.000> might <sil=0.000> find <sil=0.000> the <sil=0.000> approach <sil=0.000> to <sil=0.000> be <sil=0.000> mathematically
very <sil=0.000> novel <sil=0.000> maybe <sil=0.000> intricate <sil=1.000> ,COMMA  you <sil=0.000> may <sil=0.000> find <sil=0.000> some <sil=0.000> initial <sil=0.000> difficulty <sil=0.000> in <sil=0.000> understanding <sil=1.000> ,COMMA  but <sil=0.000> I am <sil=0.000> sure
you <sil=0.000> will <sil=0.000> understand <sil=0.000> it <sil=0.000> very <sil=0.000> fast <sil=1.000> ,COMMA  but <sil=0.000> you <sil=0.000> will <sil=0.000> see <sil=0.000> that <sil=0.000> encoding <sil=0.000> it <sil=0.000> as <sil=0.000> a c <sil=0.000> program <sil=0.000> is <sil=0.000> or <sil=0.000> as <sil=0.000> a
program <sil=0.000> is <sil=0.000> really <sil=0.000> simple <sil=2.000> .PERIOD  Now <sil=0.000> you <sil=0.000> are <sil=0.000> learning <sil=0.000> C <sil=1.000> ,COMMA  in <sil=0.000> future <sil=0.000> will <sil=0.000> be <sil=0.000> using <sil=0.000> MATLAB <sil=0.000> and <sil=0.000> other
things <sil=1.000> ,COMMA  you <sil=0.000> will <sil=0.000> be <sil=0.000> able <sil=0.000> to <sil=0.000> solve <sil=0.000> it <sil=0.000> very <sil=0.000> easily <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> showing <sil=0.000> you <sil=0.000> the <sil=0.000> c solution <sil=0.000> here <sil=2.000> .PERIOD  On <sil=0.000> this <sil=0.000> side <sil=1.000> ,COMMA 
I <sil=0.000> have <sil=0.000> kept <sil=0.000> what <sil=0.000> we <sil=0.000> learnt <sil=0.000> till <sil=0.000> now <sil=1.000> ,COMMA  y <sil=0.000> i plus <sil=0.000> 1 <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  in <sil=0.000> our <sil=0.000> case <sil=0.000> the <sil=0.000> temperature <sil=0.000> at <sil=0.000> 480
degree <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> temperature <sil=0.000> at <sil=0.000> 240 <sil=0.000> degree <sil=0.000> plus <sil=0.000> this <sil=0.000> and <sil=0.000> k 1 <sil=0.000> is <sil=0.000> f x <sil=0.000> y <sil=1.000> ,COMMA  k <sil=0.000> 2 is <sil=0.000> f x <sil=0.000> i  <sil=1.000> ,COMMA <sil=0.000> this <sil=0.000> one <sil=0.000> f x <sil=0.000> i plus <sil=0.000> half
h <sil=0.000> plus <sil=0.000> y i <sil=0.000> plus <sil=0.000> half <sil=0.000> k 1 <sil=0.000> h etc <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  now <sil=0.000> let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> the <sil=0.000> program <sil=0.000> we <sil=0.000> have <sil=0.000> got <sil=0.000> the <sil=0.000> math <sil=0.000> function <sil=0.000> and <sil=0.000> everything <sil=0.000> ready <sil=2.000> .PERIOD  Now
somehow <sil=0.000> this <sil=0.000> function <sil=0.000> has <sil=0.000> to <sil=0.000> be <sil=0.000> written <sil=2.000> .PERIOD  Now <sil=0.000> this <sil=0.000> function  <sil=1.000> ,COMMA  here <sil=0.000> its <sil=0.000> being <sil=0.000> shown <sil=0.000> as <sil=0.000> a very
simple <sil=0.000> function <sil=1.000> ,COMMA  it <sil=0.000> can <sil=0.000> be <sil=0.000> any <sil=0.000> function <sil=1.000> ,COMMA  the <sil=0.000> differential <sil=0.000> equation <sil=0.000> function <sil=1.000> ,COMMA  the <sil=0.000> earlier <sil=0.000> functions
that <sil=0.000> we <sil=0.000> have <sil=0.000> shown <sil=0.000> or <sil=0.000> the <sil=0.000> thelog <sil=0.000> function <sil=0.000> which <sil=0.000> you <sil=0.000> will <sil=0.000> have <sil=0.000> to <sil=0.000> write <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> an <sil=0.000> example
of <sil=0.000> a simple <sil=0.000> function <sil=0.354> ;SEMICOLON  x <sil=0.000> minus <sil=0.000> y by <sil=0.000> x plus <sil=0.000> y <sil=2.000> .PERIOD  With <sil=0.000> the <sil=0.000> dy <sil=0.000> dx <sil=0.000> given <sil=1.000> ,COMMA  that <sil=0.000> will <sil=0.000> come <sil=0.000> in <sil=0.000> this <sil=0.000> function <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  you <sil=0.000> see <sil=0.000> here <sil=0.000> I did <sil=0.000> how <sil=0.000> many <sil=0.000> times <sil=0.228> ?QUESTIONMARK  And <sil=0.000> h value <sil=1.000> ,COMMA  x <sil=0.000> 0 x <sil=0.000> 1 value <sil=1.000> ,COMMA  all <sil=0.000> these <sil=0.000> things <sil=0.000> I read <sil=2.000> .PERIOD 
Now <sil=0.000> the <sil=0.000> key <sil=0.000> things <sil=0.000> comes <sil=0.000> here <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> the <sil=0.000> implementation <sil=0.000> of <sil=0.000> the <sil=0.000> Runge <sil=0.000> Kutta <sil=0.000> method <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  very
simple <sil=1.000> ,COMMA  you <sil=0.000> see <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> computing <sil=0.000> k 1 <sil=1.000> ,COMMA  k <sil=0.000> one <sil=0.000> is <sil=0.000> f x <sil=0.000> 0 y <sil=0.000> 0 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> coming <sil=0.000> to <sil=0.000> this <sil=0.000> function <sil=0.000> computing <sil=0.000> x 0 <sil=0.000> y 0 <sil=1.000> ,COMMA  then <sil=0.000> I am <sil=0.000> going <sil=0.000> back <sil=0.000> computing <sil=0.000> k 2 <sil=0.000> for <sil=0.000> x 0
plus <sil=0.000> h by <sil=0.000> 2 <sil=2.000> .PERIOD  h <sil=0.000> has <sil=0.000> been <sil=0.000> read  <sil=2.000> .PERIOD  This <sil=0.000> h has <sil=0.000> been <sil=0.000> read <sil=1.000> ,COMMA  then <sil=0.000> y 0 <sil=0.000> plus <sil=0.000> m 1 <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> sorry <sil=1.000> ,COMMA  here <sil=0.000> it <sil=0.000> should
be <sil=0.000> k 1  <sil=1.000> ,COMMA  this <sil=0.000> would <sil=0.000> be <sil=0.000> k 2 <sil=1.000> ,COMMA  all <sil=0.000> these <sil=0.000> m s <sil=0.000> you <sil=0.000> should <sil=0.000> read <sil=0.000> it <sil=0.000> as <sil=0.000> k <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> k 3 <sil=1.000> ,COMMA   <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> k 2 <sil=0.000> times <sil=0.000> h <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  actually <sil=0.000> we <sil=0.000> are <sil=0.000> computing <sil=0.000> this <sil=0.000> thing <sil=0.000> straight <sil=0.000> way <sil=0.000> and <sil=0.000> then <sil=0.000> y is <sil=0.000> assigned <sil=0.000> y plus <sil=0.000> k h <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> this <sil=0.000> statement <sil=0.000> will <sil=0.000> be <sil=0.000> y plus <sil=0.000> k h <sil=0.000> and <sil=0.000> x plus <sil=0.000> h <sil=2.000> .PERIOD  I <sil=0.000> am <sil=0.000> incrementing <sil=0.000> x and <sil=0.000> going <sil=0.000> on <sil=2.000> .PERIOD  I
am <sil=0.000> doing <sil=0.000> it <sil=0.000> for <sil=0.000> 2 intervals <sil=0.000> till <sil=0.000> I come <sil=0.000> over <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> ultimately <sil=0.000> come <sil=0.000> to <sil=0.000> this <sil=0.000> print <sil=0.000> f and <sil=0.000> I print
the <sil=0.000> value <sil=0.000> of <sil=0.000> y for <sil=0.000> a particular <sil=0.000> x <sil=0.354> ;SEMICOLON  that <sil=0.000> is <sil=0.000> the <sil=0.000> Runge <sil=0.000> Kutta <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> in <sil=0.000> a straight <sil=0.000> way <sil=0.000> amenable <sil=0.000> to
some <sil=0.000> c program <sil=0.000> and <sil=0.000> for <sil=0.000> each <sil=0.000> of <sil=0.000> these <sil=0.000> f s <sil=1.000> ,COMMA  you <sil=0.000> are <sil=0.000> calling <sil=0.000> the <sil=0.000> function <sil=0.000> every <sil=0.000> time <sil=1.000> ,COMMA  <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> the <sil=0.000> Runge <sil=0.000> Kutta <sil=0.000> method <sil=0.000> for <sil=0.000> solving <sil=0.000> a differential <sil=0.000> equation <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> encourage <sil=0.000> you <sil=0.000> to
look <sil=0.000> at <sil=0.000> other <sil=0.000> methods <sil=0.000> of <sil=0.000> a integration <sil=0.000> like <sil=0.000> Simpsons <sil=0.000> one <sil=0.000> third <sil=0.000> rule <sil=0.000> which <sil=0.000> is <sil=0.000> a very <sil=0.000> popular
method <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> Runge <sil=0.000> Kutta <sil=0.000> fourth <sil=0.000> order <sil=0.000> method <sil=0.000> because <sil=0.000> we <sil=0.000> are <sil=0.000> taking <sil=0.000> 4 terms <sil=1.000> ,COMMA  here <sil=1.000> ,COMMA  but <sil=0.000> this <sil=0.000> works <sil=0.000> very <sil=0.000> well <sil=0.000> for <sil=0.000> most <sil=0.000> of <sil=0.000> the <sil=0.000> engineering <sil=0.000> problems <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> encourage <sil=0.000> you <sil=0.000> to <sil=0.000> write <sil=0.000> programs <sil=0.000> on <sil=0.000> this <sil=0.000> and <sil=0.000> later <sil=0.000> on <sil=0.000> hence <sil=0.000> forth <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> move <sil=0.000> to <sil=0.000> another <sil=0.000> interesting <sil=0.000> aspect <sil=0.000> that <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> recursion <sil=0.000> a new <sil=0.000> style <sil=0.000> of <sil=0.000> programming <sil=0.000> which <sil=0.000> will <sil=0.000> take <sil=0.000> up <sil=0.000> in <sil=0.000> the <sil=0.000> next <sil=0.000> lecture <sil=2.000> .PERIOD 

Thank <sil=0.000> you <sil=2.000> .PERIOD 

Today <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> be <sil=0.000> discussing <sil=0.000> on <sil=0.000> a new <sil=0.000> concept <sil=0.000> of <sil=0.000> programming <sil=0.000> which <sil=0.000> is <sil=0.000> very <sil=0.000> interesting <sil=1.000> ,COMMA  but
possibly <sil=0.000> not <sil=0.000> very <sil=0.000> much <sil=0.000> familiar <sil=0.000> to <sil=0.000> you <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> Recursion <sil=2.000> .PERIOD  You <sil=0.000> know <sil=0.000> repetitions <sil=0.354> ;SEMICOLON  how
they <sil=0.000> are <sil=0.000> implemented <sil=0.000> in <sil=0.000> C programming <sil=2.000> .PERIOD  Whenever <sil=0.000> I want <sil=0.000> to <sil=0.000> do <sil=0.000> a particular <sil=0.000> work <sil=2.000> .PERIOD 

For <sil=0.000> example <sil=0.000> I want <sil=0.000> to <sil=0.000> add <sil=0.000> 10 <sil=0.000> numbers <sil=1.000> ,COMMA  then <sil=0.000> I add <sil=0.000> the <sil=0.000> sum <sil=0.000> with <sil=0.000> sum <sil=0.000> plus <sil=0.000> sum <sil=0.000> a i <sil=0.000> with <sil=0.000> i equal <sil=0.000> to
1 <sil=0.000> and <sil=0.000> then <sil=0.000> I repeat <sil=0.000> it <sil=0.000> i plus <sil=0.000> plus <sil=0.000> and <sil=0.000> I go <sil=0.000> on <sil=0.000> repeating <sil=0.000> it <sil=0.000> and <sil=0.000> this <sil=0.000> repetition <sil=0.000> is <sil=0.000> done <sil=0.000> in <sil=0.000> the <sil=0.000> form <sil=0.000> of
a <sil=0.000> for <sil=0.000> loop <sil=0.000> or <sil=0.000> while <sil=0.000> loop <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  recursion <sil=0.000> is <sil=0.000> a different <sil=0.000> way <sil=0.000> of <sil=0.000> doing <sil=0.000> this <sil=2.000> .PERIOD  When <sil=0.000> a function <sil=0.000> calls <sil=0.000> itself <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  a
function <sil=0.354> ;SEMICOLON  a <sil=0.000> particular <sil=0.000> function <sil=0.000> will <sil=0.000> have <sil=0.000> some <sil=0.000> inputs <sil=0.000> and <sil=0.000> we <sil=0.000> will <sil=0.000> deliver <sil=0.000> one <sil=0.000> output <sil=2.000> .PERIOD  Now <sil=0.000> you
know <sil=0.000> nesting <sil=0.000> of <sil=0.000> functions <sil=0.000> that <sil=0.000> in <sil=0.000> order <sil=0.000> to <sil=0.000> achieve <sil=0.000> this <sil=0.000> objective <sil=0.000> of <sil=0.000> taking <sil=0.000> these <sil=0.000> inputs <sil=0.000> and

delivering <sil=0.000> these <sil=0.000> outputs <sil=1.000> ,COMMA  a <sil=0.000> function <sil=0.000> could <sil=0.000> call <sil=0.000> other <sil=0.000> functions <sil=0.000> from <sil=0.000> another <sil=0.000> function <sil=0.000> and <sil=0.000> then
ultimately <sil=1.000> ,COMMA  return <sil=0.000> to <sil=0.000> this <sil=0.000> function <sil=0.000> which <sil=0.000> could <sil=0.000> be <sil=0.000> done <sil=0.000> and <sil=0.000> this <sil=0.000> was <sil=0.000> known <sil=0.000> as <sil=0.000> nesting <sil=2.000> .PERIOD 

But <sil=0.000> recursion <sil=0.000> is <sil=0.000> a little <sil=0.000> different <sil=1.000> ,COMMA  here <sil=0.000> there <sil=0.000> is <sil=0.000> a function <sil=0.000> which <sil=0.000> is <sil=0.000> supposed <sil=0.000> to <sil=0.000> be <sil=0.000> to <sil=0.000> deliver <sil=0.000> some
output <sil=2.000> .PERIOD  Now <sil=0.000> in <sil=0.000> order <sil=0.000> to <sil=0.000> do <sil=0.000> this <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> actually <sil=0.000> repeating <sil=0.000> itself <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  let <sil=0.000> me <sil=0.000> give <sil=0.000> you <sil=0.000> an
example <sil=2.000> .PERIOD  Suppose <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> a machine <sil=0.000> which <sil=0.000> can <sil=0.000> generate <sil=0.000> 1 apple <sil=1.000> ,COMMA  it <sil=0.000> can <sil=0.000> generate <sil=0.000> 1 apple <sil=1.000> ,COMMA  produce
1 <sil=0.000> apple <sil=0.000> or <sil=0.000> maybe <sil=0.000> let <sil=0.000> us <sil=0.000> say <sil=1.000> ,COMMA  it <sil=0.000> produces <sil=0.000> a vending <sil=0.000> machine <sil=0.000> which <sil=0.000> can <sil=0.000> deliver <sil=0.000> 1 coke <sil=1.000> ,COMMA  alright <sil=1.000> ,COMMA  1
piece <sil=0.000> of <sil=0.000> coke <sil=0.000> or1 <sil=0.000> can <sil=0.000> of <sil=0.000> coke <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  you <sil=0.000> put <sil=0.000> in <sil=0.000> some <sil=0.000> input <sil=0.000> some <sil=0.000> commands <sil=0.000> and <sil=0.000> it <sil=0.000> gives <sil=0.000> you <sil=0.000> 1 coke <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  it <sil=0.000> has <sil=0.000> been <sil=0.000> asked <sil=0.000> to
deliver <sil=0.000> 5 cokes <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  how <sil=0.000> can <sil=0.000> you <sil=0.000> deliver <sil=0.000> 5 cokes <sil=0.228> ?QUESTIONMARK  It <sil=0.000> can <sil=0.000> deliver <sil=0.000> only <sil=0.000> 1 coke <sil=0.000> at <sil=0.000> a time <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  as <sil=0.000> we
know <sil=0.000> in <sil=0.000> our <sil=0.000> knowledge <sil=0.000> of <sil=0.000> iteration <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> some <sil=0.000> function <sil=0.354> ;SEMICOLON  function <sil=0.000> is <sil=0.000> delivering <sil=0.000> coke <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> can
be <sil=0.000> repeated <sil=1.000> ,COMMA  this <sil=0.000> switch <sil=0.000> can <sil=0.000> be <sil=0.000> pressed <sil=1.000> ,COMMA  there <sil=0.000> is <sil=0.000> a switch <sil=1.000> ,COMMA  it <sil=0.000> can <sil=0.000> be <sil=0.000> pressed <sil=0.000> 5 times <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  first <sil=1.000> ,COMMA  1
coke <sil=0.000> comes <sil=0.000> out <sil=1.000> ,COMMA  second <sil=0.000> coke <sil=0.000> comes <sil=0.000> out <sil=0.000> so <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> being <sil=0.000> repeated <sil=0.000> 5 times <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> the <sil=0.000> conventional <sil=0.000> way <sil=0.000> of <sil=0.000> iterating <sil=1.000> ,COMMA  repeating <sil=0.000> the <sil=0.000> same <sil=0.000> thing <sil=0.000> in <sil=0.000> order <sil=0.000> to <sil=0.000> get <sil=0.000> the <sil=0.000> 5 cokes <sil=2.000> .PERIOD 
Let <sil=0.000> us <sil=0.000> try <sil=0.000> to <sil=0.000> do <sil=0.000> it <sil=0.000> in <sil=0.000> another <sil=0.000> way <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> assume <sil=0.000> that <sil=0.000> this <sil=0.000> machine <sil=0.000> can <sil=0.000> deliver <sil=0.000> 1 coke <sil=0.000> at <sil=0.000> a time <sil=1.000> ,COMMA 
but <sil=0.000> it <sil=0.000> can <sil=0.000> also <sil=0.000> clone <sil=0.000> itself <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> see <sil=0.000> how <sil=0.000> it <sil=0.000> looks <sil=0.000> like <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> need <sil=0.000> 5 cokes <sil=0.000> but <sil=0.000> I can <sil=0.000> deliver <sil=0.000> only <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> deliver <sil=0.000> only <sil=0.000> 1 coke <sil=0.000> but <sil=0.000> I will <sil=0.000> not <sil=0.000> deliver <sil=0.000> it
till <sil=0.000> I am <sil=0.000> ensured <sil=0.000> that <sil=0.000> all <sil=0.000> the <sil=0.000> 5 cokes <sil=0.000> are <sil=0.000> deliverable <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  what <sil=0.000> it <sil=0.000> does <sil=0.228> ?QUESTIONMARK  It <sil=0.000> clones <sil=0.000> itself <sil=0.000> makes <sil=0.000> another <sil=0.000> one <sil=0.000> copy <sil=0.000> of <sil=0.000> itself <sil=0.000> say <sil=0.000> and <sil=0.000> activates - this <sil=0.000> using
which <sil=0.000> I can <sil=0.000> deliver <sil=0.000> one <sil=0.000> coke <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> asked <sil=0.000> him <sil=0.000> to <sil=0.000> give <sil=0.000> a 4 <sil=0.000> cokes <sil=2.000> .PERIOD  Now <sil=0.000> this <sil=0.000> one <sil=0.000> can <sil=0.000> also <sil=0.000> deliver
only <sil=0.000> 1 coke <sil=0.000> and <sil=0.000> finds <sil=0.000> that <sil=0.000> ok <sil=1.000> ,COMMA  I <sil=0.000> cannot <sil=0.000> deliver <sil=0.000> everything <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> keep <sil=0.000> 1 coke <sil=0.000> ready <sil=1.000> ,COMMA  but <sil=0.000> I cloned
myself <sil=0.000> and <sil=0.000> another <sil=0.000> copy <sil=1.000> ,COMMA  I <sil=0.000> activate <sil=0.000> him - this <sil=0.000> machine <sil=0.000> and <sil=0.000> say <sil=0.000> please <sil=0.000> deliver <sil=0.000> 3 cokes <sil=1.000> ,COMMA  but <sil=0.000> it
cannot <sil=0.000> also <sil=0.000> deliver <sil=0.000> 3 cokes <sil=1.000> ,COMMA  it <sil=0.000> can <sil=0.000> deliver <sil=0.000> only <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  nothing <sil=0.000> is <sil=0.000> being <sil=0.000> delivered <sil=1.000> ,COMMA  but <sil=0.000> only <sil=0.000> kept
noted <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> puts <sil=0.000> somebody <sil=0.000> another <sil=0.000> clone <sil=0.000> please <sil=0.000> deliver <sil=0.000> 2 cokes <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> 1 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> also <sil=0.000> not <sil=0.000> delivering <sil=0.000> because <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> being <sil=0.000> able <sil=0.000> to <sil=0.000> satisfy <sil=0.000> the <sil=0.000> request <sil=0.000> of <sil=0.000> 2 cokes <sil=0.000> which <sil=0.000> has <sil=0.000> been <sil=0.000> opposed <sil=0.000> by <sil=0.000> this <sil=0.000> machine <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> now <sil=0.000> comes <sil=0.000> to <sil=0.000> another <sil=0.000> clone <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  asks <sil=0.000> this <sil=0.000> clone <sil=0.000> please

deliver <sil=0.000> 1 coke <sil=2.000> .PERIOD  Now <sil=0.000> as <sil=0.000> you <sil=0.000> know <sil=0.000> this <sil=0.000> machine <sil=0.000> can <sil=0.000> deliver <sil=0.000> 1 coke <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  it <sil=0.000> delivers <sil=0.000> 1 coke
and <sil=0.000> tells <sil=0.000> ok <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> delivered <sil=2.000> .PERIOD  Now <sil=0.000> this <sil=0.000> one <sil=1.000> ,COMMA  then <sil=0.000> since <sil=0.000> it <sil=0.000> has <sil=0.000> delivered <sil=1.000> ,COMMA  it <sil=0.000> delivers <sil=0.000> the <sil=0.000> other <sil=0.000> coke
which <sil=0.000> it <sil=0.000> could <sil=0.000> do  <sil=1.000> ,COMMA  it <sil=0.000> also <sil=0.000> tells <sil=0.000> it s <sil=0.000> requestor <sil=1.000> ,COMMA  its <sil=0.000> earlier <sil=0.000> version <sil=0.000> that <sil=0.000> I have <sil=0.000> done <sil=0.000> my <sil=0.000> thing <sil=1.000> ,COMMA  you <sil=0.000> do
yours <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> will <sil=0.000> it <sil=0.000> do <sil=0.228> ?QUESTIONMARK <sil=0.000> Remember <sil=0.000> it <sil=0.000> can <sil=0.000> only <sil=0.000> deliver <sil=0.000> one <sil=0.000> coke <sil=0.000> at <sil=0.000> a time <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> deliver <sil=0.000> another <sil=0.000> coke <sil=1.000> ,COMMA  it <sil=0.000> passes <sil=0.000> on <sil=0.000> to <sil=0.000> its <sil=0.000> caller <sil=0.000> or <sil=0.000> its <sil=0.000> generator <sil=0.000> that <sil=0.000> I have <sil=0.000> delivered <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
it <sil=0.000> delivers <sil=0.000> the <sil=0.000> other <sil=0.000> coke <sil=0.000> and <sil=0.000> ultimately <sil=0.000> this <sil=0.000> one <sil=0.000> also <sil=0.000> knows <sil=0.000> that <sil=0.000> it s <sil=0.000> child <sil=0.000> has <sil=0.000> delivered <sil=0.000> the <sil=0.000> coke <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  ultimately <sil=0.000> we <sil=0.000> get <sil=0.000> 5 cokes <sil=2.000> .PERIOD  This <sil=0.000> was <sil=0.000> one <sil=0.000> this <sil=0.000> is <sil=0.000> one <sil=0.000> way <sil=0.000> in <sil=0.000> which <sil=0.000> if <sil=0.000> each <sil=0.000> of <sil=0.000> this <sil=0.000> function <sil=1.000> ,COMMA 
each <sil=0.000> of <sil=0.000> these <sil=0.000> blocks <sil=1.000> ,COMMA  although <sil=0.000> they <sil=0.000> are <sil=0.000> the <sil=0.000> same <sil=0.000> function <sil=0.000> is <sil=0.000> being <sil=0.000> activated <sil=0.000> with <sil=0.000> different
requests <sil=0.000> and <sil=0.000> they <sil=0.000> are <sil=0.000> waiting <sil=0.000> till <sil=0.000> the <sil=0.000> request <sil=0.000> can <sil=0.000> be <sil=0.000> fulfilled <sil=2.000> .PERIOD 

But <sil=0.000> in <sil=0.000> the <sil=0.000> meanwhile <sil=0.000> it <sil=0.000> is <sil=0.000> passing <sil=0.000> on <sil=0.000> the <sil=0.000> request <sil=0.000> to <sil=0.000> another <sil=0.000> one <sil=0.000> and <sil=0.000> as <sil=0.000> soon <sil=0.000> as <sil=0.000> this <sil=0.000> could <sil=0.000> fulfil <sil=0.000> it <sil=1.000> ,COMMA  it <sil=0.000> passes <sil=0.000> it <sil=0.000> on <sil=0.000> and <sil=0.000> then <sil=0.000> it <sil=0.000> goes <sil=0.000> back <sil=2.000> .PERIOD  In <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> iteration <sil=0.000> what <sil=0.000> would <sil=0.000> have <sil=0.000> happened <sil=0.228> ?QUESTIONMARK  5 <sil=0.000> cokes <sil=0.000> would <sil=0.000> be <sil=0.000> generated <sil=0.000> by <sil=0.000> calling <sil=0.000> the <sil=0.000> same <sil=0.000> function <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> I call <sil=0.000> each <sil=0.000> of <sil=0.000> these <sil=0.000> as <sil=0.000> functions <sil=1.000> ,COMMA  then <sil=0.000> there <sil=0.000> is <sil=0.000> no <sil=0.000> difference <sil=0.000> between <sil=0.000> these <sil=0.000> function <sil=1.000> ,COMMA  the <sil=0.000> only <sil=0.000> difference <sil=0.000> is <sil=0.000> the <sil=0.000> value <sil=0.000> with <sil=0.000> which <sil=0.000> it <sil=0.000> is <sil=0.000> being <sil=0.000> called <sil=0.000> and <sil=0.000> this <sil=0.000> process <sil=0.000> is <sil=0.000> successful <sil=0.000> because <sil=0.000> ultimately <sil=0.000> there <sil=0.000> will <sil=0.000> be <sil=0.000> a situation <sil=0.000> when <sil=0.000> this <sil=0.000> function <sil=0.000> of <sil=0.000> this <sil=0.000> machine <sil=0.000> will <sil=0.000> be <sil=0.000> able <sil=0.000> to <sil=0.000> deliver <sil=0.000> what <sil=0.000> it <sil=0.000> has <sil=0.000> been <sil=0.000> asked <sil=0.000> to- deliver <sil=0.000> 1 coke <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
that <sil=0.000> will <sil=0.000> be <sil=0.000> done <sil=2.000> .PERIOD 

Therefore <sil=1.000> ,COMMA  we <sil=0.000> can <sil=0.000> go <sil=0.000> back <sil=0.000> and <sil=0.000> have <sil=0.000> everybody <sil=0.000> else <sil=0.000> deliver <sil=0.000> the <sil=0.000> same <sil=0.000> thing <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> the <sil=0.000> principle
of <sil=0.000> recursion <sil=2.000> .PERIOD  I <sil=0.000> just <sil=0.000> used <sil=0.000> it <sil=0.000> as <sil=0.000> a fun <sil=0.000> example <sil=1.000> ,COMMA  but <sil=0.000> let <sil=0.000> us <sil=0.000> now <sil=0.000> come <sil=0.000> to <sil=0.000> a little <sil=0.000> more <sil=0.000> serious <sil=0.000> look <sil=0.000> at
this <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> a process <sil=0.000> by <sil=0.000> which <sil=0.000> a function <sil=0.000> calls <sil=0.000> itself <sil=0.000> repeatedly <sil=1.000> ,COMMA  either <sil=0.000> directly <sil=0.000> like <sil=0.000> X is <sil=0.000> calling <sil=0.000> X or
cyclically <sil=0.000> in <sil=0.000> a chain <sil=0.000> like <sil=0.000> X is <sil=0.000> calling <sil=0.000> Y <sil=1.000> ,COMMA  Y <sil=0.000> is <sil=0.000> calling <sil=0.000> X basically <sil=0.000> used <sil=0.000> for <sil=0.000> repetitive <sil=0.000> computations <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  the <sil=0.000> best <sil=0.000> thing <sil=0.000> is <sil=0.000> you <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=0.000> example <sil=2.000> .PERIOD  All <sil=0.000> of <sil=0.000> us <sil=0.000> know <sil=0.000> that <sil=0.000> factorial <sil=0.000> 5 is <sil=0.000> nothing <sil=1.000> ,COMMA  but <sil=0.000> 5 <sil=1.000> ,COMMA  4
times <sil=0.000> 4 <sil=1.000> ,COMMA  times <sil=0.000> 3 <sil=1.000> ,COMMA  times <sil=0.000> 2 <sil=1.000> ,COMMA  times <sil=0.000> 1 <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  you <sil=0.000> see <sil=0.000> the <sil=0.000> same <sil=0.000> thing <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> say <sil=0.354> ;SEMICOLON  what <sil=0.000> is <sil=0.000> this <sil=0.000> part <sil=0.228> ?QUESTIONMARK  4 <sil=0.000> multiplied <sil=0.000> by <sil=0.000> 3 multiplied <sil=0.000> by <sil=0.000> 2
multiplied <sil=0.000> by <sil=0.000> 1 <sil=0.354> ;SEMICOLON  this <sil=0.000> is <sil=0.000> factorial <sil=0.000> 4 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you <sil=0.000> see <sil=0.000> I am <sil=0.000> expressing <sil=0.000> factorial <sil=0.000> 5 <sil=1.000> ,COMMA  factorial <sil=0.000> function <sil=0.000> in
terms <sil=0.000> of <sil=0.000> itself <sil=2.000> .PERIOD  5 <sil=0.000> times <sil=0.000> factorial <sil=0.000> 4 and <sil=0.000> factorial <sil=0.000> 4 can <sil=0.000> again <sil=0.000> be <sil=0.000> expressed <sil=0.000> as <sil=0.000> 4 times <sil=0.000> factorial <sil=0.000> 3
and <sil=0.000> factorial <sil=0.000> 3 can <sil=0.000> be <sil=0.000> expressed <sil=0.000> as <sil=0.000> 3 times <sil=0.000> factorial <sil=0.000> 2 and <sil=0.000> factorial <sil=0.000> 2 and <sil=0.000> be <sil=0.000> expressed <sil=0.000> in <sil=0.000> terms
of <sil=0.000> factorial <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  5 <sil=1.000> ,COMMA  4 <sil=1.000> ,COMMA  3 <sil=1.000> ,COMMA  2 <sil=0.000> and <sil=0.000> factorial <sil=0.000> 1 is <sil=0.000> the <sil=0.000> end <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> certainly <sil=0.000> getting <sil=0.000> the
factorial <sil=0.000> there <sil=0.000> without <sil=0.000> any <sil=0.000> further <sil=0.000> expansion <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  we <sil=0.000> can <sil=0.000> write <sil=0.000> in <sil=0.000> general <sil=0.000> factorial <sil=0.000> of <sil=0.000> n is <sil=0.000> n times <sil=0.000> factorial <sil=0.000> of <sil=0.000> n minus <sil=0.000> 1 and <sil=0.000> factorial <sil=0.000> of <sil=0.000> n
minus <sil=0.000> 1 will <sil=0.000> be <sil=0.000> n minus <sil=0.000> 1 into <sil=0.000> factorial <sil=0.000> of <sil=0.000> n minus <sil=0.000> 2 <sil=1.000> ,COMMA  factorial <sil=0.000> of <sil=0.000> n minus <sil=0.000> 2 will <sil=0.000> be <sil=0.000> n minus <sil=0.000> 2
into <sil=0.000> factorial <sil=0.000> of <sil=0.000> n minus <sil=0.000> 3 <sil=2.000> .PERIOD  In <sil=0.000> that <sil=0.000> way <sil=0.000> it <sil=0.000> will <sil=0.000> go <sil=0.000> on <sil=1.000> ,COMMA  but <sil=0.000> it <sil=0.000> will <sil=0.000> be <sil=0.000> successful <sil=0.000> only <sil=0.000> if <sil=0.000> there <sil=0.000> is <sil=0.000> a
terminating <sil=0.000> point <sil=0.000> where <sil=0.000> which <sil=0.000> we <sil=0.000> often <sil=0.000> call <sil=0.000> the <sil=0.000> basis <sil=0.000> condition <sil=2.000> .PERIOD  I <sil=0.000> hope <sil=0.000> you <sil=0.000> have <sil=0.000> understood
this <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  two <sil=0.000> conditions <sil=0.000> are <sil=0.000> to <sil=0.000> be <sil=0.000> satisfied  <sil=1.000> ,COMMA  in <sil=0.000> order <sil=0.000> for <sil=0.000> us <sil=0.000> to <sil=0.000> write <sil=0.000> a recursive <sil=0.000> formula <sil=2.000> .PERIOD  One <sil=0.000> is - it
should <sil=0.000> be <sil=0.000> possible <sil=0.000> to <sil=0.000> express <sil=0.000> the <sil=0.000> problem <sil=0.000> in <sil=0.000> the <sil=0.000> recursive <sil=0.000> form <sil=0.000> just <sil=0.000> like <sil=0.000> factorial <sil=0.000> n is <sil=0.000> n times
factorial <sil=0.000> n minus <sil=0.000> 1 and <sil=0.000> also <sil=0.000> there <sil=0.000> is <sil=0.000> another <sil=0.000> point <sil=0.000> that <sil=0.000> is <sil=0.000> the <sil=0.000> problem <sil=0.000> statement <sil=0.000> must <sil=0.000> include <sil=0.000> a
stopping <sil=0.000> condition <sil=1.000> ,COMMA  what <sil=0.000> was <sil=0.000> my <sil=0.000> stopping <sil=0.000> condition <sil=0.000> in <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> factorial <sil=0.228> ?QUESTIONMARK  Factorial <sil=0.000> 1 is <sil=0.000> 1 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  that <sil=0.000> was <sil=0.000> the <sil=0.000> stopping <sil=0.000> condition <sil=0.354> ;SEMICOLON  what <sil=0.000> was <sil=0.000> the <sil=0.000> stopping <sil=0.000> condition <sil=0.000> in <sil=0.000> the <sil=0.000> example <sil=0.000> of
delivering <sil=0.000> the <sil=0.000> coke <sil=0.228> ?QUESTIONMARK  When <sil=0.000> the <sil=0.000> machine <sil=0.000> was <sil=0.000> asked <sil=0.000> to <sil=0.000> deliver <sil=0.000> only <sil=0.000> 1 coke <sil=1.000> ,COMMA  then <sil=0.000> it <sil=0.000> can <sil=0.000> complete <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> a stopping <sil=0.000> condition <sil=0.000> and <sil=0.000> then <sil=0.000> we <sil=0.000> go <sil=0.000> back <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  the <sil=0.000> stopping <sil=0.000> factorial <sil=0.000> n is <sil=0.000> 1 if <sil=0.000> n is <sil=0.000> equal <sil=0.000> to <sil=0.000> 0 or <sil=0.000> n equal <sil=0.000> to <sil=0.000> 1 <sil=1.000> ,COMMA  otherwise <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> n into <sil=0.000> factorial <sil=0.000> n
minus <sil=0.000> 1 if <sil=0.000> n is <sil=0.000> greater <sil=0.000> than <sil=0.000> 0 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  ultimately <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> go <sil=0.000> on <sil=0.000> and <sil=0.000> ultimately <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> conclude <sil=2.000> .PERIOD 

Another <sil=0.000> example <sil=0.354> ;SEMICOLON  greatest <sil=0.000> common <sil=0.000> divisor <sil=1.000> ,COMMA  we <sil=0.000> can <sil=0.000> express <sil=0.000> that <sil=0.000> in <sil=0.000> a recursive <sil=0.000> form <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> very
interesting <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> look <sil=0.000> at <sil=0.000> it <sil=0.000> that <sil=0.000> the <sil=0.000> greatest <sil=0.000> common <sil=0.000> divisor <sil=0.000> of <sil=0.000> the <sil=0.000> same <sil=0.000> number <sil=0.000> is <sil=0.000> itself <sil=0.000> that
is <sil=0.000> the <sil=0.000> key <sil=0.000> to <sil=0.000> the <sil=0.000> logic <sil=2.000> .PERIOD  GCD <sil=0.000> of <sil=0.000> m and <sil=0.000> m is <sil=0.000> m and <sil=0.000> GCD <sil=0.000> of <sil=0.000> m and <sil=0.000> n is <sil=0.000> GCD <sil=0.000> of <sil=0.000> m minus <sil=0.000> n and <sil=0.000> n or
the <sil=0.000> other <sil=0.000> way <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  for <sil=0.000> example <sil=1.000> ,COMMA  GCD <sil=0.000> of <sil=0.000> 15 <sil=0.000> and <sil=0.000> 5 also <sil=0.000> 75 <sil=0.000> and <sil=0.000> 15 <sil=0.000> will <sil=0.000> be <sil=0.000> GCD <sil=0.000> of <sil=0.000> 60 <sil=0.000> and <sil=0.000> 15 <sil=1.000> ,COMMA 
GCD <sil=0.000> of <sil=0.000> 60 <sil=0.000> and <sil=0.000> 15 <sil=0.000> would <sil=0.000> be <sil=0.000> for <sil=0.000> GCD <sil=0.000> of <sil=0.000> 45 <sil=0.000> and <sil=0.000> 15 <sil=1.000> ,COMMA  GCD <sil=0.000> of <sil=0.000> 45 <sil=1.000> ,COMMA  15 <sil=0.000> would <sil=0.000> be <sil=0.000> GCD <sil=0.000> of <sil=0.000> 30 <sil=0.000> and <sil=0.000> 15 <sil=1.000> ,COMMA 
GCD <sil=0.000> of <sil=0.000> 30 <sil=0.000> and <sil=0.000> 15 <sil=0.000> will <sil=0.000> be <sil=0.000> GCD <sil=0.000> of <sil=0.000> 15 <sil=0.000> and <sil=0.000> 15 <sil=2.000> .PERIOD  Now <sil=0.000> I have <sil=0.000> got <sil=0.000> the <sil=0.000> stopping <sil=0.000> condition <sil=0.000> that <sil=0.000> GCD
of <sil=0.000> the <sil=0.000> same <sil=0.000> number <sil=0.000> will <sil=0.000> be <sil=0.000> 15 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  my <sil=0.000> result <sil=0.000> will <sil=0.000> be <sil=0.000> 15 <sil=0.000> is <sil=0.000> it <sil=0.000> clear <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> a recursive <sil=0.000> definition <sil=0.000> of <sil=0.000> GCD <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  most <sil=0.000> of <sil=0.000> the
interesting <sil=0.000> problems <sil=0.000> can <sil=0.000> be <sil=0.000> expressed <sil=0.000> in <sil=0.000> the <sil=0.000> form <sil=0.000> of <sil=0.000> in <sil=0.000> the <sil=0.000> recursive <sil=0.000> form <sil=0.000> and <sil=0.000> that <sil=0.000> helps <sil=0.000> in
writing <sil=0.000> a very <sil=0.000> second <sil=0.000> and <sil=0.000> tight <sil=0.000> code <sil=2.000> .PERIOD 

Here <sil=0.000> is <sil=0.000> another <sil=0.000> example <sil=0.000> of <sil=0.000> recursion <sil=0.000> Fibonacci <sil=0.000> series - a <sil=0.000> series <sil=0.000> like <sil=0.000> this <sil=0.000> one <sil=1.000> ,COMMA  then <sil=0.000> one <sil=1.000> ,COMMA  then <sil=0.000> 2 <sil=1.000> ,COMMA  2 <sil=0.000> is <sil=0.000> what <sil=0.000> the <sil=0.000> sum <sil=0.000> of <sil=0.000> the <sil=0.000> previous <sil=0.000> 2 elements <sil=0.000> 1 plus <sil=0.000> 1 and <sil=0.000> 3 <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> 3 <sil=0.228> ?QUESTIONMARK  3 <sil=0.000> is <sil=0.000> the <sil=0.000> sum <sil=0.000> of <sil=0.000> the <sil=0.000> previous <sil=0.000> two  <sil=0.354> ;SEMICOLON  2 <sil=0.000> and <sil=0.000> 1 <sil=1.000> ,COMMA  then <sil=0.000> 5 <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> 5 <sil=0.228> ?QUESTIONMARK  5 <sil=0.000> is <sil=0.000> the <sil=0.000> sum <sil=0.000> of <sil=0.000> the <sil=0.000> previous <sil=0.000> two <sil=2.000> .PERIOD 

Then <sil=0.000> 8 <sil=0.354> ;SEMICOLON  what <sil=0.000> is <sil=0.000> 8 <sil=0.228> ?QUESTIONMARK  8 <sil=0.000> is <sil=0.000> the <sil=0.000> sum <sil=0.000> of <sil=0.000> the <sil=0.000> previous <sil=0.000> two <sil=2.000> .PERIOD  5 <sil=0.000> and <sil=0.000> 3 <sil=1.000> ,COMMA  then <sil=0.000> 13 <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> 13 <sil=0.228> ?QUESTIONMARK  13 <sil=0.000> is <sil=0.000> the <sil=0.000> sum
of <sil=0.000> the <sil=0.000> previous <sil=0.000> two <sil=1.000> ,COMMA  8 <sil=0.000> and <sil=0.000> 5 <sil=1.000> ,COMMA  then <sil=0.000> 21 <sil=0.354> ;SEMICOLON  what <sil=0.000> is <sil=0.000> 21 <sil=0.228> ?QUESTIONMARK  21 <sil=0.000> is <sil=0.000> the <sil=0.000> sum <sil=0.000> of <sil=0.000> the <sil=0.000> previous <sil=0.000> two <sil=1.000> ,COMMA  13 <sil=0.000> and <sil=0.000> 8 <sil=1.000> ,COMMA 
you <sil=0.000> can <sil=0.000> see <sil=0.000> how <sil=0.000> nice <sil=0.000> this <sil=0.000> pattern <sil=0.000> is <sil=2.000> .PERIOD  Can <sil=0.000> you <sil=0.000> think <sil=0.000> of <sil=0.000> how <sil=0.000> we <sil=0.000> can <sil=0.000> write <sil=0.000> it <sil=0.000> in <sil=0.000> a recursive <sil=0.000> form <sil=1.000> ,COMMA 
how <sil=0.000> we <sil=0.000> can <sil=0.000> express <sil=0.000> it <sil=0.000> in <sil=0.000> a recursive <sil=0.000> form <sil=0.228> ?QUESTIONMARK  If <sil=0.000> you <sil=0.000> think <sil=0.000> a little <sil=0.000> bit <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> very <sil=0.000> easy <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be
something <sil=0.000> like <sil=0.000> Fibonacci <sil=0.000> number <sil=0.000> of <sil=0.000> n is <sil=0.000> Fibonacci <sil=0.000> of <sil=0.000> n minus <sil=0.000> 1 plus <sil=0.000> Fibonacci <sil=0.000> n minus <sil=0.000> 2 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  n <sil=0.000> 21- this <sil=0.000> one <sil=1.000> ,COMMA  is <sil=0.000> the <sil=0.000> sum <sil=0.000> of <sil=0.000> the <sil=0.000> earlier <sil=0.000> 2 Fibonacci <sil=0.000> sequences <sil=2.000> .PERIOD  Now <sil=0.000> f n <sil=0.000> minus <sil=0.000> 2 will <sil=0.000> be <sil=0.000> what
will <sil=0.000> be <sil=0.000> f n <sil=0.000> minus <sil=0.000> 3 plus <sil=0.000> f n <sil=0.000> minus <sil=0.000> 4 <sil=2.000> .PERIOD  Similarly <sil=1.000> ,COMMA  f <sil=0.000> n minus <sil=0.000> 1 will <sil=0.000> be <sil=0.000> f n <sil=0.000> minus <sil=0.000> 2 plus <sil=0.000> fn <sil=0.000> minus <sil=0.000> 3 in
that <sil=0.000> it <sil=0.000> will <sil=0.000> go <sil=0.000> on <sil=1.000> ,COMMA  but <sil=0.000> when <sil=0.000> will <sil=0.000> it <sil=0.000> stop <sil=0.228> ?QUESTIONMARK  The <sil=0.000> stopping <sil=0.000> condition <sil=0.000> is <sil=0.000> that <sil=0.000> Fibonacci <sil=0.000> of <sil=0.000> 1 is <sil=0.000> one <sil=2.000> .PERIOD  We
will <sil=0.000> see <sil=0.000> that <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  if <sil=0.000> we <sil=0.000> try <sil=0.000> to <sil=0.000> express <sil=0.000> it <sil=0.000> in <sil=0.000> the <sil=0.000> recursive <sil=0.000> form <sil=1.000> ,COMMA  it <sil=0.000> turns <sil=0.000> out <sil=0.000> to <sil=0.000> be <sil=0.000> Fibonacci <sil=0.000> of <sil=0.000> 0 is <sil=0.000> 1 <sil=2.000> .PERIOD 

That <sil=0.000> means <sil=0.000> the <sil=0.000> first <sil=0.000> element <sil=0.000> is <sil=0.000> one <sil=1.000> ,COMMA <sil=0.000> Fibonacci <sil=0.000> of <sil=0.000> 1 is <sil=0.000> 1 <sil=2.000> .PERIOD  There <sil=0.000> is <sil=0.000> a second <sil=0.000> element <sil=1.000> ,COMMA  then <sil=0.000> Fibonacci
of <sil=0.000> n is <sil=0.000> Fibonacci <sil=0.000> of <sil=0.000> n minus <sil=0.000> 1 plus <sil=0.000> Fibonacci <sil=0.000> of <sil=0.000> n minus <sil=0.000> 2 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  suppose <sil=0.000> I give <sil=0.000> you
Fibonacci <sil=0.000> of <sil=0.000> 5 <sil=1.000> ,COMMA  how <sil=0.000> do <sil=0.000> you <sil=0.000> write <sil=0.000> that <sil=0.228> ?QUESTIONMARK  It <sil=0.000> will <sil=0.000> be <sil=0.000> Fibonacci <sil=0.000> of <sil=0.000> 5 <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> Fibonacci <sil=0.000> of <sil=0.000> 4 plus
Fibonacci <sil=0.000> of <sil=0.000> 3 and <sil=0.000> Fibonacci <sil=0.000> of <sil=0.000> 3 will <sil=0.000> be <sil=0.000> Fibonacci <sil=0.000> of <sil=0.000> 2 plus <sil=0.000> Fibonacci <sil=0.000> of <sil=0.000> 1 and <sil=0.000> Fibonacci <sil=0.000> of <sil=0.000> 1
we <sil=0.000> know <sil=0.000> is <sil=0.000> 1 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> know <sil=0.000> this <sil=0.000> and <sil=0.000> then <sil=0.000> Fibonacci <sil=0.000> of <sil=0.000> 2 will <sil=0.000> be <sil=0.000> Fibonacci <sil=0.000> of <sil=0.000> 1 plus <sil=0.000> Fibonacci <sil=0.000> of <sil=0.000> 0 <sil=1.000> ,COMMA  I <sil=0.000> know <sil=0.000> that
this <sil=0.000> is <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> get <sil=0.000> this <sil=0.354> ;SEMICOLON  this <sil=0.000> is <sil=0.000> done <sil=2.000> .PERIOD  Similarly <sil=1.000> ,COMMA  once <sil=0.000> this <sil=0.000> is <sil=0.000> done <sil=0.000> I got <sil=0.000> this <sil=0.000> number <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what
would <sil=0.000> that <sil=0.000> be <sil=0.228> ?QUESTIONMARK  This <sil=0.000> will <sil=0.000> be <sil=0.000> 2 and <sil=0.000> so <sil=0.000> third <sil=0.000> one <sil=0.000> will <sil=0.000> be <sil=0.000> 2 <sil=1.000> ,COMMA  then <sil=0.000> Fibonacci <sil=0.000> of <sil=0.000> 4 will <sil=0.000> be <sil=0.000> 2 plus <sil=0.000> 3 <sil=1.000> ,COMMA  5 <sil=0.354> ;SEMICOLON 
in <sil=0.000> that <sil=0.000> way <sil=0.000> it <sil=0.000> will <sil=0.000> go <sil=0.000> on <sil=2.000> .PERIOD  Now <sil=0.000> we <sil=0.000> see <sil=0.354> ;SEMICOLON  how <sil=0.000> we <sil=0.000> can <sil=0.000> write <sil=0.000> a function <sil=1.000> ,COMMA  how <sil=0.000> we <sil=0.000> can <sil=0.000> express <sil=0.000> this
Fibonacci <sil=0.000> or <sil=0.000> this <sil=0.000> factorial <sil=1.000> ,COMMA  the <sil=0.000> recursive <sil=0.000> expression <sil=0.000> in <sil=0.000> the <sil=0.000> form <sil=0.000> of <sil=0.000> a function <sil=2.000> .PERIOD 

Let <sil=0.000> us <sil=0.000> see <sil=0.000> here <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> writing <sil=0.000> this <sil=1.000> ,COMMA  you <sil=0.000> had <sil=0.000> seen <sil=0.000> earlier <sil=0.000> functions <sil=0.000> written <sil=0.000> for <sil=0.000> factorial <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> see <sil=0.000> factorial <sil=0.000> n is <sil=0.000> if <sil=0.000> n equal <sil=0.000> to <sil=0.000> 0 <sil=1.000> ,COMMA  return <sil=0.000> 1 <sil=1.000> ,COMMA  otherwise <sil=0.000> return <sil=0.000> n times <sil=0.000> factorial <sil=0.000> n minus <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> will <sil=0.000> happen <sil=0.228> ?QUESTIONMARK  How <sil=0.000> will <sil=0.000> this <sil=0.000> be <sil=0.000> executed <sil=0.228> ?QUESTIONMARK  What <sil=0.000> will <sil=0.000> it <sil=0.000> return <sil=0.228> ?QUESTIONMARK  While <sil=0.000> returning <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> again <sil=0.000> call <sil=0.000> this <sil=0.000> function <sil=1.000> ,COMMA  again <sil=1.000> ,COMMA  this <sil=0.000> function <sil=0.000> will <sil=0.000> start <sil=0.000> in <sil=0.000> the <sil=0.000> same <sil=0.000> way <sil=0.000> just <sil=0.000> by <sil=0.000> replacing <sil=0.000> n with <sil=0.000> n minus <sil=0.000> 1
and <sil=0.000> here <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> come <sil=0.000> out <sil=0.000> with <sil=0.000> n minus <sil=0.000> 2 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> again <sil=0.000> be <sil=0.000> called <sil=0.000> with <sil=0.000> n minus <sil=0.000> 2 and <sil=0.000> so <sil=0.000> on
and <sil=0.000> so <sil=0.000> forth <sil=2.000> .PERIOD <sil=0.000> It <sil=0.000> will <sil=0.000> go <sil=0.000> on <sil=2.000> .PERIOD  Now <sil=0.000> how <sil=0.000> is <sil=0.000> that <sil=0.000> executed <sil=0.228> ?QUESTIONMARK 

The <sil=0.000> function <sil=0.000> as <sil=0.000> I said <sil=0.000> is <sil=0.000> not <sil=0.000> executed <sil=0.000> immediately <sil=1.000> ,COMMA  when <sil=0.000> I asked <sil=0.000> that <sil=0.000> coke <sil=0.000> machine <sil=0.000> to <sil=0.000> deliver <sil=0.000> 5
cokes <sil=1.000> ,COMMA  it <sil=0.000> did <sil=0.000> not <sil=0.000> deliver <sil=0.000> immediately <sil=1.000> ,COMMA  it <sil=0.000> could <sil=0.000> deliver <sil=0.000> 1 coke <sil=1.000> ,COMMA  but <sil=0.000> held <sil=0.000> it <sil=0.000> back <sil=1.000> ,COMMA  but <sil=0.000> created <sil=0.000> another
machine <sil=0.000> to <sil=0.000> deliver <sil=0.000> n minus <sil=0.000> 1 cokes <sil=0.000> and <sil=0.000> that <sil=0.000> machine <sil=0.000> held <sil=0.000> it <sil=0.000> back <sil=0.000> and <sil=0.000> generated <sil=0.000> another <sil=0.000> machine
to <sil=0.000> deliver <sil=0.000> n minus <sil=0.000> 2 cokes <sil=2.000> .PERIOD  In <sil=0.000> this <sil=0.000> way <sil=1.000> ,COMMA  it <sil=0.000> went <sil=0.000> on <sil=2.000> .PERIOD  They <sil=0.000> are <sil=0.000> kept <sil=0.000> aside <sil=0.000> on <sil=0.000> a stack <sil=0.000> one <sil=0.000> after
another <sil=0.000> until <sil=0.000> the <sil=0.000> stopping <sil=0.000> condition <sil=0.000> is <sil=0.000> encountered <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> remembered <sil=0.000> that <sil=0.000> I have <sil=0.000> to <sil=0.000> deliver <sil=0.000> one <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  if <sil=0.000> you <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=1.000> ,COMMA  I <sil=0.000> do <sil=0.000> not <sil=0.000> know <sil=0.000> whether <sil=0.000> that <sil=0.000> will <sil=0.000> visible <sil=0.000> or <sil=0.000> not <sil=2.000> .PERIOD  Here <sil=0.000> here <sil=0.000> you <sil=0.000> see
everybody <sil=0.000> remembered <sil=0.000> that <sil=0.000> I have <sil=0.000> to <sil=0.000> deliver <sil=1.000> ,COMMA  but <sil=0.000> they <sil=0.000> did <sil=0.000> not <sil=0.000> deliver <sil=1.000> ,COMMA  when <sil=0.000> the <sil=0.000> stopping
condition <sil=0.000> was <sil=0.000> met <sil=0.000> after <sil=0.000> that <sil=0.000> this <sil=0.000> back <sil=0.000> chain <sil=0.000> started <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  they <sil=0.000> are <sil=0.000> kept <sil=0.000> aside <sil=1.000> ,COMMA  but <sil=0.000> not <sil=0.000> delivered
immediately <sil=2.000> .PERIOD  Then <sil=0.000> the <sil=0.000> function <sil=0.000> calls <sil=0.000> are <sil=0.000> executed <sil=0.000> in <sil=0.000> reverse <sil=0.000> order <sil=2.000> .PERIOD  Again <sil=0.000> you <sil=0.000> can <sil=0.000> see <sil=0.000> that <sil=0.000> they
are <sil=0.000> executed <sil=0.000> in <sil=0.000> reverse <sil=0.000> order <sil=0.000> in <sil=0.000> order <sil=0.000> to <sil=0.000> get <sil=0.000> the <sil=0.000> solution <sil=2.000> .PERIOD 

Say <sil=0.000> I am <sil=0.000> calculating <sil=0.000> factorial <sil=0.000> 4 <sil=1.000> ,COMMA  first <sil=0.000> the <sil=0.000> function <sil=0.000> calls <sil=0.000> will <sil=0.000> be <sil=0.000> processed <sil=2.000> .PERIOD  Factorial <sil=0.000> 4 is <sil=0.000> factorial
4 <sil=0.000> times <sil=0.000> factorial <sil=0.000> 3 <sil=1.000> ,COMMA  then <sil=0.000> factorial <sil=0.000> 3 is <sil=0.000> 3 times <sil=0.000> factorial <sil=0.000> 2 <sil=1.000> ,COMMA  factorial <sil=0.000> 2 is <sil=0.000> 2 times <sil=0.000> factorial <sil=0.000> 1 <sil=0.354> ;SEMICOLON 
factorial <sil=0.000> 1 is <sil=0.000> 1 times <sil=0.000> factorial <sil=0.000> 0 and <sil=0.000> factorial <sil=0.000> 0 is <sil=0.000> 1 <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  the <sil=0.000> actual <sil=0.000> values <sil=0.000> will <sil=0.000> return <sil=0.000> in <sil=0.000> the <sil=0.000> reverse <sil=0.000> order <sil=0.354> ;SEMICOLON  1 <sil=0.000> into <sil=0.000> 1 is <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  factorial <sil=0.000> 1 is <sil=0.000> complete <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  1 <sil=0.000> into <sil=0.000> 2 is <sil=0.000> 2 that <sil=0.000> goes <sil=0.000> here <sil=1.000> ,COMMA  fact <sil=0.000> 2 is <sil=0.000> 2 <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> way <sil=1.000> ,COMMA  it <sil=0.000> goes <sil=0.000> on <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> goes <sil=0.000> back <sil=0.000> in <sil=0.000> this

direction <sil=0.000> ultimately <sil=1.000> ,COMMA  we <sil=0.000> get <sil=0.000> the <sil=0.000> result <sil=0.000> from <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> actual <sil=0.000> values <sil=0.000> return <sil=0.000> in <sil=0.000> reverse <sil=0.000> order <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  factorial <sil=0.000> 0 is <sil=0.000> 1 <sil=1.000> ,COMMA  factorial <sil=0.000> 1 is <sil=0.000> 1 times <sil=0.000> 1 is <sil=0.000> 1 <sil=1.000> ,COMMA  now <sil=0.000> the <sil=0.000> reverse <sil=0.000> order <sil=0.000> is <sil=0.000> being <sil=0.000> done <sil=0.000> 2 into <sil=0.000> 1 is <sil=0.000> 2 <sil=1.000> ,COMMA  3 <sil=0.000> into <sil=0.000> 2 is <sil=0.000> 6 and <sil=0.000> 4 into <sil=0.000> 6 <sil=1.000> ,COMMA  6 <sil=0.354> ;SEMICOLON  24 <sil=0.000> in <sil=0.000> that <sil=0.000> way <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> being <sil=0.000> computed <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> a stack <sil=2.000> .PERIOD  Stack <sil=0.000> is <sil=0.000> a data <sil=0.000> structure <sil=1.000> ,COMMA  stack <sil=0.000> is <sil=0.000> a way <sil=0.000> of <sil=0.000> storing <sil=0.000> data <sil=0.000> where <sil=0.000> we <sil=0.000> stored <sil=0.000> the
data <sil=0.000> just <sil=0.000> where <sil=0.000> whatever <sil=0.000> comes <sil=0.000> in <sil=0.000> first <sil=0.354> ;SEMICOLON  obviously <sil=1.000> ,COMMA  goes <sil=0.000> out <sil=0.000> last <sil=0.000> because <sil=0.000> if <sil=0.000> I put <sil=0.000> something <sil=0.000> here
and <sil=0.000> above <sil=0.000> that <sil=0.000> I put <sil=0.000> something <sil=0.000> just <sil=0.000> like <sil=0.000> a stack <sil=0.000> of <sil=0.000> books <sil=1.000> ,COMMA  you <sil=0.000> will <sil=0.000> have <sil=0.000> to <sil=0.000> take <sil=0.000> it <sil=0.000> out <sil=0.000> in <sil=0.000> the <sil=0.000> other
way <sil=1.000> ,COMMA  this <sil=0.000> one <sil=0.000> will <sil=0.000> come <sil=0.000> out <sil=0.000> first <sil=0.000> then <sil=0.000> this <sil=0.000> one <sil=0.000> will <sil=0.000> come <sil=0.000> out <sil=0.000> then <sil=0.000> this <sil=0.000> one <sil=0.000> will <sil=0.000> come <sil=0.000> out <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let
us <sil=0.000> see <sil=0.000> how <sil=0.000> it <sil=0.000> works <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  factorial <sil=0.000> 4 <sil=1.000> ,COMMA  factor <sil=0.000> step <sil=0.000> 0 executes <sil=0.000> factorial <sil=0.000> 4 <sil=2.000> .PERIOD  Now <sil=0.000> return <sil=0.000> 4 times <sil=0.000> factorial <sil=0.000> 3 <sil=1.000> ,COMMA  you <sil=0.000> see <sil=0.000> here <sil=0.000> is
the <sil=0.000> recursive <sil=0.000> call <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> calling <sil=0.000> itself <sil=0.000> return <sil=0.000> 4 times <sil=0.000> factorial <sil=0.000> 3 <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> factorial <sil=0.000> 3 <sil=1.000> ,COMMA  oh <sil=0.000> you <sil=0.000> do <sil=0.000> not
know <sil=0.354> ;SEMICOLON  what <sil=0.000> is <sil=0.000> factorial <sil=0.000> 3 <sil=0.228> ?QUESTIONMARK  Return <sil=0.000> 3 times <sil=0.000> factorial <sil=0.000> true <sil=0.000> 2 <sil=2.000> .PERIOD  Oh <sil=0.000> you <sil=0.000> do <sil=0.000> not <sil=0.000> know <sil=0.354> ;SEMICOLON  what <sil=0.000> is <sil=0.000> factorial
clue <sil=0.000> 2  <sil=0.228> ?QUESTIONMARK  Then <sil=0.000> return <sil=0.000> 2 into <sil=0.000> factorial <sil=0.000> 1 or <sil=0.000> you <sil=0.000> still <sil=0.000> do <sil=0.000> not <sil=0.000> know <sil=0.354> ;SEMICOLON  what <sil=0.000> is <sil=0.000> factorial <sil=0.000> 1 <sil=0.228> ?QUESTIONMARK  Return <sil=0.000> 1 into
factorial <sil=0.000> 0 and <sil=0.000> so <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  you <sil=0.000> know <sil=0.000> factorial <sil=0.000> 0 is <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you <sil=0.000> get <sil=0.000> 1 and <sil=0.000> now <sil=0.000> you <sil=0.000> could <sil=0.000> not <sil=0.000> answer
these <sil=0.000> questions <sil=0.000> earlier <sil=0.000> so <sil=0.000> I have <sil=0.000> broken <sil=0.000> it <sil=0.000> down <sil=0.000> and <sil=0.000> given <sil=0.000> you <sil=0.000> an <sil=0.000> easier <sil=0.000> solution <sil=2.000> .PERIOD 

And <sil=0.000> so <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  you <sil=0.000> go <sil=0.000> back <sil=0.000> here <sil=0.000> and <sil=0.000> you <sil=0.000> return <sil=0.000> one <sil=0.000> into <sil=0.000> one <sil=0.000> then <sil=0.000> you <sil=0.000> go <sil=0.000> back <sil=0.000> here <sil=1.000> ,COMMA  return <sil=0.000> 1 into
2 <sil=1.000> ,COMMA  return <sil=0.000> 2 and <sil=0.000> you <sil=0.000> go <sil=0.000> back <sil=0.000> here  <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> what <sil=0.000> is <sil=0.000> meant <sil=0.000> by <sil=0.000> recursion <sil=0.000> if <sil=0.000> we <sil=0.000> redo <sil=0.000> it <sil=0.000> if <sil=0.000> we <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> the <sil=0.000> computer <sil=0.000> implementation <sil=0.000> of <sil=0.000> that <sil=0.000> factorial <sil=0.000> if <sil=0.000> n is <sil=0.000> less <sil=0.000> than <sil=0.000> 0 <sil=1.000> ,COMMA  return <sil=0.000> 1 <sil=1.000> ,COMMA  return <sil=0.000> n
times <sil=0.000> factorial <sil=0.000> n minus <sil=0.000> 1 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  computes <sil=0.000> 5 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> again <sil=0.000> recursively <sil=0.000> expressing <sil=0.000> itself <sil=0.000> f 4 <sil=0.000> is <sil=0.000> being <sil=0.000> expressed <sil=0.000> in <sil=0.000> terms <sil=0.000> of <sil=0.000> f 3 <sil=1.000> ,COMMA  everything <sil=0.000> is <sil=0.000> being <sil=0.000> expressed <sil=1.000> ,COMMA  f <sil=0.000> is <sil=0.000> being <sil=0.000> expressed <sil=0.000> in <sil=0.000> terms <sil=0.000> of <sil=0.000> f <sil=1.000> ,COMMA  f <sil=0.000> 3 is <sil=0.000> being <sil=0.000> expressed <sil=0.000> in <sil=0.000> terms <sil=0.000> of <sil=0.000> f 2 <sil=1.000> ,COMMA  f <sil=0.000> 2 is <sil=0.000> being <sil=0.000> expressed <sil=0.000> in <sil=0.000> terms <sil=0.000> of <sil=0.000> f 1 <sil=1.000> ,COMMA  f <sil=0.000> 1 is <sil=0.000> being <sil=0.000> expressed <sil=0.000> in <sil=0.000> terms <sil=0.000> of <sil=0.000> f 0 <sil=0.000> and <sil=0.000> I know <sil=0.000> what <sil=0.000> f 0 <sil=0.000> is <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  f <sil=0.000> 0 is <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> go <sil=0.000> back <sil=0.000> and <sil=0.000> I know <sil=0.000> that <sil=0.000> now <sil=0.000> f 0 <sil=0.000> is <sil=0.000> 1 <sil=2.000> .PERIOD 

Therefore <sil=0.000> f 1 <sil=0.000> is <sil=0.000> 1 into <sil=0.000> 1 and <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=1.000> ,COMMA  I <sil=0.000> go <sil=0.000> back <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  you <sil=0.000> see <sil=0.000> it <sil=0.000> had <sil=0.000> expanded <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=2.000> .PERIOD 
Now <sil=0.000> it <sil=0.000> is <sil=0.000> shrinking <sil=0.000> 1 into <sil=0.000> 1 is <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  I <sil=0.000> know <sil=0.000> factorial <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> will <sil=0.000> shrink <sil=0.354> ;SEMICOLON  now <sil=0.000> I know
what <sil=0.000> is <sil=0.000> factorial <sil=0.000> 2 that <sil=0.000> is <sil=0.000> 2 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> will <sil=0.000> shrink <sil=0.000> 3 into <sil=0.000> 2 <sil=0.354> ;SEMICOLON  6 <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> shrinking <sil=0.000> coming <sil=0.000> here - 24 <sil=0.000> and
then <sil=0.000> here <sil=0.000> it <sil=0.000> is <sil=0.000> 120 <sil=0.354> ;SEMICOLON  that <sil=0.000> is <sil=0.000> how <sil=0.000> as <sil=0.000> if <sil=0.000> in <sil=0.000> a spring <sil=0.000> it <sil=0.000> got <sil=0.000> expanded <sil=0.000> and <sil=0.000> then <sil=0.000> it <sil=0.000> contracted <sil=0.000> back <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> recursion <sil=0.000> return <sil=0.000> it <sil=0.000> ultimately <sil=0.000> returns <sil=0.000> factorial <sil=0.000> 5 to <sil=0.000> be <sil=0.000> 120 <sil=2.000> .PERIOD 

Another <sil=0.000> example <sil=0.000> will <sil=0.000> be <sil=0.000> Fibonacci <sil=0.000> number <sil=2.000> .PERIOD  We <sil=0.000> will <sil=0.000> explain <sil=0.000> it <sil=0.000> in <sil=0.000> the <sil=0.000> next <sil=0.000> lecture <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  we <sil=0.000> are <sil=0.000> looking <sil=0.000> at <sil=0.000> recursion <sil=0.000> and <sil=0.000> that <sil=0.000> is <sil=0.000> a new <sil=0.000> style <sil=0.000> of <sil=0.000> programming <sil=0.000> where <sil=0.000> we <sil=0.000> can <sil=0.000> express <sil=0.000> a
particular <sil=0.000> function <sil=0.000> in <sil=0.000> terms <sil=0.000> of <sil=0.000> itself <sil=0.000> like <sil=0.000> I can <sil=0.000> express <sil=0.000> factorial <sil=0.000> n in <sil=0.000> terms <sil=0.000> of <sil=0.000> factorial <sil=0.000> n into
factorial <sil=0.000> n minus <sil=0.000> 1 ok <sil=2.000> .PERIOD  Another <sil=0.000> very <sil=0.000> common <sil=0.000> example <sil=0.000> and <sil=0.000> easy <sil=0.000> example <sil=0.000> of <sil=0.000> recursion <sil=0.000> is
Fibonacci <sil=0.000> numbers <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> already <sil=0.000> told <sil=0.000> you <sil=0.354> ;SEMICOLON  what <sil=0.000> Fibonacci <sil=0.000> sequence <sil=0.000> is <sil=1.000> ,COMMA <sil=0.000> the <sil=0.000> Fibonacci
sequence <sil=0.000> can <sil=0.000> be <sil=0.000> expressed <sil=0.000> as <sil=0.000> f 0 <sil=1.000> ,COMMA  the <sil=0.000> 0th <sil=0.000> Fibonacci <sil=0.000> number <sil=0.000> is <sil=0.000> 0 <sil=2.000> .PERIOD  The <sil=0.000> next <sil=0.000> one <sil=0.000> is <sil=0.000> also <sil=0.000> 1 <sil=2.000> .PERIOD 

And <sil=0.000> henceforth <sil=1.000> ,COMMA  all <sil=0.000> other <sil=0.000> ones <sil=0.000> are <sil=0.000> sum <sil=0.000> of <sil=0.000> the <sil=0.000> previous <sil=0.000> two <sil=0.354> ;SEMICOLON  so <sil=1.000> ,COMMA  0 <sil=1.000> ,COMMA  1 <sil=1.000> ,COMMA  1 <sil=1.000> ,COMMA  2 <sil=1.000> ,COMMA  3 <sil=1.000> ,COMMA  5 <sil=1.000> ,COMMA  8 <sil=1.000> ,COMMA  13 <sil=1.000> ,COMMA  21 <sil=1.000> ,COMMA  so <sil=0.000> and
so <sil=0.000> forth <sil=2.000> .PERIOD  Therefore <sil=1.000> ,COMMA  we <sil=0.000> should <sil=0.000> be <sil=0.000> able <sil=0.000> to <sil=0.000> define <sil=0.000> it <sil=0.000> in <sil=0.000> terms <sil=0.000> of <sil=0.000> a recursive <sil=0.000> function <sil=0.000> because <sil=0.000> you
can <sil=0.000> see <sil=0.000> this <sil=0.000> function <sil=0.000> f and <sil=0.000> this <sil=0.000> function <sil=0.000> f are <sil=0.000> the <sil=0.000> same <sil=1.000> ,COMMA  only <sil=0.000> variations <sil=0.000> are <sil=0.000> in <sil=0.000> these <sil=0.000> parameters <sil=2.000> .PERIOD  I
am <sil=0.000> expressing <sil=0.000> the <sil=0.000> same <sil=0.000> function <sil=0.000> in <sil=0.000> terms <sil=0.000> of <sil=0.000> these <sil=0.000> parameters <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> function <sil=0.000> definition <sil=0.000> will <sil=0.000> be
is <sil=0.000> very <sil=0.000> simple <sil=0.000> f <sil=0.354> ;SEMICOLON  int <sil=0.000> end <sil=0.000> some <sil=0.000> integer <sil=1.000> ,COMMA  if <sil=0.000> n is <sil=0.000> less <sil=0.000> than <sil=0.000> 2 <sil=1.000> ,COMMA  then <sil=0.000> return <sil=0.000> n if <sil=0.000> n is <sil=0.000> less <sil=0.000> than <sil=0.000> 2 if <sil=0.000> it <sil=0.000> is <sil=0.000> 0
then <sil=0.000> 0 <sil=2.000> .PERIOD 

If <sil=0.000> it <sil=0.000> is <sil=0.000> 1 <sil=1.000> ,COMMA  then <sil=0.000> it <sil=0.000> is <sil=0.000> 1 <sil=1.000> ,COMMA  otherwise <sil=0.000> what <sil=0.000> did <sil=0.000> you <sil=0.000> return <sil=0.228> ?QUESTIONMARK  Return <sil=0.000> f n <sil=0.000> minus <sil=0.000> 1 plus <sil=0.000> f n <sil=0.000> minus <sil=0.000> 2 <sil=1.000> ,COMMA  sum <sil=0.000> of
the <sil=0.000> previous <sil=0.000> 2 Fibonacci <sil=0.000> numbers <sil=2.000> .PERIOD  Now <sil=0.000> this <sil=0.000> is <sil=0.000> interesting <sil=0.000> because <sil=0.000> again <sil=0.000> if <sil=0.000> you <sil=0.000> see <sil=0.000> how <sil=0.000> this <sil=0.000> will
be <sil=0.000> computed <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> first <sil=0.000> expanding <sil=0.000> what <sil=0.000> are <sil=0.000> the <sil=0.000> things <sil=0.000> I have <sil=0.000> to <sil=0.000> compute <sil=0.000> and <sil=0.000> when <sil=0.000> it <sil=0.000> meets
stopping <sil=0.000> condition <sil=0.000> then <sil=0.000> it <sil=0.000> starts <sil=0.000> collecting <sil=0.000> back <sil=0.000> and <sil=0.000> comes <sil=0.000> back <sil=2.000> .PERIOD 

If <sil=0.000> I want <sil=0.000> to <sil=0.000> compute <sil=0.000> Fibonacci <sil=0.000> of <sil=0.000> 4 <sil=1.000> ,COMMA  how <sil=0.000> many <sil=0.000> times <sil=0.000> will <sil=0.000> that <sil=0.000> function <sil=0.000> be <sil=0.000> called <sil=0.228> ?QUESTIONMARK  Let <sil=0.000> us <sil=0.000> look <sil=0.000> at
the <sil=0.000> expansion <sil=0.000> of <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  how <sil=0.000> will <sil=0.000> it <sil=0.000> happen <sil=0.228> ?QUESTIONMARK  I <sil=0.000> want <sil=0.000> to <sil=0.000> compute <sil=0.000> Fibonacci <sil=0.000> of <sil=0.000> 4 which <sil=0.000> is
Fibonacci <sil=0.000> of <sil=0.000> 3 <sil=1.000> ,COMMA <sil=0.000> Fibonacci <sil=0.000> of <sil=0.000> 2 <sil=1.000> ,COMMA  these <sil=0.000> 2 should <sil=0.000> be <sil=0.000> added <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> not <sil=0.000> yet <sil=0.000> have <sil=0.000> found <sil=0.000> out
anything <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> just <sil=0.000> decomposing <sil=0.000> the <sil=0.000> problem  <sil=2.000> .PERIOD 

There <sil=0.000> is <sil=0.000> a very <sil=0.000> very <sil=0.000> important <sil=0.000> concept <sil=0.000> that <sil=0.000> in <sil=0.000> order <sil=0.000> to <sil=0.000> solve <sil=0.000> the <sil=0.000> problem <sil=1.000> ,COMMA  I <sil=0.000> want <sil=0.000> to <sil=0.000> decompose <sil=0.000> it
into <sil=0.000> smaller <sil=0.000> sub <sil=0.000> problems <sil=2.000> .PERIOD  For <sil=0.000> f 4 <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> to <sil=0.000> solve <sil=0.000> it <sil=0.000> by <sil=0.000> solving <sil=0.000> f 3 <sil=0.000> and <sil=0.000> f 2 <sil=2.000> .PERIOD  Now <sil=0.000> for <sil=0.000> solving <sil=0.000> f 3 <sil=1.000> ,COMMA  I
have <sil=0.000> to <sil=0.000> solve <sil=0.000> f 2 <sil=0.000> and <sil=0.000> f 1 <sil=1.000> ,COMMA  I <sil=0.000> further <sil=0.000> decomposed <sil=0.000> it <sil=2.000> .PERIOD  Now <sil=0.000> for <sil=0.000> solving <sil=0.000> f 2 <sil=0.000> I have <sil=0.000> to <sil=0.000> solve <sil=0.000> f 1 <sil=0.000> and <sil=0.000> f 0 <sil=2.000> .PERIOD 
Even <sil=0.000> now <sil=0.000> the <sil=0.000> entire <sil=0.000> thing <sil=0.000> has <sil=0.000> not <sil=0.000> been <sil=0.000> broken <sil=0.000> down <sil=1.000> ,COMMA  f <sil=0.000> 2 <sil=1.000> ,COMMA  for <sil=0.000> that <sil=0.000> I have <sil=0.000> to <sil=0.000> solve <sil=0.000> f 1 <sil=0.000> and <sil=0.000> f 0 <sil=2.000> .PERIOD  Now <sil=0.000> I have <sil=0.000> expanded <sil=0.000> the <sil=0.000> whole <sil=0.000> thing <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  I <sil=0.000> know <sil=0.000> that <sil=0.000> f 1 <sil=0.000> is <sil=0.000> 1 <sil=1.000> ,COMMA  f <sil=0.000> 0 is <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  f <sil=0.000> 2 will <sil=0.000> be <sil=0.000> 1 plus <sil=0.000> 1 <sil=0.354> ;SEMICOLON  2 <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> known <sil=1.000> ,COMMA  all <sil=0.000> these <sil=0.000> endpoints <sil=0.000> of
this <sil=0.000> structure <sil=0.000> are <sil=0.000> known - 1 <sil=0.000> 0 <sil=1.000> ,COMMA  1 <sil=1.000> ,COMMA  1 <sil=1.000> ,COMMA  0 <sil=1.000> ,COMMA  1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> go <sil=0.000> on <sil=0.000> adding <sil=0.000> them <sil=0.000> and <sil=0.000> ultimately <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> get <sil=0.000> f 4 <sil=2.000> .PERIOD 
Now <sil=0.000> it <sil=0.000> is <sil=0.000> in <sil=0.000> a way <sil=0.000> inefficient <sil=1.000> ,COMMA  because <sil=0.000> the <sil=0.000> same <sil=0.000> thing <sil=0.000> is <sil=0.000> being <sil=0.000> computed <sil=0.000> repeatedly <sil=1.000> ,COMMA  but <sil=0.000> to <sil=0.000> a practiced <sil=0.000> programmer <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> make <sil=0.000> your <sil=0.000> programming <sil=0.000> much <sil=0.000> more <sil=0.000> easier <sil=1.000> ,COMMA  I <sil=0.000> mean <sil=0.000> less <sil=0.000> line <sil=0.000> lines
of <sil=0.000> codes <sil=0.000> if <sil=0.000> you <sil=0.000> can <sil=0.000> express <sil=0.000> it <sil=0.000> in <sil=0.000> a much <sil=0.000> better <sil=0.000> way <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> see <sil=0.000> here <sil=0.354> ;SEMICOLON  how <sil=0.000> many <sil=0.000> times <sil=0.000> the <sil=0.000> function <sil=0.000> was <sil=0.000> called <sil=0.228> ?QUESTIONMARK  1 <sil=1.000> ,COMMA  2 <sil=1.000> ,COMMA  3 <sil=1.000> ,COMMA  4 <sil=1.000> ,COMMA  5 <sil=1.000> ,COMMA  6 <sil=1.000> ,COMMA  7 <sil=1.000> ,COMMA  8 <sil=1.000> ,COMMA  9 <sil=0.000> times <sil=0.354> ;SEMICOLON  9
times <sil=0.000> the <sil=0.000> same <sil=0.000> function <sil=0.000> was <sil=0.000> called <sil=0.000> in <sil=0.000> order <sil=0.000> to <sil=0.000> compute <sil=0.000> f 4 <sil=2.000> .PERIOD 

Now <sil=0.000> the <sil=0.000> stopping <sil=0.000> condition <sil=0.000> of <sil=0.000> the <sil=0.000> base <sil=0.000> condition <sil=0.000> is <sil=0.000> very <sil=0.000> very <sil=0.000> important <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> n is <sil=0.000> 0 or <sil=0.000> n is <sil=0.000> 1 <sil=1.000> ,COMMA 
then <sil=0.000> I return <sil=0.000> 1 <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> the <sil=0.000> base <sil=0.000> case <sil=1.000> ,COMMA  unless <sil=0.000> I reach <sil=0.000> at <sil=0.000> this <sil=0.000> point <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> not <sil=0.000> be <sil=0.000> able <sil=0.000> to <sil=0.000> compute <sil=0.000> the <sil=0.000> entire <sil=0.000> solution <sil=2.000> .PERIOD 

Return <sil=0.000> Fibonacci <sil=0.000> of <sil=0.000> n minus <sil=0.000> 1 plus <sil=0.000> Fibonacci <sil=0.000> of <sil=0.000> n minus <sil=0.000> 2 - that <sil=0.000> is <sil=0.000> the <sil=0.000> code <sil=0.000> for <sil=0.000> the <sil=0.000> Fibonacci
number <sil=2.000> .PERIOD  Now <sil=0.000> whenever <sil=0.000> I will <sil=0.000> have <sil=0.000> too <sil=0.000> many <sil=0.000> calls <sil=0.000> in <sil=0.000> that <sil=0.000> case <sil=1.000> ,COMMA  I <sil=0.000> should <sil=0.000> avoid <sil=0.000> them <sil=0.000> as <sil=0.000> much <sil=0.000> as
possible <sil=0.000> and <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> the <sil=0.000> difference <sil=0.228> ?QUESTIONMARK 

Between <sil=0.000> recursion <sil=0.000> and <sil=0.000> iteration <sil=0.228> ?QUESTIONMARK  In <sil=0.000> iteration <sil=0.000> there <sil=0.000> is <sil=0.000> an <sil=0.000> explicit <sil=0.000> loop <sil=0.000> for <sil=0.000> i equals <sil=0.000> 0 <sil=1.000> ,COMMA  i <sil=0.000> less <sil=0.000> than
equal <sil=0.000> to <sil=0.000> n minus <sil=0.000> 1 i <sil=0.000> plus <sil=0.000> plus <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  there <sil=0.000> is <sil=0.000> an <sil=0.000> explicit <sil=0.000> loop <sil=0.000> whereas <sil=1.000> ,COMMA  in <sil=0.000> case <sil=0.000> of <sil=0.000> recursion <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> repeated <sil=0.000> function <sil=0.000> calls <sil=2.000> .PERIOD 
Termination <sil=0.000> iteration <sil=0.000> if <sil=0.000> the <sil=0.000> loop <sil=0.000> condition <sil=0.000> is <sil=0.000> no <sil=0.000> longer <sil=0.000> satisfied <sil=0.000> while <sil=0.000> this <sil=0.000> condition <sil=0.000> do <sil=1.000> ,COMMA  if <sil=0.000> that
condition <sil=0.000> fails <sil=1.000> ,COMMA  then <sil=0.000> we <sil=0.000> come <sil=0.000> out <sil=0.000> of <sil=0.000> the <sil=0.000> loop <sil=2.000> .PERIOD  In <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> recursion <sil=1.000> ,COMMA  the <sil=0.000> base <sil=0.000> condition <sil=0.000> must <sil=0.000> be <sil=0.000> recognised <sil=0.000> whenever <sil=0.000> we <sil=0.000> are <sil=0.000> getting <sil=0.000> the <sil=0.000> base <sil=0.000> condition <sil=0.354> ;SEMICOLON  factorial <sil=0.000> one <sil=0.000> or <sil=0.000> factorial <sil=0.000> 0 Fibonacci <sil=0.000> of <sil=0.000> 0 or <sil=0.000> Fibonacci <sil=0.000> of <sil=0.000> 1 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  those <sil=0.000> are <sil=0.000> the <sil=0.000> base <sil=0.000> conditions <sil=1.000> ,COMMA  if <sil=0.000> wrongly <sil=0.000> programmed <sil=0.000> both <sil=0.000> can <sil=0.000> have <sil=0.000> infinite <sil=0.000> loop <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the
performance <sil=0.000> wise <sil=0.000> iteration <sil=0.000> often <sil=0.000> gives <sil=0.000> faster <sil=0.000> result <sil=1.000> ,COMMA  but <sil=0.000> it <sil=0.000> is <sil=0.000> a good <sil=0.000> software <sil=0.000> engineering <sil=0.000> practice <sil=0.000> to <sil=0.000> gradually <sil=0.000> get <sil=0.000> accustomed <sil=0.000> to <sil=0.000> recursion <sil=0.000> as <sil=0.000> you <sil=0.000> do <sil=0.000> more <sil=0.000> and <sil=0.000> more <sil=0.000> programming <sil=1.000> ,COMMA  you <sil=0.000> will <sil=0.000> see <sil=0.000> that <sil=0.000> you <sil=0.000> will <sil=0.000> be <sil=0.000> able <sil=0.000> to <sil=0.000> express <sil=0.000> the <sil=0.000> things <sil=0.000> in <sil=0.000> a much <sil=0.000> subtler <sil=0.000> way <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  whenever <sil=0.000> there <sil=0.000> is <sil=0.000> a performance <sil=0.000> issue <sil=0.000> try <sil=0.000> to <sil=0.000> avoid <sil=0.000> recursion <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> require <sil=0.000> additional
memory <sil=0.000> also <sil=2.000> .PERIOD  There <sil=0.000> is <sil=0.000> a particular <sil=0.000> type <sil=0.000> of <sil=0.000> storage <sil=0.000> that <sil=0.000> is <sil=0.000> required <sil=0.000> in <sil=0.000> recursion <sil=0.000> that <sil=0.000> is <sil=0.000> known <sil=0.000> as
stack <sil=2.000> .PERIOD  Stack <sil=0.000> is <sil=0.000> a last <sil=0.000> in <sil=0.000> first <sil=0.000> out <sil=0.000> type <sil=0.000> of <sil=0.000> structure <sil=2.000> .PERIOD 

Briefly <sil=1.000> ,COMMA  let <sil=0.000> me <sil=0.000> tell <sil=0.000> you <sil=0.354> ;SEMICOLON  how <sil=0.000> this <sil=0.000> thing <sil=0.000> is <sil=0.000> done <sil=0.000> because <sil=0.000> stack <sil=0.000> is <sil=0.000> nothing <sil=1.000> ,COMMA  but <sil=0.000> a structure <sil=0.000> where <sil=0.000> we
can <sil=0.000> push <sil=0.000> in <sil=0.000> data <sil=0.000> from <sil=0.000> one <sil=0.000> side - say <sil=0.000> I put <sil=0.000> say <sil=0.000> 5 first <sil=1.000> ,COMMA  I <sil=0.000> push <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  5 <sil=0.000> comes <sil=0.000> here <sil=1.000> ,COMMA  then <sil=0.000> I push <sil=0.000> 4 <sil=1.000> ,COMMA  then
I <sil=0.000> do <sil=0.000> n minus <sil=0.000> 1 <sil=1.000> ,COMMA  3 <sil=0.000> is <sil=0.000> pushed <sil=1.000> ,COMMA  then <sil=0.000> 2 is <sil=0.000> pushed <sil=0.000> then <sil=0.000> n minus <sil=0.000> 1 again <sil=0.000> and <sil=0.000> 1 is <sil=0.000> pushed <sil=2.000> .PERIOD  Now <sil=0.000> when <sil=0.000> I
take <sil=0.000> out <sil=0.000> the <sil=0.000> data <sil=1.000> ,COMMA  the <sil=0.000> data <sil=0.000> will <sil=0.000> come <sil=0.000> out <sil=0.000> as <sil=0.000> 1 <sil=1.000> ,COMMA  then <sil=0.000> 2 <sil=1.000> ,COMMA  then <sil=0.000> 3 <sil=1.000> ,COMMA  then <sil=0.000> 4 <sil=1.000> ,COMMA  then <sil=0.000> 5 in <sil=0.000> the <sil=0.000> reverse <sil=0.000> order  <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  the <sil=0.000> 2 operations <sil=0.000> are <sil=0.000> push <sil=0.000> and <sil=0.000> pop <sil=2.000> .PERIOD 

Popping <sil=0.000> out <sil=0.000> from <sil=0.000> the <sil=0.000> stack <sil=0.000> and <sil=0.000> pushing <sil=0.000> inside <sil=0.000> the <sil=0.000> stack <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> stack <sil=0.000> data <sil=0.000> structure <sil=0.000> becomes <sil=0.000> very <sil=0.000> handy <sil=0.000> for <sil=0.000> implementation <sil=0.000> of <sil=0.000> function <sil=1.000> ,COMMA <sil=0.000> recursive
functions <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> show <sil=0.000> some <sil=0.000> examples <sil=2.000> .PERIOD 

Like <sil=0.000> here <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  I <sil=0.000> want <sil=0.000> to <sil=0.000> compute <sil=0.000> the <sil=0.000> gcd <sil=0.000> of <sil=0.000> a b <sil=2.000> .PERIOD  Now <sil=0.000> typically <sil=0.000> what <sil=0.000> happens <sil=0.000> is <sil=0.000> I call
this <sil=1.000> ,COMMA  gcd <sil=0.000> is <sil=0.000> computed <sil=1.000> ,COMMA <sil=0.000> I return <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  here <sil=0.000> when <sil=0.000> I call <sil=0.000> something <sil=0.000> say <sil=0.354> ;SEMICOLON  I <sil=0.000> was <sil=0.000> here <sil=1.000> ,COMMA  my <sil=0.000> program <sil=0.000> flow <sil=0.000> was <sil=0.000> here <sil=0.000> I went <sil=0.000> in <sil=2.000> .PERIOD  So <sil=0.000> when
I <sil=0.000> went <sil=0.000> in <sil=0.000> all <sil=0.000> the <sil=0.000> local <sil=0.000> variables <sil=0.000> and <sil=0.000> everything <sil=0.000> here <sil=0.000> were <sil=0.000> stored <sil=0.000> and <sil=0.000> I had <sil=0.000> to <sil=0.000> remember <sil=0.000> where <sil=0.000> I
will <sil=0.000> be <sil=0.000> returning <sil=0.000> back <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  all <sil=0.000> those <sil=0.000> things <sil=0.000> are <sil=0.000> stored <sil=0.000> in <sil=0.000> the <sil=0.000> stack <sil=0.000> and <sil=0.000> without <sil=0.000> a stack <sil=0.000> data
structure <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> very <sil=0.000> difficult <sil=0.000> to <sil=0.000> implement <sil=0.000> recursion <sil=0.000> and <sil=0.000> for <sil=0.000> that <sil=0.000> matter <sil=0.000> any <sil=0.000> function <sil=0.000> call <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  you <sil=0.000> see <sil=0.000> here <sil=0.000> is <sil=0.000> a function <sil=0.000> and <sil=0.000> so <sil=0.000> all <sil=0.000> those <sil=0.000> return <sil=0.000> addresses <sil=0.000> are <sil=0.000> stored <sil=1.000> ,COMMA  before <sil=0.000> call <sil=0.000> this <sil=0.000> stack
was <sil=0.000> empty <sil=1.000> ,COMMA  now <sil=0.000> after <sil=0.000> its <sil=0.000> returning <sil=0.000> it <sil=0.000> is <sil=0.000> taking <sil=0.000> out <sil=0.000> from <sil=0.000> the <sil=0.000> top <sil=0.000> of <sil=0.000> the <sil=0.000> stack <sil=0.000> and <sil=0.000> again <sil=0.000> I come <sil=0.000> to
know <sil=0.000> where <sil=0.000> I was <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> so <sil=1.000> ,COMMA  similarly <sil=0.000> you <sil=0.000> see <sil=0.000> here <sil=2.000> .PERIOD  N <sil=0.000> choose <sil=0.000> r a <sil=0.000> b <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  n <sil=0.000> c r  <sil=2.000> .PERIOD  n <sil=0.000> choose <sil=0.000> r <sil=1.000> ,COMMA  if <sil=0.000> I compute <sil=1.000> ,COMMA 
then <sil=0.000> n choose <sil=0.000> r is <sil=0.000> factorial <sil=0.000> r divided <sil=0.000> by <sil=0.000> factorial <sil=0.000> of <sil=0.000> n minus <sil=0.000> r or <sil=0.000> some <sil=0.000> people <sil=0.000> write <sil=0.000> it <sil=0.000> in <sil=0.000> this <sil=0.000> way
- factorial <sil=0.000> of <sil=0.000> n minus <sil=0.000> r <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  how <sil=0.000> did <sil=0.000> I do <sil=0.000> that <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  how <sil=0.000> can <sil=0.000> I implement <sil=0.000> it <sil=0.228> ?QUESTIONMARK 

So <sil=1.000> ,COMMA  here <sil=0.000> n c <sil=0.000> r has <sil=0.000> been <sil=0.000> called <sil=0.000> from <sil=0.000> here <sil=0.000> factorial <sil=0.000> has <sil=0.000> been <sil=0.000> called <sil=0.000> and <sil=0.000> then <sil=0.000> where <sil=0.000> do <sil=0.000> I return <sil=0.228> ?QUESTIONMARK  I
have <sil=0.000> to <sil=0.000> come <sil=0.000> here <sil=1.000> ,COMMA  ultimately <sil=0.000> I have <sil=0.000> to <sil=0.000> return <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> should <sil=0.000> not <sil=0.000> lose <sil=0.000> the <sil=0.000> path <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  what <sil=0.000> the <sil=0.000> stack <sil=0.000> does <sil=0.000> is <sil=0.000> when <sil=0.000> I make <sil=0.000> the <sil=0.000> call <sil=1.000> ,COMMA <sil=0.000> the <sil=0.000> first <sil=0.000> call <sil=0.000> the <sil=0.000> local <sil=0.000> variables <sil=0.000> here <sil=0.000> will <sil=0.000> be
stored <sil=0.000> here <sil=0.000> on <sil=0.000> the <sil=0.000> stack <sil=0.000> and <sil=0.000> again <sil=0.000> I make <sil=0.000> another <sil=0.000> call <sil=0.000> from <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  local <sil=0.000> variables <sil=0.000> are <sil=0.000> there <sil=1.000> ,COMMA  I
am <sil=0.000> calling <sil=0.000> fact <sil=1.000> ,COMMA  as <sil=0.000> I go <sil=0.000> in <sil=0.000> here <sil=1.000> ,COMMA  the <sil=0.000> local <sil=0.000> variables <sil=0.000> here <sil=0.000> has <sil=0.000> stacked <sil=0.000> up <sil=0.000> and <sil=0.000> then <sil=0.000> when <sil=0.000> I return <sil=0.000> this <sil=0.000> part <sil=0.000> will <sil=0.000> be <sil=0.000> taken <sil=0.000> out <sil=0.000> and <sil=0.000> passed <sil=0.000> on <sil=0.000> to <sil=0.000> this <sil=2.000> .PERIOD 

So <sil=0.000> as <sil=0.000> it <sil=0.000> returns <sil=0.000> this <sil=0.000> part <sil=0.000> is <sil=0.000> taken <sil=0.000> out <sil=0.000> and <sil=0.000> I am <sil=0.000> here <sil=1.000> ,COMMA  it <sil=0.000> can <sil=0.000> again <sil=0.000> continue <sil=0.000> and <sil=0.000> then <sil=0.000> it <sil=0.000> returns <sil=1.000> ,COMMA 
when <sil=0.000> it <sil=0.000> returns <sil=0.000> here <sil=0.000> this <sil=0.000> part <sil=0.000> will <sil=0.000> be <sil=0.000> taken <sil=0.000> out  <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> for <sil=0.000> normal <sil=0.000> function <sil=0.000> call <sil=1.000> ,COMMA  how <sil=0.000> the <sil=0.000> stack <sil=0.000> remembers <sil=0.000> where <sil=0.000> I should <sil=0.000> go <sil=0.000> back <sil=2.000> .PERIOD  In <sil=0.000> the <sil=0.000> case
of <sil=0.000> recursive <sil=0.000> calls <sil=0.000> what <sil=0.000> happens <sil=0.000> what <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=0.000> is <sil=0.000> activation <sil=0.000> record <sil=0.000> gets <sil=0.000> pushed <sil=0.000> into <sil=0.000> the <sil=0.000> stack
when <sil=0.000> a function <sil=0.000> I will <sil=0.000> call <sil=0.000> is <sil=0.000> made <sil=2.000> .PERIOD  In <sil=0.000> recursion <sil=0.000> a function <sil=0.000> calls <sil=0.000> itself <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  several <sil=0.000> function <sil=0.000> calls <sil=0.000> are <sil=0.000> going <sil=0.000> on <sil=0.000> with <sil=0.000> none <sil=0.000> of <sil=0.000> the <sil=0.000> calls <sil=0.000> getting <sil=0.000> back <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  all <sil=0.000> the <sil=0.000> activation
records <sil=0.000> are <sil=0.000> collected <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you <sil=0.000> need <sil=0.000> not <sil=0.000> delve <sil=0.000> into <sil=0.000> that <sil=0.000> too <sil=0.000> much <sil=2.000> .PERIOD 

I <sil=0.000> will <sil=0.000> show <sil=0.000> it <sil=0.000> by <sil=0.000> an <sil=0.000> example <sil=0.000> of <sil=0.000> a computing <sil=0.000> factorial <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  an <sil=0.000> activation <sil=0.000> record <sil=0.000> is <sil=0.000> the <sil=0.000> local
variables <sil=0.000> and <sil=0.000> the <sil=0.000> return <sil=0.000> value <sil=1.000> ,COMMA  what <sil=0.000> the <sil=0.000> function <sil=0.000> should <sil=0.000> return <sil=0.000> and <sil=0.000> where <sil=0.000> it <sil=0.000> should <sil=0.000> return <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  that <sil=0.000> with <sil=0.000> that <sil=0.000> say <sil=0.000> the <sil=0.000> main <sil=0.000> function <sil=0.000> is <sil=0.000> calling <sil=0.000> fact <sil=0.000> 3 and <sil=0.000> here <sil=0.000> is <sil=0.000> a fact <sil=0.000> n <sil=1.000> ,COMMA  if <sil=0.000> n equal <sil=0.000> to <sil=0.000> 0 return
one <sil=0.000> otherwise <sil=0.000> n times <sil=0.000> fact <sil=0.000> n minus <sil=0.000> 1 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  main <sil=0.000> calls <sil=0.000> fact <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  when <sil=0.000> it <sil=0.000> calls <sil=0.000> the <sil=0.000> value <sil=0.000> n is <sil=0.000> equal <sil=0.000> to <sil=0.000> 3 <sil=1.000> ,COMMA <sil=0.000> so <sil=0.000> there <sil=0.000> is <sil=0.000> no <sil=0.000> return <sil=0.000> value <sil=1.000> ,COMMA  the
return <sil=0.000> address <sil=0.000> is <sil=0.000> in <sil=0.000> the <sil=0.000> main <sil=0.000> I am <sil=0.000> remembering <sil=0.000> that <sil=2.000> .PERIOD  Next <sil=0.000> again <sil=0.000> fact <sil=0.000> is <sil=0.000> calling <sil=0.000> itself <sil=0.354> ;SEMICOLON  so <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA 
fact <sil=0.000> is <sil=0.000> calling <sil=0.000> fact <sil=0.000> 3 is <sil=0.000> calling <sil=0.000> fact <sil=0.000> 2 and <sil=0.000> my <sil=0.000> return <sil=0.000> address <sil=0.000> is <sil=0.000> fact <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you <sil=0.000> see <sil=0.000> it <sil=0.000> has <sil=0.000> been <sil=0.000> stacked <sil=0.000> up <sil=2.000> .PERIOD  Next <sil=0.000> fact <sil=0.000> 2 will <sil=0.000> call <sil=0.000> fact <sil=0.000> 1 <sil=1.000> ,COMMA  so <sil=0.000> what <sil=0.000> is <sil=0.000> this <sil=0.228> ?QUESTIONMARK  The <sil=0.000> stack <sil=0.000> is <sil=0.000> growing <sil=0.000> and <sil=0.000> its <sil=0.000> return <sil=0.000> is <sil=0.000> in <sil=0.000> fact <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  next <sil=0.000> time <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> fact <sil=0.000> 0 <sil=2.000> .PERIOD  Till <sil=0.000> now <sil=1.000> ,COMMA  there <sil=0.000> was <sil=0.000> no <sil=0.000> return <sil=0.000> value <sil=2.000> .PERIOD  Now <sil=0.000> the <sil=0.000> return <sil=0.000> value <sil=0.000> is <sil=0.000> 1
and <sil=0.000> return <sil=0.000> addresses <sil=0.000> fact <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  as <sil=0.000> I do <sil=0.000> that <sil=0.000> I return <sil=1.000> ,COMMA  then <sil=0.000> I have <sil=0.000> got <sil=0.000> a return <sil=0.000> value <sil=0.000> because <sil=0.000> now <sil=0.000> I
have <sil=0.000> come <sil=0.000> to <sil=0.000> this <sil=0.000> point <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  1 <sil=0.000> into <sil=0.000> 1 will <sil=0.000> be <sil=0.000> 1 and <sil=0.000> I am <sil=0.000> returning <sil=0.000> to <sil=0.000> fact <sil=1.000> ,COMMA  as <sil=0.000> I return <sil=0.000> the <sil=0.000> stack <sil=0.000> will
contract <sil=0.000> and <sil=0.000> what <sil=0.000> is <sil=0.000> the <sil=0.000> return <sil=0.000> result <sil=0.228> ?QUESTIONMARK  2 <sil=0.000> times <sil=0.000> 1 that <sil=0.000> is <sil=0.000> 2 <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> a factorial <sil=0.000> 2 and <sil=0.000> I am <sil=0.000> returning
to <sil=0.000> fact <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> return <sil=0.000> again <sil=2.000> .PERIOD  Now <sil=0.000> I am <sil=0.000> coming <sil=0.000> for <sil=0.000> last <sil=0.000> time <sil=0.000> in <sil=0.000> the <sil=0.000> fact <sil=0.000> with <sil=0.000> n equal <sil=0.000> to <sil=0.000> 3 that <sil=0.000> started
here <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  and <sil=0.000> the <sil=0.000> result <sil=0.000> is <sil=0.000> 6 <sil=2.000> .PERIOD  Now <sil=0.000> I return <sil=0.000> to <sil=0.000> main <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  at <sil=0.000> every <sil=0.000> stage <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=1.000> ,COMMA  I <sil=0.000> know <sil=0.000> I remember
from <sil=0.000> where <sil=0.000> I started <sil=0.000> and <sil=0.000> from <sil=0.000> where <sil=0.000> I am <sil=0.000> returning <sil=0.000> back <sil=1.000> ,COMMA  nothing <sil=0.000> is <sil=0.000> lost <sil=0.000> using <sil=0.000> this <sil=0.000> stack <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
stack <sil=0.000> is <sil=0.000> a very <sil=0.000> interesting <sil=0.000> data <sil=0.000> structure <sil=1.000> ,COMMA  that <sil=0.000> helps <sil=0.000> us <sil=0.000> in <sil=0.000> many <sil=0.000> ways <sil=1.000> ,COMMA  especially <sil=0.000> in <sil=0.000> implementing
things <sil=0.000> like <sil=0.000> recursion <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  one <sil=0.000> assignment <sil=0.000> that <sil=0.000> I am <sil=0.000> leaving <sil=0.000> to <sil=0.000> you <sil=0.000> do <sil=0.000> it <sil=0.000> yourself <sil=1.000> ,COMMA  trace <sil=0.000> the <sil=0.000> activation <sil=0.000> record <sil=0.000> for <sil=0.000> the
following <sil=0.000> version <sil=0.000> of <sil=0.000> Fibonacci <sil=2.000> .PERIOD  Please <sil=0.000> note <sil=0.000> down <sil=0.000> the <sil=0.000> code <sil=0.000> include <sil=0.000> stdio <sil=0.000> dot <sil=0.000> h <sil=1.000> ,COMMA  int <sil=0.000> f <sil=1.000> ,COMMA  f <sil=0.000> is <sil=0.000> the
Fibonacci <sil=0.000> function <sil=1.000> ,COMMA  a <sil=0.000> and <sil=0.000> b if <sil=0.000> n is <sil=0.000> less <sil=0.000> than <sil=0.000> 2 return <sil=0.000> n  <sil=1.000> ,COMMA <sil=0.000> if <sil=0.000> it <sil=0.000> is <sil=0.000> 0 then <sil=0.000> return <sil=0.000> 0 <sil=2.000> .PERIOD 

If <sil=0.000> it <sil=0.000> is <sil=0.000> 1 return <sil=0.000> 1 <sil=1.000> ,COMMA  otherwise <sil=0.000> a is <sil=0.000> fn <sil=0.000> minus <sil=0.000> 1 <sil=1.000> ,COMMA  b <sil=0.000> is <sil=0.000> fn <sil=0.000> minus <sil=0.000> 2 <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> done <sil=0.000> it <sil=0.000> in <sil=0.000> a different <sil=0.000> way <sil=1.000> ,COMMA  fn
minus <sil=0.000> 1 and <sil=0.000> fn <sil=0.000> minus <sil=0.000> 2 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> n minus <sil=0.000> 1 has <sil=0.000> to <sil=0.000> be <sil=0.000> solved <sil=0.000> separately <sil=0.000> and <sil=0.000> fn <sil=0.000> minus <sil=0.000> 2 should <sil=0.000> be
solved <sil=0.000> separately <sil=1.000> ,COMMA  then <sil=0.000> we <sil=0.000> will <sil=0.000> return <sil=0.000> a plus <sil=0.000> b <sil=1.000> ,COMMA  then <sil=0.000> the <sil=0.000> main <sil=0.000> will <sil=0.000> print <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  just <sil=0.000> for <sil=0.000> fun <sil=0.000> you <sil=0.000> try <sil=0.000> to
draw <sil=0.000> the <sil=0.000> activation <sil=0.000> record <sil=0.000> of <sil=0.000> this <sil=0.000> version <sil=0.000> of <sil=0.000> the <sil=0.000> function <sil=1.000> ,COMMA  please <sil=0.000> note <sil=0.000> it <sil=0.000> down <sil=1.000> ,COMMA  take <sil=0.000> some <sil=0.000> time
and <sil=0.000> note <sil=0.000> down <sil=0.000> this <sil=0.000> function <sil=0.000> and <sil=0.000> you <sil=0.000> see <sil=0.000> on <sil=0.000> this <sil=0.000> side <sil=0.000> I have <sil=0.000> shown <sil=2.000> .PERIOD 

How <sil=0.000> the <sil=0.000> activation <sil=0.000> record <sil=0.000> will <sil=0.000> look <sil=0.000> like <sil=0.000> local <sil=0.000> variables <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> see <sil=0.000> n <sil=1.000> ,COMMA  a <sil=0.000> and <sil=0.000> b <sil=2.000> .PERIOD  Return <sil=0.000> value <sil=0.000> you
have <sil=0.000> to <sil=0.000> keep <sil=0.000> whether <sil=0.000> it <sil=0.000> is <sil=0.000> in <sil=0.000> Fibonacci <sil=0.000> or <sil=0.000> in <sil=0.000> main <sil=1.000> ,COMMA  either <sil=0.000> in <sil=0.000> main <sil=0.000> or <sil=0.000> in <sil=0.000> x or <sil=0.000> y <sil=1.000> ,COMMA   <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> x and <sil=0.000> this
is <sil=0.000> y <sil=1.000> ,COMMA  alright <sil=0.000> not <sil=0.000> these <sil=0.000> 2  <sil=1.000> ,COMMA <sil=0.000> these <sil=0.000> are <sil=0.000> not <sil=0.000> aligned <sil=0.000> properly <sil=2.000> .PERIOD 

Here <sil=0.000> is <sil=0.000> the <sil=0.000> return <sil=0.000> to <sil=0.000> the <sil=0.000> main <sil=1.000> ,COMMA  either <sil=0.000> return <sil=0.000> to <sil=0.000> main <sil=0.000> or <sil=0.000> to <sil=0.000> x or <sil=0.000> to <sil=0.000> y and <sil=0.000> what <sil=0.000> is <sil=0.000> the <sil=0.000> return <sil=0.000> value <sil=0.228> ?QUESTIONMARK 
Draw <sil=0.000> the <sil=0.000> activation <sil=0.000> record <sil=0.000> of <sil=0.000> this <sil=0.000> and <sil=0.000> then <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> see <sil=0.000> how <sil=0.000> much <sil=0.000> you <sil=0.000> could <sil=0.000> do <sil=0.000> it <sil=0.000> I am <sil=0.000> sure <sil=0.000> you
will <sil=0.000> be <sil=0.000> able <sil=0.000> to <sil=0.000> do <sil=0.000> it <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  today <sil=0.000> we <sil=0.000> have <sil=0.000> learnt <sil=0.000> a new <sil=0.000> style <sil=0.000> of <sil=0.000> programming <sil=0.000> that <sil=0.000> is <sil=0.000> recursion <sil=0.000> and <sil=0.000> also <sil=0.000> we <sil=0.000> discussed <sil=0.000> in <sil=0.000> the <sil=0.000> last <sil=0.000> class <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  recursion <sil=0.000> is <sil=0.000> a type <sil=0.000> of <sil=0.000> writing <sil=0.000> functions <sil=0.000> where <sil=0.000> the <sil=0.000> function <sil=0.000> calls <sil=0.000> itself <sil=0.000> and <sil=0.000> that <sil=0.000> makes <sil=0.000> many <sil=0.000> functions <sil=0.000> to <sil=0.000> be <sil=0.000> written <sil=0.000> much <sil=0.000> more <sil=0.000> subtle <sil=0.000> and <sil=0.000> that <sil=0.000> is <sil=0.000> a very <sil=0.000> good <sil=0.000> software <sil=0.000> engineering <sil=0.000> practice <sil=2.000> .PERIOD 

Although <sil=0.000> as <sil=0.000> a beginner <sil=1.000> ,COMMA  If <sil=0.000> you <sil=0.000> find <sil=0.000> difficulty <sil=0.000> in <sil=0.000> that <sil=0.354> ;SEMICOLON  you <sil=0.000> need <sil=0.000> not <sil=0.000> bother <sil=0.000> too <sil=0.000> much <sil=0.000> about <sil=0.000> it <sil=1.000> ,COMMA  you
have <sil=0.000> got <sil=0.000> iteration <sil=0.000> at <sil=0.000> your <sil=0.000> disposal <sil=0.000> and <sil=0.000> you <sil=0.000> can <sil=0.000> solve <sil=0.000> most <sil=0.000> of <sil=0.000> the <sil=0.000> problems <sil=0.000> with <sil=0.000> iteration <sil=1.000> ,COMMA 
practically <sil=0.000> all <sil=0.000> the <sil=0.000> problems <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> do <sil=2.000> .PERIOD  May <sil=0.000> be <sil=0.000> in <sil=0.000> some <sil=0.000> cases <sil=1.000> ,COMMA  it <sil=0.000> may <sil=0.000> be <sil=0.000> a little <sil=0.000> more <sil=0.000> difficult <sil=0.000> to
write <sil=1.000> ,COMMA  but <sil=0.000> ultimately <sil=0.000> it <sil=0.000> is <sil=0.000> will <sil=0.000> be <sil=0.000> possible <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> you <sil=0.000> find <sil=0.000> difficulty <sil=0.000> with <sil=0.000> recursion <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> set <sil=0.000> it
aside <sil=0.000> for <sil=0.000> the <sil=0.000> time <sil=0.000> being <sil=1.000> ,COMMA  but <sil=0.000> we <sil=0.000> have <sil=0.000> to <sil=0.000> discuss <sil=0.000> it <sil=0.000> because <sil=0.000> that <sil=0.000> is <sil=0.000> a very <sil=0.000> nice <sil=0.000> way <sil=0.000> of <sil=0.000> writing
functions <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> continue <sil=0.000> with <sil=0.000> the <sil=0.000> concept <sil=0.000> of <sil=0.000> structures <sil=0.000> in <sil=0.000> the <sil=0.000> next <sil=0.000> lecture <sil=1.000> ,COMMA  a <sil=0.000> new <sil=0.000> thing <sil=0.000> will <sil=0.000> be
introduced <sil=0.000> that <sil=0.000> is <sil=0.000> called <sil=0.000> structure <sil=2.000> .PERIOD 

Thank <sil=0.000> you <sil=2.000> .PERIOD 

Earlier <sil=1.000> ,COMMA  we <sil=0.000> had <sil=0.000> talked <sil=0.000> about <sil=0.000> storage <sil=0.000> of <sil=0.000> data <sil=0.000> in <sil=0.000> arrays <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  what <sil=0.000> we <sil=0.000> found <sil=0.354> ;SEMICOLON  what <sil=0.000> we <sil=0.000> mentioned
in <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> arrays <sil=0.000> is <sil=0.000> that <sil=0.000> in <sil=0.000> an <sil=0.000> array <sil=0.000> we <sil=0.000> can <sil=0.000> store <sil=0.000> data <sil=0.000> only <sil=0.000> of <sil=0.000> a particular <sil=0.000> type <sil=0.354> ;SEMICOLON  say <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> integers <sil=0.000> or <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> floats <sil=0.000> or <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> characters <sil=1.000> ,COMMA  but <sil=0.000> we <sil=0.000> could <sil=0.000> not <sil=0.000> mix <sil=0.000> different <sil=0.000> types <sil=0.000> in <sil=0.000> the <sil=0.000> same <sil=0.000> array <sil=2.000> .PERIOD  For <sil=0.000> example <sil=1.000> ,COMMA  we <sil=0.000> had <sil=0.000> faced <sil=0.000> the <sil=0.000> problem <sil=0.000> of <sil=0.000> representing <sil=0.000> the <sil=0.000> student s <sil=0.000> database <sil=0.000> where <sil=0.000> we <sil=0.000> will <sil=0.000> have <sil=0.000> the <sil=0.000> student s <sil=0.000> name <sil=0.000> as <sil=0.000> well <sil=0.000> as <sil=0.000> the <sil=0.000> student s <sil=0.000> marks <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  we <sil=0.000> needed <sil=0.000> something <sil=0.000> like <sil=0.000> this <sil=0.354> ;SEMICOLON  actually <sil=0.000> that <sil=0.000> is <sil=0.000> what <sil=0.000> was <sil=0.000> desired <sil=0.354> ;SEMICOLON  that <sil=0.000> will <sil=0.000> have <sil=0.000> the <sil=0.000> names
here <sil=0.000> and <sil=0.000> the <sil=0.000> names <sil=0.000> will <sil=0.000> be <sil=0.000> nothing <sil=0.000> but <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> characters <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> will <sil=0.000> be <sil=0.000> some <sil=0.000> names <sil=0.000> ABC <sil=0.000> and <sil=0.000> here <sil=0.000> will <sil=0.000> be <sil=0.000> the <sil=0.000> marks <sil=0.000> 56 <sil=0.000> A <sil=2.000> .PERIOD  Now <sil=0.000> this <sil=0.000> representation <sil=0.000> requires <sil=0.000> two <sil=0.000> arrays <sil=0.354> ;SEMICOLON  one <sil=0.000> is <sil=0.000> the
representing <sil=0.000> the <sil=0.000> names <sil=0.000> and <sil=0.000> the <sil=0.000> other <sil=0.000> is <sil=0.000> representing <sil=0.000> marks  <sil=2.000> .PERIOD 

Now <sil=0.354> ;SEMICOLON  however <sil=1.000> ,COMMA  as <sil=0.000> the <sil=0.000> diagram <sil=0.000> is <sil=0.000> showing <sil=0.000> here <sil=1.000> ,COMMA  we <sil=0.000> are <sil=0.000> trying <sil=0.000> to <sil=0.000> represent <sil=0.000> them <sil=0.000> in <sil=0.000> an <sil=0.000> unified
structure <sil=0.000> in <sil=0.000> the <sil=0.000> same <sil=0.000> structure <sil=1.000> ,COMMA  but <sil=0.000> that <sil=0.000> is <sil=0.000> not <sil=0.000> possible <sil=0.000> in <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> an <sil=0.000> array <sil=1.000> ,COMMA  here <sil=0.000> we <sil=0.000> have <sil=0.000> got <sil=0.000> 2

different <sil=0.000> data <sil=0.000> types <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> characters <sil=0.000> and <sil=0.000> this <sil=0.000> is <sil=0.000> an <sil=0.000> integer <sil=2.000> .PERIOD  For <sil=0.000> example <sil=1.000> ,COMMA  we <sil=0.000> can <sil=0.000> we <sil=0.000> can <sil=0.000> see <sil=0.000> that <sil=0.000> if <sil=0.000> I had <sil=0.000> stored <sil=0.000> something <sil=0.000> lets <sil=0.000> say  <sil=2.000> .PERIOD 

For <sil=0.000> example <sil=1.000> ,COMMA  I <sil=0.000> want <sil=0.000> to <sil=0.000> store <sil=0.000> a graph <sil=0.000> where <sil=0.000> at <sil=0.000> every <sil=0.000> point <sil=0.354> ;SEMICOLON  1 <sil=1.000> ,COMMA  2 <sil=1.000> ,COMMA  3 <sil=0.000> seconds <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  this <sil=0.000> time
in <sil=0.000> seconds <sil=0.000> and <sil=0.000> here <sil=0.000> I am <sil=0.000> measuring <sil=0.000> the <sil=0.000> temperature <sil=0.000> and <sil=0.000> if <sil=0.000> I have <sil=0.000> a graph <sil=0.000> which <sil=0.000> is <sil=0.000> something
like <sil=0.000> this <sil=1.000> ,COMMA  I <sil=0.000> cannot <sil=0.000> say <sil=0.000> that <sil=0.000> at <sil=0.000> every <sil=0.000> point <sil=1.000> ,COMMA  the <sil=0.000> temperature <sil=0.000> will <sil=0.000> also <sil=0.000> be <sil=0.000> an <sil=0.000> integer <sil=0.000> therefore <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  suppose <sil=0.000> here <sil=0.000> at <sil=0.000> point <sil=0.000> number <sil=0.000> 2 <sil=1.000> ,COMMA  the <sil=0.000> temperature <sil=0.000> is <sil=0.000> 50 <sil=2.000> .PERIOD <sil=0.000> 34 <sil=1.000> ,COMMA  at <sil=0.000> point <sil=0.000> number <sil=0.000> 3 <sil=1.000> ,COMMA  the <sil=0.000> temperature <sil=0.000> can <sil=0.000> be <sil=0.000> 70 <sil=2.000> .PERIOD <sil=0.000> 2 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> I had <sil=0.000> tried <sil=0.000> to <sil=0.000> represent <sil=0.000> that <sil=0.000> in <sil=0.000> the <sil=0.000> form <sil=0.000> of <sil=0.000> a 2D <sil=0.000> array <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> case <sil=1.000> ,COMMA  it <sil=0.000> wouldn t <sil=0.000> have <sil=0.000> been <sil=0.000> possible <sil=0.000> because <sil=0.000> a 2D <sil=0.000> array <sil=0.000> is <sil=0.000> also <sil=0.000> an <sil=0.000> array <sil=0.000> and <sil=0.000> therefore <sil=0.000> is <sil=0.000> of <sil=0.000> only <sil=0.000> one <sil=0.000> type <sil=2.000> .PERIOD  We <sil=0.000> have <sil=0.000> to <sil=0.000> declare <sil=0.000> a 2D <sil=0.000> array <sil=0.000> as <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> integer <sil=0.000> or <sil=0.000> as <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> characters <sil=0.000> or <sil=0.000> array <sil=0.000> of <sil=0.000> float <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> cannot <sil=0.000> represent <sil=0.000> that <sil=0.000> in <sil=0.000> a 2D <sil=0.000> array <sil=0.000> where <sil=0.000> one <sil=0.000> side <sil=0.000> say <sil=0.000> for <sil=0.000> example <sil=0.000> one <sil=0.000> column <sil=0.000> will <sil=0.000> be
temperature <sil=0.000> and <sil=0.000> another <sil=0.000> column <sil=0.000> will <sil=0.000> be <sil=0.000> the <sil=0.000> time <sil=0.354> ;SEMICOLON  its <sil=0.000> time <sil=0.000> and <sil=0.000> temperature <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> wont
possibly <sil=0.000> be <sil=0.000> executed <sil=0.000> in <sil=0.000> a 2 <sil=0.000> dimensional <sil=0.000> array <sil=0.000> because <sil=0.000> while <sil=0.000> time <sil=0.000> will <sil=0.000> be <sil=0.000> an <sil=0.000> integer (1 <sil=1.000> ,COMMA  2 <sil=1.000> ,COMMA  3)
temperatures <sil=0.000> can <sil=0.000> be <sil=0.000> something <sil=0.000> different <sil=0.000> 50 <sil=2.000> .PERIOD <sil=0.000> 6 <sil=1.000> ,COMMA  70 <sil=2.000> .PERIOD <sil=0.000> 3 <sil=1.000> ,COMMA  etc <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  an <sil=0.000> array <sil=0.000> is <sil=0.000> not <sil=0.000> possible <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  our <sil=0.000> question <sil=0.000> is <sil=0.000> then <sil=0.000> what <sil=0.000> is <sil=0.000> the <sil=0.000> type <sil=0.000> of <sil=0.000> data <sil=0.000> structure <sil=0.354> ;SEMICOLON  what <sil=0.000> is <sil=0.000> the <sil=0.000> type <sil=0.000> of <sil=0.000> arrangement <sil=0.000> by
which <sil=0.000> I can <sil=0.000> represent <sil=0.000> data <sil=0.000> of <sil=0.000> different <sil=0.000> types <sil=0.000> together  <sil=0.228> ?QUESTIONMARK  The <sil=0.000> answer <sil=0.000> to <sil=0.000> that <sil=0.000> is <sil=0.000> what <sil=0.000> we <sil=0.000> will <sil=0.000> be
looking <sil=0.000> at <sil=0.000> today <sil=0.000> that <sil=0.000> is <sil=0.000> structure <sil=2.000> .PERIOD  Structures <sil=0.000> in <sil=0.000> C allows <sil=0.000> us <sil=0.000> to <sil=0.000> represent <sil=0.000> a combination <sil=0.000> of
different <sil=0.000> data <sil=0.000> types <sil=2.000> .PERIOD 

For <sil=0.000> example <sil=1.000> ,COMMA  let <sil=0.000> me <sil=0.000> give <sil=0.000> an <sil=0.000> example <sil=0.000> of <sil=0.000> a structure <sil=1.000> ,COMMA  say <sil=0.000> I want <sil=0.000> to <sil=0.000> define <sil=0.000> student <sil=0.000> data <sil=0.000> and <sil=0.000> student <sil=0.000> data <sil=0.000> will <sil=0.000> consist <sil=0.000> of <sil=0.000> the <sil=0.000> student <sil=0.000> name <sil=1.000> ,COMMA  lets <sil=0.000> say <sil=0.000> the <sil=0.000> department <sil=0.000> of <sil=0.000> the <sil=0.000> student <sil=1.000> ,COMMA  roll <sil=0.000> number <sil=0.000> of <sil=0.000> the <sil=0.000> student <sil=1.000> ,COMMA  may <sil=0.000> be <sil=0.000> the <sil=0.000> CGPA <sil=0.000> of <sil=0.000> the <sil=0.000> student <sil=1.000> ,COMMA  grade <sil=1.000> ,COMMA  point <sil=1.000> ,COMMA  average <sil=0.000> of <sil=0.000> the <sil=0.000> student <sil=1.000> ,COMMA  etc <sil=2.000> .PERIOD 

If <sil=0.000> I want <sil=0.000> to <sil=0.000> store <sil=0.000> them <sil=0.000> together <sil=0.000> as <sil=0.000> a common <sil=0.000> piece <sil=1.000> ,COMMA  the <sil=0.000> student <sil=0.000> data <sil=1.000> ,COMMA  then <sil=0.000> this <sil=0.000> entire <sil=0.000> thing <sil=0.000> has <sil=0.000> got <sil=0.000> components <sil=0.000> of <sil=0.000> different <sil=0.000> data <sil=0.000> types <sil=2.000> .PERIOD  For <sil=0.000> example <sil=1.000> ,COMMA  what <sil=0.000> will <sil=0.000> be <sil=0.000> student <sil=0.000> name <sil=0.000> say <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  Amith <sil=0.000> will <sil=0.000> be <sil=0.000> either <sil=0.000> a string <sil=0.000> or <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> character <sil=1.000> ,COMMA  department <sil=1.000> ,COMMA  somebody <sil=0.000> can <sil=0.000> say <sil=0.000> mechanical <sil=0.000> engineering <sil=0.000> that <sil=0.000> can <sil=0.000> also <sil=0.000> be <sil=0.000> a character <sil=0.000> string <sil=1.000> ,COMMA  whereas <sil=1.000> ,COMMA  roll <sil=0.000> number <sil=0.000> 748 <sil=0.000> will <sil=0.000> be <sil=0.000> an <sil=0.000> integer <sil=0.000> and <sil=0.000> CGPA <sil=0.000> say <sil=0.000> 7 <sil=2.000> .PERIOD <sil=0.000> 8 will <sil=0.000> be <sil=0.000> a floating <sil=0.000> point <sil=0.000> number <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  what <sil=0.000> we <sil=0.000> can <sil=0.000> see <sil=0.000> that <sil=0.000> in <sil=0.000> order <sil=0.000> to <sil=0.000> store <sil=0.000> the <sil=0.000> student <sil=0.000> data <sil=0.000> we <sil=0.000> have <sil=0.000> to <sil=0.000> have <sil=0.000> a mixture <sil=0.000> of <sil=0.000> different <sil=0.000> data <sil=0.000> types <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  a <sil=0.000> structure <sil=0.000> allows <sil=0.000> us <sil=0.000> to <sil=0.000> do <sil=0.000> exactly <sil=0.000> this <sil=0.000> where <sil=0.000> I can <sil=0.000> consider <sil=0.000> this <sil=0.000> student <sil=0.000> data <sil=0.000> as <sil=0.000> a structure <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> me <sil=0.000> redraw <sil=0.000> it <sil=0.000> in <sil=0.000> a different <sil=0.000> way <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> draw <sil=0.000> a box <sil=0.000> which <sil=0.000> is <sil=0.000> representing <sil=0.000> the <sil=0.000> student <sil=0.000> data <sil=2.000> .PERIOD  I <sil=0.000> name <sil=0.000> it <sil=0.000> stud <sil=0.000> data <sil=0.000> and <sil=0.000> I have <sil=0.000> got
different <sil=0.000> fields <sil=0.000> in <sil=0.000> this <sil=2.000> .PERIOD  Each <sil=0.000> field <sil=0.000> has <sil=0.000> gotten <sil=0.000> some <sil=0.000> identification <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> field <sil=0.000> is <sil=0.000> storing <sil=0.000> the <sil=0.000> name
and <sil=0.000> this <sil=0.000> field <sil=0.000> is <sil=0.000> basically <sil=0.000> of <sil=0.000> a type <sil=0.000> character <sil=0.000> array <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  another <sil=0.000> field <sil=0.000> is <sil=0.000> name <sil=0.000> is <sil=0.000> department <sil=0.000> and <sil=0.000> its <sil=0.000> type <sil=0.000> is <sil=0.000> also <sil=0.000> character <sil=0.000> array <sil=1.000> ,COMMA  another <sil=0.000> field  <sil=0.354> ;SEMICOLON  remember <sil=0.000> that <sil=0.000> I every <sil=0.000> time <sil=0.000> I am <sil=0.000> using <sil=0.000> that <sil=0.000> term <sil=0.000> field <sil=0.000> of <sil=0.000> student <sil=0.000> data <sil=2.000> .PERIOD 

So <sil=0.000> name <sil=1.000> ,COMMA  department <sil=1.000> ,COMMA  what <sil=0.000> else <sil=0.000> do <sil=0.000> we <sil=0.000> have - role <sil=0.000> number <sil=0.000> which <sil=0.000> will <sil=0.000> be <sil=0.000> of <sil=0.000> type <sil=0.000> integer <sil=0.000> and
CGPA <sil=0.000> which <sil=0.000> will <sil=0.000> be <sil=0.000> float <sil=2.000> .PERIOD  Suppose <sil=0.000> there <sil=0.000> is <sil=0.000> no <sil=0.000> other <sil=0.000> field <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> call <sil=0.000> this <sil=0.000> entire <sil=0.000> box <sil=0.000> to <sil=0.000> be <sil=0.000> a
structure - this <sil=0.000> is <sil=0.000> a structure <sil=0.000> and <sil=0.000> what <sil=0.000> is <sil=0.000> contained <sil=0.000> in <sil=0.000> this <sil=0.000> structure <sil=0.228> ?QUESTIONMARK  There <sil=0.000> are <sil=0.000> 4 fields <sil=0.000> that <sil=0.000> define <sil=0.000> the <sil=0.000> structure - the <sil=0.000> 4 fields <sil=0.000> are <sil=0.000> name <sil=1.000> ,COMMA  department <sil=1.000> ,COMMA  roll <sil=0.000> number <sil=0.000> and <sil=0.000> CGPA <sil=1.000> ,COMMA  these <sil=0.000> 4 fields <sil=0.000> are <sil=0.000> defining <sil=0.000> a structure <sil=2.000> .PERIOD  Now <sil=0.000> C allows <sil=0.000> us <sil=0.000> to <sil=0.000> define <sil=0.000> structures <sil=0.000> of <sil=0.000> this <sil=0.000> type <sil=0.000> and <sil=0.000> we <sil=0.000> learn <sil=0.000> how <sil=0.000> we <sil=0.000> can <sil=0.000> define <sil=0.000> such <sil=0.000> things <sil=0.000> and <sil=0.000> let <sil=0.000> us <sil=0.000> go <sil=0.000> ahead <sil=0.000> a little <sil=0.000> bit <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> a structure <sil=0.228> ?QUESTIONMARK  It <sil=0.000> is <sil=0.000> a convenient <sil=0.000> tool <sil=0.000> for <sil=0.000> handling <sil=0.000> a group <sil=0.000> of <sil=0.000> logically <sil=0.000> related <sil=0.000> data <sil=0.000> items <sil=0.000> here <sil=2.000> .PERIOD 

Of <sil=0.000> course <sil=1.000> ,COMMA  the <sil=0.000> logically <sil=0.000> related <sil=0.000> data <sil=0.000> items <sil=0.000> were <sil=0.000> the <sil=0.000> different <sil=0.000> information <sil=0.000> fields <sil=0.000> or <sil=0.000> information
component <sil=0.000> that <sil=0.000> are <sil=0.000> related <sil=0.000> to <sil=0.000> a particular <sil=0.000> student <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  till <sil=0.000> now <sil=1.000> ,COMMA  we <sil=0.000> saw <sil=0.000> very <sil=0.000> simple <sil=0.000> data
structures <sil=0.000> like <sil=0.000> array <sil=2.000> .PERIOD  Now <sil=0.000> here <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> related <sil=0.000> components - student <sil=0.000> name <sil=1.000> ,COMMA  roll
number <sil=0.000> and <sil=0.000> marks <sil=0.000> or <sil=0.000> CGPA <sil=0.000> or <sil=0.000> for <sil=0.000> example <sil=0.000> a real <sil=0.000> part <sil=0.000> and <sil=0.000> imaginary <sil=0.000> part <sil=0.000> of <sil=0.000> a complex <sil=0.000> number <sil=2.000> .PERIOD 

For <sil=0.000> example <sil=1.000> ,COMMA  if <sil=0.000> I had <sil=0.000> tried <sil=0.000> this <sil=1.000> ,COMMA  a <sil=0.000> complex <sil=0.000> number (all <sil=0.000> of <sil=0.000> you <sil=0.000> know <sil=0.000> that <sil=0.000> a complex <sil=0.000> number <sil=0.000> is
expressed <sil=0.000> as <sil=0.000> a plus <sil=0.000> ib) where <sil=0.000> x is <sil=0.000> a complex <sil=0.000> number <sil=0.000> a plus <sil=0.000> i b <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  maybe <sil=0.000> x is <sil=0.000> equal <sil=0.000> to <sil=0.000> 4 plus <sil=0.000> i 3 <sil=2.000> .PERIOD 
All <sil=0.000> of <sil=0.000> you <sil=0.000> are <sil=0.000> aware <sil=0.000> of <sil=0.000> that <sil=2.000> .PERIOD  Now <sil=0.000> how <sil=0.000> do <sil=0.000> I represent <sil=0.000> I know <sil=0.000> how <sil=0.000> could <sil=0.000> I can <sil=0.000> represent <sil=0.000> an
integer <sil=1.000> ,COMMA  I <sil=0.000> know <sil=1.000> ,COMMA  how <sil=0.000> I can <sil=0.000> represent <sil=0.000> a floating <sil=0.000> point <sil=0.000> number <sil=1.000> ,COMMA  but <sil=0.000> now <sil=0.000> the <sil=0.000> question <sil=0.000> is <sil=0.354> ;SEMICOLON  how <sil=0.000> I can
represent <sil=0.000> such <sil=0.000> a complex <sil=0.000> number <sil=0.228> ?QUESTIONMARK  Now <sil=0.000> well <sil=0.000> let <sil=0.000> me <sil=0.000> have <sil=0.000> a structure <sil=0.000> like <sil=0.000> this <sil=0.000> which <sil=0.000> will <sil=0.000> have <sil=0.000> 2
fields <sil=1.000> ,COMMA  one <sil=0.000> is <sil=0.000> the <sil=0.000> real <sil=0.000> part <sil=1.000> ,COMMA  there <sil=0.000> is <sil=0.000> a real <sil=0.000> part <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> call <sil=0.000> it <sil=0.000> the <sil=0.000> real <sil=0.000> part <sil=0.000> another <sil=0.000> part <sil=0.000> is <sil=0.000> the
imaginary <sil=0.000> part <sil=0.000> and <sil=0.000> I can <sil=0.000> store <sil=0.000> this <sil=0.000> number <sil=0.000> simply <sil=0.000> as <sil=0.000> 4 <sil=1.000> ,COMMA  3 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  the <sil=0.000> imaginary <sil=0.000> part <sil=0.000> is <sil=0.000> 3 and <sil=0.000> the <sil=0.000> real <sil=0.000> part <sil=0.000> is <sil=0.000> 4 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> complex <sil=0.000> number <sil=0.000> instead <sil=0.000> of <sil=0.000> being <sil=0.000> an
integer <sil=0.000> or <sil=0.000> a float <sil=0.000> is <sil=0.000> essentially <sil=0.000> a structure <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> another <sil=0.000> very <sil=0.000> common <sil=0.000> and <sil=0.000> easy <sil=0.000> use <sil=0.000> of
structures <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  whenever <sil=0.000> I refer <sil=0.000> to <sil=0.000> this <sil=0.000> variable <sil=0.000> x which <sil=0.000> is <sil=0.000> of <sil=0.000> type <sil=0.000> complex <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> be <sil=0.000> referring <sil=0.000> to
this <sil=0.000> structure <sil=0.000> and <sil=0.000> neither <sil=0.000> at <sil=0.000> 4 or <sil=0.000> nor <sil=0.000> at <sil=0.000> 3 <sil=2.000> .PERIOD  I <sil=0.000> will <sil=0.000> be <sil=0.000> looking <sil=0.000> at <sil=0.000> this <sil=0.000> whole <sil=0.000> thing <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  so <sil=1.000> ,COMMA  it <sil=0.000> helps <sil=0.000> us <sil=0.000> in <sil=0.000> organising <sil=0.000> the <sil=0.000> complex <sil=0.000> data <sil=0.000> in <sil=0.000> a much <sil=0.000> more <sil=0.000> meaningful <sil=0.000> way <sil=2.000> .PERIOD  The
individual <sil=0.000> structure <sil=0.000> elements <sil=0.000> that <sil=0.000> I was <sil=0.000> talking <sil=0.000> of <sil=0.000> which <sil=0.000> i was <sil=0.000> mentioning <sil=0.000> as <sil=0.000> fields <sil=0.000> is <sil=0.000> also <sil=0.000> known
as <sil=0.000> members <sil=2.000> .PERIOD  Now <sil=0.000> you <sil=0.000> will <sil=0.000> also <sil=0.000> find <sil=0.000> other <sil=0.000> names <sil=0.000> of <sil=0.000> structures  <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  structures <sil=0.000> are <sil=0.000> sometimes
called <sil=0.000> records <sil=0.000> and <sil=0.000> each <sil=0.000> of <sil=0.000> these <sil=0.000> horizontal <sil=0.000> boxes <sil=0.000> that <sil=0.000> we <sil=0.000> are <sil=0.000> drawing <sil=0.000> are <sil=0.000> called <sil=0.000> fields <sil=0.000> of <sil=0.000> that
record <sil=0.000> or <sil=0.000> when <sil=0.000> we <sil=0.000> referred <sil=0.000> to <sil=0.000> it <sil=0.000> as <sil=0.000> structures <sil=0.000> we <sil=0.000> call <sil=0.000> each <sil=0.000> of <sil=0.000> those <sil=0.000> smaller <sil=0.000> boxes <sil=0.000> as <sil=0.000> members <sil=2.000> .PERIOD 

So <sil=0.000> the <sil=0.000> composition <sil=0.000> of <sil=0.000> a structure <sil=0.000> can <sil=0.000> be <sil=0.000> defined <sil=0.000> as <sil=0.000> follows <sil=2.000> .PERIOD  See <sil=0.000> in <sil=0.000> a structure <sil=0.000> I can <sil=0.000> put <sil=0.000> a tag <sil=1.000> ,COMMA 
now <sil=0.000> this <sil=0.000> is <sil=0.000> very <sil=0.000> important <sil=0.354> ;SEMICOLON  what <sil=0.000> is <sil=0.000> the <sil=0.000> tag <sil=0.000> that <sil=0.000> I am <sil=0.000> putting <sil=0.000> over <sil=0.000> here <sil=0.228> ?QUESTIONMARK 

Say <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  earlier <sil=0.000> I was <sil=0.000> talking <sil=0.000> of <sil=0.000> student <sil=0.000> data <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  my <sil=0.000> tag <sil=0.000> could <sil=0.000> be <sil=0.000> stud <sil=0.000> data <sil=0.000> as <sil=0.000> I had
written <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> to <sil=0.000> write <sil=0.000> struct <sil=0.000> stud <sil=0.000> data <sil=0.000> and <sil=0.000> inside <sil=0.000> that <sil=0.000> I have <sil=0.000> got <sil=0.000> several <sil=0.000> members <sil=0.000> and <sil=0.000> what
where <sil=0.000> my <sil=0.000> members <sil=0.228> ?QUESTIONMARK  My <sil=0.000> member <sil=0.000> was <sil=0.000> name <sil=1.000> ,COMMA  my <sil=0.000> member <sil=0.000> was <sil=0.000> roll <sil=0.000> number <sil=1.000> ,COMMA  department <sil=0.000> and
CGPA <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> had <sil=0.000> 4 members <sil=2.000> .PERIOD  Now <sil=0.000> each <sil=0.000> of <sil=0.000> these <sil=0.000> were <sil=0.000> of <sil=0.000> different <sil=0.000> types <sil=0.000> that <sil=0.000> is <sil=0.000> something <sil=0.000> which
is <sil=0.000> very <sil=0.000> important <sil=0.000> to <sil=0.000> understand <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  struct <sil=0.000> is <sil=0.000> the <sil=0.000> required <sil=0.000> keyword <sil=0.000> I must <sil=0.000> write <sil=1.000> ,COMMA  this <sil=0.000> word -
struct <sil=2.000> .PERIOD  This  tag  is <sil=0.000> the <sil=0.000> name <sil=0.000> of <sil=0.000> the <sil=0.000> structure <sil=0.000> like <sil=0.000> stud <sil=0.000> data <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> a structure <sil=2.000> .PERIOD  Just <sil=0.000> as <sil=0.000> we <sil=0.000> had
done <sil=0.000> for <sil=0.000> other <sil=0.000> variables <sil=0.000> we <sil=0.000> had <sil=0.000> done <sil=0.000> say <sil=0.000> int <sil=0.000> x float <sil=0.000> y <sil=1.000> ,COMMA  etcetera <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> also <sil=0.000> instead <sil=0.000> of <sil=0.000> int <sil=0.000> or <sil=0.000> float <sil=0.000> I have <sil=0.000> to <sil=0.000> say <sil=0.000> struct <sil=0.000> and <sil=0.000> what <sil=0.000> is <sil=0.000> struct <sil=0.228> ?QUESTIONMARK  That <sil=0.000> is <sil=0.000> defined <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
first <sil=0.000> of <sil=0.000> all <sil=0.000> I have <sil=0.000> to <sil=0.000> define <sil=0.000> the <sil=0.000> structure <sil=2.000> .PERIOD  Int <sil=0.000> and <sil=0.000> float <sil=0.000> are <sil=0.000> defined <sil=0.000> by <sil=0.000> default <sil=0.000> any <sil=0.000> c compiler <sil=0.000> will
understand <sil=0.000> what <sil=0.000> int <sil=0.000> or <sil=0.000> float <sil=0.000> is <sil=1.000> ,COMMA  but <sil=0.000> if <sil=0.000> I write <sil=0.000> struct <sil=1.000> ,COMMA  then <sil=0.000> by <sil=0.000> default <sil=0.000> the <sil=0.000> compiler <sil=0.000> will <sil=0.000> not
understand <sil=0.000> what <sil=0.000> the <sil=0.000> structure <sil=0.000> is <sil=0.000> because <sil=0.000> there <sil=0.000> can <sil=0.000> be <sil=0.000> different <sil=0.000> structure <sil=1.000> ,COMMA  one <sil=0.000> structure <sil=0.000> can <sil=0.000> be <sil=0.000> for
student <sil=0.000> names <sil=1.000> ,COMMA  one <sil=0.000> structure <sil=0.000> can <sil=0.000> be <sil=0.000> for <sil=0.000> book <sil=0.000> details - if <sil=0.000> I had <sil=0.000> thought <sil=0.000> of <sil=0.000> a book <sil=0.000> detail <sil=0.000> and
wanted <sil=0.000> to <sil=0.000> store <sil=0.000> that <sil=0.000> in <sil=0.000> a structure <sil=1.000> ,COMMA  what <sil=0.000> will <sil=0.000> be <sil=0.000> the <sil=0.000> components <sil=0.228> ?QUESTIONMARK  The <sil=0.000> members <sil=0.000> will <sil=0.000> be <sil=0.000> of <sil=0.000> course
the <sil=0.000> title <sil=0.000> of <sil=0.000> the <sil=0.000> book <sil=1.000> ,COMMA  the <sil=0.000> author <sil=0.000> of <sil=0.000> the <sil=0.000> book <sil=0.000> the <sil=0.000> publisher <sil=0.000> year <sil=0.000> of <sil=0.000> publication <sil=1.000> ,COMMA  the <sil=0.000> ISBN <sil=0.000> number <sil=1.000> ,COMMA 
etc <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  therefore <sil=1.000> ,COMMA  each <sil=0.000> of <sil=0.000> these <sil=0.000> members <sil=0.000> will <sil=0.000> again <sil=0.000> be <sil=0.000> of <sil=0.000> different <sil=0.000> types <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> a
heterogeneous <sil=0.000> organisation <sil=0.000> just <sil=0.000> as <sil=0.000> it <sil=0.000> was <sil=0.000> with <sil=0.000> the <sil=0.000> student <sil=0.000> data <sil=2.000> .PERIOD  If <sil=0.000> I want <sil=0.000> to <sil=0.000> define <sil=0.000> books <sil=0.000> for
example <sil=1.000> ,COMMA  I <sil=0.000> would <sil=0.000> have <sil=0.000> to <sil=0.000> write <sil=0.000> struct <sil=0.000> book <sil=0.000> followed <sil=0.000> by <sil=0.000> the <sil=0.000> definition <sil=0.000> of <sil=0.000> the <sil=0.000> members <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is
equivalent <sil=0.000> to <sil=0.000> as <sil=0.000> if <sil=0.000> I am <sil=0.000> drawing <sil=0.000> a structure <sil=0.000> and <sil=0.000> its <sil=0.000> name <sil=0.000> is <sil=0.000> becoming - book <sil=0.000> and <sil=0.000> I am <sil=0.000> defining
what <sil=0.000> are <sil=0.000> the <sil=0.000> members <sil=0.000> of <sil=0.000> this <sil=0.000> structure <sil=2.000> .PERIOD  Let <sil=0.000> us <sil=0.000> move <sil=0.000> a little <sil=0.000> ahead <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  member <sil=0.000> 1 <sil=1.000> ,COMMA  member <sil=0.000> 2 <sil=1.000> ,COMMA  etcetera <sil=0.000> are <sil=0.000> individual <sil=0.000> member <sil=0.000> declarations <sil=2.000> .PERIOD  We <sil=0.000> will <sil=0.000> see <sil=0.000> more
examples <sil=0.000> of <sil=0.000> this <sil=2.000> .PERIOD  The <sil=0.000> individual <sil=0.000> members <sil=0.000> can <sil=0.000> be <sil=0.000> of <sil=0.000> different <sil=0.000> types <sil=0.000> and <sil=0.000> that <sil=0.000> is <sil=0.000> the <sil=0.000> beauty <sil=0.000> of
structure <sil=1.000> ,COMMA  the <sil=0.000> individual <sil=0.000> members <sil=0.000> can <sil=0.000> be <sil=0.000> ordinarily <sil=0.000> variables <sil=1.000> ,COMMA  pointers <sil=1.000> ,COMMA  arrays <sil=0.000> or <sil=0.000> other <sil=0.000> structures <sil=1.000> ,COMMA  it <sil=0.000> can <sil=0.000> even <sil=0.000> be <sil=0.000> other <sil=0.000> structure <sil=0.000> that <sil=0.000> is <sil=0.000> very <sil=0.000> important <sil=0.000> it <sil=0.000> can <sil=0.000> be <sil=0.000> some <sil=0.000> variable <sil=1.000> ,COMMA  just <sil=0.000> as <sil=0.000> name <sil=0.000> or <sil=0.000> it <sil=0.000> can <sil=0.000> be <sil=0.000> an <sil=0.000> array - say <sil=0.000> name <sil=0.000> was <sil=0.000> a character <sil=0.000> array <sil=0.000> or <sil=0.000> it <sil=0.000> can <sil=0.000> even <sil=0.000> be <sil=0.000> a structure <sil=2.000> .PERIOD  That <sil=0.000> means <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> have <sil=0.000> a structure <sil=0.000> within <sil=0.000> a structure <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> possible <sil=0.000> that <sil=0.000> I will <sil=0.000> have <sil=0.000> something <sil=0.000> like <sil=0.000> this <sil=2.000> .PERIOD 

One <sil=0.000> field <sil=0.000> of <sil=0.000> the <sil=0.000> structure <sil=0.000> is <sil=0.000> a character <sil=0.000> array <sil=1.000> ,COMMA  another <sil=0.000> field <sil=0.000> of <sil=0.000> the <sil=0.000> structure <sil=0.000> can <sil=0.000> be <sil=0.000> an <sil=0.000> integer
variable <sil=0.000> or <sil=0.000> another <sil=0.000> field <sil=0.000> of <sil=0.000> the <sil=0.000> structure <sil=0.000> can <sil=0.000> be <sil=0.000> a structure <sil=0.000> itself <sil=1.000> ,COMMA  it <sil=0.000> can <sil=0.000> be <sil=0.000> another <sil=0.000> structure
where <sil=0.000> there <sil=0.000> are <sil=0.000> more <sil=0.000> members <sil=0.000> inside <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> also <sil=0.000> possible  <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> the <sil=0.000> beauty <sil=0.000> and <sil=0.000> the <sil=0.000> flexibility <sil=0.000> that <sil=0.000> we <sil=0.000> get <sil=0.000> from <sil=0.000> structures <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> member <sil=0.000> names
within <sil=0.000> a particular <sil=0.000> structure <sil=0.000> must <sil=0.000> be <sil=0.000> distinct <sil=0.000> from <sil=0.000> one <sil=0.000> another <sil=1.000> ,COMMA  we <sil=0.000> cannot <sil=0.000> put <sil=0.000> the <sil=0.000> same <sil=0.000> name <sil=0.000> to <sil=0.000> 2 different <sil=0.000> structures <sil=2.000> .PERIOD  Once <sil=0.000> a structure <sil=0.000> has <sil=0.000> been <sil=0.000> defined <sil=0.000> individual <sil=0.000> structure <sil=0.000> type <sil=0.000> variables <sil=0.000> can <sil=0.000> be <sil=0.000> declared <sil=0.000> as (we <sil=0.000> will <sil=0.000> see) struct <sil=0.000> tag <sil=0.000> variable <sil=0.000> one <sil=0.000> variable <sil=0.000> 2 variable <sil=0.000> n <sil=1.000> ,COMMA  I <sil=0.000> think <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> much
more <sil=0.000> clearer <sil=1.000> ,COMMA  if <sil=0.000> we <sil=0.000> go <sil=0.000> through <sil=0.000> an <sil=0.000> example <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=0.000> example <sil=0.000> A <sil=2.000> .PERIOD 

First <sil=0.000> I start <sil=0.000> with <sil=0.000> a structure <sil=0.000> definition - struct <sil=0.000> student <sil=0.000> and <sil=0.000> then <sil=0.000> I put <sil=0.000> just <sil=0.000> 2 parentheses <sil=0.000> to <sil=0.000> show
that <sil=0.000> there <sil=0.000> will <sil=0.000> be <sil=0.000> some <sil=0.000> members <sil=0.000> defined <sil=0.000> inside <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  how <sil=0.000> do <sil=0.000> I define <sil=0.000> the <sil=0.000> members <sil=0.228> ?QUESTIONMARK  I <sil=0.000> say <sil=0.000> that <sil=0.000> one <sil=0.000> member <sil=0.000> is <sil=0.000> name <sil=0.000> which <sil=0.000> is <sil=0.000> an <sil=0.000> array <sil=0.000> of
character <sil=2.000> .PERIOD  The <sil=0.000> next <sil=0.000> one <sil=0.000> is <sil=0.000> roll <sil=0.000> number <sil=0.000> which <sil=0.000> is <sil=0.000> an <sil=0.000> integer <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  roll <sil=0.000> number <sil=0.000> is <sil=0.000> a variable <sil=2.000> .PERIOD  I <sil=0.000> said
that <sil=0.000> a structure <sil=0.000> can <sil=0.000> field <sil=0.000> can <sil=0.000> be <sil=0.000> variable <sil=0.000> or <sil=0.000> can <sil=0.000> be <sil=0.000> array <sil=0.000> or <sil=0.000> can <sil=0.000> be <sil=0.000> another <sil=0.000> structure <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> an <sil=0.000> example <sil=0.000> where <sil=0.000> you <sil=0.000> have <sil=0.000> an <sil=0.000> array <sil=0.000> and <sil=0.000> a variable <sil=0.000> of <sil=0.000> type <sil=0.000> int <sil=0.000> again <sil=1.000> ,COMMA  total <sil=0.000> marks <sil=0.000> can <sil=0.000> be <sil=0.000> integer <sil=1.000> ,COMMA  data <sil=0.000> of <sil=0.000> birth <sil=0.000> can <sil=0.000> be <sil=0.000> character <sil=0.000> and <sil=0.000> sizes <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  data <sil=0.000> birth <sil=0.000> is <sil=0.000> again <sil=0.000> of <sil=0.000> type <sil=0.000> array <sil=0.000> character <sil=0.000> array <sil=0.000> because <sil=0.000> the <sil=0.000> date <sil=0.000> of <sil=0.000> birth <sil=0.000> can <sil=0.000> be <sil=0.000> say <sil=0.000> 10 <sil=0.000> Jan <sil=1.000> ,COMMA  2010 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  like <sil=0.000> that <sil=0.000> it <sil=0.000> can <sil=0.000> be <sil=0.000> a character <sil=0.000> array <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> how <sil=0.000> a structure <sil=0.000> is <sil=0.000> defined <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> now <sil=0.000> defining <sil=0.000> the <sil=0.000> variables <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> defined <sil=0.000> the
structures <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> know <sil=0.000> once <sil=0.000> the <sil=0.000> compiler <sil=0.000> reads <sil=0.000> this <sil=0.000> and <sil=0.000> finds <sil=0.000> that <sil=0.000> well <sil=0.000> I some <sil=0.000> definition <sil=0.000> of
some <sil=0.000> variable <sil=0.000> called <sil=0.000> student <sil=0.000> I know <sil=0.000> that <sil=0.000> that <sil=0.000> is <sil=0.000> a structure <sil=0.000> and <sil=0.000> what <sil=0.000> is <sil=0.000> the <sil=0.000> constituent <sil=0.000> of <sil=0.000> that
structure <sil=0.228> ?QUESTIONMARK  That <sil=0.000> will <sil=0.000> be <sil=0.000> these <sil=0.000> fields <sil=2.000> .PERIOD 

Now <sil=0.000> this <sil=0.000> is <sil=0.000> just <sil=0.000> a type - just <sil=0.000> as <sil=0.000> we <sil=0.000> had <sil=0.000> int <sil=0.000> float <sil=1.000> ,COMMA  etcetera <sil=0.000> or <sil=0.000> char <sil=0.000> those <sil=0.000> where <sil=0.000> data <sil=0.000> types <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  I
am <sil=0.000> saying <sil=0.000> that <sil=0.000> I have <sil=0.000> got <sil=0.000> a structure <sil=0.000> of <sil=0.000> type <sil=0.000> this <sil=0.000> where <sil=0.000> there <sil=0.000> are <sil=0.000> 4 fields <sil=1.000> ,COMMA  but <sil=0.000> the <sil=0.000> data <sil=0.000> has <sil=0.000> not <sil=0.000> yet <sil=0.000> been <sil=0.000> put <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> very <sil=0.000> important <sil=0.000> though <sil=1.000> ,COMMA  there <sil=0.000> are <sil=0.000> 4 fields <sil=1.000> ,COMMA  one <sil=0.000> field <sil=0.000> is <sil=0.000> name <sil=0.000> and <sil=0.000> I say <sil=0.000> that <sil=0.000> is <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> thirty <sil=0.000> characters <sil=0.000> and <sil=0.000> there <sil=0.000> is <sil=0.000> a role <sil=0.000> number <sil=0.000> roll <sil=0.000> which <sil=0.000> is <sil=0.000> an <sil=0.000> int <sil=1.000> ,COMMA  total <sil=0.000> marks <sil=0.000> is <sil=0.000> an <sil=0.000> integer <sil=0.000> and <sil=0.000> date <sil=0.000> of <sil=0.000> birth <sil=0.000> is <sil=0.000> an <sil=0.000> array <sil=1.000> ,COMMA  but <sil=0.000> you <sil=0.000> see <sil=0.000> that <sil=0.000> there <sil=0.000> are <sil=0.000> no <sil=0.000> data <sil=0.000> already <sil=0.000> put <sil=0.000> inside <sil=0.000> this <sil=0.000> array <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> name <sil=0.000> variables - a <sil=0.000> 1 <sil=1.000> ,COMMA  a <sil=0.000> 2 <sil=1.000> ,COMMA  a <sil=0.000> 3 are <sil=0.000> variables <sil=0.000> of <sil=0.000> type <sil=0.000> student <sil=0.000> structure <sil=0.000> and <sil=0.000> what <sil=0.000> is
that <sil=0.000> student <sil=0.000> structure <sil=0.000> this <sil=0.000> is <sil=0.000> a structure <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  a <sil=0.000> 1 will <sil=0.000> just <sil=0.000> be <sil=0.000> a copy <sil=0.000> of <sil=0.000> this <sil=0.000> structure <sil=0.000> and <sil=0.000> a variable <sil=1.000> ,COMMA 
a <sil=0.000> 1 may <sil=0.000> have (if <sil=0.000> I take <sil=0.000> this) may <sil=0.000> have <sil=0.000> some <sil=0.000> name <sil=0.000> like <sil=0.000> amith <sil=0.000> here <sil=1.000> ,COMMA  roll <sil=0.000> number <sil=0.000> may <sil=0.000> be <sil=0.000> 560 <sil=0.000> and
total <sil=0.000> maybe <sil=0.000> 700 <sil=0.000> and <sil=0.000> date <sil=0.000> of <sil=0.000> birth <sil=0.000> can <sil=0.000> be <sil=0.000> something <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> one <sil=0.000> particular <sil=0.000> instance <sil=0.000> of <sil=0.000> this
particular <sil=0.000> structure <sil=0.000> that <sil=0.000> has <sil=0.000> been <sil=0.000> defined <sil=2.000> .PERIOD <sil=0.000> This <sil=0.000> part <sil=0.000> must <sil=0.000> be <sil=0.000> very <sil=0.000> clear <sil=0.000> to <sil=0.000> all <sil=0.000> of <sil=0.000> you <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> defined <sil=0.000> 3 variables <sil=0.000> a 1 <sil=1.000> ,COMMA  a <sil=0.000> 2 and <sil=0.000> a 3 <sil=0.000> each <sil=0.000> of <sil=0.000> type <sil=0.354> ;SEMICOLON  what <sil=0.000> kind <sil=0.000> of <sil=0.000> type <sil=0.228> ?QUESTIONMARK  type <sil=0.000> structure
student <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  type <sil=0.000> is <sil=0.000> struct <sil=0.000> student <sil=2.000> .PERIOD  We <sil=0.000> have <sil=0.000> got <sil=0.000> these <sil=0.000> fields <sil=0.000> as <sil=0.000> its <sil=0.000> constituents <sil=0.354> ;SEMICOLON  so <sil=0.000> struct <sil=0.000> student <sil=0.000> tells <sil=0.000> us <sil=0.000> a new <sil=0.000> data <sil=0.000> type <sil=0.000> and <sil=0.000> these <sil=0.000> are <sil=0.000> the <sil=0.000> variables <sil=0.000> of <sil=0.000> the <sil=0.000> data <sil=0.000> type <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> also <sil=0.000> possible <sil=0.000> to <sil=0.000> write <sil=0.000> it <sil=0.000> in <sil=0.000> a much <sil=0.000> more <sil=0.000> compact <sil=0.000> form <sil=0.000> like <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  struct <sil=0.000> tag <sil=0.000> and <sil=0.000> then <sil=0.000> i write
struct <sil=0.000> student <sil=0.000> and <sil=0.000> I declare <sil=0.000> char <sil=0.000> name <sil=0.000> 40 <sil=1.000> ,COMMA  int <sil=0.000> roll <sil=0.000> no <sil=1.000> ,COMMA  int <sil=0.000> total <sil=0.000> marks <sil=1.000> ,COMMA <sil=0.000> char <sil=0.000> date <sil=0.000> of <sil=0.000> birth <sil=0.000> 10 <sil=0.000> and
then <sil=0.000> I could <sil=0.000> have <sil=0.000> put <sil=0.000> the <sil=0.000> variables <sil=0.000> a 1 <sil=1.000> ,COMMA  a <sil=0.000> 2 <sil=1.000> ,COMMA  a <sil=0.000> 3 inside <sil=0.000> this <sil=0.000> note <sil=0.000> here <sil=1.000> ,COMMA  the <sil=0.000> semicolon <sil=0.000> is <sil=0.000> coming
here <sil=0.000> that <sil=0.000> is <sil=0.000> that <sil=0.000> is <sil=0.000> the <sil=0.000> end <sil=0.000> of <sil=0.000> the <sil=0.000> definition <sil=2.000> .PERIOD <sil=0.000> So <sil=1.000> ,COMMA  here <sil=0.000> I have <sil=0.000> done <sil=0.000> it <sil=0.000> in <sil=0.000> a much <sil=0.000> more <sil=0.000> compact <sil=0.000> form
compared <sil=0.000> to <sil=0.000> the <sil=0.000> earlier <sil=0.000> one <sil=2.000> .PERIOD  In <sil=0.000> this <sil=0.000> form <sil=0.000> of <sil=0.000> course <sil=1.000> ,COMMA  this <sil=0.000> tag <sil=0.000> is <sil=0.000> optional <sil=2.000> .PERIOD  (Refer <sil=0.000> Slide <sil=0.000> Time: 22:40)

So <sil=1.000> ,COMMA  what <sil=0.000> I mean <sil=0.000> is <sil=0.000> say <sil=0.000> I define <sil=0.000> once <sil=0.000> again <sil=0.000> let <sil=0.000> me <sil=0.000> give <sil=0.000> an <sil=0.000> example <sil=0.000> to <sil=0.000> you <sil=0.000> say <sil=0.000> a complex <sil=0.000> number
I <sil=0.000> can <sil=0.000> write <sil=0.000> that <sil=0.000> as <sil=0.000> struct <sil=0.000> complex <sil=0.000> and <sil=0.000> members <sil=0.000> are <sil=0.000> int(need <sil=0.000> not <sil=0.000> be <sil=0.000> always <sil=0.000> int) <sil=2.000> .PERIOD  So <sil=0.000> instead <sil=0.000> if <sil=0.000> I
want <sil=0.000> to <sil=0.000> store <sil=0.000> data <sil=0.000> of <sil=0.000> type <sil=0.000> say <sil=0.000> 4 <sil=2.000> .PERIOD <sil=0.000> 5 plus <sil=0.000> i 7 <sil=2.000> .PERIOD <sil=0.000> 2 <sil=1.000> ,COMMA  then <sil=0.000> I would <sil=0.000> need <sil=0.000> float <sil=0.000> real <sil=0.354> ;SEMICOLON  float <sil=0.000> imaginary <sil=0.000> and

that <sil=0.000> is <sil=0.000> the <sil=0.000> end <sil=0.000> of <sil=0.000> the <sil=0.000> structure <sil=0.000> and <sil=0.000> I can <sil=0.000> say <sil=0.000> struct <sil=0.000> complex <sil=0.000> x 1 <sil=1.000> ,COMMA  x <sil=0.000> 2 <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> one <sil=0.000> way <sil=0.000> of
representing <sil=0.000> structure <sil=2.000> .PERIOD 

What <sil=0.000> does <sil=0.000> it <sil=0.000> mean <sil=0.228> ?QUESTIONMARK  It <sil=0.000> means <sil=0.000> that <sil=0.000> I have <sil=0.000> first <sil=0.000> defined <sil=0.000> the <sil=0.000> structure <sil=0.000> called <sil=0.000> complex <sil=0.000> which <sil=0.000> will
have <sil=0.000> these <sil=0.000> 2 components <sil=0.000> and <sil=0.000> then <sil=0.000> I defined <sil=0.000> that <sil=0.000> x 1 <sil=0.000> and <sil=0.000> x 2 <sil=0.000> are <sil=0.000> 2 variables <sil=0.000> of <sil=0.000> type <sil=0.000> this <sil=0.000> complex <sil=2.000> .PERIOD 
If <sil=0.000> I do <sil=0.000> it <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=0.000> I have <sil=0.000> got <sil=0.000> an <sil=0.000> advantage <sil=0.000> that <sil=0.000> later <sil=0.000> on <sil=0.000> I can <sil=0.000> define <sil=0.000> some <sil=0.000> other <sil=0.000> variables <sil=0.000> also <sil=0.000> y1 <sil=0.000> y 2 <sil=0.000> over <sil=0.000> here <sil=0.000> or <sil=0.000> I can <sil=0.000> also <sil=0.000> define <sil=0.000> it <sil=0.000> as <sil=0.000> struct <sil=0.000> float <sil=0.000> real <sil=0.000> part <sil=2.000> .PERIOD 

So <sil=0.000> that <sil=0.000> you <sil=0.000> do <sil=0.000> not <sil=0.000> face <sil=0.000> confusion <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> float <sil=0.000> real <sil=0.000> part <sil=0.354> ;SEMICOLON  float <sil=0.000> imaginary <sil=0.000> part <sil=0.000> and <sil=0.000> then <sil=0.000> I can <sil=0.000> say <sil=0.000> x
1 <sil=1.000> ,COMMA  x <sil=0.000> 2 <sil=2.000> .PERIOD  Note <sil=0.000> that <sil=0.000> here <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> not <sil=0.000> written <sil=0.000> the <sil=0.000> thing <sil=0.000> complex <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> not <sil=0.000> written <sil=0.000> it <sil=2.000> .PERIOD <sil=0.000> I could <sil=0.000> have
written <sil=1.000> ,COMMA  it <sil=0.000> would <sil=0.000> not <sil=0.000> have <sil=0.000> affected <sil=0.000> me <sil=1.000> ,COMMA  in <sil=0.000> any <sil=0.000> adverse <sil=0.000> way <sil=1.000> ,COMMA  but <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> necessary <sil=0.000> to <sil=0.000> write <sil=0.000> it <sil=0.000> over
here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> I write <sil=0.000> this <sil=0.000> how <sil=0.000> will <sil=0.000> the <sil=0.000> compiler <sil=0.000> interpret <sil=0.000> it <sil=0.228> ?QUESTIONMARK <sil=0.000> Always <sil=0.000> you <sil=0.000> should <sil=0.000> think <sil=0.000> when
compiler <sil=0.000> looks <sil=0.000> at <sil=0.000> it <sil=0.000> what <sil=0.000> will <sil=0.000> it <sil=0.000> think <sil=0.000> what <sil=0.000> would <sil=0.000> it <sil=0.000> possibly <sil=0.000> do <sil=0.228> ?QUESTIONMARK 

So <sil=1.000> ,COMMA  the <sil=0.000> compiler <sil=0.000> is <sil=0.000> trying <sil=0.000> to <sil=0.000> understand <sil=0.000> ok <sil=0.000> now <sil=0.000> there <sil=0.000> is <sil=0.000> no <sil=0.000> ambiguity <sil=0.000> because <sil=0.000> it <sil=0.000> knows <sil=0.000> that <sil=0.000> x 1
and <sil=0.000> x 2 <sil=0.000> are <sil=0.000> 2 variables <sil=0.000> of <sil=0.000> type <sil=0.000> structure <sil=0.000> and <sil=0.000> the <sil=0.000> structure <sil=0.000> is <sil=0.000> defined <sil=0.000> here <sil=0.000> itself <sil=2.000> .PERIOD  I <sil=0.000> need <sil=0.000> not <sil=0.000> give
any <sil=0.000> name <sil=1.000> ,COMMA  but <sil=0.000> the <sil=0.000> advantage <sil=0.000> of <sil=0.000> giving <sil=0.000> a name <sil=0.000> is <sil=0.000> say <sil=0.000> I give <sil=0.000> the <sil=0.000> name <sil=0.000> complex <sil=0.000> here <sil=2.000> .PERIOD  Here <sil=0.000> I have
defined <sil=0.000> x 1 <sil=0.000> and <sil=0.000> x 2 <sil=1.000> ,COMMA  if <sil=0.000> I had <sil=0.000> done <sil=0.000> it <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=0.000> I could <sil=0.000> have <sil=0.000> later <sil=0.000> on <sil=1.000> ,COMMA  down <sil=0.000> the <sil=0.000> line <sil=0.000> in <sil=0.000> this
program <sil=1.000> ,COMMA  have <sil=0.000> written <sil=0.000> struct <sil=0.000> complex <sil=0.000> say <sil=0.000> y 1 <sil=0.000> z 1( its <sil=0.000> possible <sil=1.000> ,COMMA  because <sil=0.000> I have <sil=0.000> already <sil=0.000> defined
struct <sil=0.000> complex ) <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  there <sil=0.000> is <sil=0.000> a choice <sil=0.000> over <sil=0.000> here <sil=0.000> which <sil=0.000> you <sil=0.000> can <sil=0.000> think <sil=0.000> of <sil=0.000> let <sil=0.000> us <sil=0.000> go <sil=0.000> ahead <sil=0.000> a little <sil=0.000> bit <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  in <sil=0.000> this <sil=0.000> case
the <sil=0.000> tag <sil=0.000> is <sil=0.000> optional <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> an <sil=0.000> example <sil=0.000> we <sil=0.000> will <sil=0.000> conclude <sil=0.000> this <sil=0.000> lecture <sil=0.000> with <sil=0.000> this <sil=0.000> example <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  struct <sil=0.000> student
character <sil=0.000> name <sil=0.000> thirty <sil=0.354> ;SEMICOLON  int <sil=0.000> roll <sil=0.000> number <sil=0.354> ;SEMICOLON  int <sil=0.000> total <sil=0.000> marks <sil=0.354> ;SEMICOLON  character <sil=0.000> data <sil=0.000> birth <sil=0.000> 10 <sil=1.000> ,COMMA  a <sil=0.000> 1 <sil=1.000> ,COMMA  a <sil=0.000> 2 <sil=1.000> ,COMMA  a <sil=0.000> 3 <sil=0.354> ;SEMICOLON  that
means <sil=1.000> ,COMMA  a <sil=0.000> 1 <sil=1.000> ,COMMA  a <sil=0.000> 2 and <sil=0.000> a 3 <sil=0.000> are <sil=0.000> 3 students <sil=1.000> ,COMMA  3 <sil=0.000> pieces <sil=0.000> of <sil=0.000> student <sil=0.000> information <sil=0.000> or <sil=0.000> I could <sil=0.000> have <sil=0.000> done <sil=0.000> it <sil=0.000> in
the <sil=0.000> way <sil=0.000> I have <sil=0.000> just <sil=0.000> now <sil=0.000> shown <sil=1.000> ,COMMA  the <sil=0.000> same <sil=0.000> thing <sil=0.000> without <sil=0.000> giving <sil=0.000> any <sil=0.000> tag <sil=0.000> over <sil=0.000> here <sil=1.000> ,COMMA  these <sil=0.000> are
equivalent <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  next <sil=0.000> lecture <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> talk <sil=0.000> about <sil=0.000> how <sil=0.000> do <sil=0.000> you <sil=0.000> process <sil=0.000> a structure <sil=0.000> that <sil=0.000> will <sil=0.000> come <sil=0.000> in <sil=0.000> the <sil=0.000> next
lecture <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  in <sil=0.000> the <sil=0.000> last <sil=0.000> lecture <sil=0.000> we <sil=0.000> had <sil=0.000> seen <sil=0.000> how <sil=0.000> a structure <sil=0.000> is <sil=0.000> defined <sil=2.000> .PERIOD  Now <sil=0.000> we <sil=0.000> will <sil=0.000> see <sil=0.000> more <sil=0.000> examples <sil=0.000> of <sil=0.000> that <sil=0.000> in <sil=0.000> this <sil=0.000> course <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  today <sil=0.000> we <sil=0.000> will <sil=0.000> be <sil=0.000> concentrating <sil=0.000> on <sil=0.000> how <sil=0.000> a particular <sil=0.000> structure <sil=0.000> can <sil=0.000> be
processed <sil=2.000> .PERIOD  In <sil=0.000> order <sil=0.000> to <sil=0.000> process <sil=0.000> a structure <sil=1.000> ,COMMA  we <sil=0.000> can <sil=0.000> we <sil=0.000> have <sil=0.000> to <sil=0.000> process <sil=0.000> every <sil=0.000> field <sil=0.000> of <sil=0.000> the <sil=0.000> structure <sil=2.000> .PERIOD 
We <sil=0.000> can <sil=0.000> operate <sil=0.000> on <sil=0.000> every <sil=0.000> field <sil=0.000> of <sil=0.000> the <sil=0.000> structure <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  we <sil=0.000> can <sil=0.000> see <sil=0.000> that <sil=0.000> a structure <sil=0.000> how <sil=0.000> can <sil=0.000> we <sil=0.000> access <sil=0.000> the <sil=0.000> member <sil=0.000> of <sil=0.000> a structure <sil=2.000> .PERIOD  Say <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA 
there <sil=0.000> is <sil=0.000> a variable <sil=0.000> like <sil=0.000> name <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> can <sil=0.000> say <sil=0.000> overalls <sil=0.000> name <sil=0.000> of <sil=0.000> the <sil=0.000> structure <sil=0.000> is <sil=0.000> say <sil=0.000> student <sil=0.000> all
right <sil=0.354> ;SEMICOLON  and <sil=0.000> in <sil=0.000> the <sil=0.000> inside <sil=0.000> student <sil=0.000> we <sil=0.000> have <sil=0.000> got <sil=0.000> name <sil=1.000> ,COMMA  roll <sil=0.000> number <sil=0.000> etcetera <sil=0.000> now <sil=0.000> I can <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  my
variable <sil=0.000> is <sil=0.000> say <sil=0.000> all <sil=0.000> right <sil=0.000> let <sil=0.000> me <sil=0.000> say <sil=0.000> I have <sil=0.000> defined <sil=0.000> like <sil=0.000> this <sil=0.000> struct <sil=0.000> student <sil=1.000> ,COMMA  then <sil=0.000> all <sil=0.000> these <sil=0.000> then <sil=0.000> the
variables <sil=0.000> are <sil=0.000> a 1 <sil=1.000> ,COMMA  a <sil=0.000> 2 <sil=1.000> ,COMMA  a <sil=0.000> 3 I <sil=0.000> am <sil=0.000> sure <sil=0.000> you <sil=0.000> are <sil=0.000> getting <sil=0.000> confused <sil=0.000> a little <sil=0.000> bit <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> define <sil=0.000> it <sil=0.000> in <sil=0.000> the <sil=0.000> proper <sil=0.000> way <sil=0.000> as <sil=0.000> we <sil=0.000> are <sil=0.000> done <sil=0.000> in <sil=0.000> the <sil=0.000> last <sil=0.000> class <sil=2.000> .PERIOD  Suppose <sil=0.000> I define <sil=0.000> struct
student <sil=1.000> ,COMMA  char <sil=0.000> name <sil=0.000> 10 <sil=1.000> ,COMMA  int <sil=0.000> roll <sil=0.000> number <sil=0.000> all <sil=0.000> right <sil=0.000> suppose <sil=0.000> only <sil=0.000> two <sil=0.000> fields <sil=0.000> are <sil=0.000> there <sil=0.000> and <sil=0.000> I also <sil=0.000> say
that <sil=0.000> the <sil=0.000> variable <sil=0.000> is <sil=0.000> variables <sil=0.000> are <sil=0.000> x 1 <sil=0.000> comma <sil=0.000> x 2 <sil=0.000> these <sil=0.000> are <sil=0.000> 2 variables <sil=0.000> of <sil=0.000> the <sil=0.000> type <sil=0.000> of <sil=0.000> this <sil=0.000> structure
whose <sil=0.000> name <sil=0.000> is <sil=0.000> student <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> my <sil=0.000> variable <sil=0.000> named <sil=0.228> ?QUESTIONMARK  x <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> I can <sil=0.000> say <sil=0.000> x 1 <sil=0.000> x 1 <sil=0.000> dot <sil=0.000> this <sil=0.000> is <sil=0.000> the <sil=0.000> dot <sil=0.000> operator <sil=0.000> which <sil=0.000> tells <sil=0.000> about <sil=0.000> the <sil=0.000> member <sil=1.000> ,COMMA  now <sil=0.000> which <sil=0.000> member <sil=0.000> say <sil=0.000> I want <sil=0.000> to <sil=0.000> get <sil=0.000> the <sil=0.000> roll
number <sil=2.000> .PERIOD  x <sil=0.000> 1 dot <sil=0.000> roll <sil=0.000> number <sil=0.000> assign <sil=0.000> 720 <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> how <sil=0.000> I can <sil=0.000> get <sil=0.000> access <sil=0.000> to <sil=0.000> a particular
member <sil=0.000> of <sil=0.000> a particular <sil=0.000> structure <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> also <sil=0.000> similarly <sil=0.000> write <sil=0.000> x 2 <sil=0.000> dot <sil=0.000> name <sil=2.000> .PERIOD 

Because <sil=0.000> that <sil=0.000> members <sil=0.000> name <sil=0.000> is <sil=0.000> name <sil=0.000> right <sil=0.000> name <sil=0.000> 3 is <sil=0.000> j all <sil=0.000> right <sil=0.000> because <sil=0.000> name <sil=0.000> has <sil=0.000> got <sil=0.000> a 10 <sil=0.000> field
character <sil=0.000> ok <sil=2.000> .PERIOD  I <sil=0.000> could <sil=0.000> have <sil=0.000> written <sil=0.000> x 2 <sil=0.000> dot <sil=0.000> name <sil=0.000> and <sil=0.000> I could <sil=0.000> have <sil=0.000> assigned <sil=0.000> a string <sil=0.000> to <sil=0.000> this <sil=0.000> all <sil=0.000> these <sil=0.000> are <sil=0.000> possible <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  if <sil=0.000> this <sil=0.000> is <sil=0.000> clear <sil=0.000> then <sil=0.000> we <sil=0.000> go <sil=0.000> ahead <sil=0.000> a little <sil=0.000> bit <sil=0.000> were <sil=0.000> variable <sil=0.000> refers <sil=0.000> this <sil=0.000> variable <sil=0.000> is <sil=0.000> referring <sil=0.000> to <sil=0.000> is
referring <sil=0.000> to <sil=0.000> the <sil=0.000> name <sil=0.000> of <sil=0.000> a structure <sil=0.000> type <sil=0.000> variable <sil=0.000> and <sil=0.000> member <sil=0.000> is <sil=0.000> the <sil=0.000> referring <sil=0.000> to <sil=0.000> the <sil=0.000> field <sil=0.000> or <sil=0.000> the
particular <sil=0.000> member <sil=0.000> element <sil=0.000> ok <sil=2.000> .PERIOD  The <sil=0.000> examples <sil=0.000> are <sil=0.000> a 1 <sil=0.000> dot <sil=0.000> name <sil=1.000> ,COMMA  a <sil=0.000> 1 dot <sil=0.000> roll <sil=0.000> number <sil=1.000> ,COMMA  a <sil=0.000> 3 dot <sil=0.000> date <sil=0.000> of <sil=0.000> birth <sil=0.000> etcetera <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  now <sil=0.000> here <sil=0.000> let <sil=0.000> us <sil=0.000> take <sil=0.000> the <sil=0.000> old <sil=0.000> example <sil=0.000> that <sil=0.000> we <sil=0.000> had <sil=0.000> seen <sil=0.000> that <sil=0.000> is <sil=0.000> a complex <sil=0.000> number <sil=0.000> and <sil=0.000> how <sil=0.000> we
can <sil=0.000> perform <sil=0.000> complex <sil=0.000> number <sil=0.000> addition <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  just <sil=0.000> to <sil=0.000> refresh <sil=0.000> your <sil=0.000> mind <sil=0.000> say <sil=0.000> I have <sil=0.000> I have <sil=0.000> got <sil=0.000> two
complex <sil=0.000> numbers <sil=0.000> x and <sil=0.000> y and <sil=0.000> I want <sil=0.000> to <sil=0.000> perform <sil=0.000> x plus <sil=0.000> y <sil=2.000> .PERIOD  Suppose <sil=0.000> x is <sil=0.000> a plus <sil=0.000> i b <sil=0.000> and <sil=0.000> y is <sil=0.000> m plus <sil=0.000> in <sil=0.000> then <sil=0.000> x plus <sil=0.000> y is <sil=0.000> the <sil=0.000> real <sil=0.000> parts <sil=0.000> are <sil=0.000> added <sil=0.000> separately <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> a plus <sil=0.000> m plus <sil=0.000> i then <sil=0.000> the <sil=0.000> imaginary
parts <sil=0.000> are <sil=0.000> added <sil=0.000> separately <sil=1.000> ,COMMA  b <sil=0.000> plus <sil=0.000> n that <sil=0.000> we <sil=0.000> know <sil=0.000> from <sil=0.000> our <sil=0.000> school <sil=0.000> level <sil=0.000> knowledge <sil=2.000> .PERIOD 

Now <sil=0.000> how <sil=0.000> can <sil=0.000> I perform <sil=0.000> this <sil=0.000> addition <sil=0.000> using <sil=0.000> the <sil=0.000> concept <sil=0.000> of <sil=0.000> a structure <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> you <sil=0.000> see <sil=0.000> in <sil=0.000> the
program <sil=1.000> ,COMMA  we <sil=0.000> define <sil=0.000> a structure <sil=0.000> called <sil=0.000> complex <sil=0.000> and <sil=0.000> there <sil=0.000> are <sil=0.000> three <sil=0.000> variables <sil=0.000> a <sil=1.000> ,COMMA  b <sil=0.000> and <sil=0.000> c of <sil=0.000> this
structure <sil=0.000> type <sil=0.000> of <sil=0.000> type <sil=0.000> complex <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  what <sil=0.000> are <sil=0.228> ?QUESTIONMARK  There <sil=0.000> that <sil=0.000> components <sil=0.000> are <sil=0.000> one <sil=0.000> is <sil=0.000> float
sorry <sil=0.000> I am <sil=0.000> sorry <sil=0.000> one <sil=0.000> is <sil=0.000> real <sil=0.000> part <sil=1.000> ,COMMA  another <sil=0.000> is <sil=0.000> I should <sil=0.000> rename <sil=0.000> this <sil=0.000> is <sil=0.000> actually <sil=0.000> the <sil=0.000> imaginary <sil=0.000> part <sil=0.000> its
renamed <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=0.000> here <sil=0.000> in <sil=0.000> this <sil=0.000> program <sil=0.000> it <sil=0.000> would <sil=0.000> have <sil=0.000> been <sil=0.000> better <sil=1.000> ,COMMA  if <sil=0.000> we <sil=0.000> I had <sil=0.000> written <sil=0.000> float <sil=0.000> real
part <sil=0.000> float <sil=0.000> imaginary <sil=0.000> part <sil=0.000> however <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  scan <sil=0.000> f I <sil=0.000> am <sil=0.000> reading <sil=0.000> the <sil=0.000> two <sil=0.000> numbers <sil=0.000> a is <sil=0.000> a variable <sil=1.000> ,COMMA  a <sil=0.000> is <sil=0.000> real <sil=0.000> part <sil=0.000> is <sil=0.000> being <sil=0.000> read <sil=0.000> and <sil=0.000> a is
complex <sil=0.000> part <sil=0.000> is <sil=0.000> being <sil=0.000> read <sil=0.000> note <sil=0.000> the <sil=0.000> format <sil=0.000> statements <sil=0.000> because <sil=0.000> both <sil=0.000> of <sil=0.000> them <sil=0.000> are <sil=0.000> float <sil=0.000> we <sil=0.000> are
putting <sil=0.000> percentage <sil=0.000> f all <sil=0.000> right <sil=2.000> .PERIOD  And <sil=0.000> so <sil=1.000> ,COMMA  I <sil=0.000> read <sil=0.000> a <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you <sil=0.000> see <sil=0.000> normally <sil=0.000> I would <sil=0.000> have <sil=0.000> just <sil=0.000> done <sil=0.000> scan <sil=0.000> f amperes <sil=0.000> and <sil=0.000> a <sil=1.000> ,COMMA  but <sil=0.000> here <sil=0.000> I have <sil=0.000> to <sil=0.000> do <sil=0.000> separately <sil=0.000> I have <sil=0.000> to <sil=0.000> read <sil=0.000> the <sil=0.000> real <sil=0.000> part <sil=0.000> and <sil=0.000> the <sil=0.000> imaginary
part <sil=1.000> ,COMMA  then <sil=0.000> the <sil=0.000> sum <sil=0.000> is <sil=0.000> being <sil=0.000> stored <sil=0.000> in <sil=0.000> c <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  c <sil=0.000> is <sil=0.000> real <sil=0.000> will <sil=0.000> be <sil=0.000> c is <sil=0.000> the <sil=0.000> sum <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> real <sil=0.000> will <sil=0.000> be <sil=0.000> sorry <sil=0.000> it <sil=0.000> is <sil=0.000> a real <sil=0.000> part <sil=0.000> will <sil=0.000> be <sil=0.000> the <sil=0.000> real <sil=0.000> part <sil=0.000> of
a <sil=0.000> plus <sil=0.000> the <sil=0.000> real <sil=0.000> part <sil=0.000> of <sil=0.000> b and <sil=0.000> the <sil=0.000> imaginary <sil=0.000> part <sil=0.000> or <sil=0.000> the <sil=0.000> as <sil=0.000> it <sil=0.000> is <sil=0.000> written <sil=0.000> here <sil=0.000> complex <sil=0.000> part <sil=0.000> is <sil=0.000> the
complex <sil=0.000> part <sil=0.000> of <sil=0.000> imaginary <sil=0.000> part <sil=0.000> of <sil=0.000> a plus <sil=0.000> the <sil=0.000> imaginary <sil=0.000> part <sil=0.000> of <sil=0.000> b <sil=2.000> .PERIOD  Then <sil=0.000> I am <sil=0.000> printing <sil=0.000> look <sil=0.000> at <sil=0.000> how
I <sil=0.000> am <sil=0.000> printing <sil=0.000> it <sil=1.000> ,COMMA  printing <sil=0.000> percentage <sil=0.000> f the <sil=0.000> real <sil=0.000> part <sil=0.000> of <sil=0.000> c and <sil=0.000> plus <sil=0.000> then <sil=0.000> I put <sil=0.000> j and <sil=0.000> then <sil=0.000> the <sil=0.000> complex
part <sil=0.000> of <sil=0.000> c <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> being <sil=0.000> done <sil=0.000> is <sil=0.000> suppose <sil=0.000> I have <sil=0.000> got <sil=0.000> 2 numbers <sil=1.000> ,COMMA  3 <sil=2.000> .PERIOD <sil=0.000> 4 plus <sil=0.000> here <sil=0.000> I am <sil=0.000> using <sil=0.000> j some <sil=0.000> people <sil=0.000> I usually <sil=0.000> use <sil=0.000> i or <sil=0.000> j whatever <sil=0.000> you <sil=0.000> do <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  you <sil=0.000> write <sil=0.000> 7 <sil=2.000> .PERIOD <sil=0.000> 2 that <sil=0.000> is <sil=0.000> a is <sil=0.000> real <sil=0.000> part <sil=0.000> is <sil=0.000> this <sil=1.000> ,COMMA  and <sil=0.000> b is <sil=0.000> real <sil=0.000> part <sil=0.000> is <sil=0.000> say <sil=0.000> 4 <sil=2.000> .PERIOD <sil=0.000> 6 plus <sil=0.000> j 3 <sil=2.000> .PERIOD <sil=0.000> 8 now <sil=0.000> if <sil=0.000> I add <sil=0.000> them <sil=0.000> c will <sil=0.000> be <sil=0.000> these <sil=0.000> real <sil=0.000> parts <sil=0.000> are <sil=0.000> being <sil=0.000> added <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> 8 <sil=2.000> .PERIOD <sil=0.000> 0 plus <sil=0.000> the <sil=0.000> imaginary <sil=0.000> part <sil=0.000> is <sil=0.000> added <sil=0.000> that <sil=0.000> is <sil=0.000> 11 <sil=0.000> j 11 <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=0.000> is <sil=0.000> 8 plus <sil=0.000> j then <sil=0.000> the <sil=0.000> complex <sil=0.000> part <sil=0.000> 7 <sil=2.000> .PERIOD <sil=0.000> 0 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> a I <sil=0.000> think <sil=0.000> this <sil=0.000> is <sil=0.000> clear <sil=0.000> to <sil=0.000> you <sil=0.000> this <sil=0.000> not <sil=0.000> very <sil=0.000> difficult <sil=0.000> to <sil=0.000> understand <sil=0.000> let <sil=0.000> us <sil=0.000> move <sil=0.000> ahead <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  you <sil=0.000> have <sil=0.000> seen <sil=0.000> here <sil=1.000> ,COMMA  if <sil=0.000> you <sil=0.000> note <sil=0.000> here <sil=0.000> you <sil=0.000> have <sil=0.000> got <sil=0.000> the <sil=0.000> structure <sil=0.000> definition <sil=0.000> specified <sil=0.000> and <sil=0.000> here <sil=0.000> are <sil=0.000> the <sil=0.000> very <sil=0.000> variable <sil=0.000> definitions <sil=2.000> .PERIOD  And <sil=0.000> here <sil=0.000> we <sil=0.000> are <sil=0.000> doing <sil=0.000> the <sil=0.000> reading <sil=0.000> and <sil=0.000> adding <sil=0.000> them <sil=0.000> part <sil=0.000> by <sil=0.000> part <sil=0.000> how <sil=0.000> am <sil=0.000> I accessing <sil=0.000> the <sil=0.000> members <sil=2.000> .PERIOD  I <sil=0.000> am <sil=0.000> accessing <sil=0.000> the <sil=0.000> members <sil=0.000> using <sil=0.000> this <sil=0.000> dot <sil=0.000> operator <sil=0.000> and
whenever <sil=0.000> I am <sil=0.000> reading <sil=0.000> the <sil=0.000> member <sil=0.000> I am <sil=0.000> actually <sil=0.000> reading <sil=0.000> the <sil=0.000> members <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> not <sil=0.000> reading <sil=0.000> the
structure <sil=0.000> as <sil=0.000> a whole <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  one <sil=0.000> thing <sil=0.000> to <sil=0.000> note <sil=0.000> is <sil=0.000> when <sil=0.000> I am <sil=0.000> declaring <sil=0.000> this <sil=0.000> structure <sil=0.000> inside <sil=0.000> the <sil=0.000> main <sil=1.000> ,COMMA  then <sil=0.000> the <sil=0.000> scope <sil=0.000> of
these <sil=0.000> variables <sil=0.000> real <sil=0.000> and <sil=0.000> complex <sil=0.000> etcetera <sil=0.000> or <sil=0.000> this <sil=0.000> structure <sil=0.000> as <sil=0.000> such <sil=0.000> is <sil=0.000> its <sil=0.000> scope <sil=0.000> is <sil=0.000> within <sil=0.000> the <sil=0.000> main <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  if <sil=0.000> a structure <sil=0.000> is <sil=0.000> defined <sil=0.000> within <sil=0.000> a function <sil=1.000> ,COMMA  then <sil=0.000> as <sil=0.000> we <sil=0.000> exit <sil=0.000> that <sil=0.000> function <sil=0.000> the <sil=0.000> life <sil=0.000> of <sil=0.000> that
particular <sil=0.000> structure <sil=0.000> will <sil=0.000> end <sil=0.000> at <sil=0.000> that <sil=0.000> point <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  there <sil=0.000> are <sil=0.000> some <sil=0.000> things <sil=0.000> which <sil=0.000> we <sil=0.000> can <sil=0.000> do <sil=0.000> in <sil=0.000> a much <sil=0.000> more <sil=0.000> simpler <sil=0.000> way <sil=1.000> ,COMMA  you <sil=0.000> remember <sil=0.000> that <sil=0.000> in
the <sil=0.000> case <sil=0.000> of <sil=0.000> arrays <sil=0.000> we <sil=0.000> could <sil=0.000> not <sil=0.000> compare <sil=0.000> arrays <sil=0.000> together <sil=2.000> .PERIOD  That <sil=0.000> array <sil=0.000> a 1 <sil=0.000> is <sil=0.000> equal <sil=0.000> to <sil=0.000> a 2 <sil=0.000> that <sil=0.000> was
not <sil=0.000> possible <sil=1.000> ,COMMA  if <sil=0.000> we <sil=0.000> had <sil=0.000> to <sil=0.000> compare <sil=0.000> the <sil=0.000> array <sil=0.000> I had <sil=0.000> to <sil=0.000> check <sil=0.000> them <sil=0.000> element <sil=0.000> by <sil=0.000> element <sil=2.000> .PERIOD  On <sil=0.000> the
other <sil=0.000> hand <sil=0.000> in <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> a structure <sil=1.000> ,COMMA  a <sil=0.000> structure <sil=0.000> variable <sil=0.000> can <sil=0.000> be <sil=0.000> directly <sil=0.000> assigned <sil=0.000> to <sil=0.000> another
structure <sil=0.000> variable <sil=0.000> of <sil=0.000> the <sil=0.000> same <sil=0.000> type <sil=2.000> .PERIOD  For <sil=0.000> example <sil=1.000> ,COMMA  here <sil=0.000> if <sil=0.000> a is <sil=0.000> a structure <sil=1.000> ,COMMA  then <sil=0.000> I can <sil=0.000> assign <sil=0.000> another
structure <sil=0.000> b to <sil=0.000> it <sil=0.000> directly <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  all <sil=0.000> the <sil=0.000> elements <sil=0.000> if <sil=0.000> they <sil=0.000> are <sil=0.000> of <sil=0.000> course <sil=1.000> ,COMMA  of <sil=0.000> the <sil=0.000> same <sil=0.000> type <sil=0.354> ;SEMICOLON  So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> one <sil=0.000> structure <sil=1.000> ,COMMA  here <sil=0.000> is
another <sil=0.000> structure <sil=0.000> now <sil=0.000> if <sil=0.000> I do <sil=0.000> this <sil=0.000> operation  <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  assignment <sil=0.000> then <sil=0.000> this <sil=0.000> will <sil=0.000> be <sil=0.000> copied
here <sil=1.000> ,COMMA  this <sil=0.000> will <sil=0.000> be <sil=0.000> copied <sil=0.000> here <sil=1.000> ,COMMA  this <sil=0.000> will <sil=0.000> be <sil=0.000> copied <sil=0.000> here <sil=1.000> ,COMMA  this <sil=0.000> will <sil=0.000> be <sil=0.000> copied <sil=0.000> here <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD 

But <sil=0.000> if <sil=0.000> a and <sil=0.000> b where <sil=0.000> arrays <sil=0.000> in <sil=0.000> that <sil=0.000> case <sil=1.000> ,COMMA  that <sil=0.000> would <sil=0.000> not <sil=0.000> have <sil=0.000> been <sil=0.000> possible <sil=0.000> that <sil=0.000> a is <sil=0.000> an <sil=0.000> array <sil=0.000> and <sil=0.000> b is <sil=0.000> an <sil=0.000> array <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> elements <sil=0.000> just <sil=0.000> by <sil=0.000> assigning <sil=0.000> a assign <sil=0.000> b <sil=1.000> ,COMMA  I <sil=0.000> could <sil=0.000> not <sil=0.000> assign <sil=0.000> these <sil=0.000> b elements <sil=0.000> to <sil=0.000> a that <sil=0.000> is <sil=0.000> not <sil=0.000> allowed <sil=0.000> in <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> an <sil=0.000> array <sil=0.354> ;SEMICOLON  however <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> possible <sil=0.000> in <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> a structure <sil=2.000> .PERIOD 

Secondly <sil=0.000> now <sil=0.000> here <sil=0.000> one <sil=0.000> important <sil=0.000> thing <sil=0.000> is <sil=0.000> that <sil=0.000> they <sil=0.000> must <sil=0.000> be <sil=0.000> of <sil=0.000> the <sil=0.000> same <sil=0.000> type <sil=0.000> all <sil=0.000> right <sil=0.000> otherwise
of <sil=0.000> course <sil=1.000> ,COMMA  the <sil=0.000> members <sil=0.000> and <sil=0.000> the <sil=0.000> fields <sil=0.000> will <sil=0.000> not <sil=0.000> match <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  a <sil=0.000> 1 assigned <sil=0.000> a 2 <sil=0.000> I can <sil=0.000> do <sil=1.000> ,COMMA  all <sil=0.000> the <sil=0.000> individual <sil=0.000> members <sil=0.000> get <sil=0.000> assigned <sil=2.000> .PERIOD  Two <sil=0.000> structure <sil=0.000> variables
cannot <sil=0.000> be <sil=0.000> compared <sil=0.000> for <sil=0.000> equality <sil=0.000> or <sil=0.000> inequality <sil=2.000> .PERIOD  Now <sil=0.000> this <sil=0.000> is <sil=0.000> important <sil=0.000> that <sil=0.000> two <sil=0.000> structure <sil=0.000> variables
I <sil=0.000> cannot <sil=0.000> compare <sil=0.000> them <sil=1.000> ,COMMA  that <sil=0.000> structure <sil=0.000> a 1 <sil=0.000> whether <sil=0.000> that <sil=0.000> is <sil=0.000> equal <sil=0.000> to <sil=0.000> a 2 <sil=0.000> that <sil=0.000> will <sil=0.000> have <sil=0.000> to <sil=0.000> do
compare <sil=0.000> I mean <sil=1.000> ,COMMA  what <sil=0.000> I said <sil=0.000> just <sil=0.000> a couple <sil=0.000> of <sil=0.000> minutes <sil=0.000> back <sil=0.000> was <sil=0.000> inadvertent <sil=0.000> that <sil=0.000> is <sil=0.000> wrong <sil=2.000> .PERIOD 

Structures <sil=0.000> we <sil=0.000> cannot <sil=0.000> compare <sil=0.000> we <sil=0.000> can <sil=0.000> assign <sil=0.000> in <sil=0.000> a short <sil=1.000> ,COMMA  but <sil=0.000> comparison <sil=0.000> of <sil=0.000> structures <sil=0.000> we <sil=0.000> cannot <sil=0.000> do <sil=0.000> as <sil=0.000> a whole <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD  Two <sil=0.000> structure <sil=0.000> variables <sil=0.000> cannot <sil=0.000> be <sil=0.000> compared <sil=0.000> for <sil=0.000> equality <sil=0.000> or <sil=0.000> inequality <sil=0.000> now <sil=0.000> for <sil=0.000> that <sil=1.000> ,COMMA  what <sil=0.000> we <sil=0.000> have <sil=0.000> to <sil=0.000> do <sil=0.000> we <sil=0.000> can <sil=0.000> write <sil=0.000> a simple <sil=0.000> function <sil=0.000> say <sil=0.000> I can <sil=0.000> write <sil=0.000> and <sil=0.000> you <sil=0.000> can <sil=0.000> take <sil=0.000> it <sil=0.000> as <sil=0.000> an <sil=0.000> assignment <sil=1.000> ,COMMA  that <sil=0.000> we <sil=0.000> can <sil=0.000> write <sil=0.000> struct <sil=0.000> comp <sil=1.000> ,COMMA  struct <sil=0.000> c m <sil=0.000> p where <sil=0.000> you <sil=0.000> will <sil=0.000> take <sil=0.000> 2 structures <sil=0.000> as <sil=0.000> input <sil=0.000> and <sil=0.000> we <sil=0.000> will <sil=0.000> compare <sil=0.000> them <sil=0.000> and <sil=0.000> how <sil=0.000> do <sil=0.000> you <sil=0.000> compare <sil=0.000> them <sil=0.228> ?QUESTIONMARK  We <sil=0.000> will <sil=0.000> do <sil=0.000> say <sil=0.000> variable <sil=0.000> a 1 <sil=0.000> dot <sil=0.000> member <sil=0.000> 1 equals <sil=0.000> to <sil=0.000> is <sil=0.000> whether <sil=0.000> its <sil=0.000> if <sil=0.000> it <sil=0.000> is <sil=0.000> equal <sil=0.000> to <sil=0.000> variable <sil=0.000> a 2 <sil=0.000> dot <sil=0.000> member <sil=0.000> 1 <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> way <sil=0.000> if <sil=0.000> you <sil=0.000> do <sil=0.000> then <sil=0.000> it <sil=0.000> is <sil=0.000> possible <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  what <sil=0.000> we <sil=0.000> can <sil=0.000> do <sil=0.000> here <sil=0.000> is <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> two <sil=0.000> structures <sil=0.000> and <sil=0.000> there <sil=0.000> are <sil=0.000> 2 variables <sil=0.000> of <sil=0.000> the <sil=0.000> same <sil=0.000> type
of <sil=0.000> the <sil=0.000> same <sil=0.000> structure <sil=0.000> type <sil=0.000> one <sil=0.000> is <sil=0.000> a 1 <sil=0.000> and <sil=0.000> one <sil=0.000> is <sil=0.000> a 2 <sil=0.000> and <sil=0.000> I have <sil=0.000> got <sil=0.000> some <sil=0.000> values <sil=0.000> here <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD  And <sil=0.000> say <sil=0.000> this <sil=0.000> is <sil=0.000> member <sil=0.000> 1 <sil=1.000> ,COMMA  member <sil=0.000> 2 <sil=1.000> ,COMMA  member <sil=0.000> 3 member <sil=0.000> 4 like <sil=0.000> that <sil=0.000> now <sil=0.000> in <sil=0.000> order <sil=0.000> to <sil=0.000> compare <sil=0.000> if <sil=0.000> I want <sil=0.000> to <sil=0.000> compare <sil=0.000> them <sil=0.000> what <sil=0.000> I have <sil=0.000> to <sil=0.000> do <sil=0.228> ?QUESTIONMARK  <sil=2.000> .PERIOD 

I <sil=0.000> will <sil=0.000> have <sil=0.000> to <sil=0.000> see <sil=0.000> if <sil=0.000> this <sil=0.000> is <sil=0.000> a 1 <sil=1.000> ,COMMA  a <sil=0.000> 1 dot <sil=0.000> m 1 <sil=0.000> is <sil=0.000> this <sil=0.000> also <sil=0.000> m 1 <sil=0.000> is <sil=0.000> equal <sil=0.000> to <sil=0.000> a 2 <sil=0.000> dot <sil=0.000> m 1 <sil=0.000> and <sil=0.000> a 1 <sil=0.000> dot <sil=0.000> m 2
is <sil=0.000> equal <sil=0.000> to <sil=0.000> a 2 <sil=0.000> dot <sil=0.000> m 2 <sil=0.000> and <sil=0.000> so <sil=0.000> and <sil=0.000> so <sil=0.000> forth <sil=2.000> .PERIOD  If <sil=0.000> I do <sil=0.000> then <sil=0.000> return <sil=0.000> 1 that <sil=0.000> could <sil=0.000> be <sil=0.000> my <sil=0.000> function  <sil=0.354> ;SEMICOLON  that
means <sil=1.000> ,COMMA  if <sil=0.000> all <sil=0.000> these <sil=0.000> are <sil=0.000> matching <sil=1.000> ,COMMA  then <sil=0.000> only <sil=0.000> I will <sil=0.000> say <sil=0.000> that <sil=0.000> they <sil=0.000> have <sil=0.000> been <sil=0.000> compared <sil=0.000> to <sil=0.000> be <sil=0.000> the
same <sil=0.000> otherwise <sil=0.000> it <sil=0.000> will <sil=0.000> return <sil=0.000> false <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> other <sil=0.000> else <sil=0.000> return <sil=0.000> false <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you <sil=0.000> have <sil=0.000> to <sil=0.000> write <sil=0.000> it <sil=0.000> nicely
you <sil=0.000> can <sil=0.000> take <sil=0.000> it <sil=0.000> up <sil=0.000> take <sil=0.000> it <sil=0.000> up <sil=0.000> as <sil=0.000> an <sil=0.000> assignment <sil=0.000> arrays <sil=0.000> of <sil=0.000> structures <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  once <sil=0.000> we <sil=0.000> know <sil=0.000> this <sil=1.000> ,COMMA  we <sil=0.000> can <sil=0.000> now <sil=0.000> make <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> structure <sil=0.000> why <sil=0.000> is <sil=0.000> that <sil=0.000> useful <sil=0.000> let <sil=0.000> us <sil=0.000> take
one <sil=0.000> problem <sil=2.000> .PERIOD  Let <sil=0.000> us <sil=0.000> say <sil=0.000> that <sil=0.000> I am <sil=0.000> trying <sil=0.000> to <sil=0.000> store <sil=0.000> the <sil=0.000> information <sil=0.000> of <sil=0.000> a class <sil=0.000> of <sil=0.000> students <sil=2.000> .PERIOD 

Where <sil=0.000> maybe <sil=0.000> there <sil=0.000> are <sil=0.000> say <sil=0.000> 40 <sil=0.000> students <sil=0.000> and <sil=0.000> their <sil=0.000> information <sil=0.000> about <sil=0.000> each <sil=0.000> student <sil=0.000> has <sil=0.000> got <sil=0.000> different <sil=0.000> components <sil=0.354> ;SEMICOLON  name <sil=0.000> in <sil=0.000> a particular <sil=0.000> class <sil=1.000> ,COMMA  roll <sil=0.000> number <sil=0.000> and <sil=0.000> say <sil=0.000> marks <sil=0.000> total <sil=0.000> marks <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  marks <sil=0.000> is <sil=0.000> an <sil=0.000> integer <sil=0.000> let <sil=0.000> me <sil=0.000> say <sil=1.000> ,COMMA  roll <sil=0.000> number <sil=0.000> is <sil=0.000> also <sil=0.000> an <sil=0.000> integer <sil=0.000> and <sil=0.000> name <sil=0.000> is <sil=0.000> a character <sil=0.000> array <sil=0.000> something <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD  Now <sil=0.000> that <sil=0.000> so <sil=1.000> ,COMMA  this <sil=0.000> box <sil=0.000> this <sil=0.000> can <sil=0.000> be <sil=0.000> also <sil=0.000> depicted <sil=0.000> as <sil=0.000> a box <sil=0.000> having <sil=0.000> three <sil=0.000> fields <sil=0.000> name <sil=1.000> ,COMMA  roll <sil=0.000> number <sil=0.000> and <sil=0.000> marks <sil=1.000> ,COMMA  but <sil=0.000> I want <sil=0.000> to <sil=0.000> have <sil=0.000> that <sil=0.000> for <sil=0.000> all <sil=0.000> the <sil=0.000> 40 <sil=0.000> students <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> have <sil=0.000> 40 <sil=0.000> such <sil=0.000> small <sil=0.000> boxes <sil=1.000> ,COMMA  each <sil=0.000> having <sil=0.000> 3 fields <sil=0.000> one <sil=0.000> after <sil=0.000> another <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> can <sil=0.000> be
represented <sil=0.000> as <sil=0.000> an <sil=0.000> array <sil=0.000> you <sil=0.000> know <sil=0.000> that <sil=0.000> in <sil=0.000> an <sil=0.000> array <sil=0.000> we <sil=0.000> can <sil=0.000> store <sil=0.000> data <sil=0.000> of <sil=0.000> only <sil=0.000> the <sil=0.000> same <sil=0.000> type <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
that <sil=0.000> is <sil=0.000> not <sil=0.000> causing <sil=0.000> any <sil=0.000> problem <sil=0.000> here <sil=1.000> ,COMMA  because <sil=0.000> each <sil=0.000> of <sil=0.000> these <sil=0.000> boxes <sil=0.000> are <sil=0.000> of <sil=0.000> the <sil=0.000> type <sil=0.000> struct <sil=0.000> students <sil=0.000> therefore <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> very <sil=0.000> well <sil=0.000> consider <sil=0.000> them <sil=0.000> to <sil=0.000> be <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> such <sil=0.000> structures <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  if <sil=0.000> I call <sil=0.000> this <sil=0.000> class <sil=0.000> is <sil=0.000> this <sil=0.000> array <sil=1.000> ,COMMA  then <sil=0.000> each <sil=0.000> of <sil=0.000> these <sil=0.000> boxes <sil=0.000> are <sil=0.000> an <sil=0.000> element <sil=0.000> of <sil=0.000> that <sil=0.000> array <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> I
say <sil=0.000> class <sil=0.000> 0 <sil=1.000> ,COMMA  which <sil=0.000> element <sil=0.000> am <sil=0.000> I looking <sil=0.000> at <sil=0.228> ?QUESTIONMARK  This <sil=0.000> element <sil=0.000> right <sil=0.354> ;SEMICOLON  if <sil=0.000> I take <sil=0.000> class <sil=0.000> 0 dot <sil=0.000> name <sil=1.000> ,COMMA  then
which <sil=0.000> field <sil=0.000> am <sil=0.000> I looking <sil=0.000> at <sil=0.228> ?QUESTIONMARK  This <sil=0.000> particular <sil=0.000> field <sil=0.354> ;SEMICOLON  if <sil=0.000> I write <sil=0.000> class <sil=0.000> 2 dot <sil=0.000> roll <sil=0.000> number <sil=1.000> ,COMMA  which <sil=0.000> field
am <sil=0.000> I looking <sil=0.000> at <sil=0.228> ?QUESTIONMARK  Class <sil=0.000> 2 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> an <sil=0.000> array <sil=0.000> 0 1 <sil=0.000> 2 you <sil=0.000> know <sil=0.000> that <sil=0.000> just <sil=0.000> in <sil=0.000> c any <sil=0.000> array <sil=0.000> starts <sil=0.000> with <sil=0.000> 0 <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  0 <sil=0.000> 1 2 <sil=0.000> I come <sil=0.000> over <sil=0.000> here <sil=0.000> and <sil=0.000> which <sil=0.000> field <sil=0.000> am <sil=0.000> I looking <sil=0.000> at <sil=0.000> roll <sil=0.000> number <sil=0.000> roll <sil=0.000> number <sil=0.000> is <sil=0.000> the <sil=0.000> second
field <sil=2.000> .PERIOD  In <sil=0.000> that <sil=0.000> way <sil=0.000> I can <sil=0.000> access <sil=0.000> each <sil=0.000> element <sil=0.000> of <sil=0.000> this <sil=0.000> array <sil=1.000> ,COMMA  either <sil=0.000> as <sil=0.000> a structure <sil=0.000> or <sil=0.000> as <sil=0.000> an <sil=0.000> individual
member <sil=0.000> of <sil=0.000> that <sil=0.000> structure <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  in <sil=0.000> such <sil=0.000> cases <sil=0.000> or <sil=0.000> the <sil=0.000> same <sil=0.000> thing <sil=0.000> could <sil=0.000> be <sil=0.000> applicable <sil=1.000> ,COMMA  if <sil=0.000> I want <sil=0.000> to <sil=0.000> represent <sil=0.000> a library <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> case <sil=0.000> what <sil=0.000> will <sil=0.000> happen <sil=0.228> ?QUESTIONMARK  A <sil=0.000> library <sil=0.000> will <sil=0.000> consist <sil=0.000> of <sil=0.000> books <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  suppose <sil=0.000> it <sil=0.000> is <sil=0.000> a small <sil=0.000> library <sil=1.000> ,COMMA 
where <sil=0.000> I have <sil=0.000> got <sil=0.000> a library <sil=0.000> of <sil=0.000> 20 <sil=0.000> books <sil=0.000> all <sil=0.000> right <sil=0.000> 20 <sil=0.000> books <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  books <sil=0.000> is <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> type <sil=0.000> what <sil=0.000> or <sil=0.000> let <sil=0.000> me <sil=0.000> let <sil=0.000> me <sil=0.000> name <sil=0.000> it <sil=0.000> different <sil=0.000> way <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> say <sil=0.000> in <sil=0.000> my
library <sil=0.000> is <sil=0.000> consisting <sil=0.000> of <sil=0.000> 20 <sil=0.000> books <sil=0.000> at <sil=0.000> most <sil=1.000> ,COMMA  and <sil=0.000> what <sil=0.000> is <sil=0.000> the <sil=0.000> type <sil=0.000> of <sil=0.000> library <sil=0.000> when <sil=0.000> we <sil=0.000> write <sil=0.000> in <sil=0.000> a
array <sil=0.228> ?QUESTIONMARK  We <sil=0.000> write <sil=0.000> int <sil=0.000> a 20 <sil=0.000> float <sil=0.000> a 20 <sil=0.000> like <sil=0.000> that <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> what <sil=0.000> is <sil=0.000> the <sil=0.000> type <sil=0.000> of <sil=0.000> library <sil=0.228> ?QUESTIONMARK  Type <sil=0.000> of <sil=0.000> library
will <sil=0.000> be <sil=0.000> struct <sil=0.000> book <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  because <sil=0.000> every <sil=0.000> element <sil=0.000> of <sil=0.000> this <sil=0.000> library <sil=1.000> ,COMMA  when <sil=0.000> I write <sil=0.000> int <sil=0.000> a 20 <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  I
am <sil=0.000> talking <sil=0.000> of <sil=0.000> an <sil=0.000> array <sil=0.000> where <sil=0.000> there <sil=0.000> are <sil=0.000> 20 <sil=0.000> elements <sil=0.000> and <sil=0.000> each <sil=0.000> element <sil=0.000> is <sil=0.000> of <sil=0.000> type <sil=0.000> int <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  when <sil=0.000> I am <sil=0.000> talking <sil=0.000> of <sil=0.000> this <sil=0.000> struct <sil=0.000> book <sil=0.000> library <sil=0.000> 20 <sil=0.000> what <sil=0.000> will <sil=0.000> that <sil=0.000> mean <sil=0.228> ?QUESTIONMARK  That <sil=0.000> will <sil=0.000> mean <sil=0.000> that
here <sil=0.000> is <sil=0.000> an <sil=0.000> array <sil=0.000> library <sil=0.000> having <sil=0.000> 20 <sil=0.000> such <sil=0.000> field <sil=0.000> 20 <sil=0.000> such <sil=0.000> positions <sil=0.000> elements <sil=0.000> and <sil=0.000> each <sil=0.000> element <sil=0.000> is <sil=0.000> a
structure <sil=0.000> called <sil=0.000> book <sil=2.000> .PERIOD  I <sil=0.000> have <sil=0.000> not <sil=0.000> defined <sil=0.000> here <sil=0.000> the <sil=0.000> structure <sil=0.000> of <sil=0.000> book <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> should <sil=0.000> have <sil=0.000> done <sil=0.000> it
earlier <sil=2.000> .PERIOD 

Suppose <sil=0.000> I do <sil=0.000> here <sil=0.000> struct <sil=0.000> book <sil=1.000> ,COMMA  char <sil=0.000> name <sil=0.000> 10 <sil=0.000> semicolon <sil=0.000> that <sil=0.000> is <sil=0.000> the <sil=0.000> name <sil=0.000> of <sil=0.000> the <sil=0.000> book <sil=2.000> .PERIOD  Char <sil=0.000> author <sil=0.000> 10 <sil=0.000> the <sil=0.000> author <sil=0.000> of <sil=0.000> the <sil=0.000> book <sil=0.000> int <sil=0.000> ISBN <sil=0.000> and <sil=0.000> I close <sil=0.000> that <sil=2.000> .PERIOD  Suppose <sil=0.000> this <sil=0.000> is <sil=0.000> a structure <sil=0.000> of <sil=0.000> the <sil=0.000> book <sil=0.000> having <sil=0.000> 3 fields <sil=0.000> only <sil=0.000> I have <sil=0.000> it <sil=0.000> could <sil=0.000> have <sil=0.000> been <sil=0.000> more <sil=0.000> fields <sil=0.000> number <sil=0.000> of <sil=0.000> pages <sil=0.000> year <sil=0.000> of <sil=0.000> publication <sil=0.000> etcetera <sil=0.000> I am <sil=0.000> not <sil=0.000> showing <sil=0.000> that <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  each <sil=0.000> of <sil=0.000> these <sil=0.000> elements <sil=0.000> have <sil=0.000> got <sil=0.000> 3 fields <sil=0.000> here <sil=0.000> name <sil=0.000> which <sil=0.000> is <sil=0.000> itself <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> 10 <sil=0.000> characters <sil=1.000> ,COMMA  author <sil=0.000> which <sil=0.000> is <sil=0.000> itself <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> 10 <sil=0.000> characters <sil=0.000> and <sil=0.000> an <sil=0.000> integer <sil=0.000> ISBN <sil=0.000> number <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> the <sil=0.000> whole <sil=0.000> element <sil=1.000> ,COMMA  the <sil=0.000> first <sil=0.000> or <sil=0.000> 1 element <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=0.000> library <sil=2.000> .PERIOD  And <sil=0.000> library <sil=0.000> is <sil=0.000> an <sil=0.000> array
which <sil=0.000> houses <sil=0.000> 20 <sil=0.000> at <sil=0.000> the <sil=0.000> most <sil=0.000> such <sil=0.000> individual <sil=0.000> structures <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> I say <sil=0.000> library <sil=0.000> 3 dot <sil=0.000> ISBN <sil=0.000> where <sil=0.000> am
I <sil=0.000> going <sil=0.000> which <sil=0.000> one <sil=0.000> I am <sil=0.000> referring <sil=0.000> to <sil=0.228> ?QUESTIONMARK  0 <sil=1.000> ,COMMA  1 <sil=1.000> ,COMMA  2 <sil=1.000> ,COMMA  3 <sil=0.000> library <sil=0.000> 3 and <sil=0.000> the <sil=0.000> last <sil=0.000> element <sil=0.000> of <sil=0.000> that <sil=0.000> this <sil=0.000> is <sil=0.000> the
ISBN <sil=0.000> number <sil=0.000> because <sil=0.000> this <sil=0.000> is <sil=0.000> a last <sil=0.000> one <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  therefore <sil=1.000> ,COMMA  using <sil=0.000> structure <sil=0.000> allows <sil=0.000> us <sil=0.000> to <sil=0.000> store <sil=0.000> different <sil=0.000> types <sil=0.000> of <sil=0.000> data <sil=0.000> together <sil=1.000> ,COMMA  and <sil=0.000> again <sil=0.000> array
of <sil=0.000> structure <sil=0.000> is <sil=0.000> a very <sil=0.000> powerful <sil=0.000> facility <sil=0.000> that <sil=0.000> has <sil=0.000> been <sil=0.000> given <sil=0.000> to <sil=0.000> us <sil=1.000> ,COMMA  using <sil=0.000> which <sil=0.000> we <sil=0.000> can <sil=0.000> store <sil=0.000> many
more <sil=0.000> things <sil=0.000> and <sil=0.000> we <sil=0.000> get <sil=0.000> much <sil=0.000> more <sil=0.000> flexibility <sil=2.000> .PERIOD  Let <sil=0.000> us <sil=0.000> go <sil=0.000> here <sil=1.000> ,COMMA  once <sil=0.000> a structure <sil=0.000> has <sil=0.000> been <sil=0.000> defined
like <sil=0.000> the <sil=0.000> structure <sil=0.000> book <sil=0.000> that <sil=0.000> was <sil=0.000> defined <sil=0.000> we <sil=0.000> can <sil=0.000> declared <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> structures <sil=1.000> ,COMMA  for <sil=0.000> example <sil=1.000> ,COMMA 
struct <sil=0.000> student <sil=0.000> class <sil=0.000> 50 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  note <sil=0.000> here <sil=0.000> that <sil=0.000> class <sil=0.000> is <sil=0.000> an <sil=0.000> array <sil=0.000> having <sil=0.000> 50 <sil=0.000> elements <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> something <sil=0.000> like <sil=0.000> this <sil=0.000> here <sil=0.000> is <sil=0.000> class <sil=0.000> with <sil=0.000> 50 <sil=0.000> elements <sil=0.000> 0 to <sil=0.000> 49 <sil=1.000> ,COMMA  and <sil=0.000> what <sil=0.000> is <sil=0.000> each <sil=0.000> element <sil=0.228> ?QUESTIONMARK  Each <sil=0.000> of <sil=0.000> these <sil=0.000> elements <sil=0.000> is <sil=0.000> a structure <sil=0.000> of <sil=0.000> type <sil=0.000> student <sil=0.000> must <sil=0.000> have <sil=0.000> been <sil=0.000> defined <sil=0.000> somewhere <sil=0.000> earlier <sil=2.000> .PERIOD 

The <sil=0.000> individual <sil=0.000> members <sil=0.000> can <sil=0.000> be <sil=0.000> accessed <sil=0.000> by <sil=0.000> class <sil=0.000> whichever <sil=0.000> element <sil=0.000> are <sil=0.000> you <sil=0.000> want <sil=0.000> to <sil=0.000> have <sil=0.000> say
for <sil=0.000> example <sil=1.000> ,COMMA  struct <sil=0.000> student <sil=1.000> ,COMMA  one <sil=0.000> field <sil=0.000> is <sil=0.000> int <sil=0.000> roll <sil=0.000> number <sil=1.000> ,COMMA  there <sil=0.000> is <sil=0.000> a name <sil=1.000> ,COMMA  there <sil=0.000> is <sil=0.000> marks <sil=0.000> and
character <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> the <sil=0.000> student <sil=0.000> and <sil=0.000> I have <sil=0.000> got <sil=0.000> 3 variables <sil=0.000> a 1 <sil=1.000> ,COMMA  a <sil=0.000> 2 <sil=1.000> ,COMMA  a <sil=0.000> 3 <sil=2.000> .PERIOD  The <sil=0.000> array <sil=0.000> element <sil=0.000> within <sil=0.000> the <sil=0.000> structure <sil=0.000> and <sil=0.000> I have <sil=0.000> defined <sil=0.000> an <sil=0.000> array <sil=0.000> earlier <sil=0.000> that <sil=0.000> is <sil=0.000> a class <sil=0.000> of <sil=0.000> 50 <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> which <sil=0.000> every <sil=0.000> element <sil=0.000> is <sil=0.000> a structure <sil=0.000> like <sil=0.000> this <sil=1.000> ,COMMA  and <sil=0.000> the <sil=0.000> structures <sil=0.000> are <sil=0.000> variables <sil=0.000> a 1 <sil=1.000> ,COMMA  these <sil=0.000> are <sil=0.000> also <sil=0.000> the <sil=0.000> student <sil=0.000> variables <sil=0.000> also <sil=0.000> my <sil=0.000> class <sil=0.000> is <sil=0.000> consisting <sil=0.000> of <sil=0.000> the <sil=0.000> same <sil=0.000> structure <sil=2.000> .PERIOD 

The <sil=0.000> array <sil=0.000> element <sil=0.000> within <sil=0.000> the <sil=0.000> structure <sil=0.000> can <sil=0.000> be <sil=0.000> accessed <sil=0.000> as <sil=0.000> now <sil=0.000> you <sil=0.000> can <sil=0.000> very <sil=0.000> easily <sil=0.000> guess <sil=1.000> ,COMMA  if <sil=0.000> a 1
dot <sil=0.000> marks <sil=0.000> 2 <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  here <sil=0.000> this <sil=0.000> example <sil=0.000> is <sil=0.000> telling <sil=0.000> us <sil=0.000> something <sil=0.000> more <sil=1.000> ,COMMA  here <sil=0.000> this <sil=0.000> example <sil=0.000> is <sil=0.000> showing
that <sil=0.000> any <sil=0.000> element <sil=0.000> of <sil=0.000> have <sil=0.000> and <sil=0.000> a member <sil=0.000> of <sil=0.000> this <sil=0.000> structure <sil=0.000> student <sil=0.000> can <sil=0.000> also <sil=0.000> be <sil=0.000> an <sil=0.000> array <sil=1.000> ,COMMA  that <sil=0.000> we <sil=0.000> had <sil=0.000> defined <sil=0.000> earlier <sil=0.000> this <sil=0.000> is <sil=0.000> also <sil=0.000> an <sil=0.000> array <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  suppose <sil=0.000> I have <sil=0.000> got <sil=0.000> this <sil=0.000> student <sil=0.000> a 1 <sil=0.000> his <sil=0.000> name <sil=0.000> is <sil=0.000> a <sil=1.000> ,COMMA  roll <sil=0.000> number <sil=0.000> is <sil=0.000> say <sil=0.000> 1 <sil=1.000> ,COMMA  and <sil=0.000> marks <sil=0.000> is <sil=0.000> itself
an <sil=0.000> array <sil=0.000> where <sil=0.000> the <sil=0.000> marks <sil=0.000> of <sil=0.000> literature <sil=1.000> ,COMMA  history <sil=0.000> geography <sil=1.000> ,COMMA  maths <sil=1.000> ,COMMA  science <sil=0.000> everything <sil=0.000> is <sil=0.000> stored <sil=0.000> and <sil=0.000> the <sil=0.000> date <sil=0.000> of <sil=0.000> birth <sil=0.000> is <sil=0.000> a character <sil=0.000> array <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD  Now <sil=0.000> so <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> say <sil=0.000> 07 <sil=0.000> 07 <sil=0.000> 2007 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> a character <sil=0.000> array <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  when <sil=0.000> I am <sil=0.000> saying <sil=0.000> a 1 <sil=0.000> marks <sil=0.000> 2 <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> going <sil=0.000> to <sil=0.000> this <sil=0.000> field <sil=0.000> is <sil=0.000> the <sil=0.000> marks <sil=0.000> field <sil=1.000> ,COMMA  I <sil=0.000> am
going <sil=0.000> to <sil=0.000> the <sil=0.000> a 1 <sil=0.000> structure <sil=0.000> a 1 <sil=0.000> variable <sil=1.000> ,COMMA  and <sil=0.000> I am <sil=0.000> taking <sil=0.000> its <sil=0.000> structure <sil=0.000> and <sil=0.000> coming <sil=0.000> to <sil=0.000> the <sil=0.000> marks <sil=0.000> field <sil=0.000> or <sil=0.000> membership <sil=0.000> member <sil=0.000> and <sil=0.000> I am <sil=0.000> coming <sil=0.000> to <sil=0.000> the <sil=0.000> element <sil=0.000> 0 1 <sil=0.000> 2 this <sil=0.000> particular <sil=0.000> element <sil=0.000> this
particular <sil=0.000> element <sil=0.000> I am <sil=0.000> coming <sil=0.000> to <sil=0.000> by <sil=0.000> this <sil=1.000> ,COMMA  this <sil=0.000> you <sil=0.000> must <sil=0.000> understand <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> have <sil=0.000> an <sil=0.000> array <sil=0.000> within <sil=0.000> a structure <sil=1.000> ,COMMA  also <sil=0.000> I can <sil=0.000> have <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> structure <sil=2.000> .PERIOD  Till <sil=0.000> now <sil=0.000> what <sil=0.000> we
are <sil=0.000> discussing <sil=0.000> was <sil=0.000> and <sil=0.000> here <sil=0.000> what <sil=0.000> we <sil=0.000> discussed <sil=0.000> was <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> structure <sil=0.000> right <sil=2.000> .PERIOD  And <sil=0.000> here <sil=0.000> what <sil=0.000> we <sil=0.000> have <sil=0.000> just <sil=0.000> now <sil=0.000> shown <sil=0.000> you <sil=0.000> is <sil=0.000> what <sil=0.000> we <sil=0.000> have <sil=0.000> just <sil=0.000> now <sil=0.000> shown <sil=0.000> you <sil=0.000> is <sil=0.000> an <sil=0.000> example <sil=0.000> of <sil=0.000> that <sil=0.000> an <sil=0.000> array <sil=0.000> can <sil=0.000> also <sil=0.000> be <sil=0.000> a part <sil=0.000> of <sil=0.000> a structure <sil=2.000> .PERIOD 

Next <sil=0.000> lecture <sil=0.000> we <sil=0.000> will <sil=0.000> be <sil=0.000> talking <sil=0.000> about <sil=0.000> a new <sil=0.000> thing <sil=0.000> that <sil=0.000> is <sil=0.000> that <sil=0.000> is <sil=0.000> also <sil=0.000> very <sil=0.000> important <sil=0.000> type <sil=0.000> def <sil=2.000> .PERIOD  That
is <sil=0.000> very <sil=0.000> much <sil=0.000> useful <sil=0.000> for <sil=0.000> that <sil=0.000> facilitates <sil=0.000> us <sil=0.000> to <sil=0.000> create <sil=0.000> new <sil=0.000> type <sil=0.000> definitions <sil=0.000> and <sil=0.000> we <sil=0.000> can <sil=0.000> write <sil=0.000> much
simpler <sil=0.000> programs <sil=0.000> with <sil=0.000> this <sil=0.000> we <sil=0.000> will <sil=0.000> take <sil=0.000> it <sil=0.000> up <sil=0.000> in <sil=0.000> the <sil=0.000> next <sil=0.000> lecture <sil=2.000> .PERIOD 

We <sil=0.000> were <sil=0.000> discussing <sil=0.000> about <sil=0.000> structures <sil=0.000> and <sil=0.000> in <sil=0.000> particular <sil=0.000> we <sil=0.000> have <sil=0.000> discussed <sil=0.000> about <sil=0.000> the <sil=0.000> way <sil=0.000> the
structure <sil=0.000> is <sil=0.000> formed <sil=0.000> and <sil=0.000> in <sil=0.000> that <sil=0.000> context <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=0.000> that <sil=0.000> a structure <sil=0.000> can <sil=0.000> contain <sil=0.000> within <sil=0.000> itself
some <sil=0.000> members <sil=0.000> which <sil=0.000> can <sil=0.000> also <sil=0.000> be <sil=0.000> a structure <sil=0.000> themselves <sil=2.000> .PERIOD 

For <sil=0.000> example <sil=1.000> ,COMMA  this <sil=0.000> one <sil=0.000> member <sil=0.000> which <sil=0.000> can <sil=0.000> itself <sil=0.000> be <sil=0.000> a structure <sil=0.000> consisting <sil=0.000> of <sil=0.000> other <sil=0.000> members <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
this <sil=0.000> is <sil=0.000> a structure <sil=0.000> struct <sil=0.000> S in <sil=0.000> which <sil=0.000> there <sil=0.000> is <sil=0.000> another <sil=0.000> struct <sil=0.000> say <sil=0.000> P which <sil=0.000> is <sil=0.000> a member <sil=0.000> of <sil=0.000> this <sil=1.000> ,COMMA  also
some <sil=0.000> member <sil=0.000> can <sil=0.000> be <sil=0.000> an <sil=0.000> array <sil=2.000> .PERIOD  This <sil=0.000> can <sil=0.000> be <sil=0.000> say <sil=0.000> name <sil=0.000> 10 <sil=0.000> char <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> a character <sil=0.000> array <sil=0.000> of <sil=0.000> name <sil=0.000> 10 <sil=1.000> ,COMMA  similarly <sil=0.000> it <sil=0.000> could <sil=0.000> be <sil=0.000> some <sil=0.000> member <sil=0.000> like <sil=0.000> int <sil=0.000> marks <sil=0.000> 20 <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> seen <sil=0.000> that <sil=0.000> we <sil=0.000> can <sil=0.000> have <sil=0.000> arrays <sil=0.000> within <sil=0.000> structure <sil=0.000> also <sil=0.000> in <sil=0.000> the <sil=0.000> last <sil=0.000> lecture <sil=0.000> we <sil=0.000> have
talked <sil=0.000> about <sil=0.000> arrays <sil=0.000> of <sil=0.000> structure <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  there <sil=0.000> is <sil=0.000> a scope <sil=0.000> of <sil=0.000> confusion <sil=0.000> between <sil=0.000> these <sil=0.000> two <sil=0.000> that <sil=0.000> is <sil=0.000> why <sil=0.000> I want <sil=0.000> to <sil=0.000> make <sil=0.000> it <sil=0.000> clearer <sil=0.000> that <sil=0.000> there <sil=0.000> can <sil=0.000> be <sil=0.000> an <sil=0.000> array <sil=0.000> within <sil=0.000> a structure <sil=0.000> as <sil=0.000> a member <sil=2.000> .PERIOD 

So <sil=0.000> the <sil=0.000> other <sil=0.000> thing <sil=0.000> is <sil=0.000> we <sil=0.000> can <sil=0.000> have <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> structure <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  in <sil=0.000> this <sil=0.000> case <sil=0.000> we <sil=0.000> have <sil=0.000> got <sil=0.000> an <sil=0.000> array <sil=1.000> ,COMMA 
every <sil=0.000> element <sil=0.000> of <sil=0.000> that <sil=0.000> array <sil=0.000> is <sil=0.000> a structure <sil=0.000> of <sil=0.000> a particular <sil=0.000> type <sil=2.000> .PERIOD  We <sil=0.000> know <sil=0.000> that <sil=0.000> an <sil=0.000> array <sil=0.000> can <sil=0.000> hold
data <sil=0.000> elements <sil=0.000> of <sil=0.000> the <sil=0.000> same <sil=0.000> type <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> I have <sil=0.000> one <sil=0.000> particular <sil=0.000> structure <sil=0.000> defined <sil=0.000> like <sil=0.000> say <sil=0.000> student <sil=1.000> ,COMMA  it
can <sil=0.000> be <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> students <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  each <sil=0.000> of <sil=0.000> them <sil=0.000> is <sil=0.000> of <sil=0.000> the <sil=0.000> type <sil=0.000> student <sil=2.000> .PERIOD <sil=0.000> So <sil=1.000> ,COMMA  these <sil=0.000> two <sil=0.000> must <sil=0.000> be
differentiated <sil=0.000> very <sil=0.000> clearly <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD  

So <sil=1.000> ,COMMA  as <sil=0.000> you <sil=0.000> can <sil=0.000> see <sil=0.000> that <sil=0.000> here <sil=0.000> a structure <sil=0.000> member <sil=0.000> can <sil=0.000> be <sil=0.000> an <sil=0.000> array <sil=1.000> ,COMMA  we <sil=0.000> saw <sil=0.000> it <sil=0.000> in <sil=0.000> the <sil=0.000> last <sil=0.000> class <sil=0.000> last
lecture <sil=0.000> that <sil=0.000> say <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  a <sil=0.000> structure <sil=0.000> student <sil=0.000> has <sil=0.000> got <sil=0.000> an <sil=0.000> array <sil=0.000> char <sil=1.000> ,COMMA  character <sil=0.000> array <sil=0.000> name
thirty <sil=1.000> ,COMMA  all <sil=0.000> right <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> a part <sil=0.000> of <sil=0.000> an <sil=0.000> array <sil=2.000> .PERIOD  Now <sil=0.000> we <sil=0.000> know <sil=0.000> arrays <sil=0.000> within <sil=0.000> structure <sil=0.000> and <sil=0.000> we <sil=0.000> have <sil=0.000> also
seen <sil=0.000> arrays <sil=0.000> of <sil=0.000> structure <sil=1.000> ,COMMA  where <sil=0.000> we <sil=0.000> can <sil=0.000> have <sil=0.000> a number <sil=0.000> of <sil=0.000> elements <sil=0.000> of <sil=0.000> that <sil=0.000> particular <sil=0.000> structure <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=0.000> that <sil=0.000> we <sil=0.000> have <sil=0.000> got <sil=0.000> a an <sil=0.000> array <sil=0.000> class <sil=1.000> ,COMMA  the <sil=0.000> array <sil=0.000> is <sil=0.000> class <sil=0.000> which <sil=0.000> can <sil=0.000> hold <sil=0.000> up <sil=0.000> to <sil=0.000> 50 <sil=0.000> elements <sil=0.000> and <sil=0.000> each <sil=0.000> element <sil=0.000> of <sil=0.000> this <sil=0.000> class <sil=0.000> is <sil=0.000> a structure <sil=0.000> of <sil=0.000> type <sil=0.000> student <sil=2.000> .PERIOD 

When <sil=0.000> I come <sil=0.000> to <sil=0.000> say <sil=0.000> class <sil=0.000> i <sil=1.000> ,COMMA  then <sil=0.000> I am <sil=0.000> actually <sil=0.000> accessing <sil=0.000> a structure <sil=0.000> a particular <sil=0.000> structure <sil=0.000> in <sil=0.000> that
array <sil=2.000> .PERIOD  Now <sil=0.000> that <sil=0.000> structure <sil=0.000> has <sil=0.000> got <sil=0.000> number <sil=0.000> of <sil=0.000> fields <sil=0.000> therefore <sil=1.000> ,COMMA  if <sil=0.000> I have <sil=0.000> class <sil=0.000> i dot <sil=0.000> name <sil=1.000> ,COMMA  then <sil=0.000> I will
get <sil=0.000> a particular <sil=0.000> name (if <sil=0.000> that <sil=0.000> be <sil=0.000> the <sil=0.000> field) or <sil=0.000> I can <sil=0.000> say <sil=0.000> class <sil=0.000> 2 dot <sil=0.000> roll <sil=0.000> number <sil=2.000> .PERIOD 

So <sil=0.000> here <sil=0.000> there <sil=0.000> is <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> structures <sil=0.000> and <sil=0.000> we <sil=0.000> can <sil=0.000> handle <sil=0.000> them <sil=0.000> just <sil=0.000> as <sil=0.000> in <sil=0.000> this <sil=0.000> case <sil=0.000> where <sil=0.000> the <sil=0.000> index <sil=0.000> is <sil=0.000> pointing <sil=0.000> to <sil=0.000> the <sil=0.000> particular <sil=0.000> element <sil=1.000> ,COMMA  and <sil=0.000> then <sil=0.000> by <sil=0.000> dot <sil=0.000> operator <sil=0.000> we <sil=0.000> are <sil=0.000> going <sil=0.000> inside <sil=0.000> that <sil=0.000> element <sil=0.000> and <sil=0.000> looking <sil=0.000> at <sil=0.000> that <sil=0.000> array <sil=2.000> .PERIOD 

Whereas <sil=0.000> in <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> an <sil=0.000> array <sil=0.000> within <sil=0.000> a structure <sil=0.000> we <sil=0.000> look <sil=0.000> at <sil=0.000> that <sil=0.000> in <sil=0.000> a different <sil=0.000> way <sil=1.000> ,COMMA  suppose <sil=0.000> if <sil=0.000> I
come <sil=0.000> to <sil=0.000> the <sil=0.000> structure <sil=0.354> ;SEMICOLON  student <sil=0.000> and <sil=0.000> suppose <sil=0.000> there <sil=0.000> is <sil=0.000> a variable <sil=0.000> of <sil=0.000> variable <sil=0.000> of <sil=0.000> name <sil=0.000> say <sil=0.000> a 1 <sil=0.000> as <sil=0.000> of
type <sil=0.000> student <sil=1.000> ,COMMA  then <sil=0.000> I can <sil=0.000> say <sil=0.000> a 1 <sil=0.000> dot <sil=0.000> name <sil=0.000> and <sil=0.000> I can <sil=0.000> take <sil=0.000> a particular <sil=0.000> character <sil=0.000> of <sil=0.000> that <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  look <sil=0.000> at <sil=0.000> the <sil=0.000> difference <sil=0.000> of <sil=0.000> this <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> one <sil=0.000> and <sil=0.000> the <sil=0.000> other <sil=0.000> one <sil=0.000> was <sil=0.000> class <sil=0.000> i dot <sil=0.000> name <sil=0.000> j <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> I
am <sil=0.000> accessing <sil=0.000> the <sil=0.000> particular <sil=0.000> element <sil=0.000> from <sil=0.000> that <sil=0.000> structure <sil=1.000> ,COMMA  and <sil=0.000> here <sil=0.000> I am <sil=0.000> coming <sil=0.000> to <sil=0.000> the <sil=0.000> structure
and <sil=0.000> going <sil=0.000> to <sil=0.000> that <sil=0.000> array <sil=0.000> element <sil=0.000> within <sil=0.000> that <sil=0.000> structure <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> an <sil=0.000> usual <sil=0.000> point <sil=0.000> of <sil=0.000> confusion
among <sil=0.000> many <sil=0.000> students <sil=0.000> that <sil=0.000> is <sil=0.000> why <sil=0.000> I was <sil=0.000> repeating <sil=0.000> this <sil=2.000> .PERIOD 

Next <sil=0.000> we <sil=0.000> will <sil=0.000> start <sil=0.000> looking <sil=0.000> at <sil=0.000> an <sil=0.000> important <sil=0.000> style <sil=0.000> of <sil=0.000> writing <sil=0.000> programs <sil=0.000> which <sil=0.000> is <sil=0.000> typedef <sil=2.000> .PERIOD 

That <sil=0.000> facilitates <sil=0.000> our <sil=0.000> programming <sil=0.000> with <sil=0.000> structure <sil=2.000> .PERIOD  As <sil=0.000> the <sil=0.000> name <sil=0.000> typedef <sil=0.000> implies <sil=1.000> ,COMMA  we <sil=0.000> are <sil=0.000> defining
some <sil=0.000> type <sil=2.000> .PERIOD  We <sil=0.000> know <sil=0.000> that <sil=0.000> int <sil=0.000> is <sil=0.000> a type <sil=1.000> ,COMMA  float <sil=0.000> is <sil=0.000> a type <sil=1.000> ,COMMA  data <sil=0.000> type <sil=0.000> char <sil=0.000> is <sil=0.000> a type <sil=0.000> etcetera <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> also <sil=0.000> define <sil=0.000> my <sil=0.000> own <sil=0.000> type <sil=0.000> which <sil=0.000> I will <sil=0.000> be <sil=0.000> using <sil=0.000> in <sil=0.000> my <sil=0.000> program <sil=0.000> using <sil=0.000> this <sil=0.000> typedef <sil=0.000> command <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  we <sil=0.000> may <sil=0.000> define <sil=0.000> a structured <sil=0.000> data <sil=0.000> type <sil=0.000> using <sil=0.000> a typedef <sil=0.000> command <sil=0.000> like <sil=0.000> this <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> see <sil=0.000> the
syntax <sil=2.000> .PERIOD 

The <sil=0.000> syntax <sil=0.000> is <sil=0.000> I say <sil=0.000> typedef <sil=0.000> struct <sil=0.000> member <sil=0.000> variable <sil=0.000> 1 member <sil=0.000> variable <sil=0.000> 2 member <sil=0.000> variable <sil=0.000> n and
then <sil=0.000> some <sil=0.000> tag <sil=2.000> .PERIOD  Tag <sil=0.000> is <sil=0.000> the <sil=0.000> name <sil=0.000> of <sil=0.000> the <sil=0.000> new <sil=0.000> data <sil=0.000> type <sil=2.000> .PERIOD  Let <sil=0.000> me <sil=0.000> illustrate <sil=0.000> this <sil=0.000> by <sil=0.000> differentiating <sil=0.000> this
with <sil=0.000> the <sil=0.000> earlier <sil=0.000> thing <sil=2.000> .PERIOD  Earlier <sil=0.000> we <sil=0.000> had <sil=0.000> written <sil=0.000> something <sil=0.000> like <sil=0.000> this <sil=0.000> struct <sil=0.000> student <sil=2.000> .PERIOD 

Then <sil=0.000> char <sil=0.000> name <sil=0.000> 10 <sil=0.000> int <sil=0.000> roll <sil=0.000> number <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> was <sil=0.000> defining <sil=0.000> a structure <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=1.000> ,COMMA  and <sil=0.000> I was <sil=0.000> later <sil=0.000> on
referring <sil=0.000> to <sil=0.000> the <sil=0.000> structure <sil=0.000> as <sil=0.000> struct <sil=0.000> student <sil=0.000> say <sil=0.000> student <sil=0.000> 1 <sil=1.000> ,COMMA  student <sil=0.000> 2 <sil=1.000> ,COMMA  in <sil=0.000> this <sil=0.000> way <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  what <sil=0.000> I am
trying <sil=0.000> to <sil=0.000> do <sil=0.000> here <sil=0.000> is <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> trying <sil=0.000> to <sil=0.000> define <sil=0.000> a type <sil=1.000> ,COMMA  suppose <sil=0.000> I do <sil=0.000> not <sil=0.000> write <sil=0.000> this <sil=1.000> ,COMMA  what <sil=0.000> I am <sil=0.000> doing
instead <sil=0.000> I am <sil=0.000> saying <sil=0.000> typedef <sil=0.000> struct <sil=0.000> same <sil=0.000> thing <sil=0.000> char <sil=0.000> name <sil=0.000> 10 <sil=1.000> ,COMMA  int <sil=0.000> roll <sil=0.000> number <sil=0.000> and <sil=0.000> naming <sil=0.000> this <sil=0.000> type
as <sil=0.000> student <sil=2.000> .PERIOD  If <sil=0.000> I do <sil=0.000> this <sil=0.000> then <sil=0.000> next <sil=0.000> time <sil=0.000> when <sil=0.000> I declare <sil=0.000> the <sil=0.000> student <sil=0.000> 1 and <sil=0.000> student <sil=0.000> 2 <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> do <sil=0.000> it <sil=0.000> in <sil=0.000> a
different <sil=0.000> way <sil=0.000> I can <sil=0.000> do <sil=0.000> it <sil=0.000> much <sil=0.000> simply <sil=2.000> .PERIOD  See <sil=0.000> how <sil=0.000> I am <sil=0.000> writing <sil=0.000> now <sil=1.000> ,COMMA  in <sil=0.000> the <sil=0.000> red <sil=0.000> box <sil=2.000> .PERIOD 

If <sil=0.000> I just <sil=0.000> simply <sil=0.000> write <sil=0.000> student <sil=1.000> ,COMMA  student <sil=0.000> 1 comma <sil=0.000> student <sil=0.000> 2 that <sil=0.000> is <sil=0.000> sufficient <sil=2.000> .PERIOD  Compare <sil=0.000> this <sil=0.000> with <sil=0.000> the
way <sil=0.000> we <sil=0.000> had <sil=0.000> declared <sil=0.000> int <sil=0.000> x float <sil=0.000> y <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> int <sil=0.000> and <sil=0.000> float <sil=0.000> were <sil=0.000> some <sil=0.000> types <sil=1.000> ,COMMA  now <sil=0.000> here <sil=0.000> student <sil=0.000> 1
student <sil=0.000> 2 are <sil=0.000> two <sil=0.000> variables <sil=0.000> of <sil=0.000> type <sil=0.000> student <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  this <sil=0.000> type <sil=0.000> is <sil=0.000> not <sil=0.000> a default <sil=0.000> type <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> pre-

defined <sil=0.000> in <sil=0.000> c but <sil=0.000> I can <sil=0.000> use <sil=0.000> it <sil=0.000> because <sil=0.000> I have <sil=0.000> been <sil=0.000> already <sil=0.000> using <sil=0.000> this <sil=0.000> typedef <sil=0.000> statement <sil=0.000> has <sil=0.000> defined <sil=0.000> the <sil=0.000> structure <sil=0.000> as <sil=0.000> student <sil=2.000> .PERIOD 

But <sil=0.000> please <sil=0.000> differentiate <sil=0.000> between <sil=0.000> this <sil=0.000> and <sil=0.000> the <sil=0.000> normal <sil=0.000> definition <sil=0.000> of <sil=0.000> the <sil=0.000> student <sil=0.000> as <sil=0.000> we <sil=0.000> do <sil=0.000> normally <sil=2.000> .PERIOD 
Say <sil=0.000> struct <sil=0.000> something <sil=0.000> and <sil=0.000> then <sil=0.000> I say <sil=0.000> student <sil=2.000> .PERIOD  I <sil=0.000> say <sil=0.000> struct (we <sil=0.000> have <sil=0.000> seen <sil=0.000> this) and <sil=0.000> I write <sil=0.000> the
members <sil=0.000> here <sil=0.000> and <sil=0.000> then <sil=0.000> define <sil=0.000> that <sil=0.000> structure <sil=0.000> as <sil=0.000> the <sil=0.000> type <sil=0.000> student <sil=2.000> .PERIOD  Now <sil=0.000> this <sil=0.000> is <sil=0.000> a definition <sil=0.000> for <sil=0.000> a
particular <sil=0.000> structure <sil=0.000> as <sil=0.000> student <sil=2.000> .PERIOD  Now <sil=0.000> this <sil=1.000> ,COMMA  if <sil=0.000> I have <sil=0.000> to <sil=0.000> use <sil=0.000> it <sil=0.000> then <sil=0.000> I have <sil=0.000> to <sil=0.000> say <sil=0.000> struct <sil=0.000> student
followed <sil=0.000> by <sil=0.000> a 1 <sil=0.000> a 2 <sil=1.000> ,COMMA  student <sil=0.000> 1 student <sil=0.000> 2 whatever <sil=2.000> .PERIOD  But <sil=0.000> in <sil=0.000> this <sil=0.000> case <sil=0.000> if <sil=0.000> I do <sil=0.000> this <sil=0.000> typedef <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> saved <sil=0.000> from <sil=0.000> this <sil=0.000> problem <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> have <sil=0.000> a little <sil=0.000> look <sil=0.000> at <sil=0.000> how <sil=0.000> we <sil=0.000> will <sil=0.000> go <sil=0.000> about <sil=0.000> it <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> a tag <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> typedef <sil=0.000> a particular <sil=0.000> structure <sil=1.000> ,COMMA  just <sil=0.000> like <sil=0.000> here <sil=0.000> it <sil=0.000> could <sil=0.000> be <sil=0.000> char <sil=0.000> name <sil=0.000> or <sil=0.000> int <sil=1.000> ,COMMA  roll <sil=0.354> ;SEMICOLON  note <sil=0.000> the <sil=0.000> semicolon <sil=0.000> at <sil=0.000> the <sil=0.000> end <sil=0.000> of <sil=0.000> if <sil=0.000> all <sil=0.000> this <sil=0.000> declarations <sil=1.000> ,COMMA  ultimately <sil=0.000> I name <sil=0.000> this <sil=0.000> tag <sil=0.000> semi <sil=0.000> say <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  here <sil=0.000> as <sil=0.000> student <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  tag <sil=0.000> is <sil=0.000> the <sil=0.000> name <sil=0.000> of <sil=0.000> the <sil=0.000> new <sil=0.000> data <sil=0.000> type <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  given <sil=0.000> that <sil=0.000> here <sil=0.000> is <sil=0.000> an <sil=0.000> example <sil=0.000> of <sil=0.000> complex <sil=0.000> number <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> are <sil=0.000> defining <sil=0.000> a type <sil=0.000> called <sil=0.000> complex <sil=1.000> ,COMMA  ignore <sil=0.000> this <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  typedef <sil=0.000> something <sil=0.000> having <sil=0.000> real <sil=0.000> part <sil=0.000> and <sil=0.000> an <sil=0.000> imaginary <sil=0.000> part <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> a data <sil=0.000> type <sil=0.000> complex
and <sil=0.000> then <sil=0.000> I am <sil=0.000> saying <sil=0.000> complex <sil=0.000> a b <sil=0.000> c just <sil=0.000> like <sil=0.000> int <sil=0.000> a b <sil=0.000> c <sil=1.000> ,COMMA  float <sil=0.000> a b <sil=0.000> c <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> write <sil=0.000> complex <sil=0.000> a b <sil=0.000> c
because <sil=0.000> complex <sil=0.000> has <sil=0.000> already <sil=0.000> been <sil=0.000> defined <sil=0.000> here <sil=2.000> .PERIOD 

Because <sil=0.000> complex <sil=0.000> has <sil=0.000> already <sil=0.000> been <sil=0.000> defined <sil=0.354> ;SEMICOLON  so <sil=1.000> ,COMMA  I <sil=0.000> think <sil=0.000> this <sil=0.000> is <sil=0.000> clear <sil=0.000> right  <sil=0.228> ?QUESTIONMARK 

Next <sil=0.000> we <sil=0.000> move <sil=0.000> to <sil=1.000> ,COMMA  how <sil=0.000> do <sil=0.000> we <sil=0.000> initialise <sil=0.000> a structure  <sil=0.228> ?QUESTIONMARK  We <sil=0.000> saw <sil=0.000> that <sil=0.000> we <sil=0.000> can <sil=0.000> initialise <sil=0.000> an <sil=0.000> array
similarly <sil=0.000> we <sil=0.000> can <sil=0.000> initialise <sil=0.000> a structure <sil=0.000> as <sil=0.000> well <sil=2.000> .PERIOD  Say <sil=0.000> a structure <sil=0.000> variables <sil=0.000> may <sil=0.000> be <sil=0.000> initialised
following <sil=0.000> similar <sil=0.000> rules <sil=0.000> like <sil=0.000> an <sil=0.000> array <sil=2.000> .PERIOD  The <sil=0.000> values <sil=0.000> are <sil=0.000> provided <sil=0.000> in <sil=0.000> a within <sil=0.000> the <sil=0.000> second <sil=0.000> braces
separated <sil=0.000> by <sil=0.000> commas <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  here <sil=0.000> complex <sil=0.000> a <sil=2.000> .PERIOD 

Complex <sil=0.000> a <sil=1.000> ,COMMA  is <sil=0.000> a complex <sil=0.000> variable <sil=0.000> 1 <sil=2.000> .PERIOD <sil=0.000> 0 comma <sil=0.000> 2 <sil=2.000> .PERIOD <sil=0.000> 0 what <sil=0.000> does <sil=0.000> it <sil=0.000> imply <sil=0.228> ?QUESTIONMARK  It <sil=0.000> implies <sil=0.000> that  a  is <sil=0.000> a
structure <sil=0.000> having <sil=0.000> two <sil=0.000> fields <sil=0.000> and <sil=0.000> one <sil=0.000> field <sil=0.000> is <sil=0.000> 1 <sil=2.000> .PERIOD <sil=0.000> 0 another <sil=0.000> is <sil=0.000> 2 <sil=2.000> .PERIOD <sil=0.000> 0 <sil=2.000> .PERIOD  Similarly <sil=0.000> b is <sil=0.000> another <sil=0.000> field <sil=1.000> ,COMMA  which
is <sil=0.000> initialised <sil=0.000> to <sil=0.000> minus <sil=0.000> 3 <sil=2.000> .PERIOD <sil=0.000> 0 and <sil=0.000> 4 <sil=2.000> .PERIOD <sil=0.000> 0 <sil=2.000> .PERIOD  Just <sil=0.000> as <sil=0.000> we <sil=0.000> did <sil=0.000> it <sil=0.000> in <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> arrays <sil=1.000> ,COMMA  we <sil=0.000> do <sil=0.000> it <sil=0.000> for <sil=0.000> individual
structural <sil=0.000> variables <sil=0.000> here <sil=1.000> ,COMMA  but <sil=0.000> you <sil=0.000> have <sil=0.000> to <sil=0.000> put <sil=0.000> all <sil=0.000> the <sil=0.000> values <sil=0.000> initial <sil=0.000> values <sil=0.000> for <sil=0.000> all <sil=0.000> the <sil=0.000> fields <sil=0.000> of <sil=0.000> the
array <sil=2.000> .PERIOD (Refer <sil=0.000> Slide <sil=0.000> Time: 16:12)

So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> what <sil=0.000> happens <sil=0.000> through <sil=0.000> this <sil=0.000> initialisation <sil=2.000> .PERIOD 

The <sil=0.000> last <sil=0.000> thing <sil=0.000> that <sil=0.000> we <sil=0.000> will <sil=0.000> be <sil=0.000> talking <sil=0.000> about <sil=0.000> is <sil=0.000> parameter <sil=0.000> passing <sil=0.000> in <sil=0.000> a function <sil=2.000> .PERIOD  How <sil=0.000> do <sil=0.000> we <sil=0.000> pass <sil=0.000> a
structure <sil=0.000> as <sil=0.000> a parameter <sil=0.000> to <sil=0.000> a function <sil=0.228> ?QUESTIONMARK  We <sil=0.000> have <sil=0.000> seen <sil=0.000> how <sil=0.000> arrays <sil=0.000> can <sil=0.000> be <sil=0.000> passed <sil=0.000> similarly <sil=0.000> how <sil=0.000> can <sil=0.000> we <sil=0.000> pass <sil=0.000> structures <sil=0.000> to <sil=0.000> a function <sil=0.000> like <sil=0.000> any <sil=0.000> other <sil=0.000> variable  <sil=0.228> ?QUESTIONMARK  Just <sil=0.000> like <sil=0.000> any <sil=0.000> other <sil=0.000> variable <sil=0.000> we <sil=0.000> can <sil=0.000> pass <sil=0.000> it <sil=0.000> like <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  here <sil=0.000> you <sil=0.000> can <sil=0.000> see <sil=0.000> that <sil=0.000> there <sil=0.000> is <sil=0.000> a swap <sil=0.000> between <sil=0.000> complex <sil=0.000> variable <sil=0.000> a and
complex <sil=0.000> variable <sil=0.000> b <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  a <sil=0.000> and <sil=0.000> b are <sil=0.000> both <sil=0.000> structures <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> saying <sil=0.000> just <sil=0.000> as <sil=0.000> we <sil=0.000> use <sil=0.000> to <sil=0.000> write <sil=0.000> void <sil=0.000> swap <sil=0.000> int <sil=0.000> a int <sil=0.000> b just <sil=0.000> like <sil=0.000> that <sil=1.000> ,COMMA  here <sil=0.000> I write <sil=0.000> complex <sil=0.000> a complex <sil=0.000> b <sil=2.000> .PERIOD  It <sil=0.000> is <sil=0.000> also <sil=0.000> a call <sil=0.000> by <sil=0.000> value <sil=2.000> .PERIOD  Now <sil=0.000> so <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> again <sil=0.000> the <sil=0.000> typical <sil=0.000> assignment <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> an <sil=0.000> example <sil=0.000> program <sil=0.000> using <sil=0.000> typedef <sil=2.000> .PERIOD  What <sil=0.000> is <sil=0.000> being <sil=0.000> done <sil=0.000> here <sil=0.000> is <sil=0.000> I am <sil=0.000> defining <sil=0.000> a type
complex <sil=1.000> ,COMMA  typedef <sil=0.000> struct - they <sil=0.000> are <sil=0.000> two <sil=0.000> parts <sil=0.000> real <sil=0.000> and <sil=0.000> imaginary <sil=0.000> and <sil=0.000> this <sil=0.000> data <sil=0.000> type <sil=0.000> is <sil=0.000> known <sil=0.000> as
complex <sil=2.000> .PERIOD  Now <sil=0.000> I am <sil=0.000> writing <sil=0.000> a function <sil=0.000> swap  <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> taking <sil=0.000> another <sil=0.000> variable <sil=0.000> which <sil=0.000> is <sil=0.000> of <sil=0.000> type
complex <sil=1.000> ,COMMA  tmp <sil=0.000> is <sil=0.000> of <sil=0.000> type <sil=0.000> complex <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  when <sil=0.000> I do <sil=0.000> assign <sil=0.000> a to <sil=0.000> tmp <sil=1.000> ,COMMA  then <sil=0.000> this <sil=0.000> tmp <sil=0.000> variable <sil=0.000> which <sil=0.000> is
of <sil=0.000> type <sil=0.000> complex <sil=0.000> will <sil=0.000> copy <sil=0.000> the <sil=0.000> variables (say <sil=0.000> here <sil=0.000> it <sil=0.000> was <sil=0.000> 3 <sil=2.000> .PERIOD <sil=0.000> 0 and <sil=0.000> minus <sil=0.000> 2) so <sil=1.000> ,COMMA  this <sil=0.000> will <sil=0.000> come <sil=0.000> here
it <sil=0.000> will <sil=0.000> become <sil=0.000> 3 <sil=2.000> .PERIOD <sil=0.000> 0 and <sil=0.000> this <sil=0.000> will <sil=0.000> become <sil=0.000> minus <sil=0.000> 2 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> tmp <sil=2.000> .PERIOD  Now <sil=0.000> I copy <sil=0.000> b to <sil=0.000> a <sil=2.000> .PERIOD  I <sil=0.000> am <sil=0.000> sorry <sil=0.000> not <sil=0.000> this <sil=0.000> one <sil=1.000> ,COMMA  there <sil=0.000> was <sil=0.000> some <sil=0.000> b and <sil=0.000> the <sil=0.000> values <sil=0.000> of <sil=0.000> b
are <sil=0.000> copied <sil=0.000> to <sil=0.000> a  <sil=1.000> ,COMMA  not <sil=0.000> here <sil=1.000> ,COMMA  these <sil=0.000> are <sil=0.000> copied <sil=0.000> here <sil=0.000> and <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> might <sil=0.000> be <sil=0.000> that <sil=0.000> this <sil=0.000> is <sil=0.000> changed <sil=0.000> to <sil=0.000> 5 <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> changed <sil=0.000> to <sil=0.000> minus <sil=0.000> 2 <sil=2.000> .PERIOD <sil=0.000> 5 and <sil=0.000> then <sil=0.000> I copy <sil=0.000> tmp <sil=0.000> to <sil=0.000> b <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> again <sil=0.000> copied <sil=0.000> back <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  member <sil=0.000> by <sil=0.000> member <sil=0.000> the <sil=0.000> copy <sil=0.000> is <sil=0.000> done <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> we <sil=0.000> illustrate <sil=0.000> what <sil=0.000> you <sil=0.000> mean <sil=0.000> by <sil=0.000> typedef <sil=0.000> and <sil=0.000> a function <sil=0.000> that <sil=0.000> is <sil=0.000> using <sil=0.000> it <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  now <sil=0.000> suppose <sil=0.000> how <sil=0.000> can <sil=0.000> we <sil=0.000> print <sil=0.000> a structure <sil=0.228> ?QUESTIONMARK  Say <sil=0.000> here <sil=0.000> is <sil=0.000> a function <sil=1.000> ,COMMA  the <sil=0.000> main <sil=0.000> function <sil=0.000> is
calling <sil=0.000> print <sil=0.000> x and <sil=0.000> print <sil=0.000> y <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  say <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  my <sil=0.000> main <sil=0.000> function <sil=0.000> is <sil=0.000> initialising (now <sil=0.000> you
understand <sil=0.000> all <sil=0.000> this <sil=0.000> things) x <sil=0.000> to <sil=0.000> 4 <sil=1.000> ,COMMA  x <sil=0.000> real <sil=0.000> part <sil=0.000> to <sil=0.000> 4 <sil=1.000> ,COMMA <sil=0.000> imaginary <sil=0.000> part <sil=0.000> to <sil=0.000> 5 right <sil=0.000> and <sil=0.000> y s <sil=0.000> real <sil=0.000> part <sil=0.000> to <sil=0.000> 10
and <sil=0.000> imaginary <sil=0.000> part <sil=0.000> to <sil=0.000> 15 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> calling <sil=0.000> print <sil=0.000> x <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> calling <sil=0.000> print <sil=0.000> x <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  x <sil=0.000> is <sil=0.000> being
copied <sil=0.000> call <sil=0.000> by <sil=0.000> value <sil=0.000> to <sil=0.000> another <sil=0.000> local <sil=0.000> variable <sil=0.000> a <sil=1.000> ,COMMA  which <sil=0.000> is <sil=0.000> local <sil=0.000> to <sil=0.000> this <sil=0.000> function <sil=0.000> print <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  a <sil=0.000> is
holding <sil=0.000> the <sil=0.000> complex <sil=0.000> variable <sil=0.000> x and <sil=0.000> print <sil=0.000> f a <sil=0.000> dot <sil=0.000> real <sil=0.000> a dot <sil=0.000> imaginary <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  field <sil=0.000> by <sil=0.000> field <sil=0.000> I print <sil=0.000> them <sil=2.000> .PERIOD  Then <sil=0.000> I come <sil=0.000> back <sil=0.000> I print <sil=0.000> y <sil=2.000> .PERIOD  Y <sil=0.000> is <sil=0.000> copied <sil=0.000> to <sil=0.000> a and <sil=0.000> the <sil=0.000> same <sil=0.000> thing
happens <sil=1.000> ,COMMA  then <sil=0.000> I call <sil=0.000> swap <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  swap <sil=0.000> as <sil=0.000> a function <sil=0.000> that <sil=0.000> we <sil=0.000> just <sil=0.000> now <sil=0.000> saw <sil=0.000> where <sil=0.000> we <sil=0.000> take <sil=0.000> tmp <sil=0.000> and <sil=0.000> we <sil=0.000> copy <sil=0.000> it <sil=0.000> to <sil=0.000> tmp <sil=1.000> ,COMMA  and <sil=0.000> then <sil=0.000> I copy <sil=0.000> b to <sil=0.000> a <sil=1.000> ,COMMA  and <sil=0.000> then <sil=0.000> tmp <sil=0.000> to <sil=0.000> a in <sil=0.000> that <sil=0.000> way <sil=0.000> we <sil=0.000> carry <sil=0.000> out <sil=0.000> the
swapping <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> purely <sil=0.000> call <sil=0.000> by <sil=0.000> value <sil=0.000> and <sil=0.000> then <sil=0.000> I print <sil=0.000> x and <sil=0.000> print <sil=0.000> y <sil=2.000> .PERIOD  After <sil=0.000> I swap <sil=1.000> ,COMMA  what <sil=0.000> will <sil=0.000> happen <sil=0.000> in <sil=0.000> this
case <sil=0.228> ?QUESTIONMARK  If <sil=0.000> I go <sil=0.000> back <sil=0.000> to <sil=0.000> this <sil=0.000> case <sil=1.000> ,COMMA  where <sil=0.000> I am <sil=0.000> passing <sil=0.000> among <sil=0.000> this <sil=0.000> a and <sil=0.000> b <sil=1.000> ,COMMA  the <sil=0.000> x and <sil=0.000> y are <sil=0.000> being
swapped <sil=0.000> inside <sil=0.000> that <sil=0.000> function <sil=1.000> ,COMMA  but <sil=0.000> will <sil=0.000> that <sil=0.000> be <sil=0.000> swapped <sil=0.000> in <sil=0.000> actuality <sil=0.228> ?QUESTIONMARK  You <sil=0.000> check <sil=0.000> that <sil=0.000> yourself <sil=2.000> .PERIOD 

How <sil=0.000> do <sil=0.000> we <sil=0.000> return <sil=0.000> a structure <sil=0.000> from <sil=0.000> a function <sil=0.228> ?QUESTIONMARK  Suppose <sil=0.000> I have <sil=0.000> done <sil=0.000> something <sil=1.000> ,COMMA  but <sil=0.000> in <sil=0.000> this <sil=0.000> earlier <sil=0.000> case <sil=0.000> where <sil=0.000> x and <sil=0.000> y were <sil=0.000> being <sil=0.000> swapped <sil=0.000> inside <sil=0.000> the <sil=0.000> function <sil=1.000> ,COMMA  but <sil=0.000> when <sil=0.000> I come <sil=0.000> back <sil=0.000> to <sil=0.000> the <sil=0.000> main <sil=0.000> my <sil=0.000> x <sil=1.000> ,COMMA  y <sil=0.000> remains <sil=0.000> the <sil=0.000> same <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> we <sil=0.000> if <sil=0.000> we <sil=0.000> want <sil=0.000> to <sil=0.000> return <sil=0.000> the <sil=0.000> function <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  here <sil=1.000> ,COMMA  I <sil=0.000> carry <sil=0.000> out <sil=0.000> a real <sil=0.000> plus <sil=0.000> b real (I <sil=0.000> make <sil=0.000> it <sil=0.000> tmp) <sil=2.000> .PERIOD  So <sil=0.000> here <sil=0.000> is <sil=0.000> an <sil=0.000> example <sil=0.000> of <sil=0.000> adding <sil=0.000> two <sil=0.000> complex <sil=0.000> numbers <sil=1.000> ,COMMA  here <sil=0.000> complex <sil=0.000> a and <sil=0.000> complex <sil=0.000> b are <sil=0.000> two <sil=0.000> variables <sil=0.000> which <sil=0.000> have <sil=0.000> been <sil=0.000> passed <sil=0.000> on <sil=0.000> as <sil=0.000> parameter <sil=0.000> here <sil=1.000> ,COMMA  and <sil=0.000> I have <sil=0.000> got <sil=0.000> a tmp <sil=0.000> as <sil=0.000> a local <sil=0.000> function <sil=1.000> ,COMMA  a <sil=0.000> local <sil=0.000> variable <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  tmp <sil=0.000> dot <sil=0.000> real <sil=0.000> is <sil=0.000> copping <sil=0.000> a dot <sil=0.000> real <sil=0.000> plus <sil=0.000> b dot <sil=0.000> real <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> happening <sil=0.228> ?QUESTIONMARK  Here <sil=0.000> I have <sil=0.000> got
structure <sil=0.000> a with <sil=0.000> a real <sil=0.000> part <sil=0.000> and <sil=0.000> an <sil=0.000> imaginary <sil=0.000> part <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  3 <sil=2.000> .PERIOD <sil=0.000> 0 4 <sil=2.000> .PERIOD <sil=0.000> 2 another <sil=0.000> is <sil=0.000> b which <sil=0.000> is <sil=0.000> 2 <sil=2.000> .PERIOD <sil=0.000> 5 and <sil=0.000> may
be <sil=0.000> 3 <sil=2.000> .PERIOD <sil=0.000> 6 <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  when <sil=0.000> I am <sil=0.000> adding <sil=0.000> two <sil=0.000> complex <sil=0.000> numbers <sil=1.000> ,COMMA  you <sil=0.000> remember <sil=0.000> we <sil=0.000> discussed <sil=0.000> it <sil=0.000> in <sil=0.000> last <sil=0.000> class <sil=0.000> also <sil=1.000> ,COMMA  I <sil=0.000> first <sil=0.000> add <sil=0.000> this <sil=0.000> two <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  a <sil=0.000> real <sil=0.000> is <sil=0.000> added <sil=0.000> to <sil=0.000> b real <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> tmp <sil=0.000> where <sil=0.000> I am <sil=0.000> getting <sil=0.000> 5 <sil=2.000> .PERIOD <sil=0.000> 5 and <sil=0.000> then
imaginary <sil=0.000> I am <sil=0.000> getting <sil=0.000> 7 <sil=2.000> .PERIOD <sil=0.000> 8 and <sil=0.000> now <sil=0.000> I return <sil=0.000> tmp <sil=2.000> .PERIOD 

Now <sil=0.000> in <sil=0.000> the <sil=0.000> main <sil=0.000> function <sil=0.000> if <sil=0.000> I had <sil=0.000> written <sil=0.000> something <sil=0.000> like <sil=0.000> say <sil=0.000> x and <sil=0.000> y were <sil=0.000> two <sil=0.000> complex
variables <sil=1.000> ,COMMA  and <sil=0.000> what <sil=0.000> I did <sil=0.000> was <sil=0.000> I added <sil=0.000> x y <sil=0.000> assigned <sil=0.000> to <sil=0.000> some <sil=0.000> other <sil=0.000> complex <sil=0.000> variable <sil=0.000> z <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> case

this <sil=0.000> tmp <sil=0.000> will <sil=0.000> be <sil=0.000> assigned <sil=0.000> to <sil=0.000> this <sil=0.000> complex <sil=0.000> variable <sil=0.000> z <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> how <sil=0.000> we <sil=0.000> can <sil=0.000> return <sil=0.000> a structure <sil=0.000> from <sil=0.000> a
Function <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  structure <sil=0.000> facilitates <sil=0.000> us <sil=0.000> in <sil=0.000> many <sil=0.000> ways <sil=0.000> but <sil=0.000> direct <sil=0.000> arithmetic <sil=0.000> operations <sil=0.000> are <sil=0.000> not <sil=0.000> possible <sil=0.000> with
structure <sil=0.000> variables <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  I <sil=0.000> cannot <sil=0.000> just <sil=0.000> add <sil=0.000> a and <sil=0.000> b when <sil=0.000> both <sil=0.000> of <sil=0.000> them <sil=0.000> are <sil=0.000> structures <sil=2.000> .PERIOD  I <sil=0.000> have <sil=0.000> to <sil=0.000> do <sil=0.000> the <sil=0.000> arithmetic <sil=0.000> operations <sil=0.000> over <sil=0.000> its <sil=0.000> members <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  with <sil=0.000> that <sil=0.000> we <sil=0.000> conclude <sil=0.000> our <sil=0.000> discussion <sil=0.000> on <sil=0.000> structures <sil=0.000> and <sil=0.000> you <sil=0.000> will <sil=0.000> be <sil=0.000> given <sil=0.000> assignments <sil=0.000> on <sil=0.000> structures <sil=1.000> ,COMMA  and <sil=0.000> this <sil=0.000> will <sil=0.000> enable <sil=0.000> you <sil=0.000> to <sil=0.000> write
different <sil=0.000> types <sil=0.000> of <sil=0.000> handle <sil=0.000> different <sil=0.000> types <sil=0.000> of <sil=0.000> data <sil=0.000> types <sil=0.000> together <sil=0.000> and <sil=0.000> using <sil=0.000> the <sil=0.000> typedef <sil=1.000> ,COMMA  you <sil=0.000> can
design <sil=0.000> your <sil=0.000> own <sil=0.000> complex <sil=0.000> data <sil=0.000> type <sil=0.000> which <sil=0.000> you <sil=0.000> can <sil=0.000> utilise <sil=0.000> further <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  please <sil=0.000> practice <sil=0.000> using <sil=0.000> structures <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> at <sil=0.000> all <sil=0.000> difficult <sil=1.000> ,COMMA  only <sil=0.000> a little <sil=0.000> practice <sil=0.000> and <sil=0.000> a little
understanding <sil=0.000> is <sil=0.000> required <sil=2.000> .PERIOD 

Thank <sil=0.000> you <sil=2.000> .PERIOD 

In <sil=0.000> today s <sil=0.000> lecture <sil=0.000> we <sil=0.000> will <sil=0.000> look <sil=0.000> at <sil=0.000> very <sil=0.000> important <sil=0.000> concept <sil=0.000> of <sil=0.000> programming <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> required <sil=0.000> to
conceptualise <sil=0.000> and <sil=0.000> understand <sil=0.000> this <sil=0.000> thing <sil=0.000> very <sil=0.000> well <sil=0.000> so <sil=1.000> ,COMMA  that <sil=0.000> you <sil=0.000> can <sil=0.000> have <sil=0.000> more <sil=0.000> flexibility <sil=0.000> with
programming <sil=2.000> .PERIOD  We <sil=0.000> have <sil=0.000> visited <sil=0.000> this <sil=0.000> idea <sil=0.000> the <sil=0.000> concept <sil=0.000> of <sil=0.000> pointers <sil=1.000> ,COMMA  earlier <sil=0.000> in <sil=0.000> the <sil=0.000> context <sil=0.000> of <sil=0.000> our
discussions <sil=0.000> of <sil=0.000> call <sil=0.000> by <sil=0.000> value <sil=0.000> and <sil=0.000> call <sil=0.000> by <sil=0.000> reference <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  if <sil=0.000> you <sil=0.000> recall <sil=0.000> at <sil=0.000> that <sil=0.000> time <sil=1.000> ,COMMA  we <sil=0.000> had <sil=0.000> we <sil=0.000> had <sil=0.000> talked <sil=0.000> about <sil=0.000> the <sil=0.000> variables <sil=1.000> ,COMMA  which <sil=0.000> are <sil=0.000> in <sil=0.000> the <sil=0.000> memory
right  <sil=0.228> ?QUESTIONMARK 

So <sil=1.000> ,COMMA  suppose <sil=0.000> I am <sil=0.000> talking <sil=0.000> of <sil=0.000> a variable - x <sil=0.000> y z <sil=0.000> is <sil=0.000> the <sil=0.000> name <sil=0.000> of <sil=0.000> a variable <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> variable <sil=0.000> has <sil=0.000> got
some <sil=0.000> address <sil=1.000> ,COMMA  that <sil=0.000> address <sil=0.000> maybe <sil=0.000> say <sil=0.000> 5000 <sil=0.000> in <sil=0.000> the <sil=0.000> memory <sil=0.000> and <sil=0.000> who <sil=0.000> has <sil=0.000> allocated <sil=0.000> this <sil=0.000> address <sil=0.228> ?QUESTIONMARK 
That <sil=0.000> address <sil=0.000> has <sil=0.000> been <sil=0.000> allocated <sil=0.000> by <sil=0.000> the <sil=0.000> compiler <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  if <sil=0.000> I have <sil=0.000> another <sil=0.000> memory <sil=0.000> location <sil=1.000> ,COMMA  say <sil=0.000> a part <sil=0.000> of <sil=0.000> this <sil=0.000> which <sil=0.000> I am <sil=0.000> just <sil=0.000> drawing <sil=0.000> separately
whose <sil=0.000> address <sil=0.000> is <sil=0.000> say <sil=0.000> 7000 <sil=0.228> ?QUESTIONMARK  Say <sil=0.000> this <sil=0.000> one - 7000 <sil=0.000> and <sil=0.000> inside <sil=0.000> this <sil=0.000> location <sil=0.000> 7000 <sil=0.000> as <sil=0.000> it s <sil=0.000> content <sil=1.000> ,COMMA  I
write <sil=0.000> 5000 <sil=0.000> and <sil=0.000> I say <sil=0.000> that <sil=0.000> whatever <sil=0.000> is <sil=0.000> the <sil=0.000> content <sil=0.000> of <sil=0.000> this <sil=0.000> location <sil=0.000> 7000 <sil=0.000> that <sil=0.000> is <sil=0.000> the <sil=0.000> variable <sil=0.000> I am
interested <sil=0.000> in <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  can <sil=0.000> I say <sil=0.000> that <sil=0.000> if <sil=0.000> I now <sil=0.000> give <sil=0.000> a symbolic <sil=0.000> name <sil=0.000> p to <sil=0.000> this <sil=0.000> 7000 <sil=0.000> or <sil=0.000> say <sil=0.000> this <sil=0.000> is <sil=0.000> p <sil=1.000> ,COMMA  that <sil=0.000> this <sil=0.000> p is
pointing <sil=0.000> to <sil=0.000> x y <sil=0.000> z because <sil=0.000> p is <sil=0.000> containing <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> x y <sil=0.000> z <sil=2.000> .PERIOD  Therefore <sil=1.000> ,COMMA  p <sil=0.000> is <sil=0.000> a pointer <sil=0.000> to <sil=0.000> a
variable <sil=0.000> x y <sil=0.000> z <sil=2.000> .PERIOD  Right <sil=0.000> now <sil=0.000> p is <sil=0.000> pointing <sil=0.000> to <sil=0.000> x y <sil=0.000> z <sil=1.000> ,COMMA  but <sil=0.000> if <sil=0.000> I just <sil=0.000> change <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> this <sil=0.000> location
7000 <sil=0.000> and <sil=0.000> make <sil=0.000> it <sil=0.000> say <sil=0.000> 6000 <sil=0.000> then <sil=0.000> it <sil=0.000> will <sil=0.000> probably <sil=0.000> point <sil=0.000> to <sil=0.000> some <sil=0.000> other <sil=0.000> location <sil=0.000> here <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  p <sil=0.000> is <sil=0.000> therefore <sil=1.000> ,COMMA  a <sil=0.000> pointer <sil=0.000> variable <sil=1.000> ,COMMA  but <sil=0.000> when <sil=0.000> I say <sil=0.000> that <sil=0.000> it <sil=0.000> is <sil=0.000> a pointer <sil=0.000> variable <sil=1.000> ,COMMA  then <sil=0.000> it <sil=0.000> is <sil=0.000> not
pointing <sil=0.000> to <sil=0.000> any <sil=0.000> particular <sil=0.000> data <sil=1.000> ,COMMA  it <sil=0.000> can <sil=0.000> point <sil=0.000> to <sil=0.000> a type <sil=0.000> of <sil=0.000> data <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  instead <sil=0.000> of <sil=0.000> making <sil=0.000> this <sil=0.000> statement <sil=0.000> that <sil=0.000> p is <sil=0.000> a pointer <sil=0.000> variable <sil=0.000> to <sil=0.000> a variable <sil=0.000> x y <sil=0.000> z <sil=2.000> .PERIOD  Say <sil=0.000> this <sil=0.000> one <sil=0.000> is <sil=0.000> p q <sil=0.000> r now <sil=0.000> as <sil=0.000> I change <sil=0.000> this <sil=1.000> ,COMMA  now <sil=0.000> p is <sil=0.000> a pointer <sil=0.000> variable <sil=0.000> to <sil=0.000> a variable <sil=0.000> p q <sil=0.000> r <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  if <sil=0.000> I generalis <sil=0.000> it <sil=0.000> lets <sil=0.000> say <sil=0.000> that <sil=0.000> in <sil=0.000> this <sil=0.000> situation <sil=0.000> where <sil=0.000> I have <sil=0.000> got <sil=0.000> x y <sil=0.000> z at <sil=0.000> 5000 <sil=0.000> and <sil=0.000> p q <sil=0.000> r at <sil=0.000> 6000
and <sil=0.000> 7000 <sil=0.000> is <sil=0.000> a pointer <sil=0.000> p then <sil=0.000> I can <sil=0.000> say <sil=0.000> p is <sil=0.000> a pointer <sil=0.000> variable <sil=0.000> pointing (say <sil=0.000> x y <sil=0.000> z and <sil=0.000> p q <sil=0.000> r who <sil=0.000> are <sil=0.000> both <sil=0.000> integers) to <sil=0.000> an <sil=0.000> integer <sil=0.000> or <sil=0.000> it <sil=0.000> could <sil=0.000> be <sil=0.000> a float <sil=0.000> or <sil=0.000> it <sil=0.000> could <sil=0.000> be <sil=0.000> a some <sil=0.000> other <sil=0.000> data <sil=0.000> type <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  pointed <sil=0.000> to <sil=0.000> a particular <sil=0.000> data <sil=0.000> type <sil=2.000> .PERIOD  Why <sil=0.000> I specify <sil=0.000> the <sil=0.000> data <sil=0.000> type <sil=0.000> will <sil=0.000> be <sil=0.000> clear <sil=0.000> in <sil=0.000> some <sil=0.000> time <sil=0.000> from <sil=0.000> now <sil=2.000> .PERIOD  The <sil=0.000> most <sil=0.000> important <sil=0.000> concept <sil=0.000> here <sil=0.000> is <sil=0.000> that <sil=0.000> p is <sil=0.000> a pointer <sil=1.000> ,COMMA  p <sil=0.000> is <sil=0.000> a variable <sil=0.000> and <sil=0.000> variable <sil=0.000> is <sil=0.000> holding <sil=0.000> some <sil=0.000> value <sil=0.000> and <sil=0.000> that <sil=0.000> value <sil=0.000> is <sil=0.000> nothing <sil=1.000> ,COMMA  but <sil=0.000> an <sil=0.000> address <sil=0.000> of <sil=0.000> another <sil=0.000> variable <sil=0.000> all <sil=0.000> right <sil=0.000> address <sil=0.000> of <sil=0.000> another <sil=0.000> variable <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  now <sil=0.000> let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=0.000> the <sil=0.000> basic <sil=0.000> concept <sil=1.000> ,COMMA  every <sil=0.000> stored <sil=0.000> data <sil=0.000> items <sil=0.000> occupies <sil=0.000> one <sil=0.000> or <sil=0.000> more
memory <sil=0.000> cells <sil=1.000> ,COMMA  whenever <sil=0.000> we <sil=0.000> declare <sil=0.000> a variable <sil=0.000> the <sil=0.000> system <sil=0.000> allocates <sil=0.000> memory <sil=0.000> locations <sil=0.000> to <sil=0.000> that
variable <sil=1.000> ,COMMA  we <sil=0.000> know <sil=0.000> that <sil=0.000> very <sil=0.000> well <sil=0.354> ;SEMICOLON  so <sil=1.000> ,COMMA  need <sil=0.000> not <sil=0.000> spend <sil=0.000> more <sil=0.000> time <sil=0.000> on <sil=0.000> that <sil=2.000> .PERIOD  Now <sil=0.000> this <sil=0.000> is <sil=0.000> important <sil=1.000> ,COMMA 
you <sil=0.000> already <sil=0.000> know <sil=0.000> that <sil=0.000> the <sil=0.000> number <sil=0.000> of <sil=0.000> memory <sil=0.000> cells <sil=0.000> required <sil=0.000> to <sil=0.000> store <sil=0.000> a data <sil=0.000> item <sil=0.000> depends <sil=0.000> on <sil=0.000> its
type <sil=1.000> ,COMMA  typically <sil=0.000> for <sil=0.000> char <sil=0.000> we <sil=0.000> need <sil=0.000> one <sil=0.000> byte <sil=1.000> ,COMMA  for <sil=0.000> int <sil=0.000> we <sil=0.000> need <sil=0.000> two <sil=0.000> bytes <sil=1.000> ,COMMA  for <sil=0.000> float <sil=0.000> we <sil=0.000> need <sil=0.000> four <sil=0.000> bytes
etcetera <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  since <sil=0.000> every <sil=0.000> byte <sil=0.000> in <sil=0.000> memory <sil=0.000> has <sil=0.000> an <sil=0.000> unique <sil=0.000> address <sil=1.000> ,COMMA  this <sil=0.000> location <sil=0.000> will <sil=0.000> also <sil=0.000> have <sil=0.000> its <sil=0.000> unique
address <sil=2.000> .PERIOD  Every <sil=0.000> element <sil=0.000> will <sil=0.000> have <sil=0.000> a unique <sil=0.000> address <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> see <sil=0.000> here <sil=0.000> the <sil=0.000> same <sil=0.000> example <sil=1.000> ,COMMA  consider <sil=0.000> the <sil=0.000> statement <sil=0.000> int <sil=0.000> x y <sil=0.000> z assigned <sil=0.000> 50 <sil=2.000> .PERIOD  This <sil=0.000> statement <sil=0.000> means <sil=0.000> that <sil=0.000> the <sil=0.000> compiler <sil=0.000> will <sil=0.000> allocate <sil=0.000> for <sil=0.000> this <sil=0.000> x y <sil=0.000> z some <sil=0.000> location <sil=0.000> and <sil=0.000> put <sil=0.000> the <sil=0.000> value <sil=0.000> 50 <sil=0.000> in <sil=0.000> that <sil=0.000> location <sil=2.000> .PERIOD  Suppose <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> x y <sil=0.000> z is <sil=0.000> 1380 <sil=2.000> .PERIOD  Here <sil=0.000> x y <sil=0.000> z is <sil=0.000> a variable <sil=0.000> and <sil=0.000> 50 <sil=0.000> is <sil=0.000> the <sil=0.000> value <sil=0.000> and
1380 <sil=0.000> is <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> that <sil=0.000> variable <sil=0.000> we <sil=0.000> know <sil=0.000> that <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> discussed <sil=0.000> it <sil=0.000> earlier <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  during <sil=0.000> execution <sil=0.000> of <sil=0.000> the <sil=0.000> program <sil=1.000> ,COMMA  when <sil=0.000> the <sil=0.000> program <sil=0.000> is <sil=0.000> being <sil=0.000> executed <sil=0.000> the <sil=0.000> system <sil=0.000> always
associates <sil=0.000> the <sil=0.000> name <sil=0.000> x y <sil=0.000> z with <sil=0.000> the <sil=0.000> address <sil=0.000> 1380 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  whenever <sil=0.000> in <sil=0.000> the <sil=0.000> program <sil=0.000> we <sil=0.000> find <sil=0.000> x y <sil=0.000> z <sil=1.000> ,COMMA  the <sil=0.000> variable <sil=0.000> x y <sil=0.000> z being <sil=0.000> referred <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> go <sil=0.000> to <sil=0.000> the <sil=0.000> memory <sil=0.000> location <sil=0.000> thirteen <sil=0.000> eighty <sil=0.000> and <sil=0.000> fetch <sil=0.000> that <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> value <sil=0.000> 50 <sil=0.000> can <sil=0.000> therefore <sil=1.000> ,COMMA  be <sil=0.000> accessed <sil=0.000> by <sil=0.000> going <sil=0.000> to <sil=0.000> the <sil=0.000> location <sil=0.000> 1380 <sil=0.000> and <sil=0.000> accessing <sil=0.000> it <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  the <sil=0.000> variables <sil=0.000> which <sil=0.000> are <sil=0.000> holding <sil=0.000> these <sil=0.000> addresses <sil=0.000> are <sil=0.000> known <sil=0.000> as <sil=0.000> the <sil=0.000> pointers <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  memory <sil=0.000> address <sil=0.000> is <sil=0.000> just <sil=0.000> numbers <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> also <sil=0.000> store <sil=0.000> them <sil=0.000> in <sil=0.000> some <sil=0.000> variables <sil=0.000> and <sil=0.000> these <sil=0.000> variables <sil=0.000> which <sil=0.000> are <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  the
address <sil=0.000> of <sil=0.000> the <sil=0.000> variable <sil=0.000> that <sil=0.000> will <sil=0.000> hold <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> variable <sil=0.000> x y <sil=0.000> z is <sil=0.000> the <sil=0.000> pointer <sil=0.000> to <sil=0.000> x y <sil=0.000> z <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is
also <sil=0.000> naturally <sil=0.000> stored <sil=0.000> in <sil=0.000> some <sil=0.000> memory <sil=0.000> location <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> just <sil=0.000> the <sil=0.000> example <sil=0.000> that <sil=0.000> I was <sil=0.000> discussing <sil=0.000> right <sil=0.000> now <sil=2.000> .PERIOD  Suppose <sil=0.000> we <sil=0.000> assign <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> x y <sil=0.000> z to <sil=0.000> a variable <sil=0.000> p <sil=1.000> ,COMMA  then <sil=0.000> p is <sil=0.000> said <sil=0.000> to <sil=0.000> point <sil=0.000> to <sil=0.000> the <sil=0.000> variable <sil=0.000> x y <sil=0.000> z <sil=2.000> .PERIOD 

I <sil=0.000> was <sil=0.000> comfortably <sil=0.000> drawing <sil=0.000> this <sil=0.000> that <sil=0.000> there <sil=0.000> is <sil=0.000> 5000 <sil=0.000> here <sil=1.000> ,COMMA  x <sil=0.000> y z <sil=0.000> and <sil=0.000> 5000 <sil=0.000> here <sil=0.000> and <sil=0.000> I was <sil=0.000> simply
saying <sil=0.000> that <sil=0.000> this <sil=0.000> variable <sil=0.000> which <sil=0.000> was <sil=0.000> in <sil=0.000> location <sil=0.000> 7000 <sil=0.000> was <sil=0.000> pointing <sil=0.000> to <sil=0.000> this  <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  this <sil=0.000> was
being <sil=0.000> loaded <sil=0.000> with <sil=0.000> 5000 <sil=2.000> .PERIOD  How <sil=0.000> is <sil=0.000> that <sil=0.000> being <sil=0.000> done <sil=0.228> ?QUESTIONMARK  How <sil=0.000> is <sil=0.000> 5000 <sil=0.000> being <sil=0.000> written <sil=0.000> inside <sil=0.000> this <sil=0.000> location <sil=0.228> ?QUESTIONMARK 
The <sil=0.000> statement <sil=0.000> is <sil=0.000> just <sil=0.000> like <sil=0.000> any <sil=0.000> other <sil=0.000> assignment <sil=2.000> .PERIOD  It <sil=0.000> will <sil=0.000> be <sil=0.000> that <sil=0.000> these <sil=0.000> variables <sil=0.000> name <sil=0.000> is <sil=0.000> p <sil=1.000> ,COMMA  p <sil=0.000> is
assigned <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> x y <sil=0.000> z <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  p <sil=0.000> assigned <sil=0.000> and <sil=0.000> x y <sil=0.000> z <sil=2.000> .PERIOD 

Here <sil=0.000> we <sil=0.000> can <sil=0.000> see <sil=0.000> that <sil=0.000> the <sil=0.000> variable <sil=0.000> x y <sil=0.000> z is <sil=0.000> the <sil=0.000> address <sil=0.000> is <sil=0.000> 1380 <sil=0.000> value <sil=0.000> is <sil=0.000> 50 <sil=2.000> .PERIOD  P <sil=0.000> is <sil=0.000> a pointer <sil=0.000> variable
whose <sil=0.000> value <sil=0.000> is <sil=0.000> 1380 <sil=0.000> because <sil=0.000> it <sil=0.000> is <sil=0.000> pointing <sil=0.000> to <sil=0.000> x y <sil=0.000> z <sil=2.000> .PERIOD 

In <sil=0.000> our <sil=0.000> diagram <sil=0.000> that <sil=0.000> I was <sil=0.000> drawing <sil=0.000> by <sil=0.000> hand <sil=1.000> ,COMMA  this <sil=0.000> p was <sil=0.000> holding <sil=0.000> the <sil=0.000> value <sil=0.000> 5000 <sil=0.000> and <sil=0.000> its <sil=0.000> address
here <sil=0.000> is <sil=0.000> say <sil=0.000> 2545 <sil=1.000> ,COMMA  in <sil=0.000> my <sil=0.000> diagram <sil=0.000> it <sil=0.000> was <sil=0.000> 7000 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> a picture <sil=0.000> 1380 <sil=0.000> is <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> 50 <sil=0.000> and <sil=0.000> p which <sil=0.000> is <sil=0.000> located <sil=0.000> as <sil=0.000> 2545 <sil=0.000> is <sil=0.000> holding <sil=0.000> the <sil=0.000> address <sil=0.000> 1380 <sil=2.000> .PERIOD  Whenever <sil=0.000> you <sil=0.000> find <sil=0.000> difficulty <sil=0.000> in <sil=0.000> dealing
with <sil=0.000> pointers <sil=0.000> my <sil=0.000> suggestion <sil=0.000> to <sil=0.000> the <sil=0.000> student <sil=0.000> is <sil=0.000> to <sil=0.000> draw <sil=0.000> a piece <sil=0.000> of <sil=0.000> diagram <sil=0.000> and <sil=0.000> then <sil=0.000> make <sil=0.000> the
whole <sil=0.000> picture <sil=0.000> clear <sil=0.000> in <sil=0.000> front <sil=0.000> of <sil=0.000> you <sil=2.000> .PERIOD 

Now <sil=0.000> you <sil=0.000> know <sil=0.000> that <sil=0.000> if <sil=0.000> I put <sil=0.000> the <sil=0.000> operator <sil=0.000> and <sil=1.000> ,COMMA  ampersand <sil=0.000> immediately <sil=0.000> before <sil=0.000> the <sil=0.000> variable <sil=0.000> it <sil=0.000> will
return <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> the <sil=0.000> variable <sil=0.000> and <sil=0.000> x y <sil=0.000> z will <sil=0.000> give <sil=0.000> me <sil=0.000> the <sil=0.000> say <sil=0.000> the <sil=0.000> value <sil=0.000> 1380 <sil=1.000> ,COMMA  which <sil=0.000> is <sil=0.000> the
address <sil=0.000> of <sil=0.000> x y <sil=0.000> z <sil=2.000> .PERIOD 

The <sil=0.000> address <sil=0.000> of <sil=0.000> x y <sil=0.000> z is <sil=0.000> assigned <sil=2.000> .PERIOD  This <sil=0.000> operator  and  can <sil=0.000> be <sil=0.000> used <sil=0.000> only <sil=0.000> with <sil=0.000> a simple <sil=0.000> variable <sil=0.000> or
with <sil=0.000> an <sil=0.000> array <sil=0.000> element <sil=2.000> .PERIOD  For <sil=0.000> example  and  distance <sil=1.000> ,COMMA   and  x <sil=0.000> 0 <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  the <sil=0.000> address <sil=0.000> of <sil=0.000> the <sil=0.000> first
location <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=0.000> x and <sil=0.000> of <sil=0.000> x i <sil=0.000> minus <sil=0.000> 2 <sil=2.000> .PERIOD 

Now <sil=0.000> what <sil=0.000> is <sil=0.000> illegal <sil=0.228> ?QUESTIONMARK  This <sil=0.000> is <sil=0.000> illegal <sil=0.354> ;SEMICOLON  the <sil=0.000> reason <sil=0.000> is <sil=0.000> obvious <sil=2.000> .PERIOD  Two <sil=0.000> thirty <sil=0.000> 5 is <sil=0.000> not <sil=0.000> a variable <sil=0.000> it <sil=0.000> is <sil=0.000> a
constant <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  it <sil=0.000> does <sil=0.000> not <sil=0.000> have <sil=0.000> any <sil=0.000> fixed <sil=0.000> position <sil=0.000> in <sil=0.000> the <sil=0.000> memory <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> not <sil=0.000> a memory <sil=0.000> location <sil=0.000> therefore <sil=1.000> ,COMMA 
it <sil=0.000> does <sil=0.000> not <sil=0.000> have <sil=0.000> address <sil=0.000> so <sil=0.000> its <sil=0.000> meaningless <sil=2.000> .PERIOD  Pointing <sil=0.000> to <sil=0.000> a constant <sil=0.000> is <sil=0.000> not <sil=0.000> possible <sil=1.000> ,COMMA  I <sil=0.000> cannot <sil=0.000> say
and <sil=0.000> arr <sil=1.000> ,COMMA  because <sil=0.000> this <sil=0.000> shows <sil=0.000> that <sil=0.000> arr <sil=0.000> is <sil=0.000> a particular <sil=0.000> variable <sil=1.000> ,COMMA  but <sil=0.000> it <sil=0.000> is <sil=0.000> an <sil=0.000> array <sil=0.000> therefore <sil=0.000> I cannot
show <sil=0.000> it <sil=0.000> like <sil=0.000> this <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> just <sil=0.000> pointing <sil=0.000> at <sil=0.000> an <sil=0.000> array <sil=0.000> name <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> not <sil=0.000> pointing <sil=0.000> at <sil=0.000> the <sil=0.000> array <sil=2.000> .PERIOD 

We <sil=0.000> cannot <sil=0.000> also <sil=0.000> do <sil=0.000> this <sil=0.000> and <sil=0.000> a plus <sil=0.000> b - that <sil=0.000> is <sil=0.000> also <sil=0.000> not <sil=0.000> possible <sil=0.000> because(Refer <sil=0.000> Time: 12:19) if <sil=0.000> I
have <sil=0.000> a as <sil=0.000> some <sil=0.000> value <sil=0.000> and <sil=0.000> b has <sil=0.000> some <sil=0.000> value <sil=0.000> then <sil=0.000> I add <sil=0.000> them <sil=0.000> and <sil=0.000> it <sil=0.000> will <sil=0.000> be <sil=0.000> a value <sil=0.000> and <sil=0.000> a value
does <sil=0.000> not <sil=0.000> have <sil=0.000> any <sil=0.000> address <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> pointing <sil=0.000> at <sil=0.000> an <sil=0.000> expression <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> a quick <sil=0.000> example <sil=0.000> I think <sil=0.000> I had <sil=0.000> shown <sil=0.000> this <sil=0.000> to <sil=0.000> you <sil=0.000> earlier <sil=0.000> say <sil=0.000> I have <sil=0.000> got <sil=0.000> a number <sil=0.000> of
variables - one <sil=0.000> character <sil=1.000> ,COMMA  one <sil=0.000> double <sil=1.000> ,COMMA  floats <sil=2.000> .PERIOD  I <sil=0.000> am <sil=0.000> assigning <sil=0.000> some <sil=0.000> values <sil=0.000> to <sil=0.000> these <sil=1.000> ,COMMA  here <sil=0.000> I am
putting <sil=0.000> some <sil=0.000> values <sil=1.000> ,COMMA  and <sil=0.000> print <sil=0.000> f a <sil=0.000> particular <sil=0.000> variable  a  is <sil=0.000> stored <sil=0.000> in <sil=0.000> the <sil=0.000> address <sil=0.000> anda <sil=0.000> b is <sil=0.000> stored
in <sil=0.000> address <sil=0.000> andb <sil=1.000> ,COMMA  c <sil=0.000> is <sil=0.000> stored <sil=0.000> in <sil=0.000> address <sil=0.000> andc <sil=0.000> so <sil=0.000> and <sil=0.000> so <sil=0.000> forth <sil=0.000> therefore <sil=1.000> ,COMMA  if <sil=0.000> we <sil=0.000> run <sil=0.000> it <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> get <sil=0.000> the <sil=0.000> addresses <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  10 <sil=0.000> is <sil=0.000> stored <sil=0.000> in <sil=0.000> location <sil=0.000> so <sil=0.000> and <sil=0.000> so <sil=1.000> ,COMMA  2 <sil=2.000> .PERIOD <sil=0.000> 5 is <sil=0.000> stored <sil=0.000> in <sil=0.000> location <sil=0.000> so <sil=0.000> and <sil=0.000> so <sil=1.000> ,COMMA  all <sil=0.000> right <sil=0.228> ?QUESTIONMARK 

Now <sil=1.000> ,COMMA  here <sil=0.000> incidentally <sil=0.000> all <sil=0.000> these <sil=0.000> are <sil=0.000> contiguous <sil=0.000> locations <sil=1.000> ,COMMA  but <sil=0.000> they <sil=0.000> may <sil=0.000> not <sil=0.000> be <sil=0.000> contiguous
locations <sil=0.000> also <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  10 <sil=0.000> is <sil=0.000> stored <sil=0.000> in <sil=0.000> location <sil=1.000> ,COMMA   a  having <sil=0.000> the <sil=0.000> value <sil=0.000> 10 <sil=0.000> is <sil=0.000> stored <sil=0.000> in <sil=0.000> location <sil=0.000> so <sil=1.000> ,COMMA  and <sil=0.000> so <sil=0.000> like <sil=0.000> that <sil=0.000> it <sil=0.000> goes <sil=0.000> on <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  pointer <sil=0.000> declarations <sil=1.000> ,COMMA  when <sil=0.000> we <sil=0.000> declare <sil=0.000> some <sil=0.000> variable <sil=0.000> as <sil=0.000> a pointer <sil=1.000> ,COMMA  the <sil=0.000> typical <sil=1.000> ,COMMA  the <sil=0.000> standard
form <sil=0.000> is <sil=0.000> this <sil=2.000> .PERIOD  Data <sil=0.000> type <sil=0.000> shown <sil=0.000> in <sil=0.000> red (that <sil=0.000> is <sil=0.000> very <sil=0.000> important) and <sil=0.000> this <sil=0.000> star - this <sil=0.000> is <sil=0.000> something <sil=0.000> new
that <sil=0.000> you <sil=0.000> also <sil=0.000> saw <sil=0.000> when <sil=0.000> we <sil=0.000> were <sil=0.000> discussing <sil=0.000> call <sil=0.000> by <sil=0.000> reference <sil=1.000> ,COMMA  for <sil=0.000> example <sil=1.000> ,COMMA  int <sil=0.000> is <sil=0.000> a type <sil=0.000> star <sil=0.000> x y <sil=0.000> z x <sil=1.000> ,COMMA  what <sil=0.000> does <sil=0.000> it <sil=0.000> mean <sil=0.228> ?QUESTIONMARK  It <sil=0.000> means <sil=0.000> that <sil=0.000> x is <sil=0.000> a pointer <sil=1.000> ,COMMA  which <sil=0.000> is <sil=0.000> enabled <sil=0.000> or <sil=0.000> which <sil=0.000> is <sil=0.000> allowed <sil=0.000> to <sil=0.000> point <sil=0.000> to <sil=0.000> variables <sil=0.000> of <sil=0.000> type <sil=0.000> integer <sil=2.000> .PERIOD  Only <sil=0.000> integers <sil=0.000> can <sil=0.000> be <sil=0.000> pointed <sil=0.000> to <sil=0.000> by <sil=0.000> x <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  similarly <sil=0.000> I could <sil=0.000> have <sil=0.000> said <sil=0.000> float <sil=0.000> star <sil=0.000> p  <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  p <sil=0.000> will <sil=0.000> be <sil=0.000> a pointer <sil=1.000> ,COMMA  that <sil=0.000> can <sil=0.000> only <sil=0.000> be
pointing <sil=0.000> to <sil=0.000> floating <sil=0.000> point <sil=0.000> numbers <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  three <sil=0.000> things <sil=0.000> are <sil=0.000> specified <sil=0.000> in <sil=0.000> this <sil=0.000> disk <sil=0.000> in <sil=0.000> this <sil=0.000> declaration <sil=2.000> .PERIOD 

One <sil=0.000> is <sil=0.000> that <sil=0.000> this <sil=0.000> star <sil=0.000> tells <sil=0.000> that <sil=0.000> the <sil=0.000> variable <sil=1.000> ,COMMA  pointer <sil=0.000> name <sil=0.000> or <sil=0.000> p whatever <sil=0.000> you <sil=0.000> call <sil=0.000> it <sil=1.000> ,COMMA  is <sil=0.000> a pointer
variable <sil=1.000> ,COMMA  not <sil=0.000> a normal <sil=0.000> variable <sil=0.000> and <sil=0.000> asterisk <sil=0.000> is <sil=0.000> telling <sil=0.000> that <sil=0.000> it <sil=0.000> is <sil=0.000> a pointer <sil=0.000> variable <sil=2.000> .PERIOD  Pointer <sil=0.000> name <sil=0.000> is
a <sil=0.000> variable <sil=0.000> therefore <sil=1.000> ,COMMA  it <sil=0.000> needs <sil=0.000> a memory <sil=0.000> location <sil=0.000> and <sil=0.000> pointer <sil=0.000> name <sil=0.000> points <sil=0.000> to <sil=0.000> a variable <sil=0.000> of <sil=0.000> the
specified <sil=0.000> data <sil=0.000> type <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  these <sil=0.000> three <sil=0.000> things <sil=0.000> you <sil=0.000> must <sil=0.000> remember <sil=0.000> when <sil=0.000> you <sil=0.000> are <sil=0.000> handling <sil=0.000> with <sil=0.000> the
pointer <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> an <sil=0.000> example <sil=0.000> int <sil=0.000> star <sil=0.000> count <sil=0.000> what <sil=0.000> does <sil=0.000> it <sil=0.000> mean <sil=0.228> ?QUESTIONMARK  That <sil=0.000> means <sil=1.000> ,COMMA  count <sil=0.000> is <sil=0.000> a pointer <sil=0.000> variable <sil=2.000> .PERIOD 
Why <sil=0.000> a pointer <sil=0.000> variable <sil=0.228> ?QUESTIONMARK  Because <sil=0.000> this <sil=0.000> is <sil=0.000> preceded <sil=0.000> with <sil=0.000> the <sil=0.000> star <sil=0.000> and <sil=0.000> where <sil=0.000> can <sil=0.000> this <sil=0.000> pointer
variable <sil=0.000> point <sil=0.000> to <sil=0.228> ?QUESTIONMARK  To <sil=0.000> all <sil=0.000> data <sil=0.000> type <sil=0.000> data <sil=0.000> variables <sil=0.000> of <sil=0.000> type <sil=0.000> integer <sil=2.000> .PERIOD  Speed <sil=0.000> is <sil=0.000> again <sil=0.000> a pointer <sil=0.000> because <sil=0.000> it <sil=0.000> has <sil=0.000> got <sil=0.000> this <sil=0.000> asterisk <sil=0.000> and <sil=0.000> where <sil=0.000> can <sil=0.000> speed <sil=0.000> point <sil=0.000> to <sil=0.228> ?QUESTIONMARK  Speed <sil=0.000> can <sil=0.000> point <sil=0.000> to <sil=0.000> variables <sil=0.000> of <sil=0.000> type <sil=0.000> float <sil=2.000> .PERIOD 
Once <sil=0.000> a pointer <sil=0.000> variable <sil=0.000> has <sil=0.000> been <sil=0.000> declared <sil=1.000> ,COMMA  it <sil=0.000> can <sil=0.000> be <sil=0.000> made <sil=0.000> to <sil=0.000> point <sil=0.000> to <sil=0.000> a variable <sil=0.000> using <sil=0.000> an
assignment <sil=0.000> statement <sil=0.000> like <sil=0.000> this - int <sil=0.000> star <sil=0.000> p x <sil=0.000> y z <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  int <sil=0.000> star <sil=0.000> p is <sil=0.000> a pointer <sil=0.000> variable <sil=1.000> ,COMMA  x <sil=0.000> y z <sil=0.000> is <sil=0.000> an <sil=0.000> integer <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you <sil=0.000> see <sil=0.000> by <sil=0.000> the <sil=0.000> same <sil=0.000> declaration <sil=0.000> I have <sil=0.000> declared <sil=0.000> two <sil=0.000> things - one <sil=0.000> is <sil=0.000> a pointer <sil=0.000> to <sil=0.000> an <sil=0.000> integer <sil=0.000> and <sil=0.000> an <sil=0.000> integer <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> I make <sil=0.000> such <sil=0.000> an
assignment <sil=0.000> like <sil=0.000> p is <sil=0.000> assigned <sil=0.000> and <sil=0.000> x y <sil=0.000> z <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  x <sil=0.000> y z <sil=0.000> is <sil=0.000> here <sil=0.000> and <sil=0.000> its <sil=0.000> location <sil=0.000> can <sil=0.000> be <sil=0.000> 5000 <sil=0.000> and <sil=0.000> p is <sil=0.000> a
pointer <sil=0.000> variable <sil=0.000> and <sil=0.000> so <sil=0.000> when <sil=0.000> I do <sil=0.000> this <sil=0.000> assignment <sil=1.000> ,COMMA  this <sil=0.000> might <sil=0.000> be <sil=0.000> in <sil=0.000> the <sil=0.000> location <sil=0.000> 7000 <sil=1.000> ,COMMA  but <sil=0.000> when <sil=0.000> I
do <sil=0.000> this <sil=0.000> what <sil=0.000> it <sil=0.000> does <sil=0.000> is <sil=0.000> it <sil=0.000> loads <sil=0.000> this <sil=0.000> 5000 <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  p <sil=0.000> is <sil=0.000> pointing <sil=0.000> to <sil=0.000> x y <sil=0.000> z <sil=2.000> .PERIOD  I <sil=0.000> hope <sil=0.000> it <sil=0.000> is <sil=0.000> clear
now <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> called <sil=0.000> pointer <sil=0.000> initialisation <sil=2.000> .PERIOD 

The <sil=0.000> things <sil=0.000> to <sil=0.000> remember <sil=0.000> is <sil=0.000> the <sil=0.000> pointer <sil=0.000> variables <sil=0.000> must <sil=0.000> always <sil=0.000> point <sil=0.000> to <sil=0.000> an <sil=0.000> item <sil=0.000> of <sil=0.000> the <sil=0.000> same <sil=0.000> type <sil=2.000> .PERIOD 
One <sil=0.000> pointer <sil=0.000> variable <sil=1.000> ,COMMA  either <sil=0.000> it <sil=0.000> points <sil=0.000> to <sil=0.000> an <sil=0.000> integer <sil=0.000> or <sil=0.000> it <sil=0.000> points <sil=0.000> to <sil=0.000> a float <sil=0.000> or <sil=0.000> it <sil=0.000> points <sil=0.000> to <sil=0.000> an <sil=0.000> array <sil=0.000> of
characters <sil=0.000> whatever <sil=0.000> it <sil=0.000> is <sil=2.000> .PERIOD 

Now <sil=0.000> so <sil=1.000> ,COMMA  here <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> an <sil=0.000> error <sil=1.000> ,COMMA  why <sil=0.000> it <sil=0.000> is <sil=0.000> this <sil=0.000> is <sil=0.000> an <sil=0.000> error <sil=0.228> ?QUESTIONMARK  X <sil=0.000> is <sil=0.000> of <sil=0.000> type <sil=0.000> floating <sil=0.000> point <sil=1.000> ,COMMA  x
is <sil=0.000> a variable <sil=0.000> and <sil=0.000> p is <sil=0.000> a pointer <sil=0.000> which <sil=0.000> is <sil=0.000> allowed <sil=0.000> to <sil=0.000> point <sil=0.000> to <sil=0.000> only <sil=0.000> integer <sil=1.000> ,COMMA  but <sil=0.000> here <sil=0.000> I have <sil=0.000> made <sil=0.000> an
assignment <sil=0.000> where <sil=0.000> I am <sil=0.000> assigning <sil=0.000> to <sil=0.000> p <sil=1.000> ,COMMA  the <sil=0.000> address <sil=0.000> of <sil=0.000> the <sil=0.000> floating <sil=0.000> point <sil=0.000> number - that <sil=0.000> is <sil=0.000> not
allowed <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  therefore <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> forcing <sil=0.000> p to <sil=0.000> point <sil=0.000> to <sil=0.000> x <sil=1.000> ,COMMA  but <sil=0.000> the <sil=0.000> type <sil=0.000> of <sil=0.000> p and <sil=0.000> the <sil=0.000> type <sil=0.000> of <sil=0.000> x are <sil=0.000> different <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
assigning <sil=0.000> an <sil=0.000> absolute <sil=0.000> address <sil=0.000> to <sil=0.000> a pointer <sil=0.000> is <sil=0.000> prohibited <sil=2.000> .PERIOD  You <sil=0.000> cannot <sil=0.000> do <sil=0.000> this <sil=1.000> ,COMMA  you <sil=0.000> cannot <sil=0.000> force <sil=0.000> a
pointer <sil=0.000> to <sil=0.000> a constant <sil=0.000> value <sil=1.000> ,COMMA  that <sil=0.000> you <sil=0.000> must <sil=0.000> keep <sil=0.000> in <sil=0.000> mind <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  how <sil=0.000> do <sil=0.000> I access <sil=0.000> a variable <sil=0.000> through <sil=0.000> a pointer <sil=0.228> ?QUESTIONMARK  Once <sil=0.000> a pointer <sil=0.000> has <sil=0.000> been <sil=0.000> assigned <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> a variable <sil=1.000> ,COMMA  the <sil=0.000> value <sil=0.000> of <sil=0.000> the <sil=0.000> variable <sil=0.000> can <sil=0.000> be <sil=0.000> accessed <sil=0.000> through <sil=0.000> the <sil=0.000> indirection <sil=0.000> operation <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> give <sil=0.000> an <sil=0.000> example <sil=0.000> first <sil=2.000> .PERIOD 

For <sil=0.000> example <sil=1.000> ,COMMA  a <sil=0.000> b are <sil=0.000> two <sil=0.000> integers <sil=2.000> .PERIOD  Let <sil=0.000> us <sil=0.000> draw <sil=0.000> this <sil=0.000> I am <sil=0.000> sorry <sil=1.000> ,COMMA  suppose <sil=0.000> a is <sil=0.000> a location <sil=1.000> ,COMMA  b <sil=0.000> is
another <sil=0.000> location <sil=1.000> ,COMMA  both <sil=0.000> of <sil=0.000> them <sil=0.000> are <sil=0.000> integers <sil=0.000> and <sil=0.000> p is <sil=0.000> a variable <sil=1.000> ,COMMA  which <sil=0.000> is <sil=0.000> allowed <sil=0.000> to <sil=0.000> point <sil=0.000> to

integers <sil=0.000> and <sil=0.000> what <sil=0.000> I do <sil=0.228> ?QUESTIONMARK  I <sil=0.000> assign <sil=0.000> to <sil=0.000> p the <sil=0.000> address <sil=0.000> of <sil=0.000> a <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> address <sil=0.000> of  a  let <sil=0.000> us <sil=0.000> say <sil=0.000> is <sil=0.000> 1000 <sil=0.000> or <sil=0.000> 100 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  100 <sil=0.000> is <sil=0.000> written <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> comes <sil=0.000> here <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  what <sil=0.000> did <sil=0.000> this <sil=0.000> statement <sil=0.000> do <sil=0.228> ?QUESTIONMARK  100 <sil=0.000> was <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> a <sil=1.000> ,COMMA  that <sil=0.000> has <sil=0.000> been <sil=0.000> assigned <sil=0.000> to <sil=0.000> p <sil=2.000> .PERIOD  Now <sil=0.000> what <sil=0.000> is <sil=0.000> being <sil=0.000> done <sil=0.000> by <sil=0.000> this <sil=0.228> ?QUESTIONMARK  B <sil=0.000> is <sil=0.000> being <sil=0.000> assigned <sil=0.000> star <sil=0.000> p <sil=0.354> ;SEMICOLON  b <sil=0.000> is <sil=0.000> getting <sil=0.000> the <sil=0.000> content <sil=0.000> of <sil=0.000> wherever <sil=0.000> p is
pointing <sil=2.000> .PERIOD  Suppose <sil=0.000> this <sil=0.000> was <sil=0.000> 50 <sil=1.000> ,COMMA  then <sil=0.000> b is <sil=0.000> getting <sil=0.000> 50 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  little <sil=0.000> bit <sil=0.000> of <sil=0.000> confusion <sil=0.000> can <sil=0.000> occur <sil=0.000> because
of <sil=0.000> these <sil=0.000> two <sil=0.000> star <sil=0.000> ps <sil=2.000> .PERIOD  Please <sil=0.000> understand <sil=0.000> that <sil=0.000> this <sil=0.000> star <sil=0.000> is <sil=0.000> just <sil=0.000> telling <sil=0.000> you <sil=0.000> that <sil=0.000> p is <sil=0.000> a pointer <sil=0.000> because <sil=0.000> it <sil=0.000> is <sil=0.000> coming <sil=0.000> in <sil=0.000> a declaration <sil=0.000> statement <sil=2.000> .PERIOD  On <sil=0.000> the <sil=0.000> other <sil=0.000> hand <sil=0.000> here <sil=0.000> it s <sil=0.000> is <sil=0.000> not <sil=0.000> a declaration <sil=0.000> statement <sil=0.000> is <sil=0.000> an <sil=0.000> assignment <sil=0.000> statement <sil=2.000> .PERIOD  I <sil=0.000> have <sil=0.000> already <sil=0.000> declared <sil=0.000> p to <sil=0.000> be <sil=0.000> a pointer <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  p <sil=0.000> is <sil=0.000> a pointer <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  once <sil=0.000> a pointer <sil=0.000> has <sil=0.000> been <sil=0.000> assigned <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> a variable <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> done <sil=0.000> in <sil=0.000> this <sil=0.000> step <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> the <sil=0.000> variable <sil=0.000> can <sil=0.000> be <sil=0.000> accessed <sil=0.000> using <sil=0.000> the <sil=0.000> indirection <sil=0.000> operation <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  which <sil=0.000> variable <sil=0.000> say <sil=0.000> I could <sil=0.000> have <sil=0.000> done <sil=0.000> p assigned <sil=0.000> b assigned <sil=0.000> a <sil=2.000> .PERIOD  Instead <sil=0.000> of <sil=0.000> doing <sil=0.000> that <sil=0.000> what <sil=0.000> I am <sil=0.000> saying <sil=0.000> is (just <sil=0.000> note <sil=0.000> my <sil=0.000> two <sil=0.000> English <sil=0.000> statements) one <sil=0.000> is <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> a is <sil=0.000> being <sil=0.000> assigned <sil=0.000> to <sil=0.000> b or <sil=0.000> b is <sil=0.000> being <sil=0.000> assigned <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> a this <sil=0.000> is <sil=0.000> statement <sil=0.000> number <sil=0.000> 1 <sil=0.354> ;SEMICOLON  statement <sil=0.000> number <sil=0.000> 2 is <sil=0.000> b is <sil=0.000> being <sil=0.000> assigned <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> the <sil=0.000> variable <sil=0.000> that <sil=0.000> is <sil=0.000> being <sil=0.000> pointed <sil=0.000> at <sil=0.000> by <sil=0.000> p  <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> one <sil=0.000> is <sil=0.000> b is <sil=0.000> assigned <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> a <sil=0.354> ;SEMICOLON  one <sil=0.000> statement <sil=2.000> .PERIOD  Here <sil=0.000> that <sil=0.000> is <sil=0.000> this <sil=0.000> statement <sil=2.000> .PERIOD  And <sil=0.000> this
statement <sil=0.000> is <sil=0.000> b is <sil=0.000> assigned <sil=0.000> the <sil=0.000> value (instead  of  a <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> saying <sil=0.000> is <sil=0.000> being <sil=0.000> assigned <sil=0.000> the <sil=0.000> value) of <sil=0.000> the <sil=0.000> variable <sil=0.000> pointed <sil=0.000> by <sil=0.000> p <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> an <sil=0.000> indirect <sil=0.000> way <sil=0.000> of <sil=0.000> saying <sil=0.000> that <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> something <sil=0.000> that <sil=0.000> you <sil=0.000> must <sil=0.000> very <sil=0.000> clearly
understand <sil=1.000> ,COMMA <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=0.000> once <sil=0.000> again <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> now <sil=0.000> say <sil=0.000> that <sil=0.000> this <sil=0.000> thing <sil=0.000> is <sil=0.000> equivalent <sil=0.000> to <sil=0.000> b assigned <sil=0.000> a <sil=1.000> ,COMMA  but <sil=0.000> I have <sil=0.000> done <sil=0.000> that <sil=0.000> in <sil=0.000> a indirect
way <sil=2.000> .PERIOD 

If <sil=0.000> you <sil=0.000> have <sil=0.000> understood <sil=0.000> this <sil=0.000> then <sil=0.000> pointer <sil=0.000> should <sil=0.000> be <sil=0.000> clear <sil=0.000> to <sil=0.000> you <sil=1.000> ,COMMA  here <sil=0.000> lets <sil=0.000> look <sil=0.000> at <sil=0.000> one <sil=0.000> example
integer <sil=0.000> a b <sil=0.000> c assign <sil=0.000> 5 and <sil=0.000> p is <sil=0.000> a pointer <sil=0.000> to <sil=0.000> integers <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  in <sil=0.000> this <sil=0.000> statement <sil=0.000> what <sil=0.000> has <sil=0.000> been <sil=0.000> done <sil=0.228> ?QUESTIONMARK 

 a  has <sil=0.000> being <sil=0.000> assigned <sil=0.000> 4 times <sil=0.000> c plus <sil=0.000> 5 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  c <sil=0.000> is <sil=0.000> being <sil=0.000> added <sil=0.000> to <sil=0.000> 5 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> becoming <sil=0.000> 10 <sil=0.000> and <sil=0.000> 4
times <sil=0.000> 10 <sil=0.000> is <sil=0.000> 40 <sil=1.000> ,COMMA  40 <sil=0.000> is <sil=0.000> being <sil=0.000> assigned <sil=0.000> to <sil=0.000> a <sil=2.000> .PERIOD  Here <sil=0.000> what <sil=0.000> is <sil=0.000> being <sil=0.000> done <sil=0.228> ?QUESTIONMARK  P <sil=0.000> is <sil=0.000> being <sil=0.000> assigned <sil=1.000> ,COMMA  c <sil=0.000> is
address <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  wherever <sil=0.000> c was <sil=0.000> let s <sil=0.000> say <sil=0.000> address <sil=0.000> 1000 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> being <sil=0.000> assigned <sil=0.000> to <sil=0.000> a variable <sil=0.000> p <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  p <sil=0.000> is <sil=0.000> becoming <sil=0.000> 1000 <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  b <sil=0.000> what <sil=0.000> is <sil=0.000> b being <sil=0.000> assigned <sil=0.228> ?QUESTIONMARK  b <sil=0.000> is <sil=0.000> being <sil=0.000> assigned <sil=0.000> 4 times <sil=0.000> star <sil=0.000> p plus <sil=0.000> 5 <sil=2.000> .PERIOD  What <sil=0.000> is <sil=0.000> star <sil=0.000> p <sil=0.228> ?QUESTIONMARK  Star <sil=0.000> p is <sil=0.000> nothing <sil=1.000> ,COMMA  but <sil=0.000> the <sil=0.000> variable <sil=0.000> c <sil=1.000> ,COMMA  it s <sil=0.000> pointing <sil=0.000> to <sil=0.000> that <sil=0.000> and <sil=0.000> whatever <sil=0.000> was <sil=0.000> its <sil=0.000> value <sil=0.000> suppose <sil=0.000> it <sil=0.000> was <sil=0.000> 10 <sil=1.000> ,COMMA  it <sil=0.000> was <sil=0.000> sorry <sil=0.000> it <sil=0.000> was <sil=0.000> 5 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> value <sil=0.000> is <sil=0.000> being <sil=0.000> taken <sil=0.000> and <sil=0.000> 5 is <sil=0.000> being <sil=0.000> added <sil=0.000> to <sil=0.000> that <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> becomes <sil=0.000> 10 <sil=0.000> times <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  these <sil=0.000> two <sil=0.000> are <sil=0.000> essentially <sil=0.000> equivalent <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> another <sil=0.000> example <sil=1.000> ,COMMA  you <sil=0.000> have <sil=0.000> seen <sil=0.000> this <sil=0.000> example <sil=0.000> very <sil=0.000> similar <sil=0.000> to <sil=0.000> this <sil=0.000> that <sil=0.000> I am <sil=0.000> defining <sil=0.000> a
pointer <sil=1.000> ,COMMA  p <sil=0.000> t r <sil=0.000> is <sil=0.000> a pointer <sil=1.000> ,COMMA  x <sil=0.000> is <sil=0.000> 10 <sil=1.000> ,COMMA  you <sil=0.000> just <sil=0.000> think <sil=0.000> of <sil=0.000> what <sil=0.000> it <sil=0.000> should <sil=0.000> print <sil=0.228> ?QUESTIONMARK  X <sil=0.000> is <sil=0.000> 10 <sil=1.000> ,COMMA  p <sil=0.000> t r <sil=0.000> is <sil=0.000> the
address <sil=0.000> of <sil=0.000> x and <sil=0.000> y is <sil=0.000> being <sil=0.000> assigned <sil=0.000> star <sil=0.000> p t <sil=0.000> r <sil=1.000> ,COMMA  what <sil=0.000> does <sil=0.000> this <sil=0.000> mean <sil=0.228> ?QUESTIONMARK  P <sil=0.000> t r <sil=0.000> is <sil=0.000> pointing <sil=0.000> to <sil=0.000> 10 <sil=0.000> and <sil=0.000> y
is <sil=0.000> being <sil=0.000> assigned <sil=0.000> to <sil=0.000> star <sil=0.000> p t <sil=0.000> r <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  y <sil=0.000> is <sil=0.000> being <sil=0.000> assigned <sil=0.000> to <sil=0.000> 10 <sil=0.000> or <sil=0.000> rather <sil=0.000> I should <sil=0.000> say <sil=0.000> y is
being <sil=0.000> assigned <sil=0.000> x and <sil=0.000> x was <sil=0.000> 10 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  y <sil=0.000> is <sil=0.000> become <sil=0.000> becoming <sil=0.000> 10 <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  if <sil=0.000> I print <sil=1.000> ,COMMA  instead <sil=0.000> of <sil=0.000> x what <sil=0.000> will <sil=0.000> be <sil=0.000> printed <sil=0.228> ?QUESTIONMARK  Instead <sil=0.000> of <sil=0.000> x the <sil=1.000> ,COMMA  value <sil=0.000> of <sil=0.000> x will <sil=0.000> be <sil=0.000> printed <sil=2.000> .PERIOD <sil=0.000> 10 <sil=0.000> is
stored <sil=0.000> in <sil=0.000> the <sil=0.000> address <sil=0.000> this <sil=2.000> .PERIOD  Similarly <sil=0.000> now <sil=0.000> what <sil=0.000> is <sil=0.000> this <sil=0.228> ?QUESTIONMARK   star <sil=0.000> and <sil=0.000> x  - what <sil=0.000> does <sil=0.000> this <sil=0.000> mean <sil=0.228> ?QUESTIONMARK   and <sil=0.000> x 
is <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> x and <sil=0.000> where <sil=0.000> that <sil=0.000> is <sil=0.000> pointing <sil=0.000> to - these <sil=0.000> two <sil=0.000> should <sil=0.000> be <sil=0.000> same <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  if <sil=0.000> you <sil=0.000> look <sil=0.000> at <sil=0.000> if <sil=0.000> you <sil=0.000> look <sil=0.000> at <sil=0.000> the <sil=0.000> result - this <sil=0.000> is <sil=0.000> equivalent <sil=0.000> why <sil=0.228> ?QUESTIONMARK   And <sil=0.000> x  is <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> x
and <sil=0.000> star <sil=0.000> just <sil=0.000> like <sil=0.000> star <sil=0.000> p <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  the <sil=0.000> content <sil=0.000> of <sil=0.000> where <sil=0.000> the <sil=0.000> pointer <sil=0.000> is <sil=0.000> pointing <sil=0.000> to <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  these <sil=0.000> two <sil=0.000> are <sil=0.000> same <sil=0.000> right <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  ptr <sil=0.000> is  and <sil=0.000> x  <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  these <sil=0.000> two <sil=0.000> are <sil=0.000> all <sil=0.000> equivalent <sil=0.000> ok <sil=2.000> .PERIOD  If <sil=0.000> I say  and <sil=0.000> x   <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> taking <sil=0.000> the
address <sil=0.000> of <sil=0.000> star <sil=0.000> ptr <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> something <sil=0.000> you <sil=0.000> can <sil=0.000> play <sil=0.000> with <sil=0.000> yourself <sil=0.000> and <sil=0.000> you <sil=0.000> will <sil=0.000> get <sil=0.000> a printout <sil=0.000> like <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  these
two <sil=0.000> are <sil=0.000> the <sil=0.000> same <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  here <sil=0.000> we <sil=0.000> are <sil=0.000> coming <sil=0.000> to <sil=0.000> something <sil=0.000> more <sil=0.000> which <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> pointer <sil=0.000> expressions <sil=0.000> and <sil=0.000> we <sil=0.000> will
deal <sil=0.000> with <sil=0.000> that <sil=0.000> in <sil=0.000> the <sil=0.000> next <sil=0.000> lecture <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  we <sil=0.000> were <sil=0.000> discussing <sil=0.000> about <sil=0.000> pointers <sil=0.000> and <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=0.000> that <sil=0.000> pointer <sil=0.000> is <sil=0.000> a variable <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> a
variable <sil=1.000> ,COMMA  but <sil=0.000> a variable <sil=0.000> that <sil=0.000> points <sil=0.000> to <sil=0.000> some <sil=0.000> other <sil=0.000> variable <sil=1.000> ,COMMA  but <sil=0.000> naturally <sil=0.000> the <sil=0.000> question <sil=0.000> that <sil=0.000> can <sil=0.000> arise <sil=0.000> is <sil=0.000> since <sil=0.000> pointers <sil=0.000> are <sil=0.000> variables <sil=0.000> so <sil=1.000> ,COMMA  you <sil=0.000> should <sil=0.000> be <sil=0.000> able <sil=0.000> to <sil=0.000> do <sil=0.000> some <sil=0.000> sort <sil=0.000> of <sil=0.000> operations <sil=0.000> like <sil=0.000> arithmetic <sil=0.000> operations <sil=0.000> on <sil=0.000> them <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> answer <sil=0.000> is <sil=0.000> yes <sil=0.000> we <sil=0.000> can <sil=0.000> do <sil=0.000> that <sil=0.000> and <sil=0.000> in <sil=0.000> today s <sil=0.000> lecture <sil=0.000> we <sil=0.000> will <sil=0.000> look <sil=0.000> at <sil=0.000> exactly <sil=0.000> that - pointer <sil=0.000> expressions <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  this <sil=0.000> concept <sil=0.000> of <sil=0.000> pointers <sil=0.000> is <sil=0.000> a very <sil=0.000> strong <sil=0.000> component <sil=0.000> of <sil=0.000> the <sil=0.000> c language <sil=0.000> and <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> the <sil=0.000> case
that <sil=0.000> in <sil=0.000> all <sil=0.000> languages <sil=0.000> this <sil=0.000> pointer <sil=0.000> is <sil=0.000> there <sil=1.000> ,COMMA  but <sil=0.000> we <sil=0.000> are <sil=0.000> discussing <sil=0.000> pointers <sil=0.000> specifically <sil=1.000> ,COMMA  because <sil=0.000> it
will <sil=0.000> give <sil=0.000> you <sil=0.000> a very <sil=0.000> good <sil=0.000> idea <sil=0.000> about <sil=0.000> what <sil=0.000> indirection <sil=0.000> is <sil=2.000> .PERIOD  We <sil=0.000> had <sil=0.000> mentioned <sil=0.000> about <sil=0.000> indirection
right <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  for <sil=0.000> example <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> just <sil=0.000> before <sil=0.000> moving <sil=0.000> into <sil=0.000> the <sil=0.000> actual <sil=0.000> discussion <sil=1.000> ,COMMA  let <sil=0.000> me <sil=0.000> come <sil=0.000> to <sil=0.000> this <sil=0.000> that -
what <sil=0.000> is <sil=0.000> an <sil=0.000> indirection  <sil=0.228> ?QUESTIONMARK 

Somebody <sil=0.000> asks <sil=0.000> you <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> toms <sil=0.000> house <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> do <sil=0.000> two <sil=0.000> things - you <sil=0.000> can <sil=0.000> either <sil=0.000> give <sil=0.000> him
the <sil=0.000> address <sil=0.000> of <sil=0.000> toms <sil=0.000> house <sil=0.000> or <sil=0.000> you <sil=0.000> can <sil=0.000> give <sil=0.000> him <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> johns <sil=0.000> house <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> he <sil=0.000> goes <sil=0.000> to
johns <sil=0.000> house <sil=0.000> and <sil=0.000> asks <sil=0.000> john <sil=0.000> to <sil=0.000> get <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> toms <sil=0.000> house <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> do <sil=0.000> not <sil=0.000> know <sil=0.000> toms <sil=0.000> address <sil=1.000> ,COMMA  but <sil=0.000> I
know <sil=0.000> john <sil=0.000> who <sil=0.000> knows <sil=0.000> toms <sil=0.000> address <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> indirection - one <sil=0.000> level <sil=0.000> of <sil=0.000> indirection <sil=2.000> .PERIOD 

Another <sil=0.000> level <sil=0.000> of <sil=0.000> indirection <sil=0.000> could <sil=0.000> be <sil=0.000> that (second <sil=0.000> level <sil=0.000> of <sil=0.000> indirection) <sil=2.000> .PERIOD  You <sil=0.000> can <sil=0.000> go <sil=0.000> to <sil=0.000> ram <sil=0.000> and
ram <sil=0.000> will <sil=0.000> know <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> john <sil=0.000> who <sil=0.000> knows <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> tom <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> second <sil=0.000> level <sil=0.000> of
indirection <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  in <sil=0.000> our <sil=0.000> case <sil=0.000> we <sil=0.000> have <sil=0.000> got <sil=0.000> a particular <sil=0.000> variable <sil=0.000> p <sil=1.000> ,COMMA  let <sil=0.000> me <sil=0.000> just <sil=0.000> call <sil=0.000> this <sil=0.000> variable <sil=0.000> x <sil=1.000> ,COMMA 
and <sil=0.000> that <sil=0.000> x has <sil=0.000> got <sil=0.000> some <sil=0.000> value <sil=2.000> .PERIOD  I <sil=0.000> am <sil=0.000> not <sil=0.000> saying <sil=0.000> that <sil=0.000> x has <sil=0.000> also <sil=0.000> got <sil=0.000> an <sil=0.000> address <sil=2.000> .PERIOD 

But <sil=0.000> I am <sil=0.000> not <sil=0.000> saying <sil=0.000> what <sil=0.000> is <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> x <sil=0.228> ?QUESTIONMARK  What <sil=0.000> is <sil=0.000> x <sil=0.228> ?QUESTIONMARK  That <sil=0.000> is <sil=0.000> my <sil=0.000> question <sil=0.000> and <sil=0.000> instead <sil=0.000> of
answering <sil=0.000> that <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> giving <sil=0.000> you <sil=0.000> a pointer <sil=0.000> to <sil=0.000> x and <sil=0.000> I am <sil=0.000> asking <sil=0.000> that <sil=0.000> ok <sil=0.000> I tell <sil=0.000> you <sil=0.000> I will <sil=0.000> give <sil=0.000> you
the <sil=0.000> answer <sil=1.000> ,COMMA  go <sil=0.000> to <sil=0.000> p and <sil=0.000> find <sil=0.000> x right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  then <sil=0.000> p must <sil=0.000> be <sil=0.000> assigned <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> x <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> go <sil=0.000> to <sil=0.000> this <sil=1.000> ,COMMA  then <sil=0.000> I come <sil=0.000> to <sil=0.000> p and <sil=0.000> get <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> x as <sil=0.000> I want <sil=0.000> to <sil=0.000> have <sil=0.000> that <sil=0.000> in <sil=0.000> some <sil=0.000> other <sil=0.000> variable <sil=0.000> v <sil=1.000> ,COMMA  where <sil=0.000> I want <sil=0.000> to <sil=0.000> have <sil=0.000> star <sil=0.000> p <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  indirectly <sil=0.000> I could <sil=0.000> have <sil=0.000> done <sil=0.000> simply - v <sil=0.000> assigned <sil=0.000> x <sil=2.000> .PERIOD  These <sil=0.000> two <sil=0.000> are <sil=0.000> equivalent <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> what <sil=0.000> we
discussed <sil=0.000> in <sil=0.000> the <sil=0.000> last <sil=0.000> class <sil=0.000> right <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> why <sil=0.000> it <sil=0.000> is <sil=0.000> an <sil=0.000> indirection <sil=0.000> that <sil=0.000> often <sil=0.000> comes <sil=0.000> in <sil=0.000> very <sil=0.000> handy <sil=1.000> ,COMMA 
very <sil=0.000> useful <sil=1.000> ,COMMA  when <sil=0.000> we <sil=0.000> carry <sil=0.000> out <sil=0.000> many <sil=0.000> computations <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  like <sil=0.000> other <sil=0.000> variables <sil=0.000> pointer <sil=0.000> variables <sil=0.000> can <sil=0.000> also <sil=0.000> be <sil=0.000> used <sil=0.000> in <sil=0.000> expressions <sil=2.000> .PERIOD  If <sil=0.000> p 1 <sil=0.000> and <sil=0.000> p 2 <sil=0.000> are <sil=0.000> two
pointers <sil=0.000> the <sil=0.000> following <sil=0.000> statements <sil=0.000> are <sil=0.000> valid - star <sil=0.000> p 1 <sil=0.000> plus <sil=0.000> star <sil=0.000> p 2 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> being <sil=0.000> meant <sil=0.000> by
that <sil=0.228> ?QUESTIONMARK  Suppose <sil=0.000> p 1 <sil=0.000> is <sil=0.000> pointing <sil=0.000> to <sil=0.000> something <sil=1.000> ,COMMA  where <sil=0.000> there <sil=0.000> is <sil=0.000> 50 <sil=0.000> and <sil=0.000> p 2 <sil=0.000> is <sil=0.000> pointing <sil=0.000> to <sil=0.000> something
which <sil=0.000> is <sil=0.000> stored <sil=0.000> as <sil=0.000> 60 - then <sil=0.000> what <sil=0.000> is <sil=0.000> sum <sil=0.228> ?QUESTIONMARK  Sum <sil=0.000> becomes <sil=0.000> 50 <sil=0.000> plus <sil=0.000> 60 <sil=1.000> ,COMMA  star <sil=0.000> p 1 <sil=0.000> plus <sil=0.000> star <sil=0.000> p 2 <sil=1.000> ,COMMA  50 <sil=0.000> plus <sil=0.000> 60 <sil=0.000> so <sil=1.000> ,COMMA  that <sil=0.000> should <sil=0.000> be <sil=0.000> 110 <sil=2.000> .PERIOD 

Next <sil=0.000> similarly <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> have <sil=0.000> this <sil=2.000> .PERIOD  But <sil=0.000> here <sil=0.000> it <sil=0.000> would <sil=0.000> be <sil=0.000> easier <sil=0.000> nicer <sil=0.000> to <sil=0.000> read <sil=1.000> ,COMMA  if <sil=0.000> I had <sil=0.000> put <sil=0.000> parentheses <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  that <sil=0.000> I had <sil=0.000> not <sil=0.000> confused <sil=0.000> about <sil=0.000> this <sil=0.000> Asterix <sil=0.000> and <sil=0.000> this <sil=0.000> Asterix <sil=2.000> .PERIOD  These <sil=0.000> have <sil=0.000> got <sil=0.000> completely
different <sil=0.000> significances <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> a multiplication <sil=0.000> and <sil=0.000> this <sil=0.000> astrix <sil=0.000> is <sil=0.000> saying <sil=0.000> it <sil=0.000> is <sil=0.000> a content <sil=0.000> of <sil=0.000> a
particular <sil=0.000> pointer <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  similarly <sil=0.000> the <sil=0.000> these <sil=0.000> two <sil=0.000> are <sil=0.000> equivalent <sil=0.000> of <sil=0.000> course <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> already <sil=0.000> shown <sil=0.000> that <sil=2.000> .PERIOD  Now <sil=0.000> this <sil=0.000> is <sil=0.000> also
possible <sil=0.000> star <sil=0.000> p 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  in <sil=0.000> my <sil=0.000> earlier <sil=0.000> drawing <sil=0.000> p 1 <sil=0.000> was <sil=0.000> 50 <sil=1.000> ,COMMA  50 <sil=0.000> plus <sil=0.000> 2 - that <sil=0.000> is <sil=0.000> coming <sil=0.000> over <sil=0.000> here <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA <sil=0.000> whenever <sil=0.000> you <sil=0.000> are <sil=0.000> finding <sil=0.000> difficulty <sil=0.000> as <sil=0.000> I suggested <sil=0.000> just <sil=0.000> draw <sil=0.000> a simple <sil=0.000> diagram <sil=0.354> ;SEMICOLON  p <sil=0.000> 1 is <sil=0.000> pointing
to <sil=0.000> some <sil=0.000> other <sil=0.000> variable <sil=0.000> which <sil=0.000> has <sil=0.000> got <sil=0.000> the <sil=0.000> value <sil=0.000> 40 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  star <sil=0.000> p 1 <sil=0.000> is <sil=0.000> what <sil=0.228> ?QUESTIONMARK  Star <sil=0.000> p 1 <sil=0.000> is <sil=0.000> that <sil=0.000> particular - variable <sil=0.000> x and <sil=0.000> plus <sil=0.000> 2 that <sil=0.000> is <sil=0.000> equivalent <sil=0.000> to <sil=0.000> x plus <sil=0.000> 2 which <sil=0.000> is <sil=0.000> 42 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> one <sil=0.000> is <sil=0.000> being <sil=0.000> modified <sil=0.000> to <sil=0.000> 42 <sil=2.000> .PERIOD 

Similarly <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> do <sil=0.000> other <sil=0.000> operations <sil=0.000> like <sil=0.000> this <sil=0.000> where <sil=0.000> you <sil=0.000> must <sil=0.000> understand <sil=0.000> that <sil=0.000> this <sil=0.000> is <sil=0.000> actually <sil=0.000> just
like <sil=0.000> another <sil=0.000> variable - an <sil=0.000> integer <sil=0.000> variable <sil=0.000> or <sil=0.000> whatever <sil=0.000> type <sil=0.000> of <sil=0.000> variable <sil=0.000> p1 <sil=0.000> is <sil=0.000> and <sil=0.000> it <sil=0.000> is <sil=0.000> simple <sil=2.000> .PERIOD  No
other <sil=0.000> complications <sil=0.000> in <sil=0.000> that <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  what <sil=0.000> are <sil=0.000> allowed <sil=0.000> in <sil=0.000> C <sil=0.228> ?QUESTIONMARK  There <sil=0.000> are <sil=0.000> certain <sil=0.000> things <sil=0.000> are <sil=0.000> allowed <sil=0.000> in <sil=0.000> C and <sil=0.000> some <sil=0.000> things <sil=0.000> are <sil=0.000> not
allowed <sil=0.000> in <sil=0.000> C <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> add <sil=0.000> an <sil=0.000> integer <sil=0.000> to <sil=0.000> a pointer <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> subtract <sil=0.000> an <sil=0.000> integer <sil=0.000> from <sil=0.000> a pointer <sil=1.000> ,COMMA  I <sil=0.000> can
subtract <sil=0.000> one <sil=0.000> pointer <sil=0.000> from <sil=0.000> another <sil=0.000> and <sil=0.000> say <sil=0.000> if <sil=0.000> p 1 <sil=0.000> and <sil=0.000> p 2 <sil=0.000> are <sil=0.000> both <sil=0.000> pointers <sil=0.000> to <sil=0.000> the <sil=0.000> same <sil=0.000> array <sil=1.000> ,COMMA  then <sil=0.000> p 2 <sil=0.000> minus <sil=0.000> p 1 <sil=0.000> gives <sil=0.000> the <sil=0.000> number <sil=0.000> of <sil=0.000> elements <sil=0.000> between <sil=0.000> p 1 <sil=0.000> and <sil=0.000> p 2 <sil=2.000> .PERIOD  For <sil=0.000> example <sil=1.000> ,COMMA  suppose <sil=0.000> here <sil=0.000> there <sil=0.000> is <sil=0.000> an <sil=0.000> array <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  p <sil=0.000> 1 is <sil=0.000> pointing <sil=0.000> here <sil=0.000> and <sil=0.000> p 2 <sil=0.000> is <sil=0.000> pointing <sil=0.000> here <sil=2.000> .PERIOD  Then <sil=0.000> the <sil=0.000> number <sil=0.000> of <sil=0.000> elements <sil=0.000> p 2 <sil=0.000> minus <sil=0.000> p 1 <sil=0.000> will <sil=0.000> be <sil=0.000> just <sil=0.000> the <sil=0.000> subtraction <sil=0.000> of <sil=0.000> these <sil=0.000> addresses <sil=2.000> .PERIOD 

Suppose <sil=0.000> this <sil=0.000> was <sil=0.000> 500 <sil=1.000> ,COMMA  501 (if <sil=0.000> it <sil=0.000> is <sil=0.000> a character) 502 <sil=1.000> ,COMMA  503 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> three <sil=0.000> elements <sil=0.000> in <sil=0.000> between
right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  these <sil=0.000> are <sil=0.000> all <sil=0.000> allowed <sil=2.000> .PERIOD  I <sil=0.000> can <sil=0.000> subtract <sil=0.000> an <sil=0.000> integer <sil=0.000> from <sil=0.000> a pointer <sil=2.000> .PERIOD  I <sil=0.000> can <sil=0.000> add <sil=0.000> an <sil=0.000> integer <sil=0.000> to <sil=0.000> a
pointer <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> I add <sil=0.000> an <sil=0.000> integer <sil=0.000> to <sil=0.000> a pointer <sil=0.000> that <sil=0.000> is <sil=0.000> p 1 <sil=1.000> ,COMMA  p <sil=0.000> 1 plus <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> means <sil=0.000> it <sil=0.000> will <sil=0.000> point <sil=0.000> to
this <sil=0.000> point <sil=1.000> ,COMMA  this <sil=0.000> element <sil=2.000> .PERIOD  What <sil=0.000> are <sil=0.000> not <sil=0.000> allowed <sil=0.228> ?QUESTIONMARK  The <sil=0.000> things <sil=0.000> that <sil=0.000> are <sil=0.000> not <sil=0.000> allowed <sil=0.000> are <sil=0.000> you <sil=0.000> cannot
add <sil=0.000> two <sil=0.000> pointers <sil=2.000> .PERIOD 

The <sil=0.000> reason <sil=0.000> is <sil=0.000> obvious - p <sil=0.000> 1 is <sil=0.000> a pointer <sil=0.000> and <sil=0.000> p 2 <sil=0.000> is <sil=0.000> a pointer <sil=2.000> .PERIOD  Now <sil=0.000> these <sil=0.000> two <sil=0.000> are <sil=0.000> two <sil=0.000> different
locations <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  say <sil=0.000> p 1 <sil=0.000> is <sil=0.000> in <sil=0.000> location <sil=0.000> 7000 <sil=0.000> pointing <sil=0.000> to <sil=0.000> some <sil=0.000> variable <sil=1.000> ,COMMA  and <sil=0.000> p 2 <sil=0.000> is <sil=0.000> in <sil=0.000> location <sil=0.000> 10 <sil=1.000> ,COMMA <sil=0.000> 000
pointing <sil=0.000> to <sil=0.000> some <sil=0.000> other <sil=0.000> variable <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  what <sil=0.000> does <sil=0.000> p 1 <sil=0.000> plus <sil=0.000> p 2 <sil=0.000> mean <sil=0.228> ?QUESTIONMARK  7 <sil=1.000> ,COMMA <sil=0.000> 000 <sil=0.000> plus <sil=0.000> 10 <sil=1.000> ,COMMA <sil=0.000> 000 - 17 <sil=1.000> ,COMMA <sil=0.000> 000 <sil=0.000> that <sil=0.000> does <sil=0.000> not <sil=0.000> mean <sil=0.000> anything <sil=2.000> .PERIOD  That <sil=0.000> can <sil=0.000> be <sil=0.000> a point <sil=0.000> to <sil=0.000> some <sil=0.000> garbage <sil=0.000> value <sil=0.000> or <sil=0.000> something <sil=0.000> else <sil=0.354> ;SEMICOLON  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> not <sil=0.000> allowed <sil=2.000> .PERIOD  Compiler <sil=0.000> will <sil=0.000> hold <sil=0.000> you <sil=0.000> for <sil=0.000> that <sil=1.000> ,COMMA  multiply <sil=0.000> or <sil=0.000> divide <sil=0.000> a pointer <sil=0.000> in <sil=0.000> an <sil=0.000> expression <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> also <sil=0.000> not <sil=0.000> allowed <sil=2.000> .PERIOD  You
cannot <sil=0.000> multiply <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> just <sil=0.000> add <sil=0.000> an <sil=0.000> integer <sil=1.000> ,COMMA  subtract <sil=0.000> an <sil=0.000> integer <sil=0.000> or <sil=0.000> subtract <sil=0.000> one <sil=0.000> pointer <sil=0.000> from
another <sil=1.000> ,COMMA  these <sil=0.000> three <sil=0.000> you <sil=0.000> can <sil=0.000> do <sil=2.000> .PERIOD 

Here <sil=0.000> is <sil=0.000> something <sil=0.000> which <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> a scale <sil=0.000> factor <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> see <sil=0.000> whether <sil=0.000> you <sil=0.000> understand <sil=0.000> this <sil=0.000> or
not <sil=2.000> .PERIOD  We <sil=0.000> have <sil=0.000> seen <sil=0.000> that <sil=0.000> an <sil=0.000> integer <sil=0.000> value <sil=0.000> can <sil=0.000> be <sil=0.000> added <sil=0.000> or <sil=0.000> subtracted <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=1.000> ,COMMA  p <sil=0.000> 1 and <sil=0.000> p 2 <sil=0.000> are <sil=0.000> two <sil=0.000> pointers <sil=0.000> of <sil=0.000> type <sil=0.000> integer <sil=2.000> .PERIOD  I <sil=0.000> mean <sil=0.000> when <sil=0.000> p 1 <sil=0.000> is
pointing <sil=0.000> to <sil=0.000> an <sil=0.000> integer <sil=1.000> ,COMMA  p <sil=0.000> 2 is <sil=0.000> also <sil=0.000> pointing <sil=0.000> to <sil=0.000> an <sil=0.000> integer <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD  Now <sil=0.000> i <sil=1.000> ,COMMA <sil=0.000> j are <sil=0.000> two <sil=0.000> integer
variables <sil=2.000> .PERIOD  p <sil=0.000> 1 is <sil=0.000> p 1 <sil=0.000> plus <sil=0.000> 1 so <sil=0.000> that <sil=0.000> means <sil=0.000> what <sil=0.228> ?QUESTIONMARK  p <sil=0.000> 1 was <sil=0.000> pointing <sil=0.000> somewhere <sil=1.000> ,COMMA  but <sil=0.000> I am <sil=0.000> just <sil=0.000> adding <sil=0.000> some <sil=0.000> constant <sil=0.000> to <sil=0.000> that <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> a memory <sil=0.000> location <sil=0.000> and <sil=0.000> say <sil=0.000> p 1 <sil=0.000> is <sil=0.000> pointing <sil=0.000> to <sil=0.000> this <sil=0.000> and <sil=0.000> suppose <sil=0.000> it <sil=0.000> is <sil=0.000> an <sil=0.000> integer <sil=0.000> so <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> pointing <sil=0.000> to <sil=0.000> an <sil=0.000> integer <sil=2.000> .PERIOD  Now <sil=0.000> p 1 <sil=0.000> plus <sil=0.000> one <sil=0.000> means <sil=0.000> this <sil=0.000> will <sil=0.000> point <sil=0.000> to <sil=0.000> the <sil=0.000> next <sil=0.000> integer <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> not <sil=0.000> saying <sil=0.000> that <sil=0.000> if <sil=0.000> an <sil=0.000> integer <sil=0.000> takes <sil=0.000> two <sil=0.000> bytes <sil=0.000> each <sil=0.000> of <sil=0.000> them <sil=0.000> are <sil=0.000> of <sil=0.000> two <sil=0.000> bytes <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> just
comes <sil=0.000> to <sil=0.000> the <sil=0.000> next <sil=0.000> integer <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> why <sil=0.000> the <sil=0.000> type <sil=0.000> is <sil=0.000> important <sil=2.000> .PERIOD  Depending <sil=0.000> on <sil=0.000> the <sil=0.000> type <sil=0.000> it <sil=0.000> is <sil=0.000> updating <sil=0.000> either <sil=0.000> by <sil=0.000> 2 or <sil=0.000> by <sil=0.000> 1 <sil=1.000> ,COMMA  but <sil=0.000> p 1 <sil=0.000> plus <sil=0.000> 1 means <sil=0.000> I am <sil=0.000> going <sil=0.000> to <sil=0.000> the <sil=0.000> next <sil=2.000> .PERIOD  p <sil=0.000> 2 is <sil=0.000> assigned <sil=0.354> ;SEMICOLON  p <sil=0.000> 1 plus <sil=0.000> j where <sil=0.000> j can <sil=0.000> be <sil=0.000> something <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  p <sil=0.000> 2 was <sil=0.000> pointing <sil=0.000> somewhere <sil=0.000> here <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> upgrading <sil=0.000> that <sil=0.000> with <sil=0.000> the <sil=0.000> j value <sil=1.000> ,COMMA  going <sil=0.000> to <sil=0.000> the <sil=0.000> j th <sil=0.000> next <sil=2.000> .PERIOD 
Similarly <sil=0.000> p 2 <sil=0.000> plus <sil=0.000> plus <sil=1.000> ,COMMA  p <sil=0.000> 2 assigned <sil=0.000> any <sil=0.000> arithmetic <sil=0.000> operation <sil=0.000> I can <sil=0.000> do <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD 

In <sil=0.000> reality <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> the <sil=0.000> integer <sil=0.000> value <sil=0.000> which <sil=0.000> is <sil=0.000> added <sil=0.000> or <sil=0.000> subtracted <sil=1.000> ,COMMA  but <sil=0.000> rather <sil=0.000> the <sil=0.000> scale <sil=0.000> factor <sil=0.000> times
the <sil=0.000> value - that <sil=0.000> is <sil=0.000> one <sil=0.000> times <sil=0.000> the <sil=0.000> size <sil=0.000> of <sil=0.000> the <sil=0.000> integer <sil=0.000> if <sil=0.000> it <sil=0.000> were <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> j times <sil=0.000> the <sil=0.000> size <sil=0.000> of <sil=0.000> an
integer <sil=1.000> ,COMMA  2 <sil=0.000> bytes <sil=1.000> ,COMMA  4 <sil=0.000> bytes - that <sil=0.000> is <sil=0.000> what <sil=0.000> that <sil=0.000> is <sil=0.000> why <sil=0.000> it <sil=0.000> is <sil=0.000> called <sil=0.000> the <sil=0.000> scale <sil=0.000> factor <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> not <sil=0.000> this <sil=0.000> 1 <sil=1.000> ,COMMA  but <sil=0.000> one <sil=0.000> next <sil=1.000> ,COMMA  two <sil=0.000> next <sil=1.000> ,COMMA  here <sil=0.000> j th <sil=0.000> next <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> like <sil=0.000> that <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  for <sil=0.000> character <sil=0.000> the <sil=0.000> scale <sil=0.000> factor <sil=0.000> is <sil=0.000> 1 <sil=1.000> ,COMMA  integer <sil=0.000> is <sil=0.000> 4 <sil=1.000> ,COMMA  if <sil=0.000> 4 bytes <sil=0.000> take <sil=0.000> one <sil=0.000> integer <sil=1.000> ,COMMA  float <sil=0.000> 4 <sil=2.000> .PERIOD  Now <sil=0.000> this
could <sil=0.000> be <sil=0.000> 2 - that <sil=0.000> depends <sil=0.000> on <sil=0.000> what <sil=0.000> the <sil=0.000> scale <sil=0.000> factor <sil=0.000> is <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> I write <sil=0.000> here <sil=0.000> for <sil=0.000> an <sil=0.000> integer <sil=0.000> pointer <sil=1.000> ,COMMA 
assuming <sil=0.000> the <sil=0.000> my <sil=0.000> computer <sil=0.000> is <sil=0.000> actually <sil=0.000> doing <sil=0.000> this - that <sil=0.000> each <sil=0.000> of <sil=0.000> them <sil=0.000> is <sil=0.000> 4 <sil=1.000> ,COMMA  then <sil=0.000> p 1 <sil=0.000> plus <sil=0.000> plus <sil=0.000> is
adding <sil=0.000> p 1 <sil=0.000> by <sil=0.000> 4 <sil=1.000> ,COMMA <sil=0.000> so <sil=0.000> it <sil=0.000> is <sil=0.000> going <sil=0.000> to <sil=0.000> the <sil=0.000> next <sil=0.000> integer <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  in <sil=0.000> between <sil=0.000> there <sil=0.000> are <sil=0.000> 4 bytes <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> going <sil=0.000> to <sil=0.000> the <sil=0.000> next <sil=0.000> integer <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  there <sil=0.000> is <sil=0.000> one <sil=0.000> quick <sil=0.000> way <sil=0.000> of <sil=0.000> finding <sil=0.000> out <sil=1.000> ,COMMA  how <sil=0.000> we <sil=0.000> can <sil=0.000> find <sil=0.000> out <sil=0.000> what <sil=0.000> is <sil=0.000> the <sil=0.000> representation <sil=0.000> in <sil=0.000> my
system <sil=0.228> ?QUESTIONMARK  There <sil=0.000> is <sil=0.000> a nice <sil=0.000> inbuilt <sil=0.000> function <sil=0.000> called <sil=0.000> size <sil=0.000> of <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> I give <sil=0.000> size <sil=0.000> of <sil=0.000> int <sil=1.000> ,COMMA  the <sil=0.000> system <sil=0.000> returns
me <sil=0.000> the <sil=0.000> value <sil=0.000> 4 or <sil=0.000> 2 depending <sil=0.000> on <sil=0.000> how <sil=0.000> much <sil=1.000> ,COMMA  how <sil=0.000> many <sil=0.000> bytes <sil=0.000> does <sil=0.000> int <sil=0.000> consume <sil=2.000> .PERIOD 

Similarly <sil=1.000> ,COMMA  I <sil=0.000> could <sil=0.000> have <sil=0.000> given <sil=0.000> size <sil=0.000> of <sil=0.000> float - that <sil=0.000> will <sil=0.000> tell <sil=0.000> me <sil=0.000> how <sil=0.000> many <sil=0.000> bytes <sil=0.000> has <sil=0.000> a float
consumed <sil=0.000> so <sil=0.000> and <sil=0.000> so <sil=0.000> forth <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> one <sil=0.000> way <sil=0.000> to <sil=0.000> find <sil=0.000> the <sil=0.000> scale <sil=0.000> factors <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  number <sil=0.000> of <sil=0.000> bytes
occupied <sil=0.000> by <sil=0.000> float <sil=0.000> is <sil=0.000> size <sil=0.000> of <sil=0.000> float <sil=2.000> .PERIOD  If <sil=0.000> you <sil=0.000> give <sil=0.000> that <sil=0.000> the <sil=0.000> system <sil=0.000> will <sil=0.000> give <sil=0.000> you <sil=0.000> the <sil=0.000> number <sil=0.000> of <sil=0.000> bytes
required <sil=0.000> for <sil=0.000> that <sil=0.000> representation <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  if <sil=0.000> in <sil=0.000> a system <sil=0.000> you <sil=0.000> would <sil=0.000> run <sil=0.000> this <sil=0.000> and <sil=0.000> you <sil=0.000> find <sil=0.000> that <sil=0.000> it <sil=0.000> is <sil=0.000> float <sil=0.000> is <sil=0.000> 4 <sil=1.000> ,COMMA  int <sil=0.000> is <sil=0.000> 4 then <sil=0.000> you <sil=0.000> know <sil=0.000> what
my <sil=0.000> scale <sil=0.000> factor <sil=0.000> is <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  just <sil=0.000> like <sil=0.000> and <sil=0.000> for <sil=0.000> every <sil=0.000> case <sil=0.000> we <sil=0.000> are <sil=0.000> thinking <sil=0.000> of <sil=0.000> how <sil=0.000> do <sil=0.000> we <sil=0.000> pass <sil=0.000> an <sil=0.000> array <sil=0.000> to <sil=0.000> a function <sil=1.000> ,COMMA  how
do <sil=0.000> we <sil=0.000> pass <sil=0.000> a structure <sil=0.000> to <sil=0.000> a function <sil=1.000> ,COMMA  here <sil=0.000> again <sil=0.000> we <sil=0.000> look <sil=0.000> at <sil=0.000> how <sil=0.000> do <sil=0.000> we <sil=0.000> pass <sil=0.000> a pointer <sil=0.000> to <sil=0.000> a
function <sil=2.000> .PERIOD  Pointers <sil=0.000> are <sil=0.000> often <sil=0.000> passed <sil=0.000> as <sil=0.000> parameters <sil=0.000> to <sil=0.000> a function <sil=0.000> and <sil=0.000> if <sil=0.000> you <sil=0.000> have <sil=0.000> thought <sil=0.000> about <sil=0.000> it
you <sil=0.000> must <sil=0.000> have <sil=0.000> already <sil=0.000> discovered <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  always <sil=0.000> it <sil=0.000> allows <sil=0.000> the <sil=0.000> data <sil=0.000> items <sil=1.000> ,COMMA  within <sil=0.000> the <sil=0.000> calling
programs <sil=0.000> to <sil=0.000> be <sil=0.000> accessed <sil=0.000> by <sil=0.000> the <sil=0.000> function <sil=1.000> ,COMMA  altered <sil=0.000> and <sil=0.000> then <sil=0.000> returned <sil=0.000> to <sil=0.000> the <sil=0.000> calling <sil=0.000> function <sil=0.000> in <sil=0.000> the
altered <sil=0.000> form <sil=1.000> ,COMMA  this <sil=0.000> says <sil=0.000> the <sil=0.000> calling <sil=0.000> by <sil=0.000> reference <sil=2.000> .PERIOD 

Normally <sil=0.000> arguments <sil=0.000> are <sil=0.000> passed <sil=0.000> to <sil=0.000> a function <sil=0.000> by <sil=0.000> value <sil=1.000> ,COMMA  we <sil=0.000> had <sil=0.000> discussed <sil=0.000> this <sil=2.000> .PERIOD  Now <sil=0.000> this <sil=0.000> is <sil=0.000> called
as <sil=0.000> call <sil=0.000> by <sil=0.000> reference <sil=0.000> or <sil=0.000> call <sil=0.000> by <sil=0.000> address <sil=1.000> ,COMMA  now <sil=0.000> you <sil=0.000> can <sil=0.000> see <sil=0.000> this - how <sil=0.000> this <sil=0.000> is <sil=0.000> done <sil=2.000> .PERIOD  Because <sil=0.000> in <sil=0.000> call
by <sil=0.000> value <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=0.000> that <sil=0.000> in <sil=0.000> the <sil=0.000> swap <sil=0.000> function <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  it <sil=0.000> was <sil=0.000> swapped <sil=0.000> within <sil=0.000> the <sil=0.000> function <sil=1.000> ,COMMA  but <sil=0.000> that <sil=0.000> x y <sil=0.000> and <sil=0.000> the <sil=0.000> main <sil=0.000> functions <sil=0.000> x y <sil=0.000> were <sil=0.000> two <sil=0.000> different <sil=0.000> entities <sil=1.000> ,COMMA  therefore <sil=0.000> whatever <sil=0.000> change <sil=0.000> was <sil=0.000> there <sil=0.000> that <sil=0.000> was <sil=0.000> lost <sil=2.000> .PERIOD 

But <sil=0.000> if <sil=0.000> I had <sil=0.000> just <sil=0.000> passed <sil=0.000> on <sil=0.000> the <sil=0.000> pointer <sil=0.000> then <sil=0.000> whatever <sil=0.000> change <sil=0.000> I do <sil=0.000> in <sil=0.000> the <sil=0.000> pointer <sil=0.000> in <sil=0.000> that <sil=0.000> particular
location <sil=1.000> ,COMMA  I <sil=0.000> simply <sil=0.000> pass <sil=0.000> on <sil=0.000> the <sil=0.000> address <sil=0.000> and <sil=0.000> make <sil=0.000> a change <sil=0.000> over <sil=0.000> there <sil=1.000> ,COMMA  then <sil=0.000> the <sil=0.000> change <sil=0.000> is <sil=0.000> reflected <sil=0.000> because <sil=0.000> it <sil=0.000> is <sil=0.000> the <sil=0.000> same <sil=0.000> location <sil=0.000> that <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> call <sil=0.000> by <sil=0.000> reference <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> an <sil=0.000> example <sil=1.000> ,COMMA  you <sil=0.000> have <sil=0.000> seen <sil=0.000> this <sil=0.000> passing <sil=0.000> by <sil=0.000> value <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> repeating <sil=0.000> this - a <sil=0.000> was <sil=0.000> 5 and <sil=0.000> b was <sil=0.000> 20 <sil=1.000> ,COMMA  I <sil=0.000> call <sil=0.000> swap <sil=0.000> a b <sil=2.000> .PERIOD  Here <sil=1.000> ,COMMA  what <sil=0.000> happened  <sil=0.228> ?QUESTIONMARK  x <sil=0.000> was <sil=0.000> 5 <sil=1.000> ,COMMA  b <sil=0.000> was <sil=0.000> 20 <sil=2.000> .PERIOD  I <sil=0.000> changed <sil=0.000> it <sil=2.000> .PERIOD  Now <sil=0.000> x was <sil=0.000> 20 <sil=0.000> and <sil=0.000> b was <sil=0.000> 5 <sil=1.000> ,COMMA  but <sil=0.000> when <sil=0.000> I returned <sil=0.000> and <sil=0.000> printed <sil=0.000> this <sil=0.000> a and <sil=0.000> b they <sil=0.000> were <sil=0.000> completely <sil=0.000> different <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  swapping <sil=0.000> was <sil=0.000> not <sil=0.000> reflected <sil=2.000> .PERIOD  Therefore <sil=1.000> ,COMMA  here <sil=0.000> x and <sil=0.000> y was <sil=0.000> swapped <sil=0.000> but <sil=0.000> a and <sil=0.000> b do <sil=0.000> not <sil=0.000> swap <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> output <sil=0.000> will <sil=0.000> be <sil=0.000> the <sil=0.000> same <sil=0.000> 5 and <sil=0.000> 20 <sil=2.000> .PERIOD 

But <sil=0.000> if <sil=0.000> I had <sil=0.000> done <sil=0.000> through <sil=0.000> reference <sil=1.000> ,COMMA  here <sil=0.000> you <sil=0.000> see <sil=0.000> how <sil=0.000> I pass <sil=0.000> it <sil=0.000> on <sil=2.000> .PERIOD  Here <sil=0.000> what <sil=0.000> I am <sil=0.000> passing <sil=0.000> you
have <sil=0.000> must <sil=0.000> have <sil=0.000> thought <sil=0.000> about <sil=0.000> it <sil=2.000> .PERIOD  Swap <sil=0.000> instead <sil=0.000> of <sil=0.000> sending <sil=0.000> that <sil=0.000> value <sil=1.000> ,COMMA  what <sil=0.000> I am <sil=0.000> sending <sil=0.000> is <sil=0.000> the
address <sil=0.000> of <sil=0.000> that <sil=1.000> ,COMMA  address <sil=0.000> of <sil=0.000> a and <sil=0.000> address <sil=0.000> of <sil=0.000> and <sil=0.000> here <sil=0.000> inside <sil=0.000> the <sil=0.000> function <sil=1.000> ,COMMA  what <sil=0.000> I am <sil=0.000> a what <sil=0.000> am <sil=0.000> I
accepting <sil=0.228> ?QUESTIONMARK  I <sil=0.000> am <sil=0.000> accepting <sil=0.000> the <sil=0.000> pointer <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here (x <sil=0.000> and <sil=0.000> y) I <sil=0.000> know <sil=0.000> that <sil=0.000> what <sil=0.000> is <sil=0.000> coming <sil=0.000> to <sil=0.000> me <sil=0.000> is <sil=0.000> a pointer <sil=2.000> .PERIOD  We <sil=0.000> discussed <sil=0.000> it <sil=0.000> earlier <sil=0.000> also <sil=1.000> ,COMMA  but
let <sil=0.000> me <sil=0.000> repeat <sil=0.000> because <sil=0.000> there <sil=0.000> is <sil=0.000> a very <sil=0.000> fundamental <sil=0.000> idea <sil=1.000> ,COMMA  a <sil=0.000> is <sil=0.000> 5 <sil=1.000> ,COMMA  b <sil=0.000> is <sil=0.000> 20 <sil=0.000> and <sil=0.000> now <sil=0.000> I swap <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> do <sil=0.000> I have <sil=0.000> x <sil=0.228> ?QUESTIONMARK  No <sil=2.000> .PERIOD  I <sil=0.000> have <sil=0.000> got <sil=0.000> this <sil=0.000> x which <sil=0.000> is <sil=0.000> nothing <sil=1.000> ,COMMA  but  and <sil=0.000> a  and <sil=0.000> I have <sil=0.000> got <sil=0.000> this <sil=0.000> y which <sil=0.000> is
nothing <sil=1.000> ,COMMA  but  and <sil=0.000> b  <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  therefore <sil=1.000> ,COMMA  they <sil=0.000> are <sil=0.000> pointing <sil=0.000> to <sil=0.000> these <sil=0.000> points <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  when <sil=0.000> I swap <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> actually <sil=0.000> swapping <sil=0.000> the <sil=0.000> content <sil=0.000> of <sil=0.000> x <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> content <sil=0.000> of <sil=0.000> x  <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA 
here <sil=0.000> that <sil=0.000> is <sil=0.000> going <sil=0.000> to <sil=0.000> t and <sil=0.000> then <sil=0.000> content <sil=0.000> of <sil=0.000> y <sil=1.000> ,COMMA  indirection <sil=1.000> ,COMMA  I <sil=0.000> go <sil=0.000> from <sil=0.000> here <sil=1.000> ,COMMA  follow <sil=0.000> my <sil=0.000> cursor <sil=2.000> .PERIOD  I <sil=0.000> go
here <sil=0.000> and <sil=0.000> that <sil=0.000> one <sil=0.000> is <sil=0.000> going <sil=0.000> as <sil=0.000> the <sil=0.000> content <sil=0.000> of <sil=0.000> a <sil=1.000> ,COMMA  content <sil=0.000> of <sil=0.000> x <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> it <sil=0.000> is <sil=0.000> becoming <sil=0.000> 20 <sil=0.000> and <sil=0.000> then <sil=0.000> t is <sil=0.000> coming <sil=0.000> as <sil=0.000> a content <sil=0.000> of <sil=0.000> y <sil=2.000> .PERIOD  What <sil=0.000> is <sil=0.000> y <sil=0.228> ?QUESTIONMARK  y <sil=0.000> is <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> coming <sil=0.000> as <sil=0.000> 5 <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  when <sil=0.000> I come <sil=0.000> out <sil=0.000> and <sil=0.000> print <sil=0.000> here - a <sil=0.000> and <sil=0.000> b as <sil=0.000> you <sil=0.000> can <sil=0.000> see <sil=0.000> has <sil=0.000> changed <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you <sil=0.000> see <sil=0.000> how <sil=0.000> did <sil=0.000> I pass <sil=0.000> on <sil=0.000> the <sil=0.000> parameter <sil=0.228> ?QUESTIONMARK  Look <sil=0.000> at <sil=0.000> this - I <sil=0.000> have <sil=0.000> passed <sil=0.000> on <sil=0.000> the <sil=0.000> address <sil=0.000> and <sil=0.000> I have <sil=0.000> accepted <sil=0.000> them <sil=0.000> in <sil=0.000> my <sil=0.000> function <sil=0.000> as <sil=0.000> the <sil=0.000> pointer <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  with <sil=0.000> this <sil=0.000> we <sil=0.000> will <sil=0.000> get <sil=0.000> the <sil=0.000> correct <sil=0.000> answer <sil=0.000> x and <sil=0.000> y swap <sil=0.000> a and <sil=0.000> b also <sil=0.000> swap <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> answer <sil=0.000> is -
that <sil=0.000> is <sil=0.000> correct <sil=0.000> one <sil=0.000> as <sil=0.000> we <sil=0.000> expected <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  now <sil=0.000> let <sil=0.000> us <sil=0.000> skip <sil=0.000> this <sil=0.000> a little <sil=0.000> bit <sil=0.000> and <sil=0.000> let <sil=0.000> us <sil=0.000> go <sil=0.000> to <sil=0.000> something
else <sil=0.000> as <sil=0.000> pointers <sil=0.000> and <sil=0.000> arrays <sil=2.000> .PERIOD 

When <sil=0.000> an <sil=0.000> array <sil=0.000> is <sil=0.000> declared <sil=1.000> ,COMMA  the <sil=0.000> compiler <sil=0.000> allocates <sil=0.000> a base <sil=0.000> address <sil=0.000> and <sil=0.000> sufficient <sil=0.000> amount <sil=0.000> of
storage <sil=2.000> .PERIOD  You <sil=0.000> know <sil=0.000> that <sil=0.000> when <sil=0.000> I declare <sil=0.000> something <sil=0.000> as <sil=0.000> an <sil=0.000> array <sil=1.000> ,COMMA  int <sil=0.000> a 10 <sil=0.000> and <sil=0.000> if <sil=0.000> I say <sil=0.000> that <sil=0.000> int <sil=1.000> ,COMMA <sil=0.000> I have
discovered <sil=0.000> using <sil=0.000> size <sil=0.000> of <sil=0.000> fact <sil=0.000> that <sil=0.000> int <sil=0.000> takes <sil=0.000> 4 bytes <sil=1.000> ,COMMA  then <sil=0.000> for <sil=0.000> every <sil=0.000> element <sil=0.000> 4 bytes <sil=0.000> are <sil=0.000> kept <sil=0.000> and <sil=0.000> 40 <sil=0.000> such <sil=0.000> locations <sil=0.000> are <sil=0.000> allocated <sil=0.000> for <sil=0.000> the <sil=0.000> array <sil=0.000> a <sil=2.000> .PERIOD 

Now <sil=0.000> when <sil=0.000> I refer <sil=0.000> to <sil=0.000> this <sil=0.000> array <sil=0.000> a <sil=1.000> ,COMMA  because <sil=0.000> we <sil=0.000> saw <sil=0.000> that <sil=0.000> we <sil=0.000> pass <sil=0.000> on <sil=0.000> an <sil=0.000> array <sil=0.000> by <sil=0.000> reference <sil=0.000> to <sil=0.000> a
function <sil=0.000> the <sil=0.000> reason <sil=0.000> behind <sil=0.000> that <sil=0.000> is <sil=0.000> that <sil=0.000> this <sil=0.000> name <sil=0.000> array <sil=0.000> a is <sil=0.000> the <sil=0.000> same <sil=0.000> as <sil=0.000> a pointer <sil=0.000> to <sil=0.000> the <sil=0.000> first
location <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> as <sil=0.000> if <sil=0.000> equivalent <sil=0.000> to <sil=0.000> a is <sil=0.000> a pointer <sil=0.000> that <sil=0.000> is <sil=0.000> pointing <sil=0.000> to <sil=0.000> the <sil=0.000> first <sil=0.000> location
of <sil=0.000> this <sil=0.000> array <sil=0.000> a <sil=2.000> .PERIOD <sil=0.000> They <sil=0.000> are <sil=0.000> equivalent <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  the <sil=0.000> base <sil=0.000> address <sil=0.000> is <sil=0.000> a location <sil=0.000> of <sil=0.000> the <sil=0.000> first <sil=0.000> element <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=1.000> ,COMMA  the <sil=0.000> compiler <sil=0.000> also <sil=0.000> defines <sil=0.000> the
array <sil=0.000> name <sil=0.000> as <sil=0.000> a constant <sil=0.000> pointer <sil=0.000> to <sil=0.000> the <sil=0.000> first <sil=2.000> .PERIOD  When <sil=0.000> I declared <sil=0.000> it <sil=0.000> with <sil=0.000> the <sil=0.000> compiler <sil=0.000> it <sil=0.000> also <sil=0.000> keeps <sil=0.000> a
constant <sil=0.000> pointer <sil=1.000> ,COMMA  that <sil=0.000> pointer <sil=0.000> you <sil=0.000> cannot <sil=0.000> change <sil=0.000> ok <sil=2.000> .PERIOD 

 <sil=2.000> .PERIOD 

For <sil=0.000> example <sil=1.000> ,COMMA  when <sil=0.000> I say <sil=0.000> x 5 <sil=1.000> ,COMMA  1 <sil=1.000> ,COMMA  2 <sil=1.000> ,COMMA  3 <sil=1.000> ,COMMA  4 <sil=1.000> ,COMMA  5 <sil=0.000> then <sil=0.000> suppose <sil=0.000> the <sil=0.000> base <sil=0.000> address <sil=0.000> is <sil=0.000> 2500 <sil=1.000> ,COMMA  each <sil=0.000> integer
requires <sil=0.000> 4 bytes <sil=1.000> ,COMMA  then <sil=0.000> the <sil=0.000> elements <sil=0.000> will <sil=0.000> be <sil=0.000> x 0 <sil=0.000> will <sil=0.000> be <sil=0.000> 2500 <sil=1.000> ,COMMA  x <sil=0.000> 1 will <sil=0.000> be <sil=0.000> 2504 <sil=0.000> so <sil=0.000> and <sil=0.000> so <sil=0.000> forth <sil=0.000> and
the <sil=0.000> pointer <sil=0.000> will <sil=0.000> be <sil=0.000> 2500 <sil=2.000> .PERIOD 

If <sil=0.000> we <sil=0.000> go <sil=0.000> up <sil=0.000> 2500 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  there <sil=0.000> is <sil=0.000> a pointer <sil=0.000> x - which <sil=0.000> means  and <sil=0.000> address <sil=0.000> of <sil=0.000> x 0  <sil=1.000> ,COMMA  which <sil=0.000> is <sil=0.000> 2500  <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  p <sil=0.000> assigned <sil=0.000> x and <sil=0.000> p assigned  and <sil=0.000> of <sil=0.000> x 0 <sil=0.354> ;SEMICOLON  are <sil=0.000> equivalent <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> can <sil=0.000> access <sil=0.000> successive <sil=0.000> values <sil=0.000> of <sil=0.000> x by <sil=0.000> using <sil=0.000> p plus <sil=0.000> plus <sil=0.000> or <sil=0.000> p minus <sil=0.000> minus <sil=0.000> to <sil=0.000> move <sil=0.000> from <sil=0.000> one <sil=0.000> element <sil=0.000> to <sil=0.000> another <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> the <sil=0.000> p <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> this <sil=0.000> pointer <sil=0.000> which <sil=0.000> is <sil=0.000> pointing <sil=0.000> to <sil=0.000> the <sil=0.000> array <sil=2.000> .PERIOD  I <sil=0.000> cannot <sil=0.000> change <sil=0.000> that
pointer <sil=1.000> ,COMMA  but <sil=0.000> if <sil=0.000> I do <sil=0.000> p plus <sil=0.000> plus - this <sil=0.000> pointing <sil=0.000> to <sil=0.000> the <sil=0.000> first <sil=0.000> element <sil=1.000> ,COMMA  then <sil=0.000> I go <sil=0.000> to <sil=0.000> the <sil=0.000> next <sil=0.000> element <sil=0.000> of
the <sil=0.000> array <sil=0.000> record <sil=0.000> by <sil=0.000> the <sil=0.000> scale <sil=0.000> factor <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> if <sil=0.000> I do <sil=0.000> p plus <sil=0.000> plus <sil=0.000> I am <sil=0.000> actually <sil=0.000> doing <sil=0.000> p plus <sil=0.000> 4 <sil=2.000> .PERIOD  In
that <sil=0.000> way <sil=0.000> I can <sil=0.000> move <sil=0.000> across <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  the <sil=0.000> relationships <sil=0.000> should <sil=0.000> be <sil=0.000> clear <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  p <sil=0.000> plus <sil=0.000> 1 is <sil=0.000> the <sil=0.000> next <sil=0.000> one <sil=1.000> ,COMMA  p <sil=0.000> plus <sil=0.000> 2 is <sil=0.000> the <sil=0.000> next <sil=0.000> one -
that <sil=0.000> we <sil=0.000> have <sil=0.000> already <sil=0.000> explained <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> a function <sil=0.000> to <sil=0.000> find <sil=0.000> average <sil=1.000> ,COMMA  here <sil=0.000> you <sil=0.000> see <sil=0.000> we <sil=0.000> have <sil=0.000> got <sil=0.000> a main <sil=0.000> program <sil=1.000> ,COMMA  where <sil=0.000> I have
got <sil=0.000> an <sil=0.000> array <sil=1.000> ,COMMA <sil=0.000> 100 <sil=0.000> elements <sil=1.000> ,COMMA  for <sil=0.000> k 0 <sil=0.000> to <sil=0.000> n <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> reading <sil=0.000> k and <sil=0.000> then <sil=0.000> I am <sil=0.000> calling <sil=0.000> this <sil=0.000> average <sil=0.000> x <sil=2.000> .PERIOD  I <sil=0.000> am
calling <sil=0.000> average <sil=0.000> x n <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  here <sil=0.000> what <sil=0.000> goes <sil=0.000> in <sil=0.000> average <sil=0.000> x n <sil=1.000> ,COMMA  you <sil=0.000> have <sil=0.000> seen <sil=0.000> this <sil=1.000> ,COMMA  now <sil=0.000> I am <sil=0.000> passing
the <sil=0.000> pointer <sil=2.000> .PERIOD  When <sil=0.000> I am <sil=0.000> saying <sil=0.000> I am <sil=0.000> just <sil=0.000> passing <sil=0.000> the <sil=0.000> array <sil=0.000> actually <sil=0.000> I have <sil=0.000> passed <sil=0.000> on <sil=0.000> the <sil=0.000> pointer <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  whatever <sil=0.000> I did <sil=0.000> I am <sil=0.000> doing <sil=0.000> here <sil=2.000> .PERIOD  I <sil=0.000> am <sil=0.000> taking <sil=0.000> another <sil=0.000> star <sil=0.000> p <sil=1.000> ,COMMA  which <sil=0.000> is <sil=0.000> local <sil=0.000> which <sil=0.000> is <sil=0.000> pointing <sil=0.000> to
the <sil=0.000> array <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  my <sil=0.000> array <sil=0.000> was <sil=0.000> here <sil=0.000> and <sil=0.000> I am <sil=0.000> putting <sil=0.000> another <sil=0.000> pointer <sil=0.000> p which <sil=0.000> is <sil=0.000> pointing <sil=0.000> to <sil=0.000> this <sil=0.000> array <sil=0.000> and
array <sil=0.000> means <sil=0.000> what <sil=0.228> ?QUESTIONMARK  Array <sil=0.000> means <sil=0.000> the <sil=0.000> first <sil=0.000> location <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=2.000> .PERIOD  Then <sil=0.000> I carry <sil=0.000> on <sil=0.000> the <sil=0.000> sum <sil=0.000> here <sil=2.000> .PERIOD  I
carry <sil=0.000> on <sil=0.000> with <sil=0.000> p <sil=2.000> .PERIOD  Here <sil=0.000> you <sil=0.000> see <sil=0.000> what <sil=0.000> I do <sil=2.000> .PERIOD  I <sil=0.000> take <sil=0.000> p and <sil=0.000> then <sil=0.000> I change <sil=0.000> p <sil=2.000> .PERIOD  Sum <sil=0.000> assigns <sil=0.000> star <sil=0.000> p plus <sil=0.000> i <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  p <sil=0.000> plus <sil=0.000> 1 <sil=1.000> ,COMMA  p <sil=0.000> plus <sil=0.000> 2 <sil=1.000> ,COMMA  p <sil=0.000> plus3 <sil=0.000> and <sil=0.000> star <sil=0.000> p plus <sil=0.000> 1 <sil=1.000> ,COMMA  p <sil=0.000> plus <sil=0.000> 2 means <sil=0.000> the <sil=0.000> content <sil=0.000> of <sil=0.000> this <sil=0.354> ;SEMICOLON  these <sil=0.000> contents <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=0.000> I am <sil=0.000> getting <sil=0.000> the <sil=0.000> sum <sil=0.000> and <sil=0.000> what <sil=0.000> do <sil=0.000> I return <sil=0.228> ?QUESTIONMARK  Return <sil=0.000> float <sil=0.000> sum <sil=0.000> by <sil=0.000> size <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I
get <sil=0.000> sum <sil=0.354> ;SEMICOLON  obviously <sil=1.000> ,COMMA  the <sil=0.000> array <sil=0.000> was <sil=0.000> integer <sil=1.000> ,COMMA  but <sil=0.000> now <sil=0.000> this <sil=0.000> is <sil=0.000> something <sil=0.000> called <sil=0.000> typecasting- although
it <sil=0.000> was <sil=0.000> float <sil=1.000> ,COMMA  I <sil=0.000> put <sil=0.000> it <sil=0.000> in <sil=0.000> a bracket <sil=2.000> .PERIOD  That <sil=0.000> means <sil=1.000> ,COMMA  whatever <sil=0.000> is <sil=0.000> coming <sil=0.000> here <sil=0.000> I am <sil=0.000> converting <sil=0.000> that <sil=0.000> to
float <sil=2.000> .PERIOD  Sum <sil=0.000> will <sil=0.000> be <sil=0.000> an <sil=0.000> array <sil=1.000> ,COMMA  sum <sil=0.000> of <sil=0.000> all <sil=0.000> integers <sil=0.000> will <sil=0.000> be <sil=0.000> an <sil=0.000> integer <sil=1.000> ,COMMA  but <sil=0.000> when <sil=0.000> I divide <sil=0.000> by <sil=0.000> that <sil=1.000> ,COMMA 
although <sil=0.000> I did <sil=0.000> not <sil=0.000> declare  sum  to <sil=0.000> be <sil=0.000> ah <sil=0.000> a floating <sil=0.000> point <sil=0.000> number <sil=1.000> ,COMMA  just <sil=0.000> by <sil=0.000> this <sil=0.000> sort <sil=0.000> of <sil=0.000> type
typecasting <sil=2.000> .PERIOD 

I <sil=0.000> can <sil=0.000> make <sil=0.000> it <sil=0.000> a floating <sil=0.000> point <sil=0.000> number <sil=0.000> and <sil=0.000> then <sil=0.000> how <sil=0.000> do <sil=0.000> I return <sil=0.000> it <sil=0.228> ?QUESTIONMARK  Yes <sil=0.000> you <sil=0.000> might <sil=0.000> have <sil=0.000> guessed
correctly <sil=1.000> ,COMMA  that <sil=0.000> I do <sil=0.000> not <sil=0.000> need <sil=0.000> to <sil=0.000> return <sil=0.000> it <sil=0.000> because <sil=0.000> whatever <sil=0.000> I have <sil=0.000> done <sil=1.000> ,COMMA  here <sil=0.000> when <sil=0.000> I passed <sil=0.000> an

array <sil=1.000> ,COMMA  whatever <sil=0.000> was <sil=0.000> done <sil=0.000> that <sil=0.000> is <sil=0.000> being <sil=0.000> done <sil=0.000> here <sil=0.000> and <sil=0.000> what <sil=0.000> I am <sil=0.000> returning <sil=0.228> ?QUESTIONMARK  I <sil=0.000> am <sil=0.000> returning <sil=0.000> this <sil=0.000> to
the <sil=0.000> average <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> get <sil=0.000> this <sil=0.000> value <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> should <sil=0.000> be <sil=0.000> clear <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  its <sil=0.000> clarified <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA <sil=0.000> next <sil=0.000> thing <sil=0.000> that <sil=0.000> I will <sil=0.000> be <sil=0.000> discussing <sil=0.000> a little <sil=0.000> bit <sil=0.000> is <sil=0.000> dynamic <sil=0.000> memory
allocation <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> take <sil=0.000> little <sil=0.000> time <sil=0.000> to <sil=0.000> explain <sil=0.000> that <sil=0.000> and <sil=0.000> that <sil=0.000> is <sil=0.000> a very <sil=0.000> important <sil=0.000> concept <sil=0.000> and <sil=0.000> after <sil=0.000> that
we <sil=0.000> will <sil=0.000> move <sil=0.000> to <sil=0.000> a some <sil=0.000> discussions <sil=1.000> ,COMMA  basic <sil=0.000> discussions <sil=0.000> on <sil=0.000> file <sil=2.000> .PERIOD 

We <sil=0.000> have <sil=0.000> seen <sil=0.000> how <sil=0.000> structures <sil=0.000> are <sil=0.000> represented <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> also <sil=0.000> learnt <sil=0.000> about <sil=0.000> pointers <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  today <sil=0.000> we <sil=0.000> will <sil=0.000> be <sil=0.000> looking <sil=0.000> at <sil=0.000> the <sil=0.000> structures <sil=0.000> once <sil=0.000> again <sil=0.000> in <sil=0.000> a different <sil=0.000> light <sil=2.000> .PERIOD  As <sil=0.000> you <sil=0.000> can <sil=0.000> see <sil=0.000> here <sil=1.000> ,COMMA  a <sil=0.000> structure <sil=0.000> can <sil=0.000> be <sil=0.000> declared <sil=0.000> as <sil=0.000> is <sil=0.000> shown <sil=0.000> here <sil=0.000> the <sil=0.000> student <sil=0.000> structure <sil=0.000> struct <sil=0.000> stud <sil=0.000> is <sil=0.000> consisting <sil=0.000> of <sil=0.000> three <sil=0.000> members <sil=0.000> or <sil=0.000> three <sil=0.000> fields <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  they <sil=0.000> are - the <sil=0.000> role <sil=1.000> ,COMMA  the <sil=0.000> department <sil=0.000> code <sil=0.000> which <sil=0.000> is <sil=0.000> a character <sil=0.000> array <sil=0.000> and <sil=0.000> cgpa <sil=0.000> which <sil=0.000> is <sil=0.000> a
floating <sil=0.000> point <sil=0.000> number <sil=0.000> and <sil=0.000> a b <sil=0.000> c are <sil=0.000> three <sil=0.000> variables <sil=0.000> of <sil=0.000> the <sil=0.000> type <sil=0.000> s t <sil=0.000> u d <sil=1.000> ,COMMA  stud <sil=2.000> .PERIOD  The <sil=0.000> individual
structure <sil=0.000> elements <sil=0.000> you <sil=0.000> now <sil=0.000> can <sil=0.000> be <sil=0.000> accessed <sil=0.000> by <sil=0.000> a dot <sil=0.000> role <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  a <sil=0.000> is <sil=0.000> this <sil=0.000> field <sil=0.000> or <sil=0.000> b dot <sil=0.000> role <sil=0.000> c dot <sil=0.000> c g <sil=0.000> p a <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  with <sil=0.000> this <sil=0.000> dot <sil=0.000> operator <sil=0.000> we <sil=0.000> can <sil=0.000> access <sil=0.000> them <sil=2.000> .PERIOD  This <sil=0.000> was <sil=0.000> known <sil=0.000> to <sil=0.000> us <sil=0.000> right <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  we <sil=0.000> can <sil=0.000> also <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=0.000> that <sil=1.000> ,COMMA  we <sil=0.000> can <sil=0.000> define <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> structures <sil=0.000> where <sil=0.000> class <sil=0.000> is <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> students <sil=1.000> ,COMMA  class <sil=0.000> size <sil=0.000> is <sil=0.000> 100 <sil=0.000> and <sil=0.000> each <sil=0.000> element <sil=0.000> is <sil=0.000> a structure <sil=0.000> of <sil=0.000> type <sil=0.000> stud <sil=2.000> .PERIOD  The <sil=0.000> structure <sil=0.000> elements <sil=0.000> of <sil=0.000> the <sil=0.000> individual <sil=0.000> records <sil=0.000> can <sil=0.000> be <sil=0.000> accessed <sil=0.000> with <sil=0.000> this <sil=0.000> dot <sil=0.000> operator <sil=0.000> like <sil=0.000> class <sil=0.000> i <sil=1.000> ,COMMA  any <sil=0.000> particular <sil=0.000> element <sil=0.000> of <sil=0.000> that <sil=1.000> ,COMMA  say <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> class <sil=0.000> i where <sil=0.000> i is <sil=0.000> this <sil=0.000> index <sil=1.000> ,COMMA  I <sil=0.000> come <sil=0.000> over <sil=0.000> here <sil=1.000> ,COMMA  and <sil=0.000> get <sil=0.000> a particular <sil=0.000> field <sil=0.000> of <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> has <sil=0.000> got <sil=0.000> a number <sil=0.000> of <sil=0.000> fields <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> coming <sil=0.000> to <sil=0.000> the <sil=0.000> role <sil=0.000> field <sil=0.000> or <sil=0.000> the <sil=0.000> department <sil=0.000> code <sil=0.000> field <sil=0.000> dot <sil=0.000> the <sil=0.000> cgpa <sil=0.000> field <sil=2.000> .PERIOD  This <sil=0.000> was <sil=0.000> also <sil=0.000> known <sil=0.000> to <sil=0.000> us <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> we <sil=0.000> are <sil=0.000> trying <sil=0.000> to <sil=0.000> apply <sil=0.000> that <sil=0.000> to <sil=0.000> an <sil=0.000> example <sil=0.000> sorting <sil=0.000> by <sil=0.000> roll <sil=0.000> numbers <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> we <sil=0.000> have <sil=0.000> got
a <sil=0.000> set <sil=0.000> of <sil=0.000> students <sil=1.000> ,COMMA  look <sil=0.000> at <sil=0.000> the <sil=0.000> declaration <sil=0.000> here <sil=2.000> .PERIOD  Struct <sil=0.000> stud <sil=0.000> is <sil=0.000> the <sil=0.000> structure <sil=1.000> ,COMMA  having <sil=0.000> role <sil=0.000> department <sil=0.000> code <sil=0.000> and <sil=0.000> cgpa <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  in <sil=0.000> the <sil=0.000> main <sil=0.000> function <sil=0.000> what <sil=0.000> are <sil=0.000> you <sil=0.000> doing <sil=0.228> ?QUESTIONMARK  We <sil=0.000> are <sil=0.000> defining <sil=0.000> struct <sil=0.000> student <sil=0.000> class <sil=0.000> 100 <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  struct <sil=0.000> start <sil=0.000> has <sil=0.000> been <sil=0.000> declared <sil=1.000> ,COMMA  it <sil=0.000> has <sil=0.000> been <sil=0.000> declared <sil=0.000> globally <sil=1.000> ,COMMA  even <sil=0.000> before <sil=0.000> main <sil=0.000> that <sil=0.000> is <sil=0.000> possible <sil=2.000> .PERIOD 

Here <sil=0.000> I am <sil=0.000> saying <sil=0.000> that <sil=0.000> class <sil=0.000> 100 <sil=0.000> is <sil=0.000> one <sil=0.000> array <sil=0.000> and <sil=0.000> t and <sil=0.000> there <sil=0.000> are <sil=0.000> some <sil=0.000> integers <sil=2.000> .PERIOD   t  is <sil=0.000> again <sil=0.000> a
structure <sil=1.000> ,COMMA  t <sil=0.000> is <sil=0.000> also <sil=0.000> a structure <sil=0.000> of <sil=0.000> type <sil=0.000> stud <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> reading <sil=0.000> the <sil=0.000> number <sil=0.000> of <sil=0.000> students <sil=1.000> ,COMMA  how <sil=0.000> many
students <sil=0.000> are <sil=0.000> there <sil=0.000> in <sil=0.000> the <sil=0.000> class <sil=2.000> .PERIOD  The <sil=0.000> array <sil=0.000> can <sil=0.000> accommodate <sil=0.000> at <sil=0.000> most <sil=0.000> 100 <sil=0.000> but <sil=0.000> I am <sil=0.000> reading <sil=0.000> the
value <sil=0.000> n <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  for <sil=0.000> each <sil=0.000> of <sil=0.000> the <sil=0.000> elements <sil=1.000> ,COMMA  (look <sil=0.000> at <sil=0.000> this <sil=0.000> is <sil=0.000> our <sil=0.000> familiar <sil=0.000> for <sil=0.000> loop <sil=0.000> here) for <sil=0.000> k 0 <sil=0.000> to <sil=0.000> less
n <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> scanning <sil=0.000> the <sil=0.000> class <sil=1.000> ,COMMA  the <sil=0.000> roll <sil=0.000> number <sil=0.000> of <sil=0.000> that <sil=0.000> particular <sil=0.000> student <sil=1.000> ,COMMA  the <sil=0.000> department <sil=0.000> code <sil=0.000> and <sil=0.000> the <sil=0.000> c g <sil=0.000> p <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  in <sil=0.000> that <sil=0.000> way <sil=0.000> I read <sil=0.000> here <sil=2.000> .PERIOD  I <sil=0.000> am <sil=0.000> reading <sil=0.000> the <sil=0.000> array <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD  The <sil=0.000> array <sil=0.000> is <sil=0.000> being <sil=0.000> read <sil=0.000> here <sil=0.000> at <sil=0.000> this
point <sil=0.000> right <sil=2.000> .PERIOD  Now <sil=0.000> what <sil=0.000> I am <sil=0.000> doing <sil=0.000> now <sil=0.228> ?QUESTIONMARK  Next <sil=0.000> let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=0.000> loop <sil=2.000> .PERIOD  What <sil=0.000> are <sil=0.000> you <sil=0.000> doing <sil=0.000> here <sil=0.228> ?QUESTIONMARK 
For <sil=0.000> some <sil=0.000> value <sil=0.000> of <sil=0.000> j <sil=1.000> ,COMMA  if <sil=0.000> the <sil=0.000> role <sil=0.000> of <sil=0.000> that <sil=0.000> student <sil=0.354> ;SEMICOLON  so <sil=1.000> ,COMMA  here <sil=0.000> I have <sil=0.000> got <sil=0.000> my <sil=0.000> array <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> coming <sil=0.000> to <sil=0.000> j <sil=1.000> ,COMMA  a
particular <sil=0.000> element <sil=0.000> and <sil=0.000> looking <sil=0.000> at <sil=0.000> the <sil=0.000> role <sil=0.000> number <sil=0.000> field <sil=1.000> ,COMMA  if <sil=0.000> that <sil=0.000> is <sil=0.000> greater <sil=0.000> than <sil=0.000> some <sil=0.000> other <sil=0.000> value <sil=0.000> k <sil=1.000> ,COMMA 
if <sil=0.000> it <sil=0.000> is <sil=0.000> greater <sil=0.000> than <sil=0.000> the <sil=0.000> roll <sil=0.000> value <sil=0.000> of <sil=0.000> k <sil=1.000> ,COMMA  then <sil=0.000> I am <sil=0.000> exchanging <sil=0.000> them <sil=1.000> ,COMMA  just <sil=0.000> as <sil=0.000> we <sil=0.000> sort <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  what <sil=0.000> are <sil=0.000> we <sil=0.000> sorting <sil=0.000> here <sil=0.000> in <sil=0.000> that <sil=0.000> example <sil=0.000> earlier <sil=0.000> that <sil=0.000> we <sil=0.000> had <sil=0.000> done <sil=1.000> ,COMMA  we <sil=0.000> are <sil=0.000> sorting <sil=0.000> integers
or <sil=0.000> sorting <sil=0.000> real <sil=0.000> numbers <sil=2.000> .PERIOD  Here <sil=0.000> what <sil=0.000> we <sil=0.000> are <sil=0.000> doing <sil=0.000> we <sil=0.000> are <sil=0.000> sorting <sil=0.000> the <sil=0.000> entire <sil=0.000> structure <sil=1.000> ,COMMA  as <sil=0.000> you <sil=0.000> can
see <sil=0.000> the <sil=0.000> j is <sil=0.000> coming <sil=0.000> to <sil=0.000> t <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  t <sil=0.000> is <sil=0.000> again <sil=0.000> a structure <sil=2.000> .PERIOD  k <sil=0.000> is <sil=0.000> coming <sil=0.000> to <sil=0.000> j and <sil=0.000> so <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> a swap <sil=0.000> operation <sil=1.000> ,COMMA  swapping <sil=0.000> structures <sil=2.000> .PERIOD  It <sil=0.000> is <sil=0.000> called <sil=0.000> swapping <sil=0.000> the <sil=0.000> structures <sil=0.000> and <sil=0.000> this <sil=0.000> I am <sil=0.000> doing <sil=0.000> for <sil=0.000> k which <sil=0.000> is <sil=0.000> a internal <sil=0.000> variable <sil=0.000> and <sil=0.000> j is <sil=0.000> the
external <sil=0.000> variable <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  my <sil=0.000> diagram <sil=0.000> should <sil=0.000> be <sil=0.000> a little <sil=0.000> different <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  for <sil=0.000> every <sil=0.000> j I <sil=0.000> am <sil=0.000> looking <sil=0.000> at <sil=0.000> one <sil=0.000> j and <sil=0.000> I am <sil=0.000> varying <sil=0.000> k from <sil=0.000> here <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> k <sil=2.000> .PERIOD  k <sil=0.000> is <sil=0.000> varying <sil=0.000> from
this <sil=0.000> point <sil=0.000> to <sil=0.000> this <sil=0.000> point <sil=0.000> to <sil=0.000> the <sil=0.000> end <sil=0.000> of <sil=0.000> the <sil=0.000> structure <sil=0.000> and <sil=0.000> comparing <sil=0.000> with <sil=0.000> this <sil=0.000> j value <sil=2.000> .PERIOD  If <sil=0.000> this <sil=0.000> is <sil=0.000> any
element <sil=0.000> that <sil=0.000> is <sil=0.000> less <sil=0.000> that <sil=0.000> is <sil=0.000> coming <sil=0.000> over <sil=0.000> here <sil=0.000> and <sil=0.000> it <sil=0.000> is <sil=0.000> being <sil=0.000> swapped <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you <sil=0.000> have <sil=0.000> seen <sil=0.000> this <sil=0.000> swap <sil=0.000> algorithm <sil=0.000> earlier <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> being <sil=0.000> swapped <sil=0.000> here <sil=0.000> and <sil=0.000> then <sil=0.000> I update <sil=0.000> j and <sil=0.000> I go <sil=0.000> on <sil=0.000> doing <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> how <sil=0.000> I can
apply <sil=0.000> the <sil=0.000> sorting <sil=0.000> algorithm <sil=0.000> that <sil=0.000> we <sil=0.000> had <sil=0.000> learnt <sil=1.000> ,COMMA  for <sil=0.000> sorting <sil=0.000> student <sil=0.000> records <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD 

Next <sil=0.000> the <sil=0.000> other <sil=0.000> thing <sil=0.000> that <sil=0.000> we <sil=0.000> have <sil=0.000> to <sil=0.000> look <sil=0.000> at <sil=0.000> is <sil=0.000> pointers <sil=0.000> and <sil=0.000> structures <sil=2.000> .PERIOD  How <sil=0.000> they <sil=0.000> can <sil=0.000> be
intermingled <sil=0.228> ?QUESTIONMARK  You <sil=0.000> may <sil=0.000> recall <sil=0.000> that <sil=0.000> the <sil=0.000> name <sil=0.000> of <sil=0.000> an <sil=0.000> array <sil=0.000> stands <sil=0.000> for <sil=0.000> the <sil=0.000> zeroth <sil=0.000> element <sil=0.000> of <sil=0.000> the
array <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> this <sil=0.000> is <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> the <sil=0.000> name <sil=0.000> a <sil=1.000> ,COMMA  then <sil=0.000> the <sil=0.000> name <sil=0.000> a and <sil=0.000> a 0 <sil=0.000> are <sil=0.000> synonymous <sil=0.000> and <sil=0.000> so <sil=1.000> ,COMMA  a <sil=0.000> can <sil=0.000> be <sil=0.000> considered <sil=0.000> to <sil=0.000> be <sil=0.000> a pointer <sil=0.000> that <sil=0.000> is <sil=0.000> pointing <sil=0.000> to <sil=0.000> a 0 <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  consider <sil=0.000> the <sil=0.000> declaration <sil=2.000> .PERIOD  This <sil=0.000> is <sil=0.000> also <sil=0.000> true <sil=0.000> for <sil=0.000> the <sil=0.000> names <sil=0.000> of <sil=0.000> arrays <sil=0.000> of <sil=0.000> structures <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> I have <sil=0.000> a declaration <sil=0.000> like <sil=0.000> this <sil=1.000> ,COMMA  you <sil=0.000> look <sil=0.000> at <sil=0.000> the <sil=0.000> declaration <sil=0.000> yourself <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> see <sil=0.000> student <sil=0.000> is <sil=0.000> a structure <sil=0.000> and <sil=0.000> I have <sil=0.000> declared <sil=0.000> of <sil=0.000> the <sil=0.000> type <sil=0.000> student <sil=0.000> and <sil=0.000> array <sil=0.000> class <sil=0.000> 100 <sil=0.000> and <sil=0.000> star <sil=0.000> p t <sil=0.000> r <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> star <sil=0.000> ptr <sil=0.228> ?QUESTIONMARK  What <sil=0.000> does <sil=0.000> it <sil=0.000> mean <sil=0.228> ?QUESTIONMARK  You <sil=0.000> know <sil=0.000> by <sil=0.000> now <sil=2.000> .PERIOD  Just <sil=0.000> as <sil=0.000> we <sil=0.000> had <sil=0.000> done <sil=0.000> this (keep <sil=0.000> it
side <sil=0.000> by <sil=0.000> side ) int <sil=0.000> star <sil=0.000> p what <sil=0.000> does <sil=0.000> it <sil=0.000> mean <sil=0.228> ?QUESTIONMARK  It <sil=0.000> means <sil=0.000> that <sil=0.000> p is <sil=0.000> a pointer <sil=0.000> that <sil=0.000> points <sil=0.000> to <sil=0.000> integer <sil=0.000> data <sil=0.000> type <sil=2.000> .PERIOD  Here <sil=0.000> it <sil=0.000> means <sil=0.000> that <sil=0.000> ptr <sil=0.000> is <sil=0.000> a pointer <sil=0.000> that <sil=0.000> points <sil=0.000> to <sil=0.000> stud <sil=0.000> type <sil=0.000> of <sil=0.000> structures <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  what <sil=0.000> do <sil=0.000> I have <sil=0.228> ?QUESTIONMARK 

I <sil=0.000> have <sil=0.000> got <sil=0.000> an <sil=0.000> array <sil=0.000> called <sil=0.000> class <sil=1.000> ,COMMA  each <sil=0.000> element <sil=0.000> of <sil=0.000> which <sil=0.000> is <sil=0.000> of <sil=0.000> type <sil=0.000> student <sil=0.000> structure <sil=0.000> and <sil=0.000> I have <sil=0.000> got <sil=0.000> a pointer <sil=0.000> ptr <sil=1.000> ,COMMA  which <sil=0.000> can <sil=0.000> point <sil=0.000> to <sil=0.000> such <sil=0.000> structures <sil=2.000> .PERIOD  It <sil=0.000> can <sil=0.000> point <sil=0.000> to <sil=0.000> such <sil=0.000> structures -any <sil=0.000> of <sil=0.000> these <sil=0.000> I have <sil=0.000> not <sil=0.000> yet <sil=0.000> initialised <sil=0.000> this <sil=2.000> .PERIOD 

The <sil=0.000> name <sil=0.000> class <sil=0.000> therefore <sil=1.000> ,COMMA  represents <sil=0.000> the <sil=0.000> address <sil=0.000> of <sil=0.000> the <sil=0.000> zeroth <sil=0.000> element <sil=0.000> of <sil=0.000> the <sil=0.000> structure <sil=0.000> array <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> I have <sil=0.000> this <sil=0.000> then <sil=0.000> this <sil=0.000> class <sil=0.000> means <sil=0.000> it <sil=0.000> is <sil=0.000> a pointer <sil=0.000> that <sil=0.000> is <sil=0.000> pointing <sil=0.000> to <sil=0.000> this <sil=0.000> element <sil=0.000> plus <sil=0.000> 0 <sil=2.000> .PERIOD  Just <sil=0.000> like <sil=0.000> an <sil=0.000> array <sil=0.000> and <sil=0.000> ptr <sil=0.000> is <sil=0.000> a pointer <sil=0.000> to <sil=0.000> the <sil=0.000> data <sil=0.000> objects <sil=0.000> of <sil=0.000> type <sil=0.000> struct <sil=1.000> ,COMMA  that <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=2.000> .PERIOD 

The <sil=0.000> assignment - class <sil=0.000> assigned <sil=0.000> to <sil=0.000> ptr <sil=0.000> what <sil=0.000> will <sil=0.000> it <sil=0.000> make <sil=0.228> ?QUESTIONMARK  It <sil=0.000> will <sil=0.000> make <sil=0.000> ptr <sil=0.000> to <sil=0.000> point <sil=0.000> to <sil=0.000> the <sil=0.000> first
element <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=2.000> .PERIOD  Here <sil=0.000> is <sil=0.000> class <sil=0.000> and <sil=0.000> ptr <sil=0.000> is <sil=0.000> now <sil=0.000> pointing <sil=1.000> ,COMMA  (when <sil=0.000> I do <sil=0.000> this <sil=0.000> assignment <sil=0.000> note <sil=0.000> that
they <sil=0.000> are <sil=0.000> of <sil=0.000> the <sil=0.000> same <sil=0.000> type) to <sil=0.000> this <sil=0.000> element <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> assign <sil=0.000> ptr <sil=0.000> to <sil=0.000> class <sil=0.000> 0 <sil=1.000> ,COMMA  understood <sil=0.228> ?QUESTIONMARK  When <sil=0.000> the <sil=0.000> pointer <sil=0.000> ptr <sil=0.000> is <sil=0.000> incremented <sil=0.000> by <sil=0.000> 1 <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> ptr
plus <sil=0.000> plus <sil=0.000> you <sil=0.000> should <sil=0.000> be <sil=0.000> able <sil=0.000> to <sil=0.000> tell <sil=0.000> me <sil=0.000> what <sil=0.000> will <sil=0.000> happen <sil=2.000> .PERIOD  The <sil=0.000> ptr <sil=0.000> will <sil=0.000> be <sil=0.000> incremented <sil=0.000> to <sil=0.000> the <sil=0.000> next
element <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> actual <sil=0.000> increment <sil=0.000> will <sil=0.000> be <sil=0.000> by <sil=0.000> a scale <sil=0.000> factor <sil=0.000> and <sil=0.000> what <sil=0.000> is <sil=0.000> that <sil=0.000> scale
factor <sil=0.228> ?QUESTIONMARK  That <sil=0.000> scale <sil=0.000> factor <sil=0.000> is <sil=0.000> size <sil=0.000> of <sil=0.000> stud <sil=1.000> ,COMMA  size <sil=0.000> of <sil=0.000> the <sil=0.000> structure <sil=0.000> stud <sil=0.000> and <sil=0.000> you <sil=0.000> know <sil=0.000> that <sil=0.000> it <sil=0.000> has <sil=0.000> got <sil=0.000> a
roll <sil=0.000> number <sil=1.000> ,COMMA  it <sil=0.000> has <sil=0.000> got <sil=0.000> c g <sil=0.000> p a <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  depending <sil=0.000> on <sil=0.000> the <sil=0.000> different <sil=0.000> data <sil=0.000> types <sil=0.000> that <sil=0.000> are <sil=0.000> housed <sil=0.000> is <sil=0.000> inside <sil=0.000> that <sil=0.000> structure <sil=0.000> it <sil=0.000> will <sil=0.000> vary <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
the <sil=0.000> value <sil=0.000> of <sil=0.000> ptr <sil=0.000> will <sil=0.000> point <sil=0.000> to <sil=0.000> the <sil=0.000> next <sil=0.000> element <sil=0.000> which <sil=0.000> will <sil=0.000> be <sil=0.000> incremented <sil=0.000> by <sil=0.000> size <sil=0.000> of <sil=0.000> stud <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  its <sil=0.000> permit <sil=0.000> to <sil=0.000> point <sil=0.000> to <sil=0.000> the <sil=0.000> next <sil=0.000> record <sil=2.000> .PERIOD  Once <sil=0.000> ptr <sil=0.000> points <sil=0.000> to <sil=0.000> a structure <sil=0.000> variable <sil=1.000> ,COMMA  now <sil=0.000> this <sil=0.000> is
something <sil=0.000> new <sil=1.000> ,COMMA  the <sil=0.000> pointers <sil=0.000> can <sil=0.000> be <sil=0.000> accessed <sil=0.000> as <sil=0.000> ptr <sil=0.000> role <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> possible <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> see <sil=0.000> what <sil=0.000> is
happening <sil=0.000> you <sil=0.000> are <sil=0.000> being <sil=0.000> introduced <sil=0.000> to <sil=0.000> this <sil=0.000> operator <sil=1.000> ,COMMA  the <sil=0.000> arrow <sil=0.000> operator <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> or <sil=0.000> this <sil=0.000> only <sil=0.000> comes <sil=0.000> if <sil=0.000> the <sil=0.000> left <sil=0.000> side <sil=0.000> of <sil=0.000> this <sil=0.000> operator <sil=0.000> is <sil=0.000> a pointer <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> suppose <sil=0.000> I have <sil=0.000> got
some <sil=0.000> structure <sil=0.000> and <sil=0.000> pointer <sil=0.000> p or <sil=0.000> ptr <sil=0.000> is <sil=0.000> pointing <sil=0.000> to <sil=0.000> this <sil=0.000> structure <sil=0.000> and <sil=0.000> it <sil=0.000> has <sil=0.000> got <sil=0.000> different <sil=0.000> fields <sil=0.000> say
cgpa <sil=0.000> is <sil=0.000> a field <sil=2.000> .PERIOD  If <sil=0.000> I write <sil=0.000> ptr <sil=0.000> arrow <sil=0.000> c g <sil=0.000> p a <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=0.000> that <sil=0.000> I am <sil=0.000> now <sil=0.000> pointing <sil=0.000> to <sil=0.000> this <sil=1.000> ,COMMA  I <sil=0.000> am
actually <sil=0.000> accessing <sil=0.000> this <sil=0.000> element <sil=0.000> of <sil=0.000> the <sil=0.000> structure <sil=2.000> .PERIOD 

Just <sil=0.000> as <sil=0.000> suppose <sil=0.000> this <sil=0.000> structure <sil=0.000> is <sil=0.000> class <sil=0.000> and <sil=0.000> this <sil=0.000> element <sil=0.000> is <sil=0.000> class <sil=0.000> 1 say <sil=2.000> .PERIOD  I <sil=0.000> could <sil=0.000> have <sil=0.000> written <sil=0.000> class <sil=0.000> 1 dot <sil=0.000> cgpa <sil=0.000> and <sil=0.000> here <sil=0.000> I have <sil=0.000> already <sil=0.000> done <sil=0.000> this  <sil=1.000> ,COMMA  the <sil=0.000> pointer <sil=0.000> ptr <sil=0.000> was <sil=0.000> assigned <sil=0.000> to <sil=0.000> class <sil=0.000> 0 and <sil=0.000> then <sil=0.000> I did <sil=0.000> ptr <sil=0.000> plus <sil=0.000> plus <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  now <sil=0.000> where <sil=0.000> is <sil=0.000> ptr <sil=0.000> pointing <sil=0.000> to <sil=0.228> ?QUESTIONMARK  ptr <sil=0.000> is <sil=0.000> pointing <sil=0.000> to <sil=0.000> class <sil=0.000> 1 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> now <sil=0.000> also <sil=0.000> do <sil=0.000> ptr <sil=0.000> arrow <sil=0.000> cgpa <sil=2.000> .PERIOD  These <sil=0.000> two <sil=0.000> are <sil=0.000> equivalent <sil=1.000> ,COMMA  this <sil=0.000> and <sil=0.000> this <sil=0.000> are <sil=0.000> equivalent <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> also <sil=0.000> you <sil=0.000> can <sil=0.000> understand <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> move <sil=0.000> ahead <sil=2.000> .PERIOD 

Similarly <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> go <sil=0.000> to <sil=0.000> another <sil=0.000> field <sil=0.000> by <sil=0.000> ptr <sil=0.000> slash <sil=0.000> department <sil=0.000> code <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> go <sil=0.000> ptr <sil=0.000> cgpa <sil=1.000> ,COMMA  ptr <sil=0.000> roll  <sil=1.000> ,COMMA <sil=0.000> this
symbol <sil=0.000> is <sil=0.000> naturally <sil=0.000> called <sil=0.000> the <sil=0.000> arrow <sil=0.000> operator <sil=2.000> .PERIOD 

You <sil=0.000> can <sil=0.000> read <sil=0.000> this <sil=0.000> type <sil=0.000> def <sil=1.000> ,COMMA  now <sil=0.000> here <sil=0.000> I am <sil=0.000> defining <sil=0.000> a type <sil=1.000> ,COMMA  the <sil=0.000> name <sil=0.000> of <sil=0.000> the <sil=0.000> type <sil=0.000> is <sil=0.000> complex <sil=0.000> and
what <sil=0.000> is <sil=0.000> this <sil=0.000> type <sil=0.000> complex <sil=2.000> .PERIOD  It <sil=0.000> is <sil=0.000> a structure <sil=0.000> with <sil=0.000> a real <sil=0.000> and <sil=0.000> imaginary <sil=0.000> part <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> what <sil=0.000> we <sil=0.000> saw
earlier <sil=2.000> .PERIOD 

Next <sil=0.000> I have <sil=0.000> got <sil=0.000> a function - print <sil=0.000> complex <sil=0.000> star  <sil=1.000> ,COMMA  what <sil=0.000> does <sil=0.000> it <sil=0.000> mean <sil=0.228> ?QUESTIONMARK  A <sil=0.000> is <sil=0.000> a pointer <sil=0.000> to <sil=0.000> type
complex <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  print <sil=0.000> f <sil=1.000> ,COMMA  whatever <sil=0.000> there <sil=0.000> are <sil=0.000> two <sil=0.000> placeholders - a <sil=0.000> real <sil=1.000> ,COMMA  a <sil=0.000> imaginary <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  why <sil=0.000> is <sil=0.000> it
possible <sil=0.228> ?QUESTIONMARK   a  is <sil=0.000> a pointer <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> pointing <sil=0.000> to <sil=0.000> some <sil=0.000> complex <sil=0.000> number <sil=1.000> ,COMMA  whatever <sil=0.000> that <sil=0.000> is <sil=2.000> .PERIOD   a  is <sil=0.000> a
pointer <sil=0.000> pointing <sil=0.000> to <sil=0.000> that <sil=0.000> and <sil=0.000> I am <sil=0.000> going <sil=0.000> to <sil=0.000> the <sil=0.000> real <sil=0.000> part <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> printing <sil=0.000> a real <sil=0.000> and <sil=0.000> this <sil=0.000> part <sil=0.000> is <sil=0.000> a
imaginary <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> what <sil=0.000> is <sil=0.000> being <sil=0.000> done <sil=0.000> by <sil=0.000> this <sil=0.000> piece <sil=0.000> of <sil=0.000> function <sil=0.000> code <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  now <sil=0.000> swap <sil=0.000> reference <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> complex <sil=0.000> a and <sil=0.000> complex <sil=0.000> b <sil=2.000> .PERIOD  I <sil=0.000> am <sil=0.000> sorry <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> visible <sil=0.000> here <sil=2.000> .PERIOD  a
and <sil=0.000> b there <sil=0.000> are <sil=0.000> two <sil=0.000> pointers <sil=0.000> in <sil=0.000> complex <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  there <sil=0.000> is <sil=0.000> t m <sil=0.000> p <sil=2.000> .PERIOD  I <sil=0.000> take <sil=0.000> another <sil=0.000> structure <sil=0.000> named <sil=0.000> t m <sil=0.000> p
of <sil=0.000> type <sil=0.000> complex <sil=1.000> ,COMMA  and <sil=0.000> I swap <sil=0.000> the <sil=0.000> pointers <sil=0.000> here <sil=2.000> .PERIOD 

That <sil=0.000> is <sil=0.000> why <sil=0.000> you <sil=0.000> can <sil=0.000> you <sil=0.000> can <sil=0.000> work <sil=0.000> it <sil=0.000> out <sil=0.000> that <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  that  a  was <sil=0.000> pointing <sil=0.000> to <sil=0.000> some <sil=0.000> structure
and <sil=0.000> that  a  is <sil=0.000> pointing <sil=0.000> to <sil=0.000> this <sil=0.000> structure <sil=0.000> and <sil=0.000> this <sil=0.000> particular <sil=0.000> structure <sil=0.000> is <sil=0.000> copied <sil=0.000> to <sil=0.000> another <sil=0.000> structure
temp <sil=1.000> ,COMMA  then  b  was <sil=0.000> pointing <sil=0.000> to <sil=0.000> another <sil=0.000> structure <sil=0.000> b and <sil=0.000> a are <sil=0.000> swapped <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA   b  is <sil=0.000> pointing <sil=0.000> to
this <sil=0.000> and  a  is <sil=0.000> pointing <sil=0.000> this <sil=0.000> next <sil=0.000> I am <sil=0.000> making <sil=0.000> b point <sil=0.000> to <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> how <sil=0.000> a swap <sil=0.000> operation <sil=0.000> can
be <sil=0.000> done <sil=0.000> and <sil=0.000> how <sil=0.000> we <sil=0.000> passed <sil=0.000> on <sil=0.000> the <sil=0.000> parameter <sil=0.000> to <sil=0.000> this <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  the <sil=0.000> main <sil=0.000> program <sil=0.000> can <sil=0.000> be <sil=0.000> can <sil=0.000> define <sil=0.000> complex <sil=0.000> x <sil=1.000> ,COMMA  10 <sil=0.000> and <sil=0.000> 3 <sil=1.000> ,COMMA  y <sil=0.000> is <sil=0.000> minus <sil=0.000> 20 <sil=0.000> minus <sil=0.000> 10 <sil=0.000> because <sil=0.000> of
the <sil=0.000> resolution <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> visible <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  print <sil=0.000> x and <sil=0.000> y then <sil=0.000> swap <sil=0.000> reference <sil=0.000> print <sil=0.000> x and <sil=0.000> y <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  can <sil=0.000> you
guess <sil=0.000> and <sil=0.000> tell <sil=0.000> me <sil=0.000> whether <sil=0.000> the <sil=0.000> swapping <sil=0.000> will <sil=0.000> work <sil=0.000> in <sil=0.000> this <sil=0.000> case <sil=0.000> or <sil=0.000> not  <sil=0.228> ?QUESTIONMARK  The <sil=0.000> answer <sil=0.000> is <sil=0.000> yes <sil=0.000> it <sil=0.000> will
work <sil=0.000> because <sil=0.000> it <sil=0.000> is <sil=0.000> a call <sil=0.000> by <sil=0.000> reference <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  whatever <sil=0.000> I am <sil=0.000> swapping <sil=0.000> here <sil=1.000> ,COMMA  that <sil=0.000> will <sil=0.000> be <sil=0.000> reflected <sil=0.000> in
the <sil=0.000> main <sil=0.000> program <sil=0.000> also <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> an <sil=0.000> example <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> move <sil=0.000> ahead <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  one <sil=0.000> warning <sil=0.000> is <sil=0.000> there <sil=0.000> that <sil=1.000> ,COMMA  when <sil=0.000> using <sil=0.000> a structure <sil=0.000> pointers <sil=1.000> ,COMMA  we <sil=0.000> should <sil=0.000> take <sil=0.000> care <sil=0.000> of <sil=0.000> the
operator <sil=0.000> precedence <sil=2.000> .PERIOD  Because <sil=0.000> here <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=0.000> the <sil=0.000> star <sil=0.000> symbol <sil=0.000> as <sil=0.000> well <sil=0.000> as <sil=0.000> dot <sil=0.000> symbol <sil=1.000> ,COMMA  now <sil=0.000> this <sil=0.000> dot <sil=0.000> has <sil=0.000> a higher <sil=0.000> precedence <sil=0.000> than <sil=0.000> star <sil=1.000> ,COMMA  what <sil=0.000> does <sil=0.000> it <sil=0.000> mean <sil=0.228> ?QUESTIONMARK 

It <sil=0.000> means <sil=0.000> that <sil=0.000> if <sil=0.000> I have <sil=0.000> got <sil=0.000> something <sil=0.000> like <sil=0.000> ptr <sil=0.000> roll <sil=0.000> and <sil=0.000> star <sil=0.000> ptr <sil=0.000> dot <sil=0.000> roll <sil=0.000> the <sil=0.000> dot <sil=0.000> will <sil=0.000> have <sil=0.000> a higher
precedence <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  these <sil=0.000> two <sil=0.000> are <sil=0.000> the <sil=0.000> same <sil=0.000> thing - ptr <sil=0.000> roll (ptr <sil=0.000> is <sil=0.000> a pointer <sil=0.000> and <sil=0.000> the <sil=0.000> roll <sil=0.000> is <sil=0.000> that
particular <sil=0.000> field) and <sil=0.000> star <sil=0.000> ptr <sil=0.000> is <sil=0.000> what <sil=0.228> ?QUESTIONMARK  Star <sil=0.000> ptr <sil=0.000> is <sil=0.000> the <sil=0.000> particular <sil=0.000> structure <sil=1.000> ,COMMA  and <sil=0.000> I am <sil=0.000> going <sil=0.000> to <sil=0.000> the <sil=0.000> roll
field <sil=0.000> of <sil=0.000> that <sil=0.000> structure <sil=2.000> .PERIOD 

But <sil=0.000> if <sil=0.000> I had <sil=0.000> done <sil=0.000> this <sil=0.000> that <sil=0.000> would <sil=0.000> be <sil=0.000> an <sil=0.000> error <sil=0.000> why <sil=0.228> ?QUESTIONMARK  That <sil=0.000> would <sil=0.000> be <sil=0.000> an <sil=0.000> error <sil=0.000> because <sil=0.000> this <sil=0.000> dot
operator <sil=0.000> has <sil=0.000> got <sil=0.000> higher <sil=0.000> precedence <sil=0.000> than <sil=0.000> this <sil=0.000> star <sil=0.000> operator <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  basically <sil=0.000> I will <sil=0.000> try <sil=0.000> to <sil=0.000> get <sil=0.000> the <sil=0.000> role
filled <sil=0.000> from <sil=0.000> the <sil=0.000> pointer <sil=0.000> p t <sil=0.000> r <sil=1.000> ,COMMA  but <sil=0.000> that <sil=0.000> is <sil=0.000> not <sil=0.000> the <sil=0.000> case <sil=1.000> ,COMMA  there <sil=0.000> is <sil=0.000> no <sil=0.000> roll <sil=0.000> field <sil=0.000> inside <sil=0.000> the <sil=0.000> pointer <sil=0.000> p t <sil=0.000> r <sil=2.000> .PERIOD 
The <sil=0.000> roll <sil=0.000> field <sil=0.000> is <sil=0.000> there <sil=0.000> in <sil=0.000> the <sil=0.000> content <sil=0.000> of <sil=0.000> the <sil=0.000> pointer <sil=0.000> ptr <sil=0.000> that <sil=0.000> is <sil=0.000> star <sil=0.000> p t <sil=0.000> r <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> must <sil=0.000> make <sil=0.000> first <sil=0.000> star <sil=0.000> ptr <sil=0.000> within <sil=0.000> bracket <sil=0.000> then <sil=0.000> dot <sil=0.000> roll <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> correct <sil=1.000> ,COMMA  but <sil=0.000> this <sil=0.000> is <sil=0.000> wrong <sil=0.000> the
and <sil=0.000> the <sil=0.000> operator <sil=0.000> arrow <sil=0.000> enjoys <sil=0.000> the <sil=0.000> highest <sil=0.000> priority <sil=0.000> among <sil=0.000> operators <sil=0.000> among <sil=0.000> all <sil=0.000> these <sil=0.000> operators <sil=0.000> it
has <sil=0.000> got <sil=0.000> the <sil=0.000> highest <sil=0.000> priority <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> in <sil=0.000> this <sil=0.000> case <sil=0.000> what <sil=0.000> will <sil=0.000> happen <sil=0.228> ?QUESTIONMARK  plus <sil=0.000> plus <sil=0.000> ptr <sil=0.000> arrow <sil=0.000> roll - as <sil=0.000> we <sil=0.000> have <sil=0.000> said <sil=0.000> that <sil=0.000> this <sil=0.000> has <sil=0.000> got <sil=0.000> the <sil=0.000> highest <sil=0.000> priority <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> go <sil=0.000> to <sil=0.000> where <sil=0.000> the <sil=0.000> ptr <sil=0.000> is <sil=0.000> and <sil=0.000> go <sil=0.000> to <sil=0.000> the <sil=0.000> roll <sil=0.000> field <sil=0.000> of <sil=0.000> that <sil=0.000> and <sil=0.000> after <sil=0.000> that <sil=0.000> we <sil=0.000> will <sil=0.000> increment <sil=0.000> this <sil=0.000> plus <sil=0.000> plus <sil=1.000> ,COMMA  although <sil=0.000> it <sil=0.000> is <sil=0.000> shown <sil=0.000> as <sil=0.000> a pre <sil=0.000> increment <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  that <sil=0.000> will <sil=0.000> not <sil=0.000> have
higher <sil=0.000> precedence <sil=0.000> than <sil=0.000> the <sil=0.000> arrow <sil=0.000> operator <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  if <sil=0.000> I want <sil=0.000> to <sil=0.000> first <sil=0.000> increment <sil=0.000> the <sil=0.000> ptr <sil=0.000> and <sil=0.000> then <sil=0.000> get <sil=0.000> the <sil=0.000> roll <sil=1.000> ,COMMA  then <sil=0.000> I should <sil=0.000> do <sil=0.000> plus <sil=0.000> plus <sil=0.000> ptr <sil=0.000> arrow
roll <sil=0.000> which <sil=0.000> will <sil=0.000> do <sil=0.000> the <sil=0.000> intended <sil=0.000> thing <sil=1.000> ,COMMA  I <sil=0.000> hope <sil=0.000> this <sil=0.000> is <sil=0.000> clear <sil=0.000> this <sil=0.000> part <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  structures <sil=0.000> and <sil=0.000> functions <sil=2.000> .PERIOD  Structures <sil=0.000> can <sil=0.000> be <sil=0.000> passed <sil=0.000> as <sil=0.000> argument <sil=0.000> to <sil=0.000> a function <sil=0.000> and <sil=0.000> a function <sil=0.000> that <sil=0.000> we <sil=0.000> have <sil=0.000> already <sil=0.000> seen <sil=2.000> .PERIOD  A <sil=0.000> function <sil=0.000> can <sil=0.000> also <sil=0.000> return <sil=0.000> a structure <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> seen <sil=0.000> that <sil=0.000> using <sil=0.000> two <sil=0.000> complex <sil=0.000> numbers <sil=0.000> how <sil=0.000> we <sil=0.000> can <sil=0.000> do <sil=0.000> that <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> again <sil=0.000> we <sil=0.000> look <sil=0.000> at <sil=0.000> that <sil=0.000> example <sil=0.000> that <sil=0.000> we <sil=0.000> have <sil=0.000> got <sil=0.000> a complex <sil=0.000> structure <sil=0.000> with <sil=0.000> two <sil=0.000> fields <sil=2.000> .PERIOD  I
have <sil=0.000> now <sil=0.000> changed <sil=0.000> the <sil=0.000> names - float <sil=0.000> r e <sil=0.000> and <sil=0.000> float <sil=0.000> i m <sil=1.000> ,COMMA  and <sil=0.000> in <sil=0.000> the <sil=0.000> main <sil=0.000> function <sil=0.000> I am <sil=0.000> scanning

and <sil=0.000> a dot <sil=0.000> r e <sil=1.000> ,COMMA  real <sil=0.000> part <sil=0.000> of <sil=0.000> a <sil=1.000> ,COMMA  imaginary <sil=0.000> part <sil=0.000> of <sil=0.000> a <sil=1.000> ,COMMA  then <sil=0.000> real <sil=0.000> part <sil=0.000> of <sil=0.000> b then <sil=0.000> imaginary <sil=0.000> part <sil=0.000> of <sil=0.000> b and
then <sil=0.000> I call <sil=0.000> the <sil=0.000> function <sil=0.000> add <sil=0.000> a b <sil=2.000> .PERIOD  What <sil=0.000> is <sil=0.000> happening <sil=0.000> here <sil=0.000> when <sil=0.000> I call <sil=0.000> this <sil=0.000> add <sil=0.000> a b <sil=0.228> ?QUESTIONMARK  What <sil=0.000> am <sil=0.000> I
passing <sil=0.228> ?QUESTIONMARK <sil=0.000> I am <sil=0.000> passing <sil=0.000> a b <sil=0.000> and <sil=0.000> here <sil=0.000> x y <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> a call <sil=0.000> by <sil=0.000> value <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> this <sil=0.000> is <sil=0.000> copied <sil=0.354> ;SEMICOLON  now <sil=0.000> i have <sil=0.000> struct <sil=0.000> complex <sil=0.000> x y (there <sil=0.000> is <sil=0.000> no
problem <sil=0.000> here <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> like <sil=0.000> swap <sil=0.000> I just <sil=0.000> want <sil=0.000> to <sil=0.000> add) <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> two <sil=0.000> internal <sil=0.000> variables <sil=0.000> x and <sil=0.000> y
and <sil=0.000> t <sil=1.000> ,COMMA  that <sil=0.000> new <sil=0.000> structure <sil=0.000> t is <sil=0.000> taking <sil=0.000> x s <sil=0.000> real <sil=0.000> part <sil=0.000> and <sil=0.000> y s <sil=0.000> real <sil=0.000> part <sil=1.000> ,COMMA  then <sil=0.000> I am <sil=0.000> getting <sil=0.000> the <sil=0.000> real <sil=0.000> part
of <sil=0.000> t and <sil=0.000> in <sil=0.000> the <sil=0.000> imaginary <sil=0.000> part <sil=0.000> of <sil=0.000> t there <sil=0.000> is <sil=0.000> nothing <sil=0.000> here <sil=2.000> .PERIOD  There <sil=0.000> is <sil=0.000> an <sil=0.000> excess <sil=0.000> space <sil=2.000> .PERIOD  In <sil=0.000> the
imaginary <sil=0.000> part <sil=0.000> of <sil=0.000> t <sil=1.000> ,COMMA  I <sil=0.000> take <sil=0.000> the <sil=0.000> imaginary <sil=0.000> part <sil=0.000> of <sil=0.000> x and <sil=0.000> the <sil=0.000> imaginary <sil=0.000> part <sil=0.000> of <sil=0.000> y <sil=1.000> ,COMMA  then <sil=0.000> I am <sil=0.000> returning
this <sil=0.000> t to <sil=0.000> c <sil=1.000> ,COMMA  where <sil=0.000> c is <sil=0.000> also <sil=0.000> of <sil=0.000> type <sil=0.000> complex <sil=0.000> since <sil=0.000> the <sil=0.000> types <sil=0.000> are <sil=0.000> matching <sil=1.000> ,COMMA  I <sil=0.000> can <sil=0.000> pass <sil=0.000> it <sil=0.000> on <sil=0.000> over
there <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> one <sil=0.000> way <sil=0.000> of <sil=0.000> adding <sil=0.000> the <sil=0.000> complex <sil=0.000> numbers <sil=2.000> .PERIOD  Now <sil=0.000> if <sil=0.000> this <sil=0.000> is <sil=0.000> clear <sil=1.000> ,COMMA  now <sil=0.000> let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> an
alternative <sil=0.000> way <sil=0.000> of <sil=0.000> using <sil=0.000> the <sil=0.000> pointers <sil=2.000> .PERIOD 

Here <sil=0.000> I just <sil=0.000> changed <sil=0.000> this <sil=1.000> ,COMMA  other <sil=0.000> things <sil=0.000> are <sil=0.000> the <sil=0.000> same <sil=2.000> .PERIOD  What <sil=0.000> I am <sil=0.000> doing <sil=0.000> here <sil=0.000> is <sil=0.000> I have <sil=0.000> called <sil=0.000> them <sil=1.000> ,COMMA 
passing <sil=0.000> the <sil=0.000> address <sil=1.000> ,COMMA  now <sil=0.000> I am <sil=0.000> passing <sil=0.000> the <sil=0.000> pointers <sil=2.000> .PERIOD  In <sil=0.000> the <sil=0.000> earlier <sil=0.000> case <sil=0.000> I was <sil=0.000> passing <sil=0.000> the <sil=0.000> value
here <sil=0.000> and <sil=0.000> now <sil=0.000> I am <sil=0.000> passing <sil=0.000> the <sil=0.000> pointers <sil=2.000> .PERIOD  I <sil=0.000> am <sil=0.000> passing <sil=0.000> address <sil=0.000> of <sil=0.000> a <sil=1.000> ,COMMA  address <sil=0.000> of <sil=0.000> b and <sil=0.000> address <sil=0.000> of <sil=0.000> c <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  inside <sil=0.000> this <sil=0.000> add <sil=0.000> function <sil=1.000> ,COMMA  what <sil=0.000> am <sil=0.000> I doing <sil=0.228> ?QUESTIONMARK  I <sil=0.000> am <sil=0.000> taking <sil=0.000> x and <sil=0.000> y <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  these <sil=0.000> are <sil=0.000> pointers <sil=2.000> .PERIOD  I <sil=0.000> am
taking <sil=0.000> them <sil=0.000> and <sil=0.000> t <sil=1.000> ,COMMA  t <sil=0.000> is <sil=0.000> real <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  t <sil=0.000> is <sil=0.000> a pointer <sil=0.000> that <sil=0.000> is <sil=0.000> pointing <sil=0.000> to <sil=0.000> another <sil=0.000> structure <sil=0.000> of <sil=0.000> the <sil=0.000> type <sil=0.000> complex <sil=0.000> and <sil=0.000> t is <sil=0.000> r e <sil=1.000> ,COMMA  t <sil=0.000> arrow <sil=0.000> r e
means <sil=0.000> a real <sil=0.000> field <sil=0.000> of <sil=0.000> this <sil=0.000> t <sil=1.000> ,COMMA  will <sil=0.000> be <sil=0.000> taking <sil=0.000> the <sil=0.000> real <sil=0.000> part <sil=0.000> of <sil=0.000> x and <sil=0.000> real <sil=0.000> part <sil=0.000> of <sil=0.000> y <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> x plus <sil=0.000> y <sil=1.000> ,COMMA 
the <sil=0.000> sum <sil=0.000> will <sil=0.000> come <sil=1.000> ,COMMA  this <sil=0.000> the <sil=0.000> real <sil=0.000> part <sil=0.000> of <sil=0.000> x and <sil=0.000> real <sil=0.000> part <sil=0.000> of <sil=0.000> y will <sil=0.000> come <sil=0.000> here <sil=1.000> ,COMMA  and <sil=0.000> here <sil=0.000> the
imaginary <sil=0.000> part <sil=0.000> of <sil=0.000> x and <sil=0.000> y will <sil=0.000> be <sil=0.000> added <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  when <sil=0.000> here <sil=0.000> I am <sil=0.000> not <sil=0.000> returning <sil=0.000> any <sil=0.000> t <sil=1.000> ,COMMA  because <sil=0.000> this <sil=0.000> t is <sil=0.000> nothing <sil=1.000> ,COMMA  but <sil=0.000> this <sil=0.000> c <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> t and <sil=0.000> c are
mapped <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> a call <sil=0.000> by <sil=0.000> reference <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  c <sil=0.000> is <sil=0.000> also <sil=0.000> actually <sil=0.000> pointing <sil=0.000> over <sil=0.000> here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> get <sil=0.000> the <sil=0.000> result
here <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> another <sil=0.000> way <sil=0.000> in <sil=0.000> which <sil=0.000> in <sil=0.000> structures <sil=1.000> ,COMMA  we <sil=0.000> can <sil=0.000> use <sil=0.000> pointers <sil=0.000> also <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  these <sil=0.000> are
relatively <sil=0.000> more <sil=0.000> advanced <sil=0.000> aspects <sil=0.000> and <sil=0.000> you <sil=0.000> will <sil=0.000> gradually <sil=0.000> practice <sil=0.000> this <sil=0.000> and <sil=0.000> we <sil=0.000> will <sil=0.000> get <sil=0.000> familiar <sil=2.000> .PERIOD 

Thank <sil=0.000> you <sil=2.000> .PERIOD 

We <sil=0.000> have <sil=0.000> looked <sil=0.000> at <sil=0.000> pointers <sil=0.000> and <sil=0.000> structures <sil=0.000> in <sil=0.000> detail <sil=0.000> and <sil=0.000> we <sil=0.000> have <sil=0.000> also <sil=0.000> seen <sil=0.000> how <sil=0.000> structures <sil=0.000> can
also <sil=0.000> utilise <sil=0.000> pointers <sil=0.000> or <sil=0.000> in <sil=0.000> other <sil=0.000> words <sil=0.000> how <sil=0.000> pointers <sil=0.000> can <sil=0.000> be <sil=0.000> used <sil=0.000> in <sil=0.000> conjunction <sil=0.000> with <sil=0.000> structures <sil=2.000> .PERIOD 
Now <sil=1.000> ,COMMA  we <sil=0.000> look <sil=0.000> at <sil=0.000> another <sil=0.000> very <sil=0.000> interesting <sil=0.000> use <sil=0.000> of <sil=0.000> pointers <sil=1.000> ,COMMA  but <sil=0.000> in <sil=0.000> general <sil=0.000> let <sil=0.000> me <sil=0.000> say <sil=0.000> that <sil=0.000> it <sil=0.000> is <sil=0.000> a very <sil=0.000> fundamental <sil=0.000> concept <sil=1.000> ,COMMA  from <sil=0.000> the <sil=0.000> memory <sil=0.000> allocation <sil=0.000> point <sil=0.000> of <sil=0.000> view <sil=2.000> .PERIOD 

Dynamic <sil=0.000> memory <sil=0.000> allocation <sil=0.000> is <sil=0.000> what <sil=0.000> we <sil=0.000> will <sil=0.000> be <sil=0.000> discussing <sil=0.000> now <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  what <sil=0.000> if <sil=0.000> there <sil=0.000> is <sil=0.000> a dynamic
memory <sil=0.000> allocation <sil=0.000> then <sil=0.354> ;SEMICOLON  obviously <sil=1.000> ,COMMA  there <sil=0.000> must <sil=0.000> be <sil=0.000> something <sil=0.000> called <sil=0.000> the <sil=0.000> static <sil=0.000> memory <sil=0.000> allocation
now <sil=0.000> what <sil=0.000> is <sil=0.000> static <sil=0.000> memory <sil=0.000> allocation <sil=0.228> ?QUESTIONMARK 

When <sil=0.000> we <sil=0.000> declare <sil=0.000> an <sil=0.000> array <sil=0.000> say <sil=0.000> int <sil=0.000> A 20 <sil=1.000> ,COMMA  you <sil=0.000> know <sil=0.000> that <sil=0.000> the <sil=0.000> compiler <sil=0.000> will <sil=0.000> allocate <sil=0.000> 20 <sil=0.000> locations <sil=1.000> ,COMMA  20
locations <sil=0.000> to <sil=0.000> house <sil=0.000> 20 <sil=0.000> integers <sil=0.000> to <sil=0.000> you <sil=0.000> and <sil=0.000> that <sil=0.000> will <sil=0.000> be <sil=0.000> named <sil=0.000> as <sil=0.000> A or <sil=0.000> you <sil=0.000> can <sil=0.000> also <sil=0.000> consider <sil=0.000> that
there <sil=0.000> is <sil=0.000> a pointer <sil=0.000> A <sil=1.000> ,COMMA  which <sil=0.000> is <sil=0.000> pointing <sil=0.000> to <sil=0.000> the <sil=0.000> first <sil=0.000> element <sil=0.000> of <sil=0.000> the <sil=0.000> array <sil=2.000> .PERIOD  But <sil=0.000> you <sil=0.000> have <sil=0.000> got <sil=0.000> space <sil=0.000> for
20 <sil=0.000> locations <sil=1.000> ,COMMA  20 <sil=0.000> integers <sil=0.000> allocated <sil=0.000> to <sil=0.000> you <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  now <sil=1.000> ,COMMA  you <sil=0.000> know <sil=0.000> size <sil=0.000> of <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  how <sil=0.000> many <sil=0.000> bytes <sil=0.000> will <sil=0.000> be <sil=0.000> required <sil=0.228> ?QUESTIONMARK  You <sil=0.000> can <sil=0.000> say <sil=0.000> 20 <sil=0.000> times <sil=0.000> size <sil=0.000> of
int <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  size <sil=0.000> of <sil=0.000> int <sil=0.000> will <sil=0.000> return <sil=0.000> you <sil=0.000> how <sil=0.000> many <sil=0.000> bytes <sil=0.000> your <sil=0.000> particular <sil=0.000> system <sil=0.000> allocates <sil=0.000> for <sil=0.000> an <sil=0.000> integer
and <sil=0.000> 20 <sil=0.000> such <sil=0.000> allocation <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  so <sil=0.000> many <sil=0.000> bytes <sil=0.000> will <sil=0.000> be <sil=0.000> allocated <sil=0.000> to <sil=0.000> you <sil=2.000> .PERIOD  Now <sil=0.000> when <sil=0.000> that <sil=0.000> is <sil=0.000> statically
allocated <sil=0.000> that <sil=0.000> is <sil=0.000> allocated <sil=0.000> at <sil=0.000> compile <sil=0.000> time <sil=0.354> ;SEMICOLON  so <sil=1.000> ,COMMA  when <sil=0.000> we <sil=0.000> say <sil=0.000> static <sil=0.000> allocation <sil=0.000> that <sil=0.000> means <sil=1.000> ,COMMA 
allocation <sil=0.000> at <sil=0.000> compile <sil=0.000> time <sil=0.000> right <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  if <sil=0.000> for <sil=0.000> some <sil=0.000> reason <sil=0.000> you <sil=0.000> need <sil=0.000> more <sil=0.000> than <sil=0.000> 20 <sil=0.000> integers <sil=0.000> to <sil=0.000> be <sil=0.000> stored <sil=0.000> in <sil=0.000> this <sil=0.000> array <sil=0.000> A  <sil=1.000> ,COMMA  you <sil=0.000> will
need <sil=0.000> to <sil=0.000> redefine <sil=0.000> this <sil=0.000> whole <sil=0.000> thing <sil=0.000> or <sil=0.000> in <sil=0.000> some <sil=0.000> cases <sil=0.000> we <sil=0.000> do <sil=0.000> not <sil=0.000> know <sil=1.000> ,COMMA  we <sil=0.000> do <sil=0.000> not <sil=0.000> have <sil=0.000> an <sil=0.000> idea <sil=0.000> of
how <sil=0.000> many <sil=0.000> date <sil=0.000> data <sil=0.000> items <sil=0.000> will <sil=0.000> come <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  you <sil=0.000> was <sil=0.000> you <sil=0.000> are <sil=0.000> actually <sil=0.000> storing <sil=0.000> student
records <sil=0.000> in <sil=0.000> an <sil=0.000> array <sil=0.000> class <sil=1.000> ,COMMA  and <sil=0.000> you <sil=0.000> do <sil=0.000> not <sil=0.000> know <sil=0.000> how <sil=0.000> many <sil=0.000> students <sil=0.000> will <sil=0.000> join <sil=0.000> that <sil=0.000> class
beforehand <sil=2.000> .PERIOD 

If <sil=0.000> you <sil=0.000> know <sil=0.000> that <sil=0.000> beforehand <sil=0.000> its <sil=0.000> fine <sil=0.000> or <sil=0.000> if <sil=0.000> you <sil=0.000> have <sil=0.000> an <sil=0.000> idea <sil=0.000> that <sil=0.000> what <sil=0.000> is <sil=0.000> the <sil=0.000> maximum <sil=0.000> number <sil=0.000> of
students <sil=0.000> that <sil=0.000> can <sil=0.000> come <sil=1.000> ,COMMA  then <sil=0.000> its <sil=0.000> fine <sil=0.000> you <sil=0.000> can <sil=0.000> allocate <sil=0.000> it <sil=0.000> in <sil=0.000> the <sil=0.000> form <sil=0.000> of <sil=0.000> static <sil=0.000> allocation <sil=0.000> as <sil=0.000> we <sil=0.000> do <sil=0.000> in <sil=0.000> an <sil=0.000> array <sil=2.000> .PERIOD 

However <sil=1.000> ,COMMA  when <sil=0.000> we <sil=0.000> do <sil=0.000> not <sil=0.000> know <sil=0.000> and <sil=0.000> the <sil=0.000> information <sil=0.000> comes <sil=0.000> at <sil=0.000> a runtime <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  when <sil=0.000> is
being <sil=0.000> executed <sil=1.000> ,COMMA  that <sil=0.000> will <sil=0.000> lead <sil=0.000> to <sil=0.000> what <sil=0.000> we <sil=0.000> call <sil=0.000> dynamic <sil=0.000> allocation <sil=0.000> of <sil=0.000> memory <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> look <sil=0.000> at
how <sil=0.000> we <sil=0.000> can <sil=0.000> handle <sil=0.000> it <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  the <sil=0.000> basic <sil=0.000> idea <sil=0.000> is <sil=0.000> I have <sil=0.000> already <sil=0.000> explained <sil=0.000> that <sil=0.000> we <sil=0.000> have <sil=0.000> an <sil=0.000> amount <sil=0.000> of <sil=0.000> data <sil=0.000> we <sil=0.000> cannot <sil=0.000> predict
beforehand <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> use <sil=0.000> effectively <sil=0.000> whose <sil=0.000> dynamic <sil=0.000> memory <sil=0.000> allocation <sil=0.000> technique <sil=0.000> to <sil=0.000> do <sil=0.000> that <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  C <sil=0.000> language <sil=0.000> requires <sil=0.000> a number <sil=0.000> of <sil=0.000> elements <sil=0.000> to <sil=0.000> be <sil=0.000> specified <sil=0.000> in <sil=0.000> compiled <sil=0.000> time <sil=1.000> ,COMMA  when <sil=0.000> we
define <sil=0.000> in <sil=0.000> an <sil=0.000> array <sil=0.000> we <sil=0.000> need <sil=0.000> to <sil=0.000> specify <sil=0.000> that <sil=0.000> in <sil=0.000> compile <sil=0.000> time <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  often <sil=0.000> that <sil=0.000> leads <sil=0.000> to <sil=0.000> wastage <sil=0.000> of
memory <sil=0.000> or <sil=0.000> program <sil=0.000> failure <sil=2.000> .PERIOD  Why <sil=0.000> a program <sil=0.000> failure <sil=0.228> ?QUESTIONMARK  Program <sil=0.000> failure <sil=0.000> will <sil=0.000> occur <sil=0.000> because <sil=0.000> if <sil=0.000> we
exceed <sil=0.000> the <sil=0.000> amount <sil=0.000> of <sil=0.000> space <sil=0.000> that <sil=0.000> has <sil=0.000> been <sil=0.000> allocated <sil=1.000> ,COMMA  there <sil=0.000> will <sil=0.000> be <sil=0.000> a failure <sil=0.000> the <sil=0.000> program <sil=0.000> will <sil=0.000> give
an <sil=0.000> error <sil=0.000> or <sil=0.000> it <sil=0.000> will <sil=0.000> exit <sil=0.000> abnormally <sil=2.000> .PERIOD  However <sil=1.000> ,COMMA  if <sil=0.000> we <sil=0.000> take <sil=0.000> recourse <sil=0.000> to <sil=0.000> dynamic <sil=0.000> memory <sil=0.000> allocation <sil=1.000> ,COMMA 
we <sil=0.000> can <sil=0.000> solve <sil=0.000> this <sil=0.000> problem <sil=0.000> how <sil=0.228> ?QUESTIONMARK  Memory <sil=0.000> space <sil=0.000> required <sil=0.000> can <sil=0.000> be <sil=0.000> specified <sil=0.000> at <sil=0.000> the <sil=0.000> time <sil=0.000> of <sil=0.000> execution
how <sil=0.000> can <sil=0.000> we <sil=0.000> do <sil=0.000> that <sil=1.000> ,COMMA  how <sil=0.000> can <sil=0.000> I specify <sil=0.000> the <sil=0.000> amount <sil=0.000> of <sil=0.000> memory <sil=0.000> required <sil=0.000> at <sil=0.000> the <sil=0.000> time <sil=0.000> of <sil=0.000> execution <sil=0.228> ?QUESTIONMARK 

If <sil=0.000> while <sil=0.000> running <sil=0.000> the <sil=0.000> program <sil=1.000> ,COMMA  just <sil=0.000> like <sil=0.000> the <sil=0.000> instructions <sil=0.000> and <sil=0.000> operators <sil=1.000> ,COMMA  if <sil=0.000> we <sil=0.000> had <sil=0.000> some <sil=0.000> special
means <sil=1.000> ,COMMA  some <sil=0.000> special <sil=0.000> command <sil=1.000> ,COMMA  some <sil=0.000> special <sil=0.000> operator <sil=0.000> by <sil=0.000> which <sil=0.000> we <sil=0.000> can <sil=0.000> grab <sil=0.000> memory <sil=0.000> then <sil=0.000> it s
possible <sil=2.000> .PERIOD  Now <sil=0.000> here <sil=0.000> you <sil=0.000> should <sil=0.000> understand <sil=0.000> that <sil=0.000> who <sil=0.000> allocates <sil=0.000> memory <sil=0.000> to <sil=0.000> us <sil=0.228> ?QUESTIONMARK  It <sil=0.000> is <sil=0.000> the <sil=0.000> operating
system <sil=0.000> which <sil=0.000> allocates <sil=0.000> the <sil=0.000> memory <sil=0.000> to <sil=0.000> us <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> like <sil=0.000> the <sil=0.000> print <sil=0.000> f <sil=1.000> ,COMMA  scan <sil=0.000> f all <sil=0.000> those <sil=0.000> things <sil=0.000> are <sil=0.000> system <sil=0.000> calls <sil=2.000> .PERIOD  We <sil=0.000> are <sil=0.000> making <sil=0.000> calls <sil=0.000> to <sil=0.000> the
operating <sil=0.000> system <sil=1.000> ,COMMA  which <sil=0.000> is <sil=0.000> doing <sil=0.000> the <sil=0.000> required <sil=0.000> thing <sil=0.000> for <sil=0.000> us <sil=2.000> .PERIOD  Similarly <sil=0.000> there <sil=0.000> is <sil=0.000> a function <sil=0.000> called
Malloc - Memory <sil=0.000> Allocated <sil=1.000> ,COMMA  malloc <sil=0.000> using <sil=0.000> which <sil=0.000> we <sil=0.000> can <sil=0.000> grab <sil=0.000> memory <sil=0.000> from <sil=0.000> the <sil=0.000> operating <sil=0.000> system
how <sil=0.000> let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=2.000> .PERIOD 

In <sil=0.000> memory <sil=0.000> in <sil=0.000> C <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> different <sil=0.000> types <sil=0.000> of <sil=0.000> variables <sil=0.000> that <sil=0.000> is <sil=0.000> not <sil=0.000> so <sil=1.000> ,COMMA  much <sil=0.000> relevant <sil=0.000> right <sil=0.000> now <sil=2.000> .PERIOD 
What <sil=0.000> is <sil=0.000> needed <sil=0.000> is <sil=0.000> this <sil=0.000> part <sil=2.000> .PERIOD  These <sil=0.000> global <sil=0.000> variables <sil=0.000> and <sil=0.000> instructions <sil=0.000> are <sil=0.000> there <sil=0.000> always <sil=0.000> specified <sil=2.000> .PERIOD 

The <sil=0.000> local <sil=0.000> variables <sil=0.000> are <sil=0.000> there <sil=0.000> and <sil=0.000> there <sil=0.000> is <sil=0.000> some <sil=0.000> free <sil=0.000> memory <sil=2.000> .PERIOD  We <sil=0.000> can <sil=0.000> take <sil=0.000> from <sil=0.000> this <sil=0.000> free <sil=0.000> memory <sil=0.000> and <sil=0.000> use <sil=0.000> them <sil=0.000> as <sil=0.000> our <sil=0.000> local <sil=0.000> variables <sil=2.000> .PERIOD  The <sil=0.000> free <sil=0.000> region <sil=0.000> is <sil=0.000> has <sil=0.000> got <sil=0.000> a name <sil=0.000> heap <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  the <sil=0.000> most <sil=0.000> important <sil=0.000> thing <sil=0.000> is <sil=0.000> that <sil=0.000> we <sil=0.000> need <sil=0.000> some <sil=0.000> functions <sil=1.000> ,COMMA  which <sil=0.000> will <sil=0.000> give <sil=0.000> my <sil=0.000> program
some <sil=0.000> memory <sil=0.000> addresses <sil=0.000> or <sil=0.000> memory <sil=0.000> blocks <sil=0.000> from <sil=0.000> the <sil=0.000> operating <sil=0.000> system <sil=0.000> storage <sil=0.000> of <sil=0.000> memory <sil=1.000> ,COMMA  which <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> heap <sil=0.000> from <sil=0.000> there <sil=0.000> it <sil=0.000> will <sil=0.000> be <sil=0.000> allocated <sil=0.000> to <sil=0.000> my <sil=0.000> program <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  for <sil=0.000> that <sil=0.000> we <sil=0.000> have <sil=0.000> got <sil=0.000> four <sil=0.000> different <sil=0.000> functions - one <sil=0.000> is <sil=0.000> malloc <sil=1.000> ,COMMA  what <sil=0.000> does <sil=0.000> malloc <sil=0.000> do <sil=0.228> ?QUESTIONMARK  Malloc
allocates <sil=0.000> the <sil=0.000> requested <sil=0.000> number <sil=0.000> of <sil=0.000> bytes <sil=0.000> and <sil=0.000> returns <sil=0.000> a pointer <sil=0.000> to <sil=0.000> the <sil=0.000> first <sil=0.000> byte <sil=0.000> of <sil=0.000> the <sil=0.000> allocated
space <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> it <sil=0.000> does <sil=0.000> is <sil=0.000> something <sil=0.000> like <sil=0.000> this <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> happening <sil=0.228> ?QUESTIONMARK  (Refer <sil=0.000> Time: 08:31) <sil=2.000> .PERIOD  Malloc
allocates <sil=0.000> a requested <sil=0.000> number <sil=0.000> of <sil=0.000> bytes <sil=0.000> and <sil=0.000> returns <sil=0.000> a pointer <sil=0.000> to <sil=0.000> the <sil=0.000> first <sil=0.000> byte <sil=0.000> of <sil=0.000> the <sil=0.000> allocated <sil=0.000> space <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> try <sil=0.000> to <sil=0.000> explain <sil=0.000> this <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  when <sil=0.000> I do <sil=0.000> malloc <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> just <sil=0.000> like <sil=0.000> a function <sil=0.000> and <sil=0.000> it <sil=0.000> will <sil=0.000> return <sil=0.000> some <sil=0.000> memory <sil=0.000> bytes  <sil=1.000> ,COMMA  some
memory <sil=0.000> bytes <sil=2.000> .PERIOD  How <sil=0.000> many <sil=0.000> memory <sil=0.000> bytes <sil=0.228> ?QUESTIONMARK  It <sil=0.000> will <sil=0.000> depend <sil=0.000> on <sil=1.000> ,COMMA  what <sil=0.000> I am <sil=0.000> requesting <sil=0.000> for <sil=2.000> .PERIOD  It <sil=0.000> is <sil=0.000> a
requested <sil=0.000> number <sil=0.000> of <sil=0.000> bytes <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  malloc <sil=0.000> will <sil=0.000> have <sil=0.000> some <sil=0.000> parameters <sil=0.000> which <sil=0.000> will <sil=0.000> show <sil=0.000> later <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> give <sil=0.000> some <sil=0.000> give <sil=0.000> me <sil=0.000> some <sil=0.000> amount <sil=0.000> of <sil=0.000> memory <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  the <sil=0.000> operating <sil=0.000> system <sil=0.000> has <sil=0.000> got <sil=0.000> some
free <sil=0.000> memory <sil=0.000> spread <sil=0.000> here <sil=0.000> and <sil=0.000> there <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  from <sil=0.000> there <sil=0.000> it <sil=0.000> is <sil=0.000> giving <sil=0.000> me <sil=0.000> some <sil=0.000> piece <sil=0.000> of <sil=0.000> memory <sil=1.000> ,COMMA  but

how <sil=0.000> do <sil=0.000> I know <sil=0.000> where <sil=0.000> is <sil=0.000> that <sil=0.000> piece <sil=0.000> of <sil=0.000> memory <sil=0.228> ?QUESTIONMARK  For <sil=0.000> that <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> returning <sil=0.000> me <sil=0.000> a pointer <sil=0.000> say <sil=0.000> pointer <sil=0.000> p
which <sil=0.000> is <sil=0.000> telling <sil=0.000> me <sil=0.000> that <sil=0.000> if <sil=0.000> you <sil=0.000> follow <sil=0.000> this <sil=0.000> pointer <sil=1.000> ,COMMA  you <sil=0.000> will <sil=0.000> get <sil=0.000> this <sil=0.000> piece <sil=0.000> of <sil=0.000> memory <sil=0.000> location <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> proceed <sil=0.000> a little <sil=0.000> bit <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  similarly <sil=0.000> when <sil=0.000> this <sil=0.000> memory <sil=0.000> block <sil=0.000> is <sil=0.000> given <sil=0.000> in <sil=0.000> response <sil=0.000> to <sil=0.000> malloc <sil=0.000> request <sil=1.000> ,COMMA  the <sil=0.000> actual
memory <sil=0.000> is <sil=0.000> not <sil=0.000> initialised <sil=0.000> to <sil=0.000> some <sil=0.000> value <sil=2.000> .PERIOD  It <sil=0.000> can <sil=0.000> have <sil=0.000> any <sil=0.000> garbage <sil=0.000> value <sil=2.000> .PERIOD  But <sil=0.000> if <sil=0.000> I apply <sil=0.000> calloc <sil=0.354> ;SEMICOLON 
then <sil=0.000> it <sil=0.000> allocates <sil=0.000> space <sil=0.000> for <sil=0.000> the <sil=0.000> array <sil=0.000> of <sil=0.000> elements <sil=0.000> and <sil=0.000> initialises <sil=0.000> them <sil=0.000> to <sil=0.000> zero <sil=0.000> and <sil=0.000> returns <sil=0.000> a pointer <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  in <sil=0.000> this <sil=0.000> case <sil=0.000> if <sil=0.000> I want <sil=0.000> to <sil=0.000> have <sil=0.000> a chunk <sil=0.000> of <sil=0.000> memory <sil=0.000> where <sil=0.000> everything <sil=0.000> has <sil=0.000> been <sil=0.000> initialised <sil=0.000> to <sil=0.000> zero <sil=0.000> then <sil=0.000> I should <sil=0.000> use <sil=0.000> calloc <sil=2.000> .PERIOD  On <sil=0.000> the <sil=0.000> other <sil=0.000> hand <sil=0.000> the <sil=0.000> free <sil=0.000> function <sil=0.000> call <sil=0.000> will <sil=0.000> return <sil=0.000> this <sil=0.000> amount <sil=0.000> of
memory <sil=1.000> ,COMMA  that <sil=0.000> was <sil=0.000> given <sil=0.000> to <sil=0.000> me <sil=0.000> in <sil=0.000> request <sil=0.000> to <sil=0.000> malloc <sil=1.000> ,COMMA  will <sil=0.000> be <sil=0.000> returned <sil=0.000> back <sil=0.000> to <sil=0.000> the <sil=0.000> heap <sil=1.000> ,COMMA  returned
back <sil=0.000> to <sil=0.000> the <sil=0.000> operating <sil=0.000> system <sil=0.000> so <sil=1.000> ,COMMA  that <sil=0.000> it <sil=0.000> can <sil=0.000> be <sil=0.000> utilised <sil=0.000> by <sil=0.000> somebody <sil=0.000> else <sil=0.000> in <sil=0.000> future <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD 

So <sil=0.000> realloc <sil=0.000> modifies <sil=0.000> the <sil=0.000> size <sil=0.000> of <sil=0.000> the <sil=0.000> previously <sil=0.000> allocated <sil=0.000> space <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> some <sil=0.000> allocation <sil=0.000> and <sil=0.000> then <sil=0.000> I think <sil=0.000> that <sil=0.000> allocation <sil=0.000> is <sil=0.000> not <sil=0.000> enough <sil=2.000> .PERIOD  I <sil=0.000> want <sil=0.000> to <sil=0.000> change <sil=0.000> it <sil=2.000> .PERIOD  I <sil=0.000> can <sil=0.000> use <sil=0.000> realloc <sil=2.000> .PERIOD  However <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> be <sil=0.000> mostly <sil=0.000> concerned <sil=0.000> with <sil=0.000> malloc <sil=0.000> and <sil=0.000> free <sil=0.000> in <sil=0.000> our <sil=0.000> discussion <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  a <sil=0.000> block <sil=0.000> of <sil=0.000> memory <sil=0.000> can <sil=0.000> be <sil=0.000> allocated <sil=0.000> using <sil=0.000> the <sil=0.000> function <sil=0.000> malloc <sil=0.000> and <sil=0.000> it <sil=0.000> reserves <sil=0.000> a block <sil=0.000> of
memory <sil=0.000> and <sil=0.000> returns <sil=0.000> a pointer <sil=0.000> of <sil=0.000> type <sil=0.000> void <sil=2.000> .PERIOD  You <sil=0.000> know <sil=0.000> every <sil=0.000> pointer <sil=0.000> has <sil=0.000> got <sil=0.000> some <sil=0.000> type <sil=1.000> ,COMMA  but <sil=0.000> in
this <sil=0.000> case <sil=0.000> with <sil=0.000> malloc <sil=0.000> returns <sil=0.000> some <sil=0.000> memory <sil=0.000> block <sil=1.000> ,COMMA  the <sil=0.000> pointer <sil=0.000> that <sil=0.000> it <sil=0.000> has <sil=0.000> returned <sil=0.000> is <sil=0.000> of <sil=0.000> type <sil=0.000> void <sil=1.000> ,COMMA 
but <sil=0.000> then <sil=0.000> we <sil=0.000> have <sil=0.000> to <sil=0.000> do <sil=0.000> something <sil=2.000> .PERIOD  What <sil=0.000> we <sil=0.000> need <sil=0.000> to <sil=0.000> do <sil=0.228> ?QUESTIONMARK  I <sil=0.000> know <sil=0.000> why <sil=0.000> I needed <sil=0.000> this <sil=0.000> memory <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
accordingly <sil=0.000> I will <sil=0.000> have <sil=0.000> to <sil=0.000> do <sil=0.000> that <sil=0.000> typecasting <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  once <sil=0.000> it <sil=0.000> returns <sil=0.000> me <sil=0.000> of <sil=0.000> type <sil=0.000> void <sil=1.000> ,COMMA  but <sil=0.000> that <sil=0.000> return
pointer <sil=0.000> can <sil=0.000> be <sil=0.000> assigned <sil=0.000> to <sil=0.000> any <sil=0.000> pointer <sil=0.000> type <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> you <sil=0.000> see <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> please <sil=0.000> note <sil=1.000> ,COMMA  malloc <sil=0.000> has <sil=0.000> got <sil=0.000> a parameter <sil=0.000> of <sil=0.000> byte <sil=0.000> size - how <sil=0.000> much <sil=0.000> memory <sil=0.000> I want <sil=1.000> ,COMMA  the
amount <sil=0.000> of <sil=0.000> bytes <sil=0.000> which <sil=0.000> is <sil=0.000> required <sil=2.000> .PERIOD  Now <sil=0.000> this <sil=0.000> malloc <sil=0.000> has <sil=0.000> returned <sil=0.000> me <sil=0.000> up <sil=0.000> to <sil=0.000> this <sil=1.000> ,COMMA  it <sil=0.000> has <sil=0.000> returned
me <sil=0.000> a pointer <sil=0.000> and <sil=0.000> pointer <sil=0.000> is <sil=0.000> of <sil=0.000> type <sil=0.000> void <sil=1.000> ,COMMA  but <sil=0.000> suppose <sil=0.000> if <sil=0.000> this <sil=0.000> amount <sil=0.000> of <sil=0.000> memory <sil=0.000> I want <sil=0.000> for <sil=0.000> the
purpose <sil=0.000> of <sil=0.000> storing <sil=0.000> integer <sil=0.000> array <sil=0.000> then <sil=0.000> this <sil=0.000> type <sil=0.000> will <sil=0.000> be <sil=0.000> int <sil=0.000> star <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> casting <sil=0.000> this <sil=2.000> .PERIOD  What <sil=0.000> is <sil=0.000> malloc <sil=0.000> returning <sil=0.228> ?QUESTIONMARK  Malloc <sil=0.000> is <sil=0.000> returning <sil=0.000> a pointer <sil=1.000> ,COMMA  some <sil=0.000> pointer <sil=1.000> ,COMMA  but <sil=0.000> that <sil=0.000> pointer <sil=0.000> was <sil=0.000> of <sil=0.000> type <sil=0.000> void <sil=2.000> .PERIOD  Now <sil=0.000> when <sil=0.000> I am <sil=0.000> typecasting <sil=0.000> it <sil=0.000> to <sil=0.000> int <sil=0.000> star <sil=1.000> ,COMMA  then <sil=0.000> this <sil=0.000> void <sil=0.000> is <sil=0.000> no <sil=0.000> longer <sil=0.000> it s <sil=0.000> type <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> becoming <sil=0.000> of <sil=0.000> type <sil=0.000> int <sil=0.000> and <sil=0.000> then <sil=0.000> I am <sil=0.000> assigning <sil=0.000> it <sil=0.000> to <sil=0.000> another <sil=0.000> variable <sil=0.000> p t <sil=0.000> r <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  think <sil=0.000> of <sil=0.000> two <sil=0.000> things <sil=1.000> ,COMMA  first <sil=0.000> of <sil=0.000> all <sil=0.000> you <sil=0.000> have <sil=0.000> to <sil=0.000> decide <sil=0.000> on <sil=0.000> how <sil=0.000> many <sil=0.000> bytes <sil=0.000> you <sil=0.000> want <sil=2.000> .PERIOD  Accordingly
you <sil=0.000> do <sil=0.000> malloc <sil=0.000> and <sil=0.000> then <sil=0.000> what <sil=0.000> type <sil=0.000> of <sil=0.000> data <sil=0.000> you <sil=0.000> want <sil=0.000> to <sil=0.000> store <sil=0.000> there <sil=0.228> ?QUESTIONMARK  So <sil=1.000> ,COMMA  accordingly <sil=0.000> you <sil=0.000> do <sil=0.000> this
typecasting <sil=0.000> like <sil=0.000> int <sil=0.000> star <sil=1.000> ,COMMA  float <sil=0.000> star <sil=1.000> ,COMMA  char <sil=0.000> star <sil=0.000> whatever <sil=0.000> you <sil=0.000> do <sil=0.000> and <sil=0.000> then <sil=0.000> you <sil=0.000> assign <sil=0.000> it <sil=0.000> to <sil=0.000> a particular
pointer <sil=2.000> .PERIOD  Let <sil=0.000> us <sil=0.000> see <sil=0.000> how <sil=0.000> it <sil=0.000> will <sil=0.000> work <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> look <sil=0.000> an <sil=0.000> example <sil=2.000> .PERIOD   <sil=2.000> .PERIOD 

Here <sil=1.000> ,COMMA  how <sil=0.000> do <sil=0.000> I know <sil=0.000> how <sil=0.000> many <sil=0.000> bytes <sil=0.000> I need <sil=0.228> ?QUESTIONMARK  Suppose <sil=0.000> I need <sil=0.000> to <sil=0.000> store <sil=0.000> an <sil=0.000> element <sil=0.000> an <sil=0.000> array <sil=0.000> of <sil=0.000> 100 <sil=0.000> integers <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> I do <sil=0.000> here <sil=0.000> is <sil=0.000> I ask <sil=0.000> for <sil=0.000> malloc <sil=0.000> 100 <sil=0.000> times <sil=0.000> size <sil=0.000> of <sil=0.000> int <sil=1.000> ,COMMA  size <sil=0.000> of <sil=0.000> int <sil=0.000> if <sil=0.000> it <sil=0.000> is <sil=0.000> 4 <sil=1.000> ,COMMA  if <sil=0.000> int <sil=0.000> is <sil=0.000> 4 then <sil=0.000> I am <sil=0.000> getting <sil=0.000> 400 <sil=0.000> bytes <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  these <sil=0.000> 400 <sil=0.000> bytes <sil=0.000> that <sil=0.000> have <sil=0.000> been <sil=0.000> given <sil=0.000> to <sil=0.000> me <sil=0.000> is <sil=0.000> being <sil=0.000> pointed <sil=0.000> by <sil=0.000> some <sil=0.000> pointer <sil=0.000> of <sil=0.000> type <sil=0.000> void <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  next <sil=0.000> I make <sil=0.000> it <sil=0.000> int <sil=0.000> star <sil=0.000> and <sil=0.000> put <sil=0.000> it <sil=0.000> to <sil=0.000> p <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  p <sil=0.000> is <sil=0.000> now <sil=0.000> an <sil=0.000> integer <sil=0.000> pointer <sil=0.000> that <sil=0.000> is <sil=0.000> pointing <sil=0.000> to <sil=0.000> this
entire <sil=0.000> block <sil=0.000> of <sil=0.000> 400 <sil=0.000> integers <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  a <sil=0.000> memory <sil=0.000> space <sil=0.000> equivalent <sil=0.000> to <sil=0.000> 100 <sil=0.000> times <sil=0.000> the <sil=0.000> size <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> got <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> 400 <sil=0.000> bytes <sil=0.000> of <sil=0.000> space
and <sil=0.000> p is <sil=0.000> a pointer <sil=0.000> pointing <sil=0.000> to <sil=0.000> the <sil=0.000> beginning <sil=0.000> of <sil=0.000> this <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> this <sil=0.000> just <sil=0.000> using <sil=0.000> malloc <sil=1.000> ,COMMA  it <sil=0.000> was
not <sil=0.000> declared <sil=0.000> beforehand <sil=2.000> .PERIOD 

Now <sil=0.000> so <sil=1.000> ,COMMA  this <sil=0.000> 100 <sil=0.000> can <sil=0.000> also <sil=0.000> be <sil=0.000> a variable <sil=0.000> n <sil=1.000> ,COMMA  if <sil=0.000> I read <sil=0.000> a particular <sil=0.000> variable <sil=0.000> n now <sil=0.000> how <sil=0.000> many <sil=0.000> students
are <sil=0.000> there <sil=0.228> ?QUESTIONMARK  scan <sil=0.000> f m <sil=0.000> and <sil=0.000> n <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> read <sil=0.000> the <sil=0.000> number <sil=0.000> of <sil=0.000> students <sil=1.000> ,COMMA  then <sil=0.000> I can <sil=0.000> multiply <sil=0.000> that <sil=0.000> with <sil=0.000> n as
well <sil=2.000> .PERIOD 

Next <sil=1.000> ,COMMA  you <sil=0.000> see <sil=0.000> here <sil=0.000> I am <sil=0.000> seeking <sil=0.000> memory <sil=0.000> for <sil=0.000> 20 <sil=0.000> characters <sil=1.000> ,COMMA  I <sil=0.000> do <sil=0.000> malloc <sil=0.000> 20 <sil=0.000> because <sil=0.000> I know <sil=0.000> a
character <sil=0.000> takes <sil=0.000> one <sil=0.000> byte <sil=0.000> and <sil=0.000> then <sil=0.000> the <sil=0.000> pointer <sil=0.000> is <sil=0.000> of <sil=0.000> type <sil=0.000> void <sil=0.000> I am <sil=0.000> typecasting <sil=0.000> it <sil=0.000> to <sil=0.000> type <sil=0.000> character <sil=0.000> char <sil=0.000> star <sil=0.000> and <sil=0.000> assigning <sil=0.000> it <sil=0.000> to <sil=0.000> c p <sil=0.000> t r <sil=2.000> .PERIOD  Now <sil=0.000> it <sil=0.000> is <sil=0.000> actually <sil=0.000> wrong <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> allocating <sil=0.000> 20 <sil=0.000> bytes <sil=0.000> of <sil=0.000> space <sil=0.000> for <sil=0.000> the <sil=0.000> pointer <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  integer <sil=0.000> character <sil=0.000> was <sil=0.000> simple <sil=1.000> ,COMMA  now <sil=0.000> I want <sil=0.000> to <sil=0.000> have <sil=0.000> for <sil=0.000> space <sil=0.000> for <sil=0.000> the <sil=0.000> entire <sil=0.000> structure <sil=0.000> students <sil=1.000> ,COMMA 
now <sil=0.000> that <sil=0.000> size <sil=0.000> is <sil=0.000> larger <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> do <sil=0.000> not <sil=0.000> know <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> just <sil=0.000> have <sil=0.000> employ <sil=0.000> this <sil=0.000> function <sil=0.000> size <sil=0.000> of <sil=0.000> struct <sil=0.000> stud <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> gets <sil=0.000> how <sil=0.000> many <sil=0.000> bytes <sil=0.228> ?QUESTIONMARK  Say <sil=0.000> it <sil=0.000> requires <sil=0.000> say <sil=0.000> 40 <sil=0.000> bytes <sil=0.000> and <sil=0.000> say <sil=0.000> 10 <sil=0.000> such <sil=0.000> for <sil=0.000> 10 <sil=0.000> such <sil=0.000> students <sil=0.000> or <sil=0.000> n such <sil=0.000> students <sil=2.000> .PERIOD  I <sil=0.000> multiply <sil=0.000> with <sil=0.000> that <sil=0.000> I get <sil=0.000> so <sil=1.000> ,COMMA  much <sil=0.000> memory <sil=1.000> ,COMMA  now <sil=0.000> I have <sil=0.000> to <sil=0.000> typecast <sil=0.000> that <sil=0.000> to <sil=0.000> struct <sil=0.000> stud <sil=0.000> star <sil=0.000> and <sil=0.000> that <sil=0.000> goes <sil=0.000> as <sil=0.000> a structure <sil=0.000> pointer <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  malloc <sil=0.000> always <sil=0.000> allocates <sil=0.000> a block <sil=0.000> of <sil=0.000> contiguous <sil=0.000> bytes <sil=2.000> .PERIOD  Now <sil=0.000> suppose <sil=0.000> you <sil=0.000> are <sil=0.000> asking <sil=0.000> for <sil=0.000> 100
bytes <sil=0.000> and <sil=0.000> 100 <sil=0.000> bytes <sil=0.000> are <sil=0.000> not <sil=0.000> available <sil=0.000> then <sil=0.000> malloc <sil=0.000> will <sil=0.000> not <sil=0.000> be <sil=0.000> able <sil=0.000> to <sil=0.000> allocate <sil=0.000> you <sil=0.000> the <sil=0.000> space <sil=1.000> ,COMMA  in
that <sil=0.000> case <sil=0.000> malloc <sil=0.000> will <sil=0.000> return <sil=0.000> in <sil=0.000> null <sil=2.000> .PERIOD  That <sil=0.000> is <sil=0.000> a null <sil=0.000> pointer <sil=1.000> ,COMMA  that <sil=0.000> is <sil=0.000> a special <sil=0.000> character <sil=0.000> special <sil=0.000> value
it <sil=0.000> will <sil=0.000> return <sil=1.000> ,COMMA  that <sil=0.000> shows <sil=0.000> that <sil=0.000> I could <sil=0.000> not <sil=0.000> allocate <sil=0.000> a space <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> could <sil=0.000> not <sil=0.000> allocate <sil=0.000> it <sil=0.000> to <sil=0.000> you <sil=0.000> a valid <sil=0.000> pointer <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> a null <sil=0.000> pointer <sil=0.000> meaning <sil=0.000> thereby <sil=0.000> I failed
in <sil=0.000> allocating <sil=0.000> your <sil=0.000> memory <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> an <sil=0.000> example <sil=2.000> .PERIOD  Here <sil=0.000> let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> it <sil=0.000> from <sil=0.000> one <sil=0.000> side - I <sil=0.000> n  <sil=1.000> ,COMMA  float <sil=0.000> is <sil=0.000> a pointer <sil=1.000> ,COMMA  height <sil=0.000> is <sil=0.000> a
pointer <sil=0.000> of <sil=0.000> type <sil=0.000> float <sil=1.000> ,COMMA  sum <sil=0.000> is <sil=0.000> 0 and <sil=0.000> average <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> am <sil=0.000> I trying <sil=0.000> to <sil=0.000> do <sil=0.228> ?QUESTIONMARK  Probably <sil=0.000> I am <sil=0.000> trying <sil=0.000> to
find <sil=0.000> the <sil=0.000> average <sil=0.000> height <sil=0.000> of <sil=0.000> the <sil=0.000> class <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  input <sil=0.000> the <sil=0.000> number <sil=0.000> of <sil=0.000> students <sil=0.000> and <sil=0.000> I am <sil=0.000> reading
ampersand <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> one <sil=0.000> is <sil=0.000> ampersand <sil=0.000> n <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> n number <sil=0.000> of <sil=0.000> students <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  see <sil=0.000> I did <sil=0.000> not <sil=0.000> know <sil=0.000> how <sil=0.000> many <sil=0.000> students <sil=0.000> are <sil=0.000> there <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> getting <sil=0.000> this <sil=0.000> number <sil=0.000> of <sil=0.000> students
here <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> getting <sil=0.000> n number <sil=0.000> of <sil=0.000> students <sil=0.000> here <sil=2.000> .PERIOD  Now <sil=0.000> I want <sil=0.000> to <sil=0.000> have <sil=0.000> an <sil=0.000> amount <sil=0.000> of <sil=0.000> spaces <sil=0.000> for <sil=0.000> the
height <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> I am <sil=0.000> doing <sil=0.228> ?QUESTIONMARK  I <sil=0.000> am <sil=0.000> allocating <sil=0.000> n number <sil=0.000> of <sil=0.000> spaces <sil=1.000> ,COMMA  n <sil=0.000> is <sil=0.000> a variable <sil=0.000> here <sil=0.000> and <sil=0.000> size <sil=0.000> of <sil=0.000> float <sil=1.000> ,COMMA  whatever <sil=0.000> size <sil=0.000> of <sil=0.000> float <sil=0.000> is <sil=0.000> 4 bytes <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  n <sil=0.000> times <sil=0.000> 4 bytes <sil=1.000> ,COMMA  so <sil=0.000> much <sil=0.000> space <sil=0.000> is <sil=0.000> being <sil=0.000> allocated <sil=1.000> ,COMMA  and <sil=0.000> the <sil=0.000> pointer <sil=0.000> is <sil=0.000> height <sil=0.000> is <sil=0.000> a pointer <sil=0.000> of <sil=0.000> type <sil=0.000> float <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> pointer <sil=0.000> is <sil=0.000> being <sil=0.000> type <sil=0.000> casted <sil=0.000> to <sil=0.000> float <sil=2.000> .PERIOD  Then <sil=0.000> I get <sil=0.000> the <sil=0.000> input <sil=0.000> scan <sil=0.000> f in <sil=0.000> a loop <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> getting <sil=0.000> the <sil=0.000> heights <sil=0.000> one <sil=0.000> after <sil=0.000> another <sil=0.000> in <sil=0.000> an <sil=0.000> array <sil=0.000> and <sil=0.000> I am <sil=0.000> finding <sil=0.000> the <sil=0.000> sum <sil=0.000> of <sil=0.000> the <sil=0.000> heights <sil=1.000> ,COMMA  finding <sil=0.000> the <sil=0.000> average <sil=0.000> of <sil=0.000> the <sil=0.000> heights <sil=1.000> ,COMMA  where <sil=0.000> I am <sil=0.000> dividing <sil=0.000> sum <sil=0.000> which <sil=0.000> is <sil=0.000> a floating <sil=0.000> point <sil=0.000> number <sil=0.000> with <sil=0.000> float <sil=0.000> n <sil=2.000> .PERIOD  Here <sil=0.000> is
another <sil=0.000> example <sil=0.000> of <sil=0.000> typecasting <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  you <sil=0.000> see <sil=0.000> I am <sil=0.000> dividing <sil=0.000> by <sil=0.000> n <sil=1.000> ,COMMA  but <sil=0.000> this <sil=0.000> is <sil=0.000> a floating <sil=0.000> point <sil=0.000> real
number <sil=1.000> ,COMMA  n <sil=0.000> was <sil=0.000> an <sil=0.000> integer <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> convert <sil=0.000> it <sil=0.000> to <sil=0.000> float <sil=0.000> and <sil=0.000> convert <sil=0.000> it <sil=0.000> divided <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> how <sil=0.000> malloc <sil=0.000> works <sil=0.000> now <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> have <sil=0.000> explained <sil=0.000> that <sil=2.000> .PERIOD 

Similarly <sil=0.000> the <sil=0.000> general <sil=0.000> format <sil=0.000> for <sil=0.000> freeing <sil=0.000> space <sil=0.000> is <sil=0.000> using <sil=0.000> by <sil=0.000> using <sil=0.000> the <sil=0.000> free <sil=0.000> function <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  general
now <sil=0.000> suppose <sil=0.000> I have <sil=0.000> got <sil=0.000> a space <sil=0.000> allocated <sil=0.000> to <sil=0.000> me <sil=0.000> and <sil=0.000> that <sil=0.000> space <sil=1.000> ,COMMA  the <sil=0.000> only <sil=0.000> handle <sil=0.000> to <sil=0.000> that <sil=0.000> space <sil=0.000> is <sil=0.000> to <sil=0.000> the <sil=0.000> pointer <sil=0.000> p <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> free <sil=0.000> that <sil=0.000> pointer <sil=1.000> ,COMMA  I <sil=0.000> free <sil=0.000> p <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> pointer <sil=0.000> is <sil=0.000> freed <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  this <sil=0.000> pointer <sil=0.000> is <sil=0.000> freed <sil=0.000> means
this <sil=0.000> location <sil=1.000> ,COMMA  this <sil=0.000> amount <sil=0.000> of <sil=0.000> memory <sil=0.000> goes <sil=0.000> back <sil=0.000> to <sil=0.000> the <sil=0.000> storage <sil=0.000> of <sil=0.000> the <sil=0.000> operating <sil=0.000> system <sil=0.000> and <sil=0.000> that <sil=0.000> is <sil=0.000> the <sil=0.000> heap <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  whatever <sil=0.000> we <sil=0.000> got <sil=0.000> in <sil=0.000> malloc <sil=0.000> that <sil=0.000> gives <sil=0.000> us <sil=0.000> some <sil=0.000> idea <sil=0.000> about <sil=0.000> how <sil=0.000> we <sil=0.000> can <sil=0.000> get <sil=0.000> space <sil=0.000> and <sil=0.000> reallocate
space <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  briefly <sil=0.000> we <sil=0.000> I will <sil=0.000> be <sil=0.000> talking <sil=0.000> for <sil=0.000> the <sil=0.000> next <sil=0.000> 5 or <sil=0.000> 10 <sil=0.000> minutes <sil=0.000> on <sil=0.000> file <sil=0.000> handling <sil=0.354> ;SEMICOLON  there <sil=0.000> is <sil=0.000> not <sil=0.000> much
to <sil=0.000> understand <sil=0.000> about <sil=0.000> file <sil=0.000> handling <sil=0.000> thus <sil=0.000> you <sil=0.000> will <sil=0.000> learn <sil=0.000> as <sil=0.000> you <sil=0.000> do <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  what <sil=0.000> is <sil=0.000> a file  <sil=0.228> ?QUESTIONMARK  That <sil=0.000> is

something <sil=0.000> you <sil=0.000> have <sil=0.000> to <sil=0.000> understand <sil=2.000> .PERIOD  File <sil=0.000> is <sil=0.000> something <sil=0.000> where <sil=0.000> I want <sil=0.000> to <sil=0.000> write <sil=0.000> something <sil=0.000> write <sil=0.000> or
read <sil=0.000> from <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> want <sil=0.000> to <sil=0.000> store <sil=0.000> something <sil=2.000> .PERIOD  I <sil=0.000> will <sil=0.000> take <sil=0.000> a particular <sil=0.000> file <sil=0.000> all <sil=0.000> right <sil=0.354> ;SEMICOLON  and <sil=0.000> I will <sil=0.000> open <sil=0.000> that <sil=0.000> file <sil=0.000> and
then <sil=0.000> I will <sil=0.000> write <sil=0.000> in <sil=0.000> the <sil=0.000> into <sil=0.000> that <sil=0.000> file <sil=0.000> then <sil=0.000> close <sil=0.000> that <sil=0.000> file <sil=0.000> and <sil=0.000> then <sil=0.000> in <sil=0.000> that <sil=0.000> way <sil=0.000> I may <sil=0.000> have <sil=0.000> 10 <sil=0.000> files <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  at <sil=0.000> a particular <sil=0.000> point <sil=0.000> of <sil=0.000> time <sil=0.000> I want <sil=0.000> to <sil=0.000> read <sil=0.000> a particular <sil=0.000> thing <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> choose <sil=0.000> the <sil=0.000> particular <sil=0.000> file
what <sil=0.000> do <sil=0.000> I do <sil=0.000> next <sil=0.228> ?QUESTIONMARK  Open <sil=0.000> the <sil=0.000> file <sil=0.000> and <sil=0.000> read <sil=0.000> the <sil=0.000> file <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  some <sil=0.000> files <sil=0.000> may <sil=0.000> be <sil=0.000> allowed <sil=0.000> to <sil=0.000> be <sil=0.000> read <sil=0.000> by
others <sil=1.000> ,COMMA  some <sil=0.000> files <sil=0.000> can <sil=0.000> only <sil=0.000> be <sil=0.000> written <sil=0.000> in <sil=0.000> to <sil=0.000> and <sil=0.000> not <sil=0.000> read <sil=0.000> from <sil=1.000> ,COMMA  some <sil=0.000> files <sil=0.000> can <sil=0.000> have <sil=0.000> the <sil=0.000> option <sil=0.000> of
read <sil=0.000> or <sil=0.000> write <sil=0.000> both <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  file <sil=0.000> is <sil=0.000> some <sil=0.000> space <sil=0.000> where <sil=0.000> I will <sil=0.000> be <sil=0.000> writing <sil=0.000> or <sil=0.000> reading <sil=0.000> from <sil=0.000> some <sil=0.000> storage <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> is <sil=0.000> there <sil=0.000> in <sil=0.000> the <sil=0.000> secondary <sil=0.000> memory <sil=0.000> and <sil=0.000> till <sil=0.000> now <sil=0.000> whatever <sil=0.000> variables <sil=0.000> we <sil=0.000> are <sil=0.000> talking <sil=0.000> about <sil=1.000> ,COMMA 
those <sil=0.000> who <sil=0.000> are <sil=0.000> all <sil=0.000> in <sil=0.000> the <sil=0.000> primary <sil=0.000> memory <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> I store <sil=0.000> it <sil=0.000> in <sil=0.000> a file <sil=0.000> it <sil=0.000> goes <sil=0.000> into <sil=0.000> the <sil=0.000> secondary
memory <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> have <sil=0.000> a little <sil=0.000> idea <sil=0.000> of <sil=0.000> how <sil=0.000> files <sil=0.000> are <sil=0.000> handled <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  now <sil=0.000> again <sil=0.000> now <sil=0.000> we <sil=0.000> have <sil=0.000> learnt <sil=0.000> pointers <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  any <sil=0.000> file <sil=0.000> can <sil=0.000> be <sil=0.000> accessed <sil=0.000> using <sil=0.000> a pointer <sil=2.000> .PERIOD  Just <sil=0.000> as <sil=0.000> if <sil=0.000> I have <sil=0.000> the <sil=0.000> file <sil=0.000> of <sil=0.000> income <sil=0.000> tax <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> will <sil=0.000> have <sil=0.000> a pointer <sil=0.000> that <sil=0.000> there <sil=0.000> is <sil=0.000> the <sil=0.000> file <sil=0.000> of <sil=0.000> income <sil=0.000> tax <sil=1.000> ,COMMA  here <sil=0.000> there <sil=0.000> is <sil=0.000> some <sil=0.000> file <sil=0.000> of <sil=0.000> road <sil=0.000> tax <sil=0.000> it <sil=0.000> will <sil=0.000> be <sil=0.000> here <sil=0.000> some <sil=0.000> file <sil=0.000> of <sil=0.000> your <sil=0.000> salary <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> somewhere <sil=0.000> here <sil=1.000> ,COMMA  some <sil=0.000> file <sil=0.000> of <sil=0.000> your <sil=0.000> expenses <sil=0.000> it <sil=0.000> will <sil=0.000> be <sil=0.000> somewhere <sil=0.000> else <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  there <sil=0.000> will <sil=0.000> be <sil=0.000> pointers <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> use <sil=0.000> in <sil=0.000> c <sil=1.000> ,COMMA  the <sil=0.000> file <sil=0.000> star <sil=2.000> .PERIOD  We <sil=0.000> use <sil=0.000> file <sil=0.000> star <sil=0.000> to <sil=0.000> represent <sil=0.000> pointed <sil=0.000> to <sil=0.000> a
file <sil=0.000> and <sil=0.000> if <sil=0.000> open <sil=0.000> is <sil=0.000> the <sil=0.000> command <sil=0.000> for <sil=0.000> opening <sil=0.000> a file <sil=2.000> .PERIOD  If <sil=0.000> a file <sil=0.000> cannot <sil=0.000> be <sil=0.000> opened <sil=0.000> then <sil=0.000> it <sil=0.000> will <sil=0.000> return <sil=0.000> a
null <sil=0.000> just <sil=0.000> as <sil=0.000> in <sil=0.000> the <sil=0.000> case <sil=0.000> of <sil=0.000> malloc <sil=1.000> ,COMMA  we <sil=0.000> saw <sil=0.000> if <sil=0.000> nothing <sil=0.000> could <sil=0.000> be <sil=0.000> returned <sil=0.000> it <sil=0.000> was <sil=0.000> returning <sil=0.000> a null <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  you <sil=0.000> see <sil=0.000> f p <sil=0.000> t r <sil=0.000> is <sil=0.000> a pointer <sil=0.000> of <sil=0.000> type <sil=0.000> file <sil=2.000> .PERIOD  That <sil=0.000> means <sil=1.000> ,COMMA  f <sil=0.000> p t <sil=0.000> r will <sil=0.000> be <sil=0.000> pointing
to <sil=0.000> file <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> got <sil=0.000> a character <sil=0.000> file <sil=0.000> name <sil=0.000> whic <sil=0.000> is <sil=0.000> an <sil=0.000> array <sil=1.000> ,COMMA  file <sil=0.000> 2 dot <sil=0.000> dat <sil=0.000> it <sil=0.000> is <sil=0.000> a data <sil=0.000> file <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA 
fptr <sil=0.000> is <sil=0.000> f open <sil=0.000> file <sil=0.000> name <sil=0.000> and <sil=0.000> here <sil=0.000> when <sil=0.000> I do <sil=0.000> f open <sil=1.000> ,COMMA  I <sil=0.000> give <sil=0.000> the <sil=0.000> file <sil=0.000> name <sil=0.000> as <sil=0.000> well <sil=0.000> as <sil=0.000> the <sil=0.000> mode <sil=0.000> in
which <sil=0.000> it <sil=0.000> can <sil=0.000> be <sil=0.000> opened <sil=0.000> and <sil=0.000> this <sil=0.000> w means <sil=0.000> it <sil=0.000> is <sil=0.000> in <sil=0.000> the <sil=0.000> right <sil=0.000> mode <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  what <sil=0.000> have <sil=0.000> I done <sil=0.000> here <sil=1.000> ,COMMA  I
have <sil=0.000> called <sil=0.000> f open <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> trying <sil=0.000> to <sil=0.000> open <sil=0.000> the <sil=0.000> file <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> f open <sil=0.000> will <sil=0.000> return <sil=0.000> up <sil=0.000> file <sil=0.000> pointer <sil=2.000> .PERIOD  Now <sil=0.000> if <sil=0.000> this <sil=0.000> file <sil=0.000> pointer
is <sil=0.000> null <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  there <sil=0.000> was <sil=0.000> some <sil=0.000> error <sil=0.000> in <sil=0.000> file <sil=0.000> creation <sil=0.000> otherwise <sil=0.000> it <sil=0.000> will <sil=0.000> go <sil=0.000> on <sil=0.000> doing <sil=0.000> something <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  quickly <sil=0.000> let <sil=0.000> us <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=1.000> ,COMMA  when <sil=0.000> I do <sil=0.000> f open <sil=0.000> it <sil=0.000> will <sil=0.000> open <sil=0.000> a file <sil=0.000> and <sil=0.000> will <sil=0.000> open <sil=0.000> it <sil=0.000> in <sil=0.000> a particular
mode <sil=1.000> ,COMMA  read <sil=0.000> or <sil=0.000> write <sil=0.000> whatever <sil=0.000> I specify <sil=0.000> and <sil=0.000> it <sil=0.000> will <sil=0.000> return <sil=0.000> me <sil=0.000> a pointer <sil=2.000> .PERIOD  If <sil=0.000> a file <sil=0.000> is <sil=0.000> created
successfully <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> return <sil=0.000> me <sil=0.000> a non <sil=0.000> null <sil=0.000> pointer <sil=2.000> .PERIOD 

The <sil=0.000> second <sil=0.000> argument <sil=0.000> of <sil=0.000> f open <sil=0.000> is <sil=0.000> the <sil=0.000> mode <sil=0.000> and <sil=0.000> there <sil=0.000> are <sil=0.000> three <sil=0.000> modes <sil=2.000> .PERIOD  R <sil=0.000> means <sil=0.000> the <sil=0.000> file <sil=0.000> is <sil=0.000> opened <sil=0.000> for <sil=0.000> reading <sil=1.000> ,COMMA  w <sil=0.000> means <sil=0.000> it <sil=0.000> creates <sil=0.000> a file <sil=0.000> for <sil=0.000> writing <sil=0.000> and <sil=0.000> writes <sil=0.000> over <sil=0.000> all <sil=0.000> the <sil=0.000> previous <sil=0.000> contents <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  if <sil=0.000> I open <sil=0.000> it <sil=0.000> in <sil=0.000> the <sil=0.000> write <sil=0.000> mode <sil=1.000> ,COMMA  whatever <sil=0.000> content <sil=0.000> was <sil=0.000> in <sil=0.000> that <sil=0.000> file <sil=0.000> is <sil=0.000> erased <sil=2.000> .PERIOD  And <sil=0.000> a opens <sil=0.000> a file <sil=0.000> for <sil=0.000> appending <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  whatever <sil=0.000> is <sil=0.000> there <sil=0.000> after <sil=0.000> that <sil=0.000> it <sil=0.000> will <sil=0.000> be <sil=0.000> added <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  if <sil=0.000> you <sil=0.000> have <sil=0.000> got <sil=0.000> something <sil=0.000> already <sil=0.000> stored <sil=0.000> and <sil=0.000> you <sil=0.000> do <sil=0.000> not <sil=0.000> want <sil=0.000> to <sil=0.000> destroy <sil=0.000> that <sil=0.000> and <sil=0.000> you <sil=0.000> want <sil=0.000> to <sil=0.000> add <sil=0.000> something <sil=0.000> more <sil=0.000> to <sil=0.000> that <sil=0.000> you <sil=0.000> will <sil=0.000> open <sil=0.000> it <sil=0.000> in <sil=0.000> mode <sil=0.000> a and <sil=0.000> rb <sil=0.000> reads <sil=0.000> a binary <sil=0.000> file <sil=1.000> ,COMMA  raw <sil=0.000> bytes <sil=0.000> we
need <sil=0.000> not <sil=0.000> bother <sil=0.000> about <sil=0.000> that <sil=2.000> .PERIOD 

There <sil=0.000> is <sil=0.000> a function <sil=0.000> called <sil=0.000> exit <sil=0.000> which <sil=0.000> you <sil=0.000> have <sil=0.000> seen <sil=1.000> ,COMMA  sometimes <sil=0.000> in <sil=0.000> the <sil=0.000> emergency <sil=0.000> we <sil=0.000> can <sil=0.000> put <sil=0.000> exit <sil=0.000> minus <sil=0.000> one <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  it <sil=0.000> tells <sil=0.000> that <sil=0.000> I have <sil=0.000> exited <sil=0.000> the <sil=0.000> function <sil=0.000> without <sil=0.000> success <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  here <sil=0.000> you <sil=0.000> see <sil=0.000> use <sil=0.000> of <sil=0.000> exit <sil=2.000> .PERIOD  file <sil=0.000> f pointer <sil=1.000> ,COMMA  character <sil=0.000> file <sil=0.000> name <sil=0.000> is <sil=0.000> an <sil=0.000> array <sil=1.000> ,COMMA  file <sil=0.000> 2 dot <sil=0.000> dat <sil=2.000> .PERIOD  I <sil=0.000> tried
to <sil=0.000> do <sil=0.000> something <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  the <sil=0.000> file <sil=0.000> pointer <sil=0.000> was <sil=0.000> null <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  if <sil=0.000> it <sil=0.000> is <sil=0.000> null <sil=0.000> then <sil=0.000> what <sil=0.000> can <sil=0.000> I do <sil=0.228> ?QUESTIONMARK  I <sil=0.000> will <sil=0.000> have <sil=0.000> to <sil=0.000> exit <sil=0.000> because <sil=0.000> of <sil=0.000> some <sil=0.000> reason <sil=0.000> the <sil=0.000> file <sil=0.000> could <sil=0.000> not
be <sil=0.000> created <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  f <sil=0.000> open <sil=0.000> we <sil=0.000> have <sil=0.000> seen <sil=1.000> ,COMMA  f <sil=0.000> print <sil=0.000> is <sil=0.000> a very <sil=0.000> important <sil=0.000> command <sil=2.000> .PERIOD  f <sil=0.000> print <sil=0.000> works <sil=0.000> just <sil=0.000> like <sil=0.000> print <sil=0.000> f and <sil=0.000> s
print <sil=0.000> f <sil=1.000> ,COMMA  except <sil=0.000> that <sil=0.000> the <sil=0.000> first <sil=0.000> argument <sil=0.000> is <sil=0.000> a file <sil=0.000> pointer <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  we <sil=0.000> will <sil=0.000> see <sil=0.000> how <sil=0.000> it <sil=0.000> works <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  fptr <sil=0.000> is
again <sil=0.000> the <sil=0.000> file <sil=0.000> pointer <sil=0.000> and <sil=0.000> I have <sil=0.000> opened <sil=0.000> the <sil=0.000> file <sil=0.000> dot <sil=0.000> dat <sil=0.000> in <sil=0.000> the <sil=0.000> right <sil=0.000> mode <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  print <sil=0.000> f means
now <sil=0.000> I am <sil=0.000> printing <sil=2.000> .PERIOD  Where <sil=0.000> am <sil=0.000> I printing <sil=0.228> ?QUESTIONMARK  A <sil=0.000> file <sil=0.000> called <sil=0.000> file <sil=0.000> dot <sil=0.000> dat <sil=0.000> has <sil=0.000> been <sil=0.000> opened <sil=2.000> .PERIOD 

The <sil=0.000> name <sil=0.000> of <sil=0.000> the <sil=0.000> file <sil=0.000> is <sil=0.000> file <sil=0.000> dot <sil=0.000> dat <sil=0.000> and <sil=0.000> how <sil=0.000> do <sil=0.000> I identify <sil=0.000> it <sil=0.228> ?QUESTIONMARK  I <sil=0.000> identify <sil=0.000> it <sil=0.000> with <sil=0.000> the <sil=0.000> fptr <sil=1.000> ,COMMA  the <sil=0.000> file
pointer <sil=0.000> ok <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  it <sil=0.000> opened <sil=0.000> in <sil=0.000> the <sil=0.000> write <sil=0.000> mode <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  everything <sil=1.000> ,COMMA  whatever <sil=0.000> was <sil=0.000> there <sil=0.000> has <sil=0.000> been <sil=0.000> erased <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> writing <sil=1.000> ,COMMA  just <sil=0.000> as <sil=0.000> you <sil=0.000> have <sil=0.000> done <sil=0.000> print <sil=0.000> f then <sil=0.000> automatically <sil=0.000> by <sil=0.000> default <sil=0.000> it <sil=0.000> goes <sil=0.000> to <sil=0.000> the <sil=0.000> screen <sil=1.000> ,COMMA 
here <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> default <sil=0.000> here <sil=0.000> I have <sil=0.000> said <sil=0.000> fptr <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  whatever <sil=0.000> I write <sil=0.000> hello <sil=0.000> world <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> be <sil=0.000> written <sil=0.000> in <sil=0.000> this <sil=0.000> file <sil=0.000> not <sil=0.000> in <sil=0.000> the <sil=0.000> screen <sil=2.000> .PERIOD 

Screen <sil=0.000> is <sil=0.000> another <sil=0.000> file <sil=1.000> ,COMMA  but <sil=0.000> that <sil=0.000> is <sil=0.000> a default <sil=0.000> file <sil=2.000> .PERIOD  Reading <sil=0.000> a data <sil=0.000> similarly <sil=1.000> ,COMMA  we <sil=0.000> printed <sil=0.000> using <sil=0.000> f print
f <sil=1.000> ,COMMA  reading <sil=0.000> we <sil=0.000> can <sil=0.000> do <sil=0.000> using <sil=0.000> f scan <sil=0.000> f <sil=1.000> ,COMMA  forget <sil=0.000> about <sil=0.000> that <sil=0.000> part <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=2.000> .PERIOD  fptr - I <sil=0.000> am <sil=0.000> reading <sil=0.000> from <sil=0.000> not
from <sil=0.000> the <sil=0.000> keyboard <sil=0.000> now <sil=2.000> .PERIOD  I <sil=0.000> am <sil=0.000> reading <sil=0.000> x and <sil=0.000> y two <sil=0.000> integers <sil=0.000> from <sil=0.000> a file <sil=0.000> which <sil=0.000> is <sil=0.000> pointed <sil=0.000> out <sil=0.000> by <sil=0.000> f p
t <sil=0.000> r and <sil=0.000> what <sil=0.000> is <sil=0.000> that <sil=0.000> file <sil=0.000> f p <sil=0.000> t r <sil=0.228> ?QUESTIONMARK  I <sil=0.000> have <sil=0.000> opened <sil=0.000> the <sil=0.000> file <sil=0.000> input <sil=0.000> dot <sil=0.000> dat <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  you <sil=0.000> see <sil=0.000> in <sil=0.000> that <sil=0.000> file <sil=0.000> input <sil=0.000> dot <sil=0.000> dat <sil=0.000> 20 <sil=0.000> and <sil=0.000> 30 <sil=0.000> was <sil=0.000> written <sil=0.000> and <sil=0.000> so <sil=1.000> ,COMMA  f <sil=0.000> scan <sil=0.000> f I <sil=0.000> have <sil=0.000> read <sil=0.000> that <sil=1.000> ,COMMA  that
was <sil=0.000> input <sil=0.000> dot <sil=0.000> dat <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> opened <sil=0.000> that <sil=0.000> in <sil=0.000> the <sil=0.000> read <sil=0.000> mode <sil=0.000> and <sil=0.000> I am <sil=0.000> reading <sil=0.000> from <sil=0.000> there <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> am
getting <sil=0.000> x to <sil=0.000> be <sil=0.000> 20 <sil=0.000> and <sil=0.000> y to <sil=0.000> be <sil=0.000> 30 <sil=1.000> ,COMMA  not <sil=0.000> from <sil=0.000> the <sil=0.000> keyboard <sil=1.000> ,COMMA  but <sil=0.000> from <sil=0.000> the <sil=0.000> file <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA <sil=0.000> now <sil=0.000> here <sil=0.000> are <sil=0.000> some <sil=0.000> powerful <sil=0.000> commands <sil=2.000> .PERIOD  We <sil=0.000> can <sil=0.000> read <sil=0.000> a string <sil=0.000> using <sil=0.000> fgets <sil=1.000> ,COMMA  from <sil=0.000> a file <sil=0.000> I can
read <sil=0.000> a string <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> you <sil=0.000> see <sil=0.000> a file <sil=0.000> is <sil=0.000> f p <sil=0.000> t r <sil=0.000> and <sil=0.000> a line <sil=0.000> is <sil=0.000> of <sil=0.000> size <sil=0.000> 1000 <sil=1.000> ,COMMA  while <sil=0.000> f gets <sil=0.000> line <sil=0.000> is <sil=0.000> not
null <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> getting <sil=0.000> from <sil=0.000> f p <sil=0.000> t r <sil=1.000> ,COMMA  a <sil=0.000> value <sil=0.000> and <sil=0.000> if <sil=0.000> it <sil=0.000> is <sil=0.000> not <sil=0.000> null <sil=0.354> ;SEMICOLON  that <sil=0.000> means <sil=1.000> ,COMMA  it <sil=0.000> is <sil=0.000> not <sil=0.000> the <sil=0.000> end
of <sil=0.000> the <sil=0.000> line <sil=1.000> ,COMMA  the <sil=0.000> file <sil=0.000> is <sil=0.000> open <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> reading <sil=0.000> the <sil=0.000> line <sil=0.000> using <sil=0.000> f gets <sil=2.000> .PERIOD  I <sil=0.000> am <sil=0.000> getting <sil=0.000> the <sil=0.000> line <sil=2.000> .PERIOD  f <sil=0.000> gets <sil=0.000> takes
three <sil=0.000> arguments <sil=1.000> ,COMMA  what <sil=0.000> are <sil=0.000> the <sil=0.000> three <sil=0.000> arguments <sil=0.000> its <sil=0.000> taking <sil=0.228> ?QUESTIONMARK  A <sil=0.000> string <sil=1.000> ,COMMA  a <sil=0.000> maximum <sil=0.000> number <sil=0.000> of
characters <sil=1.000> ,COMMA  1000 <sil=0.000> and <sil=0.000> a pointer <sil=0.000> from <sil=0.000> it <sil=0.000> returns <sil=2.000> .PERIOD  If <sil=0.000> there <sil=0.000> is <sil=0.000> an <sil=0.000> error <sil=0.000> at <sil=0.000> the <sil=0.000> end <sil=0.000> of <sil=0.000> file <sil=0.000> it <sil=0.000> shows <sil=0.000> EOF
which <sil=0.000> is <sil=0.000> the <sil=0.000> end <sil=0.000> of <sil=0.000> file <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  this <sil=0.000> I think <sil=0.000> you <sil=0.000> can <sil=0.000> understand <sil=0.000> much <sil=0.000> better <sil=0.000> when <sil=0.000> you <sil=0.000> use <sil=0.000> yourself <sil=1.000> ,COMMA  now <sil=0.000> when <sil=0.000> we <sil=0.000> open <sil=0.000> a
file <sil=0.000> after <sil=0.000> that <sil=0.000> we <sil=0.000> must <sil=0.000> close <sil=0.000> that <sil=0.000> file <sil=0.000> we <sil=0.000> can <sil=0.000> simply <sil=0.000> use <sil=0.000> a command <sil=0.000> f close <sil=0.000> and <sil=0.000> the <sil=0.000> file <sil=0.000> pointer <sil=2.000> .PERIOD 
So <sil=1.000> ,COMMA  here <sil=0.000> you <sil=0.000> see <sil=0.000> f p <sil=0.000> t r <sil=1.000> ,COMMA  I <sil=0.000> opened <sil=0.000> the <sil=0.000> file <sil=0.000> in <sil=0.000> the <sil=0.000> right <sil=0.000> mode <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> written <sil=0.000> hello <sil=0.000> world <sil=0.000> over <sil=0.000> here <sil=1.000> ,COMMA  f
print <sil=0.000> f means <sil=0.000> saying <sil=0.000> I am <sil=0.000> printing <sil=0.000> in <sil=0.000> the <sil=0.000> file <sil=1.000> ,COMMA  and <sil=0.000> then <sil=0.000> f close <sil=1.000> ,COMMA  I <sil=0.000> am <sil=0.000> closing <sil=0.000> the <sil=0.000> file <sil=0.000> by <sil=0.000> f close <sil=0.000> f p <sil=0.000> t
r <sil=0.000> all <sil=0.000> right <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  here <sil=0.000> it <sil=0.000> is <sil=0.000> opening <sil=0.000> and <sil=0.000> here <sil=0.000> is <sil=0.000> access <sil=0.000> and <sil=0.000> here <sil=0.000> it s <sil=0.000> closing <sil=2.000> .PERIOD 

You <sil=0.000> have <sil=0.000> seen <sil=0.000> that <sil=0.000> s t <sil=0.000> d in <sil=1.000> ,COMMA  s <sil=0.000> t d <sil=0.000> out <sil=1.000> ,COMMA  were <sil=0.000> two <sil=0.000> special <sil=0.000> cases <sil=0.000> of <sil=0.000> files <sil=1.000> ,COMMA  which <sil=0.000> are <sil=0.000> default <sil=0.000> files <sil=0.000> and <sil=0.000> s t <sil=0.000> d error <sil=0.000> which <sil=0.000> was <sil=0.000> the <sil=0.000> printing <sil=0.000> of <sil=0.000> the <sil=0.000> error <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  here <sil=0.000> is <sil=0.000> an <sil=0.000> example <sil=0.000> program <sil=0.000> you <sil=0.000> can <sil=0.000> see <sil=0.000> that <sil=2.000> .PERIOD  Main <sil=1.000> ,COMMA  f <sil=0.000> print <sil=0.000> f s <sil=0.000> t d <sil=0.000> out <sil=0.000> give <sil=0.000> value <sil=0.000> of <sil=0.000> i <sil=0.354> ;SEMICOLON  that
means <sil=1.000> ,COMMA  where <sil=0.000> am <sil=0.000> I printing <sil=0.000> this <sil=0.228> ?QUESTIONMARK  Here <sil=0.000> I am <sil=0.000> printing <sil=0.000> it <sil=0.000> to <sil=0.000> the <sil=0.000> standard <sil=0.000> output <sil=2.000> .PERIOD  I <sil=0.000> am <sil=0.000> reading <sil=0.000> I from
the <sil=0.000> standard <sil=0.000> input <sil=2.000> .PERIOD  Now <sil=1.000> ,COMMA  f <sil=0.000> print <sil=0.000> f I <sil=0.000> am <sil=0.000> writing <sil=0.000> that <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> i is <sil=0.000> whatever <sil=0.000> value <sil=0.000> of <sil=0.000> i read <sil=2.000> .PERIOD  So
there <sil=0.000> is <sil=0.000> no <sil=0.000> error  <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  give <sil=0.000> value <sil=0.000> of <sil=0.000> i <sil=1.000> ,COMMA  it <sil=0.000> will <sil=0.000> first <sil=0.000> give <sil=0.000> value <sil=0.000> of <sil=0.000> i <sil=1.000> ,COMMA  you <sil=0.000> give <sil=0.000> 15 <sil=1.000> ,COMMA  then <sil=0.000> f print <sil=0.000> f that <sil=0.000> i <sil=1.000> ,COMMA 
then <sil=0.000> it <sil=0.000> will <sil=0.000> say <sil=0.000> value <sil=0.000> of <sil=0.000> i is <sil=0.000> equal <sil=0.000> to <sil=0.000> 15 <sil=0.000> and <sil=0.000> there <sil=0.000> are <sil=0.000> no <sil=0.000> error <sil=1.000> ,COMMA  but <sil=0.000> an <sil=0.000> example <sil=0.000> to <sil=0.000> show <sil=0.000> error
message <sil=2.000> .PERIOD 

If <sil=0.000> there <sil=0.000> is <sil=0.000> an <sil=0.000> error <sil=0.000> for <sil=0.000> example <sil=0.000> I am <sil=0.000> being <sil=0.000> returned <sil=0.000> a null <sil=0.000> pointer <sil=0.000> in <sil=0.000> that <sil=0.000> case <sil=0.000> I can <sil=0.000> use <sil=0.000> output <sil=0.000> s t
d <sil=0.000> error <sil=0.000> and <sil=0.000> say <sil=0.000> the <sil=0.000> file <sil=0.000> failed <sil=0.000> to <sil=0.000> open <sil=0.000> the <sil=0.000> file <sil=0.000> that <sil=0.000> sort <sil=0.000> of <sil=0.000> message <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  now <sil=0.000> another <sil=0.000> thing <sil=0.000> I will <sil=0.000> just <sil=0.000> talk <sil=0.000> about <sil=0.000> here <sil=1.000> ,COMMA  that <sil=0.000> will <sil=0.000> come <sil=0.000> in <sil=0.000> very <sil=0.000> handy <sil=0.000> to <sil=0.000> you <sil=0.000> that <sil=0.000> is <sil=0.000> say
for <sil=0.000> example <sil=1.000> ,COMMA  you <sil=0.000> must <sil=0.000> be <sil=0.000> running <sil=0.000> the <sil=0.000> programs <sil=0.000> and <sil=0.000> you <sil=0.000> after <sil=0.000> you <sil=0.000> compile <sil=0.000> the <sil=0.000> program <sil=0.000> and <sil=0.000> link
them <sil=0.000> you <sil=0.000> are <sil=0.000> creating <sil=0.000> an <sil=0.000> executable <sil=0.000> file <sil=1.000> ,COMMA  which <sil=0.000> is <sil=0.000> a dot <sil=0.000> out ( dot <sil=0.000> slash <sil=0.000> a dot <sil=0.000> out) <sil=2.000> .PERIOD  Now <sil=0.000> usually
what <sil=0.000> do <sil=0.000> you <sil=0.000> do <sil=0.228> ?QUESTIONMARK  You <sil=0.000> have <sil=0.000> got <sil=0.000> the <sil=0.000> dollar <sil=1.000> ,COMMA  those <sil=0.000> of <sil=0.000> you <sil=0.000> using <sil=0.000> Linux <sil=0.000> shell <sil=1.000> ,COMMA  a <sil=0.000> dot <sil=0.000> out <sil=0.000> right <sil=0.000> and
return <sil=2.000> .PERIOD 

Now <sil=1.000> ,COMMA  this <sil=0.000> dot <sil=0.000> slash <sil=0.000> a dot <sil=0.000> out <sil=0.000> what <sil=0.000> is <sil=0.000> it <sil=0.000> expecting <sil=0.228> ?QUESTIONMARK  The <sil=0.000> input <sil=0.000> from <sil=0.000> the <sil=0.000> keyboard <sil=0.000> s t <sil=0.000> d in <sil=0.000> and <sil=0.000> the
output <sil=0.000> is <sil=0.000> going <sil=0.000> to <sil=0.000> std <sil=0.000> out <sil=1.000> ,COMMA  but <sil=0.000> I do <sil=0.000> not <sil=0.000> want <sil=0.000> that <sil=2.000> .PERIOD  I <sil=0.000> want <sil=0.000> that <sil=0.000> I have <sil=0.000> got <sil=0.000> a file <sil=0.000> where <sil=0.000> my <sil=0.000> input <sil=0.000> data
is <sil=0.000> there <sil=2.000> .PERIOD 

I <sil=0.000> call <sil=0.000> that <sil=0.000> in <sil=0.000> dot <sil=0.000> dat <sil=0.000> and <sil=0.000> I have <sil=0.000> got <sil=0.000> another <sil=0.000> file <sil=0.000> which <sil=0.000> is <sil=0.000> known <sil=0.000> as <sil=0.000> out <sil=0.000> dot <sil=0.000> dat <sil=2.000> .PERIOD  I <sil=0.000> want <sil=0.000> that <sil=0.000> the
input <sil=0.000> to <sil=0.000> be <sil=0.000> taken <sil=0.000> from <sil=0.000> this <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  I <sil=0.000> want <sil=0.000> a dot <sil=0.000> out <sil=0.000> to <sil=0.000> read <sil=0.000> the <sil=0.000> data <sil=0.000> from <sil=0.000> here <sil=0.000> and <sil=0.000> the <sil=0.000> result <sil=0.000> should <sil=0.000> be <sil=0.000> written <sil=0.000> here <sil=2.000> .PERIOD  I <sil=0.000> can <sil=0.000> do <sil=0.000> that <sil=0.000> in <sil=0.000> the <sil=0.000> unix <sil=0.000> environment <sil=0.000> very <sil=0.000> simply <sil=0.000> by <sil=0.000> this <sil=0.000> redirection <sil=0.000> operation <sil=2.000> .PERIOD  You <sil=0.000> see <sil=1.000> ,COMMA  a <sil=0.000> dot <sil=0.000> out <sil=0.000> will <sil=0.000> run
taking <sil=0.000> data <sil=0.000> from <sil=0.000> in <sil=0.000> dot <sil=0.000> dat <sil=0.000> and <sil=0.000> sending <sil=0.000> the <sil=0.000> output <sil=0.000> data <sil=0.000> to <sil=0.000> out <sil=0.000> dot <sil=0.000> dat <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  say <sil=0.000> for <sil=0.000> example <sil=1.000> ,COMMA  in <sil=0.000> dot <sil=0.000> dat <sil=0.000> has <sil=0.000> got <sil=0.000> 15 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  I <sil=0.000> do <sil=0.000> that <sil=0.000> and <sil=0.000> the <sil=0.000> program <sil=0.000> runs <sil=0.000> and <sil=0.000> says <sil=0.000> give <sil=0.000> the
value <sil=0.000> of <sil=0.000> i (think <sil=0.000> of <sil=0.000> the <sil=0.000> earlier <sil=0.000> example <sil=1.000> ,COMMA  earlier <sil=0.000> program) and <sil=0.000> it <sil=0.000> reads <sil=0.000> from <sil=0.000> here <sil=0.000> and <sil=0.000> it <sil=0.000> prints <sil=0.000> the
value <sil=0.000> of <sil=0.000> i to <sil=0.000> be15 <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  this <sil=0.000> whole <sil=0.000> thing <sil=0.000> is <sil=0.000> coming <sil=0.000> in <sil=0.000> out <sil=0.000> dot <sil=0.000> i <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  let <sil=0.000> us <sil=0.000> once <sil=0.000> again <sil=0.000> look <sil=0.000> at <sil=0.000> this <sil=0.000> thing <sil=2.000> .PERIOD  Here <sil=0.000> I am <sil=0.000> asking <sil=1.000> ,COMMA  them <sil=0.000> to <sil=0.000> give <sil=0.000> the <sil=0.000> value <sil=0.000> of <sil=0.000> i which <sil=0.000> is
being <sil=0.000> given <sil=0.000> and <sil=0.000> that <sil=0.000> is <sil=0.000> being <sil=0.000> scanned <sil=0.000> from <sil=0.000> the <sil=0.000> input <sil=0.000> file <sil=0.000> and <sil=0.000> this <sil=0.000> is <sil=0.000> being <sil=0.000> written <sil=0.000> on <sil=0.000> the <sil=0.000> output
file <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  in <sil=0.000> the <sil=0.000> output <sil=0.000> file <sil=0.000> both <sil=0.000> these <sil=0.000> things <sil=0.000> are <sil=0.000> being <sil=0.000> written <sil=0.354> ;SEMICOLON  consequently <sil=1.000> ,COMMA  you <sil=0.000> see <sil=1.000> ,COMMA  what <sil=0.000> I am
getting <sil=0.000> is <sil=0.000> this <sil=0.000> output - out <sil=0.000> dot <sil=0.000> dat <sil=0.000> and <sil=0.000> in <sil=0.000> dot <sil=0.000> dat <sil=1.000> ,COMMA  there <sil=0.000> are <sil=0.000> two <sil=0.000> files <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  this <sil=0.000> in <sil=0.000> this <sil=0.000> way <sil=0.000> you <sil=0.000> can <sil=0.000> use <sil=0.000> files <sil=0.000> for <sil=0.000> storing <sil=0.000> data <sil=0.000> you <sil=0.000> have <sil=0.000> to <sil=0.000> open <sil=0.000> the <sil=0.000> file <sil=1.000> ,COMMA  let <sil=0.000> me <sil=0.000> summarise <sil=0.000> a little <sil=0.000> bit <sil=1.000> ,COMMA  you <sil=0.000> will <sil=0.000> have <sil=0.000> to <sil=0.000> open <sil=0.000> the <sil=0.000> file <sil=1.000> ,COMMA  in <sil=0.000> the <sil=0.000> read <sil=0.000> mode <sil=1.000> ,COMMA  read <sil=0.000> the <sil=0.000> data <sil=0.000> from <sil=0.000> that <sil=0.000> file <sil=1.000> ,COMMA  do <sil=0.000> the <sil=0.000> operation <sil=1.000> ,COMMA  open <sil=0.000> another <sil=0.000> file <sil=0.000> in <sil=0.000> the <sil=0.000> write <sil=0.000> mode <sil=0.000> and <sil=0.000> write <sil=0.000> the <sil=0.000> data <sil=0.000> into <sil=0.000> that <sil=0.000> file <sil=2.000> .PERIOD  Thereby <sil=1.000> ,COMMA  whenever <sil=0.000> you <sil=0.000> require <sil=0.000> some <sil=0.000> file <sil=0.000> operations <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> easily <sil=0.000> do <sil=0.000> that <sil=0.000> and <sil=0.000> this <sil=0.000> is <sil=0.000> one <sil=0.000> example <sil=0.000> that <sil=0.000> we <sil=0.000> have <sil=0.000> shown <sil=0.000> which <sil=0.000> is <sil=0.000> very <sil=0.000> common <sil=0.000> during <sil=0.000> running <sil=0.000> your <sil=0.000> programs <sil=2.000> .PERIOD  If <sil=0.000> you <sil=0.000> store <sil=0.000> some <sil=0.000> data <sil=0.000> in <sil=0.000> a particular <sil=0.000> file <sil=0.000> and <sil=0.000> read <sil=0.000> from <sil=0.000> there <sil=0.000> and <sil=0.000> write <sil=0.000> into <sil=0.000> another <sil=0.000> file <sil=0.000> you <sil=0.000> can <sil=0.000> utilise <sil=0.000> this <sil=0.000> sort <sil=0.000> of <sil=0.000> structures
this <sil=0.000> sort <sil=0.000> of <sil=0.000> commands <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  thank <sil=0.000> you <sil=0.000> very <sil=0.000> much <sil=0.354> ;SEMICOLON  I <sil=0.000> think <sil=0.000> you <sil=0.000> have <sil=0.000> got <sil=0.000> an <sil=0.000> overall <sil=0.000> idea <sil=0.000> of <sil=0.000> how <sil=0.000> to <sil=0.000> write <sil=0.000> c programs <sil=0.000> and
solve <sil=0.000> problems <sil=0.000> using <sil=0.000> programs <sil=0.000> because <sil=0.000> our <sil=0.000> the <sil=0.000> essence <sil=0.000> of <sil=0.000> our <sil=0.000> course <sil=0.000> was <sil=0.000> to <sil=0.000> solve <sil=0.000> problems
through <sil=0.000> c programming <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  you <sil=0.000> should <sil=0.000> choose <sil=0.000> different <sil=0.000> problems <sil=0.000> and <sil=0.000> you <sil=0.000> should <sil=0.000> try <sil=0.000> to <sil=0.000> write <sil=0.000> programs <sil=0.000> for <sil=0.000> solving <sil=0.000> those
problems <sil=2.000> .PERIOD  So <sil=1.000> ,COMMA  first <sil=0.000> you <sil=0.000> have <sil=0.000> to <sil=0.000> find <sil=0.000> out <sil=0.000> the <sil=0.000> proper <sil=0.000> algorithm <sil=1.000> ,COMMA  and <sil=0.000> then <sil=0.000> write <sil=0.000> the <sil=0.000> C code <sil=0.000> for <sil=0.000> that <sil=1.000> ,COMMA 
you <sil=0.000> have <sil=0.000> learnt <sil=0.000> everything <sil=0.000> about <sil=0.000> basic <sil=0.000> things <sil=0.000> about <sil=0.000> the <sil=0.000> C programming <sil=1.000> ,COMMA  I <sil=0.000> have <sil=0.000> not <sil=0.000> touched <sil=0.000> upon <sil=0.000> some <sil=0.000> special <sil=0.000> features <sil=1.000> ,COMMA  which <sil=0.000> you <sil=0.000> can <sil=0.000> also <sil=0.000> learn <sil=0.000> from <sil=0.000> the <sil=0.000> book <sil=0.000> like <sil=0.000> static <sil=0.000> variables <sil=0.000> and <sil=0.000> all <sil=0.000> those <sil=0.000> I have <sil=0.000> left <sil=0.000> out <sil=0.000> intentionally <sil=2.000> .PERIOD 

So <sil=1.000> ,COMMA  that <sil=0.000> you <sil=0.000> are <sil=0.000> not <sil=0.000> overloaded <sil=1.000> ,COMMA  you <sil=0.000> can <sil=0.000> solve <sil=0.000> it <sil=1.000> ,COMMA  the <sil=0.000> more <sil=0.000> you <sil=0.000> run <sil=0.000> the <sil=0.000> programs <sil=0.000> using <sil=0.000> the <sil=0.000> basic <sil=0.000> concepts <sil=0.000> that <sil=0.000> has <sil=0.000> been <sil=0.000> taught <sil=1.000> ,COMMA  you <sil=0.000> will <sil=0.000> be <sil=0.000> a good <sil=0.000> programmer <sil=0.000> and <sil=0.000> most <sil=0.000> importantly <sil=0.000> you <sil=0.000> will <sil=0.000> be <sil=0.000> able <sil=0.000> to <sil=0.000> think <sil=0.000> logically <sil=0.000> like <sil=0.000> a programmer <sil=1.000> ,COMMA  you <sil=0.000> will <sil=0.000> be <sil=0.000> able <sil=0.000> to <sil=0.000> think <sil=0.000> of <sil=0.000> an <sil=0.000> algorithm <sil=1.000> ,COMMA  and <sil=0.000> you <sil=0.000> will
be <sil=0.000> able <sil=0.000> to <sil=0.000> translate <sil=0.000> that <sil=0.000> into <sil=0.000> a program <sil=2.000> .PERIOD 

Thank <sil=0.000> you <sil=0.000> very <sil=0.000> much <sil=2.000> .PERIOD 